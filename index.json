[{"categories":["资源","导航"],"content":"工具、娱乐、资源、软件…… ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:0:0","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#"},{"categories":["资源","导航"],"content":"1 在线工具","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:0","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#1-在线工具"},{"categories":["资源","导航"],"content":"1.1 PDF easy PDF PDF24 Tools ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:1","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#11-pdf"},{"categories":["资源","导航"],"content":"1.2 图片 iLoveIMG 多功能图片转换器无需上传文件 AI人工智能图片放大：免费版3000x3000px, 5M; 付费版50M。 最优图像优化 在线图片去底工具 在线GIF制作和编辑 1.2.1 OCR EasyScreenOCR ONLINE OCR 1.2.2 图标制作 小米风格Logo生成器 favicon图标制作工具 favicon图标生成器 1.2.3 背景生成 Figen ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:2","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#12-图片"},{"categories":["资源","导航"],"content":"1.2 图片 iLoveIMG 多功能图片转换器无需上传文件 AI人工智能图片放大：免费版3000x3000px, 5M; 付费版50M。 最优图像优化 在线图片去底工具 在线GIF制作和编辑 1.2.1 OCR EasyScreenOCR ONLINE OCR 1.2.2 图标制作 小米风格Logo生成器 favicon图标制作工具 favicon图标生成器 1.2.3 背景生成 Figen ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:2","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#121-ocr"},{"categories":["资源","导航"],"content":"1.2 图片 iLoveIMG 多功能图片转换器无需上传文件 AI人工智能图片放大：免费版3000x3000px, 5M; 付费版50M。 最优图像优化 在线图片去底工具 在线GIF制作和编辑 1.2.1 OCR EasyScreenOCR ONLINE OCR 1.2.2 图标制作 小米风格Logo生成器 favicon图标制作工具 favicon图标生成器 1.2.3 背景生成 Figen ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:2","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#122-图标制作"},{"categories":["资源","导航"],"content":"1.2 图片 iLoveIMG 多功能图片转换器无需上传文件 AI人工智能图片放大：免费版3000x3000px, 5M; 付费版50M。 最优图像优化 在线图片去底工具 在线GIF制作和编辑 1.2.1 OCR EasyScreenOCR ONLINE OCR 1.2.2 图标制作 小米风格Logo生成器 favicon图标制作工具 favicon图标生成器 1.2.3 背景生成 Figen ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:2","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#123-背景生成"},{"categories":["资源","导航"],"content":"1.3 视频\u0026音频 网易见外工作台 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:3","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#13-视频音频"},{"categories":["资源","导航"],"content":"1.4 速查表 W3Schools KaTeX - Supported Functions Linux 命令列表 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:4","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#14-速查表"},{"categories":["资源","导航"],"content":"1.5 天梯图 桌面CPU性能天梯图 桌面GPU性能天梯图 笔记本CPU性能天梯图 手机影像DxO综合榜 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:5","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#15-天梯图"},{"categories":["资源","导航"],"content":"1.6 其他工具 Steam历史价格查询 全球Apple产品比价 极简简历模板PoleBrief 萝卜工坊 - 模拟手写字体 ProcessOn - 在线思维导图、流程图 英文字体转换 Overleaf Ubuntu Pastebin OnlineGDB C++ shell Learn Git Branching regex101 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:6","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#16-其他工具"},{"categories":["资源","导航"],"content":"2 在线观看","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:0","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#2-在线观看"},{"categories":["资源","导航"],"content":"2.1 影视 低端影视 奈菲影视 看片狂人 NO视频 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:1","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#21-影视"},{"categories":["资源","导航"],"content":"2.2 动漫 AGE动漫 樱花动漫 ZzzFun动漫视频网 漫岛动漫 EDD动漫 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:2","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#22-动漫"},{"categories":["资源","导航"],"content":"2.3 漫画 漫画DB 动漫之家 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:3","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#23-漫画"},{"categories":["资源","导航"],"content":"2.4 体育直播 CCTV-5体育频道高清直播 JRKAN直播 比赛直播 直播吧 足球巴巴 极速体育 来球网 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:4","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#24-体育直播"},{"categories":["资源","导航"],"content":"3 资源下载","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:3:0","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#3-资源下载"},{"categories":["资源","导航"],"content":"3.1 影视 高清MP4粉 片源网 BT天堂 SubDH FIX字幕侠 牛牛美剧 音范丝 Nyaa RARBG 纪录片天地 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:3:1","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#31-影视"},{"categories":["资源","导航"],"content":"3.2 字幕 SubHD 字幕库 A4k字幕网 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:3:2","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#32-字幕"},{"categories":["资源","导航"],"content":"3.3 动漫 动漫领域 肥羊-Raws 11周年Peach 不移之火资源网 漫猫动漫BT下载 爱恋动漫BT下载 90分钟足球网 知轩藏书 磁力 磁力爬 GFW 八爪鱼磁搜 搜番 吃力网 电影淘淘 Torrent Kitty - 免费种子转磁力网站 云盘狗 搜盘么 Office Word联盟 优品PPT PPT超级市场 第1PPT PPT演示设计网址导航 图片 Dribbble Pinterest Freepik Unsplash DeviantArt Behance 极简壁纸1 极简壁纸2 Wallpaper Abyss wallhaven 图标 Worldvectorlogo Iconduck StickPNG Iconfont-阿里巴巴矢量图标库 设计之家 notion icons.v5 插画 Storyset StickPNG Iconfont-阿里巴巴矢量图标库 设计 Figma 摄影 天空之城 游戏 Liquipedia DST-MOD Wikri 叽哩叽哩游戏网ACG（G站） 小爱同学音色网 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:3:3","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#33-动漫"},{"categories":["资源","导航"],"content":"软件 MSDN,我告诉你 吾爱破解 异星软件空间 易酷软件 果核剥壳 Easy To Direct Download Pc Software Crack Softwares 下载免费Wondows个人电脑游戏及软件 捷径库 反斗软件 Mergeek - 发现好产品 Appwall Today - iOS 每日限免 Awesome Windows 必备 ShareX Snipaste Clover uTools Bandizip 天若OCR Everything RubberTranslator CopyTranslator ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:4:0","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#软件"},{"categories":["资源","导航"],"content":"导航 不死鸟 - 分享为王 福利吧 缙哥哥博客 - 福利分享 好棒的羊毛站 创造狮导航 A+医学百科 wikiHow - 万事指南 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:5:0","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#导航"},{"categories":["资源","导航"],"content":"推荐 The best Programming books 历史剧网 油猴插件 Greasy Fork 雷利子 秒传链接提取 数学 Mathway | 微积分问题解答者 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:6:0","series":null,"tags":["资源","导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#推荐"},{"categories":["资源","导航"],"content":"真·学习资源。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#"},{"categories":["资源","导航"],"content":"1.编程基础环境搭建 环境搭建 Arch Linux 安装使用教程 Psyduck：XMind 记录 CS 基础问题。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#1编程基础"},{"categories":["资源","导航"],"content":"1.1 操作系统操作系统 逸仙OS简明教程 Systems Programming Cheat Sheet Linux Linux命令行与Shell脚本教程 Linux 网络编程与加密 explainshell.com ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:1","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#11-操作系统"},{"categories":["资源","导航"],"content":"1.2 数据库数据库 SQLBolt: interactive lessons and exercises ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:2","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#12-数据库"},{"categories":["资源","导航"],"content":"1.3 云 Docker Getting Started Tutorial: Docker入门。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:3","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#13-云"},{"categories":["资源","导航"],"content":"1.4 正则表达式 Regex-vis：正则表达式可视化。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:4","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#14-正则表达式"},{"categories":["资源","导航"],"content":"编程语言 Bit Twiddling Hacks: 位运算奇淫巧计。 Cheatsheet for regex syntaxes: Read Online ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#编程语言"},{"categories":["资源","导航"],"content":"C C Programming Course ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:1","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#c"},{"categories":["资源","导航"],"content":"C++ cplusplus.com C++那些事：这是一个适合初学者从入门到进阶的仓库，解决了面试者与学习者想要深入 C++及如何入坑 C++的问题。除此之外，本仓库拓展了更加深入的源码分析，多线程并发等的知识，是一个比较全面的 C++ 学习从入门到进阶提升的仓库。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:2","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#c-1"},{"categories":["资源","导航"],"content":"Go mmcgrana/gobyexample：使用带注释的示例程序进行 Go 操作的实践介绍。 Go by Example quii/learn-go-with-tests：通过编写测试学习 Go 语言。 Learn Go with tests Tutorial: Get started with Go：Go 官方教程。 Practical Go Lessons Introduction-to-Golang：最全空降 golang 资料补给包（满血战斗），包含文章，书籍，作者论文，理论分析，开源框架，云原生，大佬视频，大厂实战分享 ppt。 《Go入门指南》 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:3","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#go"},{"categories":["资源","导航"],"content":"Java Java SE Documentation：Java SE 文档。 JDK 11 API JDK 8 API How2J 的 Java教程 concurrent: 深入浅出Java多线程。 在线阅读 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:4","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#java"},{"categories":["资源","导航"],"content":"Javascript clean-code-javascript: Clean Code concepts adapted for JavaScript ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:5","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#javascript"},{"categories":["资源","导航"],"content":"Python Python-Mini-Projects: 一系列简单的 Python 迷你项目，可提高您的 Python 技能。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:6","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#python"},{"categories":["资源","导航"],"content":"Rust 使用 Rust 迈出第一步: 打下使用 Rust 构建快速、高效的程序所需的知识基础。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:7","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#rust"},{"categories":["资源","导航"],"content":"Typescript 深入理解 TypeScript: TypeScript Deep Dive的中文翻译版 在线阅读 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:8","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#typescript"},{"categories":["资源","导航"],"content":"工具论文 SCI-Hub论文下载可用网址链接 企鹅论文 一键下载 WordTEX Learn LaTeX Darling: Darling is a runtime environment for macOS applications. scrcpy: 显示和控制您的 Android 设备。 Tesseract OCR: Tesseract 开源 OCR 引擎。 PDF.js: 使用 HTML5 构建的 PDF 查看器。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#工具"},{"categories":["资源","导航"],"content":"前端 带你入门前端工程: 国内访问（Gitee） 国外访问（Github） 图解 React 源码系列: 图解 React 源码，用大量配图的方式，致力于将 React 原理表述清楚。 50 Projects in 50 Days - HTML/CSS and JavaScript ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#前端"},{"categories":["资源","导航"],"content":"人工智能","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#人工智能"},{"categories":["资源","导航"],"content":"博客博客 『A Course in Machine Learning』by Hal Daumé III AI算法工程师手册 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:1","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#博客"},{"categories":["资源","导航"],"content":"课程公开课 机器学习 - 吴恩达 | Coursera ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:2","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#课程"},{"categories":["资源","导航"],"content":"教程书籍 《利用 Python 进行数据分析（第2版）》 GitBook 《Python for Data Analysis》代码 《Pandas Cookbook》 《Pandas Cookbook》代码 教程 《简明的 TensorFlow 2》 | 在线 📅2021/07/15 🌟3484 30天吃掉那只TensorFlow2 ｜ GitBook 📅2021/05/27 🌟8855 TensorFlow 2.0 Tutorials 📅2020/09/23 🌟5993 20天吃掉那只Pytorch 20210704 深度学习500问 20210317 nlp-tutorial 20210502 Machine Learning for Beginners - A Curriculum 20210721 《Deep Learning》 《The Elements of Statistical Learning》中文版 《Interpretable machine learning》 | 在线 20210713 《动手学深度学习》李沐 | 在线 20210717 《神经网络与深度学习》邱锡鹏 | 在线 20210518 深度学习论文翻译 深度学习入门教程, 优秀文章 AiLearning: 机器学习：在线 机器学习原理：在线 Data-Science-Notes CS229 课程讲义中文翻译：在线 斯坦福大学2014（吴恩达）机器学习教程中文笔记：在线 《神经网络与深度学习》 邱锡鹏：在线 Deep Learning with PaddlePaddle：在线 Joyful-Pandas | 在线 20210331 User Guide — pandas pytorch handbook: 帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门。 【关于 NLP】那些你不知道的事 【关于 NLP】百问百答 Start Machine Learning in 2021: 2021 年开始和改进机器学习 (ML)、人工智能 (AI) 的完整指南，无需任何该领域的背景，并随时了解最新消息和最先进技术！ PyTorch 中文手册: 这是一本开源的书籍，目标是帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门。 【关于 NLP】 那些你不知道的事","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:3","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#教程"},{"categories":["资源","导航"],"content":"竞赛 阿里云天池 Kaggle ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:4","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#竞赛"},{"categories":["资源","导航"],"content":"论文 Papers With Code: The latest in Machine Learning. CVF Open Access Best Paper Awards in CS 卖萌屋学术站: 每日学术论文。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:5","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#论文"},{"categories":["资源","导航"],"content":"社区社区 Dataquest AI研习社 AMiner ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:6","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#社区"},{"categories":["资源","导航"],"content":"速查表速查表 Pandas Cheat Sheet ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:6:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#速查表"},{"categories":["资源","导航"],"content":"算法面试 Google’s Tech Dev Guide: grow your technical skills, supplement your coursework, and prepare for interviews. awesome-cs-books: 经典编程书籍大全，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试等 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#算法面试"},{"categories":["资源","导航"],"content":"面试 CS-Notes： 在线 Coding Interview University： 中文 2021笔试面试题 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:1","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#面试"},{"categories":["资源","导航"],"content":"设计模式 design-patterns-for-humans-cn: Design patterns for humans中文版 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:2","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#设计模式"},{"categories":["资源","导航"],"content":"算法 The Algorithms labuladong 的算法小抄： GitHub Pages Gitbook Gitee Pages 算法珠玑： 在线 《algorithm-note》中文版： 在线 LeetCode 101: 一个面向有C++编程基础，但缺乏刷题经验的读者的教科书和工具书（不适合编程小白喔）。 Algorithms, 4th Edition Algorithms by Jeff Erickson Competitive-Programming-Resources Algorithm Guide: 程序员必知必会的算法和数据结构 不懂动态规划？21道 LeetCode题目带你学会动态规划！ 五万字《十大排序算法》动图讲解 Learn-Algorithms: 算法学习笔记 algorithm-note: 数据结构与算法的讲解及代码实现，在线阅读 Data Structure Visualizations ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:3","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#算法"},{"categories":["资源","导航"],"content":"网络安全网络安全 《CTF竞赛权威指南》 | GitBook TryHackMe Attack-Defense Online Lab XSS 挑战 CTF - Application Security Challenge Command Challenge Exploit Education Google CTF Hack The Box Defend the Web Hacksplaining Hacker101 CTF ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:8:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#网络安全"},{"categories":["资源","导航"],"content":"其他项目 HelloGitHub free-project-course: 整理和搜集网络免费的项目实战课程 Github Digital Privacy MockingBird: AI拟声，5秒内克隆您的声音并生成任意语音内容 LaTeX-OCR: pix2tex, Using a ViT to convert images of equations into LaTeX code Bifrost: Search for visual datasets by task, application, class, label or format Manim Community: Python library for creating mathematical animations SG-NLP: SG-NLP is an initiative by AI Singapore’s NLP Hub A Vim Guide For Experts PearOCR Diffgram: Training data platform for machine learning delivered as a single application Forecasting: Principles and Practice (3rd ed) Greykite: A flexible, intuitive and fast forecasting library flow-forecast: Deep learning PyTorch library for time series forecasting, classification, and anomaly detection Codeimg.io: Convert code to image Macast: A menu bar application using mpv as DLNA Media Renderer. You can push videos, pictures or musics from your mobile phone to your computer Real-time-stock-market-prediction: Server architecture for Real-time Stock-marke","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:9:0","series":null,"tags":["资源","导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#其他"},{"categories":[],"content":"JVM 主要组成部分JVM 包含两个子系统和两个组件： 两个子系统 Class loader（类装载）：根据给定的全限定类名（如：java.lang.Object）来装载 class 文件到 Runtime data area 中的method area。 Execution engine（执行引擎）：执行 classes 中的指令。 两个组件 Runtime data area（运行时数据区）：这就是我们常说的 JVM 的内存。 Native Interface（本地接口）：与 Native libraries 交互，是其它编程语言交互的接口。 首先通过编译器（javac）把 Java 代码编译成字节码（.class）。类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内。而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:1:0","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#jvm-主要组成部分"},{"categories":[],"content":"JVM 运行时数据区JVM 在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， JVM 规范规定的区域分为以下 5 个部分： 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。 Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作 数栈、动态链接、方法出口等信息。 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。 Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享，几乎所有的对象实例都在这里分配内存。 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:2:0","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#jvm-运行时数据区"},{"categories":[],"content":"对象创建的主要流程虚拟机遇到一条 new 指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载（ClassLoader）。类加载通过后，接下来分配内存。若 Java 堆中内存是绝对规整的，使用指针碰撞方式分配内存；如果不是规整的，就从空闲列表中分配，叫做空闲列表方式。 划分内存时还需要考虑一个问题——并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。然后内存空间初始化操作，接着是做一些必要的对象设置（元信息、哈希码……），然后执行方法。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:3:0","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#对象创建的主要流程"},{"categories":[],"content":"为对象分配内存类加载完成后，接着会在 Java 堆中划分一块内存分配给对象。内存分配根据 Java 堆是否规整，有两种方式： 指针碰撞：如果 Java 堆的内存是规整，即所有用过的内存放在一边，而空闲的内存放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。 空闲列表：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。 选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理的功能决定。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:3:1","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#为对象分配内存"},{"categories":[],"content":"处理并发安全问题对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）； 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用 TLAB。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:3:2","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#处理并发安全问题"},{"categories":[],"content":"对象的访问定位Java 程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有句柄和直接指针两种方式。 直接指针：指向对象，代表一个对象在内存中的起始地址。 句柄：可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:4:0","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#对象的访问定位"},{"categories":[],"content":"句柄访问Java 堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。 优点：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:4:1","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#句柄访问"},{"categories":[],"content":"直接指针如果使用直接指针访问，引用中存储的直接就是对象地址，那么 Java 堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。 优点：速度更快，节省了一次指针定位的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 虚拟机中采用的就是这种方式。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:4:2","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#直接指针"},{"categories":[],"content":"内存溢出内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说， Java 是有 GC 垃圾回收机制的，也就是说，不再被使用的对象，会被 GC 自动回收掉，自动从内存中清除。但是，即使这样，Java 也还是存在着内存泄漏的情况，Java 导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为 长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:5:0","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#内存溢出"},{"categories":[],"content":"Java 垃圾回收机制垃圾回收（Garbage Collection，GC） 在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。 垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。使 Java 程序员在编写程序时不再考虑内存管理的问题。 程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:0","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#java-垃圾回收机制"},{"categories":[],"content":"垃圾回收器的基本原理对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。 可以手动执行System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:1","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#垃圾回收器的基本原理"},{"categories":[],"content":"Java 中的引用类型 强引用：发生 GC 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用PhantomReference 实现虚引用，虚引用的用途是在 GC 时返回一个通知。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:2","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#java-中的引用类型"},{"categories":[],"content":"如何判断对象是否可以被回收垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器加 1，引用被释放时计数减 1，当计数器为 0 时就可以被回收。它有一个缺点是不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:3","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#如何判断对象是否可以被回收"},{"categories":[],"content":"垃圾回收算法分类 **标记-清除（Mark-Sweep）**算法：标记无用对象，然后进行清除回收。 优点：实现简单，不需要对象进行移动。 缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。 复制算法：把内存空间划分为两个大小相等的区域，当一块用完的时候将活着的对象复制到另一块，然后再把已使用的内存空间一次清理掉。 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。 缺点：内存使用率不高，只有 50%。对象存活率过高时会频繁进行复制，降低了效率。 **标记-整理（Mark-Compact）**算法：标记无用对象，让所有存活的对象都向一端移动，使它们紧凑的排列在一起，然后对端边界以外的内存进行回收。 优点：解决了标记-清理算法存在的内存碎片问题。 缺点：仍需要进行局部对象移动，一定程度上降低了效率。 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代（Young Generation）、老年代（Old/Tenured Generation）和永久代（Permanent Generation）。新生代基本采用复制算法，老年代采用标记整理算法。当前商业虚拟机都采用分代收集的垃圾收集算法。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:4","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#垃圾回收算法分类"},{"categories":[],"content":"永久代中会发生垃圾回收吗垃圾回收不会发生在永久代，但如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。 Java 8 中移除了永久代，新加了一个叫做元数据区的 native 内存区。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:5","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#永久代中会发生垃圾回收吗"},{"categories":[],"content":"垃圾回收器分类 新生代的垃圾收集器： Serial（复制算法）：新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效； ParNew（复制算法）：新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现； Parallel Scavenge（复制算法）：新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； 老年代的垃圾收集器： Serial Old（标记-整理算法）：老年代单线程垃圾收集器，Serial 的老年代版本； Parallel Old（标记-整理算法）：老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本； CMS（Concurrent Mark-Sweep）（标记-清除算法）：老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。 整个 Java 堆空间 G1（Garbage First）（标记-整理算法）： Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。 CMS 垃圾回收器CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 垃圾回收器的工作流程新生代默认占总空间的 1/3，老生代默认占 2/3。新生代使用的是复制算法，新生代里有 3 个分区","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:6","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#垃圾回收器分类"},{"categories":[],"content":"垃圾回收器分类 新生代的垃圾收集器： Serial（复制算法）：新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效； ParNew（复制算法）：新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现； Parallel Scavenge（复制算法）：新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； 老年代的垃圾收集器： Serial Old（标记-整理算法）：老年代单线程垃圾收集器，Serial 的老年代版本； Parallel Old（标记-整理算法）：老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本； CMS（Concurrent Mark-Sweep）（标记-清除算法）：老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。 整个 Java 堆空间 G1（Garbage First）（标记-整理算法）： Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。 CMS 垃圾回收器CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 垃圾回收器的工作流程新生代默认占总空间的 1/3，老生代默认占 2/3。新生代使用的是复制算法，新生代里有 3 个分区","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:6","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#cms-垃圾回收器"},{"categories":[],"content":"垃圾回收器分类 新生代的垃圾收集器： Serial（复制算法）：新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效； ParNew（复制算法）：新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现； Parallel Scavenge（复制算法）：新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； 老年代的垃圾收集器： Serial Old（标记-整理算法）：老年代单线程垃圾收集器，Serial 的老年代版本； Parallel Old（标记-整理算法）：老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本； CMS（Concurrent Mark-Sweep）（标记-清除算法）：老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。 整个 Java 堆空间 G1（Garbage First）（标记-整理算法）： Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。 CMS 垃圾回收器CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 垃圾回收器的工作流程新生代默认占总空间的 1/3，老生代默认占 2/3。新生代使用的是复制算法，新生代里有 3 个分区","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:6","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#垃圾回收器的工作流程"},{"categories":[],"content":"Java 内存分配策略对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲（TLAB），将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配（大对象）。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则： 对象优先在 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。 Minor GC：发生在新生代中的 GC，因为 Java 对象大多都是朝生夕死，所以 Minor GC 非常频繁，一般回收速度也非常快； Major GC/Full GC：发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。 大对象直接进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。新生代使用的是复制算法，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。 长期存活对象将进入老年代。虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每经过一次 Minor GC 未被回收则年龄加 1，当年龄达到一个阈值（默认 15）就会被晋升到老年代。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:6:7","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#java-内存分配策略"},{"categories":[],"content":"JVM 类加载机制虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:7:0","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#jvm-类加载机制"},{"categories":[],"content":"JVM 加载 class 文件Java 中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也 是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时 候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。类装载方式，有两种： 隐式装载。程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用 类装载器加载对应的类到 JVM 中。 显式装载。通过Class.forName()等方法，显式加载需要的类。 Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到 JVM 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:7:1","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#jvm-加载-class-文件"},{"categories":[],"content":"类加载器实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有一下四种类加载器: 启动类加载器(Bootstrap ClassLoader)用来加载 Java 核心类库，无法被 java程序直接引用。 扩展类加载器(extensions class loader): 它用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径 （CLASSPATH ）来加载 Java 类。一般来说，Java 应用的类都是由它来 完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:7:2","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#类加载器"},{"categories":[],"content":"类装载的执行过程类装载分为以下 5个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 验证：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为 一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:7:3","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#类装载的执行过程"},{"categories":[],"content":"双亲委派模型在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一 个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。 ","date":"2022-04-19","objectID":"/posts/jvm-%E8%AF%A6%E8%A7%A3/:7:4","series":null,"tags":[],"title":"JVM 详解","uri":"/posts/jvm-%E8%AF%A6%E8%A7%A3/#双亲委派模型"},{"categories":[],"content":"import numpy as np ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":"随机种子 np.random.seed(self, seed=None)：固定随机数的输出结果。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#随机种子"},{"categories":[],"content":"创建数组","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#创建数组"},{"categories":[],"content":"指定值填充 np.empty(shape, dtype=float, order='C', *, like=None)：返回给定形状和类型的新数组，而无需初始化条目。 np.empty_like(prototype, dtype=None, order='K', subok=True, shape=None)：返回形状和类型与给定数组相同的新数组。 np.eye(N, M=None, k=0, dtype=\u003cclass 'float'\u003e, order='C', *, like=None)：返回单位矩阵。 np.identity(n, dtype=None, *, like=None)：返回单位矩阵。 np.ones(shape, dtype=None, order='C', *, like=None)：返回给定形状和类型的新数组，并用1填充。 np.ones_like(a, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用1填充。 np.zeros(shape, dtype=float, order='C', *, like=None)：返回给定形状和类型的新数组，并用0填充。 np.zeros_like(a, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用0填充。 np.full(shape, fill_value, dtype=None, order='C', *, like=None)：返回给定形状和类型的新数组，并用fill_value填充。 np.full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用fill_value填充。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#指定值填充"},{"categories":[],"content":"范围内填充 np.arange([start, ]stop, [step, ]dtype=None, *, like=None)：返回给定间隔内的均匀间隔的值。 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)：返回指定间隔内的等间隔数字。 np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)：返回数以对数刻度均匀分布。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#范围内填充"},{"categories":[],"content":"随机值填充 np.random.rand(d0, d1, ..., dn)：返回服从[0,1)均匀分布的指定形状的浮点数数组。 np.random.uniform(low=0.0, high=1.0, size=None)：返回服从[low,high)均匀分布的指定形状的浮点数数组。 np.random.randint(low, high=None, size=None, dtype=int)：返回服从[low,high)均匀分布的指定形状的整数数组。 np.random.randn(d0, d1, ..., dn)：返回服从N(0,1)标准正态分布的指定形状的浮点数数组。 np.random.normal(loc=0.0, scale=1.0, size=None)：返回服从N(loc,scale)正态分布的指定形状的浮点数数组。 np.random.choice(a, size=None, replace=True, p=None)：从数组中随机有放回采样若干次。 np.random.permutation(x)：返回随机排列。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#随机值填充"},{"categories":[],"content":"数组操作 ndarray.T：返回转置。 np.transpose(a, axes=None)：返回转置。 np.c_[tup]：左右合并。 np.column_stack(tup)：左右合并。 np.r_[tup]：行合并。 ``：行合并。 ``： ``： ``： ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#数组操作"},{"categories":[],"content":"API Docs CSS C++ C++ Go HTML Java SE 11 JavaScript Keras Matplotlib NumPy pandas PyTorch scikit-learn TensorFlow ","date":"2021-12-20","objectID":"/posts/%E7%BD%91%E5%9D%80%E5%AF%BC%E8%88%AA/:1:0","series":null,"tags":[],"title":"网址导航","uri":"/posts/%E7%BD%91%E5%9D%80%E5%AF%BC%E8%88%AA/#api-docs"},{"categories":["力扣","摩尔投票法"],"content":"题目链接 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:0:0","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#"},{"categories":["力扣","摩尔投票法"],"content":"摩尔投票法","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:0","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#摩尔投票法"},{"categories":["力扣","摩尔投票法"],"content":"背景摩尔投票法的核心思想为对拼消耗。首先我们考虑最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数 $\\frac{1}{2}$ 的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。摩尔投票算法的核心思想是基于这个事实： 每次从序列里选择两个不相同的数字删除掉（或称为「抵消」），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个元素。假设我们当前数组中存在次数大于总数一半的元素为 x，数组的总长度为 n，则我们可以把数组分为两部分，一部分为相同的 k 个元素 x，另一部分为 $\\frac{n - k}{2}$ 对个不同的元素配对，此时我们假设还存在另外一个次数大于总数一半的元素 y，则此时 y 应该满足 y $\\gt \\frac{n}{2}$，但是按照我们之前的推理 y 应当满足 y $\\le \\frac{n - k}{2}$，二者自相矛盾。 论文地址：MJRTYA Fast Majority Vote Algorithm ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:1","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#背景"},{"categories":["力扣","摩尔投票法"],"content":"步骤","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:2","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#步骤"},{"categories":["力扣","摩尔投票法"],"content":"代码 class Solution { public: vector\u003cint\u003e majorityElement(vector\u003cint\u003e \u0026nums) { // 记录两个元素的值 int value1, value2; // 记录对应元素出现的次数 int count1 = 0, count2 = 0; // 第一次遍历：筛选出现次数最多元素（至少0个，至多2个）或者出现位置偏后的元素，用 value1 和 value2 记录 for (int \u0026v : nums) { if (count1 == 0 \u0026\u0026 count2 == 0 || count1 == 0 \u0026\u0026 v != value2) { value1 = v; count1++; } else if (count2 == 0 \u0026\u0026 v != value1) { value2 = v; count2++; } else if (v == value1) count1++; else if (v == value2) count2++; else { // 三个元素均不相等则消除 count1--; count2--; } } int total_count1 = 0; int total_count2 = 0; // 第二次遍历：记录筛选出的元素的出现次数，用来检验是否满足题意 for (int \u0026v : nums) { if (count1 \u003e 0 \u0026\u0026 v == value1) total_count1++; if (count2 \u003e 0 \u0026\u0026 v == value2) total_count2++; } vector\u003cint\u003e ans; int len = nums.size(); if (total_count1 \u003e len / 3) ans.push_back(value1); if (total_count2 \u003e len / 3) ans.push_back(value2); return ans; } }; ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:3","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#代码"},{"categories":["力扣","摩尔投票法"],"content":"复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:4","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#复杂度分析"},{"categories":["力扣","特殊算法"],"content":"题目链接 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:0:0","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#"},{"categories":["力扣","特殊算法"],"content":"反对角线查找","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:0","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#反对角线查找"},{"categories":["力扣","特殊算法"],"content":"步骤沿着反对角线进行查找，可以右上到左下，也可以反过来，以右上到左下为例： 如果当前元素与 target 相等，返回 true； 如果当前元素大于 target，由于每一列的元素都是升序排列的，那么当前元素所在列往下所有元素全都大于 target，因此考虑左侧的元素； 如果当前元素小于 target，由于每一行的元素都是升序排列的，那么当前元素所在行往左所有元素全都小于 target，因此考虑下方的元素。 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:1","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#步骤"},{"categories":["力扣","特殊算法"],"content":"代码 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); // 右上角 int x = 0, y = n - 1; while (x \u003c m \u0026\u0026 y \u003e= 0) { if (matrix[x][y] == target) return true; // 先左 else if (matrix[x][y] \u003e target) y--; // 后下 else x++; } return false; } }; ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:2","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#代码"},{"categories":["力扣","特殊算法"],"content":"复杂度分析 时间复杂度：$O(m + n)$ 空间复杂度：$O(1)$ ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:3","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#复杂度分析"},{"categories":[],"content":"访问无公网地址的设备，如访问手机、平板、笔记本等。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":"ZeroTierZeroTier官网 特点： 免费 多平台 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#zerotier"},{"categories":[],"content":"使用 在ZeroTier官网创建一个账号。 登录后创建一个网络，得到网络ID。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#使用"},{"categories":[],"content":"使用 从ZeroTier官网下载并安装适用于您的操作系统的 ZeroTier。 加入网络，填写网络ID。 在ZeroTier中心管理网络，对已加入网络的设备，勾选Auth?，在Managed IPs处会显示 IP，即可用此 IP 访问该设备。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#使用-1"},{"categories":[],"content":"一般结构 // 包 package main // 导包 import ( \"fmt\" ) // 常量 const c = \"C\" // 变量 var v int = 5 // 自定义类型 type T struct { } // init() 函数，最先执行 func init() { } // main() 函数，其次执行 func main() { var a int Func1() // ... fmt.Println(a) } // 自定义可导出（公开）函数 func Func1() { //... } // 自定义不可导出（私有）函数 func func2() { } ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#一般结构"},{"categories":[],"content":"规范 虽然不需要分号作为语句的结束，但实际上这一过程是由编译器自动完成 不存在隐式类型转换，所有类型转换必须显式说明，如a := int(b) 标识符的命名规则遵循骆驼命名法 \\作为多行连接符 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#规范"},{"categories":[],"content":"注释 // 单行注释 /* 多行注释 */ 可通过godoc来导出注释，显示文档说明。 每一个包应该有相关注释。 在package语句之前的块注释将被默认认为是这个包的文档说明，称为包注释。 一个包可以有多个文件，只需要在其中一个文件中添加包注释。 所有全局的类型、常量、变量、函数和被导出的对象都应有注释。若出现在函数前面，称为文档注释，例如函数Abc()，则注释为// Abc ...。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#注释"},{"categories":[],"content":"可见性 public：标识符以大写字母开头，如Name。 private：标识符以小写字母开头，如id。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#可见性"},{"categories":[],"content":"包 import ( fm \"fmt\" // 别名 \"os\" \"./local_pkg\" // 本地包 ) 规范： 导入的包未使用报错。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#包"},{"categories":[],"content":"函数 func funcName(p1 int, p2 int) (add int, sub int) { return p1 + p2, p1 - p2 } // 函数很短，也可以放在同一行 func Sum(a, b int) int { return a + b } 规范： main()函数： main()函数是程序第一个执行的函数（如果有init()函数则会先执行init()） main包必须包含main()函数 main()函数既没有参数，也没有返回类型 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#函数"},{"categories":[],"content":"类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map\u003cstring, int\u003e或typedef map\u003cstring, int\u003e si; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) 每遇到一次const关键字，iota就重置为0 变量 var a, b int = 1, 2 var ( c int d bool e string ) 变量声明后，自动赋零值 int为0，float为0.0，bool为false，string为\"\"，指针为nil。 内层代码块中可使用与外部代码相同名称的变量，此时外部的同名变量将会暂时隐藏（内层不改变外部变量值） ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#类型"},{"categories":[],"content":"类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map或typedef mapsi; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#常量"},{"categories":[],"content":"类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map或typedef mapsi; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#变量"},{"categories":[],"content":" 英语 简称 中文 Accuracy 精度 Activation Function 激活函数 Adaptive Boosting AdaBoost AdaBoost Adaptive Gradient Algorithm AdaGrad AdaGrad Adaptive Moment Estimation Algorithm Adam Adam Affinity Matrix 亲和矩阵 Agent 智能体 Alpha-Beta Pruning α-β修剪法 Anomaly Detection 异常检测 Area Under ROC Curve AUC Artificial Intelligence AI 人工智能 Artificial Neural Network ANN 人工神经网络 Attention Mechanism 注意力机制 Autoencoder AE 自编码器 Automatic Differentiation AD 自动微分 Autoregressive AR 自回归 Back Propagation BP 反向传播 Bag of Words BOW 词袋 Bagging 装袋 Bandit 赌博机/老虎机 Baseline 基准 Batch Gradient Descent BGD 批量梯度下降法 Batch Normalization BN 批量规范化 Batch Size 批量大小 Bayes Classifier 贝叶斯分类器 Beam Search 束搜索 Benchmark 基准 Bi-Directional Long-Short Term Memory Bi-LSTM 双向长短期记忆 Bias 偏差/偏置 Bidirectional Recurrent Neural Network Bi-RNN 双向循环神经网络 Bigram 二元语法 Binary Sparse Coding 二值稀疏编码 Boosting Tree 提升树 Bootstrap Sampling 自助采样法 Bootstrapping 自助法/自举法 Bottom-Up 自下而上 Chebyshev Distance 切比雪夫距离 Classification And Regression Tree CART 分类与回归树 Computer Vision CV 计算","date":"2021-09-22","objectID":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/:0:0","series":null,"tags":[],"title":"翻译专业术语表","uri":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/#"},{"categories":[],"content":"参考 Artificial-Intelligence-Terminology-Database ","date":"2021-09-22","objectID":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/:1:0","series":null,"tags":[],"title":"翻译专业术语表","uri":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/#参考"},{"categories":[],"content":"根据模型预测值和真实值的区别来评价模型。 ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#"},{"categories":[],"content":"1.回归","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#1回归"},{"categories":[],"content":"1.1 MAE平均绝对误差，MAE，Mean Absolute Error $$ MAE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i| $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:1","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#11-mae"},{"categories":[],"content":"1.2 MAPE平均绝对百分比误差，MAPE，Mean Absolute Percentage Error $$ MAPE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n\\frac{|y_i-\\hat{y}_i|}{|y_i|} $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:2","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#12-mape"},{"categories":[],"content":"1.3 MSE均方误差，MSE，Mean Squared Error $$ MSE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i|_2^2 $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:3","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#13-mse"},{"categories":[],"content":"1.4 RMSE均方根误差，RMSE，Root Mean Squared Error $$ RMSE(y,\\hat{y})=\\sqrt{\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i|_2^2} $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:4","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#14-rmse"},{"categories":[],"content":"1.5 MSLE均方误差对数，MSLE，Mean Squared Log Error $$ MSLE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n\\big(\\log{(1+y_i)}-\\log{(1+\\hat{y}_i)}\\big)^2 $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:5","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#15-msle"},{"categories":[],"content":"1.6 MedAE中位绝对误差，MedAE，Median Absolute Error $$ MedAE(y,\\hat{y})=median(|y_1-\\hat{y}_1|,\\cdots,|y_n-\\hat{y}_n|) $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:6","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#16-medae"},{"categories":[],"content":"1.7 $R^2$拟合优度/可决系数，$R^2$，R Squared $$ R^2(y,\\hat{y})=1-\\frac{ \\sum_{i=1}^n (y_i-\\hat{y_i})^2 }{ \\sum_{i=1}^n (y_i-\\bar{y})^2 } $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:7","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#17-r2"},{"categories":[],"content":"参考 回归模型的评价指标比较 - 知乎 ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:2:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#参考"},{"categories":[],"content":"类图是 UML 中面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":"1.类图表示 一个类的 UML 图表示为一个矩形框，分为三层： 类名 粗体居中 若为抽象类，类名和抽象方法用斜体表示 若为接口，类名上加\u003c\u003cinterface\u003e\u003e，一般无属性 属性 可见性 + 属性名 + 类型 方法 可见性 + 方法名 + ( + 参数名 + 参数类型 + ) + 返回类型 可见性： -表示private #表示protected 空表示package/default +表示public ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#1类图表示"},{"categories":[],"content":"2.关系表示","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#2关系表示"},{"categories":[],"content":"2.1 泛化（Generalization） 关系：继承非抽象类 表示：子类指向父类的实线空心三角箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#21-泛化generalization"},{"categories":[],"content":"2.2 实现（Realize） 关系：继承抽象类 表示：子类指向父类的虚线空心三角箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#22-实现realize"},{"categories":[],"content":"2.3 聚合（Aggregation） 关系：成员对象是整体对象的属性，部分可独立存在，且可属于多个整体 表示：部分指向整体的实线空心菱形箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#23-聚合aggregation"},{"categories":[],"content":"2.4 组合（Composition） 关系：成员对象是整体对象的属性，整体与部分密不可分 表示：部分指向整体的实线实心菱形箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#24-组合composition"},{"categories":[],"content":"2.5 关联（Association） 关系：成员对象是整体对象的属性，一般表示一种平等关系 表示：部分指向整体的实线箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#25-关联association"},{"categories":[],"content":"2.6 依赖（Dependency） 关系：依赖对象一般作为参数传入另一个对象 表示：对象指向依赖对象的虚线箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#26-依赖dependency"},{"categories":[],"content":"参考 看懂UML类图和时序图 — Graphic Design Patterns 30分钟学会UML类图 - 知乎 Class diagrams - Mermaid ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#参考"},{"categories":["Java"],"content":"2.Collection","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#2collection"},{"categories":["Java"],"content":"2.1 方法 int size()：返回容器大小 boolean isEmpty()：容器是否为空 boolean contains(Object element)：是否包含指定元素 boolean add(E element)：添加元素；未添加成功返回 false boolean remove(Object element)：删除指定元素；未删除成功返回 false Iterator\u003cE\u003e iterator()：返回迭代器 boolean containsAll(Collection\u003c?\u003e c)：$A \\supset B$；当前容器是否包含了容器 c 中的所有元素 boolean addAll(Collection\u003c? extends E\u003e c)：$A \\cup B$；添加容器 c 中的所有元素到当前容器 boolean removeAll(Collection\u003c?\u003e c)：$A-B$；从当前容器中删除同时包含于容器 c 中的所有元素 boolean retainAll(Collection\u003c?\u003e c)：$A \\cap B$；从当前容器中删除不包含于容器 c 中的所有元素 void clear()：清空容器 Object[] toArray()：容器转 Object 数组 \u003cT\u003e T[] toArray(T[] a)：容器转数组 `` ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#21-方法"},{"categories":["Java"],"content":"2.2 遍历（1）聚合操作（Stream + Lambda）：只能访问，不能修改。 myColl.stream() .filter(e -\u003e e.getAttribute() == \"Attribute\") .forEach(e -\u003e System.out.println(e.toString())); myColl.forEach(System.out::println); （2）for-each：只能访问，不能修改。 for (Object o : myColl) { System.out.println(o); } （3）Iterator：可修改。 // 定义 public interface Iterator\u003cE\u003e { boolean hasNext(); // 是否存在下个元素 E next(); // 迭代器后移，同时返回下个元素 void remove(); // 删除当前元素 } for (Iterator\u003cE\u003e it = myColl.iterator(); it.hasNext();) { System.out.println(it.next()); } for (Iterator\u003cE\u003e it = myColl.iterator(); it.hasNext();) { E e = it.next(); if (judge(e)) { it.remove(); } } （4）for：可修改。 for (int i = 0; i \u003c myColl.size(); i++) { System.out.println(myColl.get(i)); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#22-遍历"},{"categories":["Java"],"content":"List","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list"},{"categories":["Java"],"content":"ArrayList import java.util.ArrayList; import java.util.List; // 定义 List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); // 数组实现 // 遍历1 for (int i = 0; i \u003c list.size(); i++) { int x = list.get(i); } // 遍历2 import java.util.Iterator; for (Iterator\u003cInteger\u003e it = list.iterator(); it.hasNext();) { int x = it.next(); } // 遍历3 for (int x : list) { // } 初始化 // 初始化1 List\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List\u003cInteger\u003e list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List\u003cInteger\u003e list4 = List.of(1, 2, 3); // 初始化5，推荐 List\u003cInteger\u003e list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List\u003cInteger\u003e list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet\u003cInteger\u003e deDuplicator = new LinkedHashSet\u003c\u003e(list1); List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List\u003cInteger\u003e list3 = list1.stream().distinct().collect(Collectors.toLi","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#arraylist"},{"categories":["Java"],"content":"ArrayList import java.util.ArrayList; import java.util.List; // 定义 List list = new ArrayList(); // 数组实现 // 遍历1 for (int i = 0; i it = list.iterator(); it.hasNext();) { int x = it.next(); } // 遍历3 for (int x : list) { // } 初始化 // 初始化1 List list1 = new ArrayList(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList(List.of(1, 2, 3)); 去重 List list1 = new ArrayList(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet(list1); List list2 = new ArrayList(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toLi","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#初始化"},{"categories":["Java"],"content":"ArrayList import java.util.ArrayList; import java.util.List; // 定义 List list = new ArrayList(); // 数组实现 // 遍历1 for (int i = 0; i it = list.iterator(); it.hasNext();) { int x = it.next(); } // 遍历3 for (int x : list) { // } 初始化 // 初始化1 List list1 = new ArrayList(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList(List.of(1, 2, 3)); 去重 List list1 = new ArrayList(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet(list1); List list2 = new ArrayList(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toLi","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#去重"},{"categories":["Java"],"content":"LinkedList import java.util.LinkedList; import java.util.List; // 定义 List\u003cInteger\u003e b = new LinkedList\u003c\u003e(); // 链表实现 List\u003cInteger\u003e c = List.of(1, 2, 3); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#linkedlist"},{"categories":["Java"],"content":"4.3 方法 E get(int index)：返回指定索引的元素 E set(int index, E element)：修改指定索引的元素，返回原来的元素 boolean add(E element)：添加到尾部 E remove(Object element)：只删除第一个匹配到的元素，返回删除的元素 int indexOf(E element)：返回第一个匹配到的元素的索引，失败返回 -1 int lastIndexOf(E element)：返回最后一个匹配到的元素的索引，失败返回 -1 boolean containsAll(Collection\u003c?\u003e c)：先将容器 c 转换为集合，再判断；只关注元素的值，不关注数量 boolean addAll(Collection\u003c? extends E\u003e c)：添加到尾部 boolean removeAll(Collection\u003c?\u003e c)：删除所有与容器 c 中具有相同值的元素；先将容器 c 转换为集合，再删除所有匹配项 boolean retainAll(Collection\u003c?\u003e c)：删除所有与容器 c 中具有不同值的元素；先将容器 c 转换为集合，再删除所有匹配项 ListIterator\u003cE\u003e listIterator()：返回列表迭代器，可双向迭代 ListIterator\u003cE\u003e listIterator(int index)：返回指定索引的列表迭代器，可双向迭代 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#43-方法"},{"categories":["Java"],"content":"4.4 遍历ListIterator：可修改，双向迭代。 // 列表迭代器定义 public interface ListIterator\u003cE\u003e extends Iterator\u003cE\u003e { boolean hasNext(); E next(); int nextIndex(); // 返回下个元素下标 boolean hasPrevious(); E previous(); int previousIndex(); void remove(); void set(E e); // 修改当前迭代器指向元素 void add(E e); // 添加到当前迭代器指向元素之前（next 之前，previous 之后），能被 } 迭代器总是位于元素之间，它并不指向某个元素，而是指向元素之间的间隔。 所以，listIterator(int index)可以接受的参数范围为[0, myList.size()] listIterator()返回的迭代器初始位于第一个元素之前。 listIterator()返回的迭代器初始位于第一个元素之前。 // 正向 for (ListIterator\u003cE\u003e it = myList.listIterator(); it.hasNext();) { E e = it.next(); } // 逆向 for (ListIterator\u003cE\u003e it = myList.listIterator(myList.size()); it.hasPrevious();) { E e = it.previous(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#44-遍历"},{"categories":["Java"],"content":"List 和数组转换List 转数组 List\u003cInteger\u003e list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List\u003cInteger\u003e list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list-和数组转换"},{"categories":["Java"],"content":"List 和数组转换List 转数组 List list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list-转数组"},{"categories":["Java"],"content":"List 和数组转换List 转数组 List list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#数组转-list"},{"categories":["Java"],"content":"排序 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#排序"},{"categories":["Java"],"content":"Queue // 定义 Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); // 向队尾添加元素 queue.offer(1); // 删除队首元素并返回 int first1 = queue.poll(); // 取队首元素 int first2 = queue.peek(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#queue"},{"categories":["Java"],"content":"Deque // 定义 Deque\u003cInteger\u003e deque = new LinkedList\u003c\u003e(); // 队尾添加 deque.offerLast(1); // 队首添加 deque.offerFirst(1); // 队尾删除并返回 int last1 = deque.pollLast(); // 队首删除并返回 int first1 = deque.pollFirst(); // 取队尾元素 int last2 = deque.peekLast(); // 取队首元素 int first2 = deque.peekFirst(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#deque"},{"categories":["Java"],"content":"PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue\u003cInteger\u003e q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue\u003cInteger\u003e q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable\u003cA\u003e { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator\u003cA\u003e { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue\u003cStu\u003e q1 = new PriorityQueue\u003c\u003e(new StuComp\u003cStu\u003e()); // 显式定义排序类 class StuComp implements Comparator\u003cStu\u003e { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#priorityqueue"},{"categories":["Java"],"content":"PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue((a, b) - b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#基本用法"},{"categories":["Java"],"content":"PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue((a, b) - b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#自定义类"},{"categories":["Java"],"content":"PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue((a, b) - b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#模板"},{"categories":["Java"],"content":"PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue((a, b) - b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#具体实现"},{"categories":["Java"],"content":"Set","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#set"},{"categories":["Java"],"content":"HashSet 元素唯一，不可重复 元素乱序 数组+哈希函数实现，性能最优 import java.util.HashSet; HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(1); set.contains(1); set.remove(1); set.clear(); set.size(); set.isEmpty(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#hashset"},{"categories":["Java"],"content":"TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); TreeSet\u003cInteger\u003e set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#treeset"},{"categories":["Java"],"content":"TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet(); TreeSet set2 = new TreeSet(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#增"},{"categories":["Java"],"content":"TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet(); TreeSet set2 = new TreeSet(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#查"},{"categories":["Java"],"content":"TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet(); TreeSet set2 = new TreeSet(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#删"},{"categories":["Java"],"content":"TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet(); TreeSet set2 = new TreeSet(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#子集"},{"categories":["Java"],"content":"TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet(); TreeSet set2 = new TreeSet(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#遍历"},{"categories":["Java"],"content":"Map","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#map"},{"categories":["Java"],"content":"HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); Map\u003cString, Integer\u003e otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry\u003cString, Integer\u003e ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#hashmap"},{"categories":["Java"],"content":"HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Mapmap = new HashMap(); MapotherMap = new HashMap(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key - 90); // 81 map.computeIfAbsent(\"Bob\", key - 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) - value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entryent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#增改"},{"categories":["Java"],"content":"HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Mapmap = new HashMap(); MapotherMap = new HashMap(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key - 90); // 81 map.computeIfAbsent(\"Bob\", key - 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) - value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entryent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#查-1"},{"categories":["Java"],"content":"HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Mapmap = new HashMap(); MapotherMap = new HashMap(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key - 90); // 81 map.computeIfAbsent(\"Bob\", key - 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) - value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entryent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#删-1"},{"categories":["Java"],"content":"HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Mapmap = new HashMap(); MapotherMap = new HashMap(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key - 90); // 81 map.computeIfAbsent(\"Bob\", key - 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) - value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entryent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#遍历-1"},{"categories":["Java"],"content":"TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable\u003cStu\u003e { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) \u003c 0 等价于 x \u003c y if (score != s.score) { return s.score - score; } else { return name.compareTo(s.name); } } } Map\u003cStu, Integer\u003e map = new TreeMap\u003c\u003e(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Map\u003cStu, Integer\u003e map1 = new TreeMap\u003c\u003e(new Comparator\u003cStu\u003e() { @Override public int compare(Stu a, Stu b) { // compare(x, y) \u003c 0 等价于 x \u003c y if (a.score != b.score) { return b.score - a.score; } else { return a.name.compareTo(b.name); } } }); // 实现2 lambda 表达式 Comparator\u003cStu\u003e cmp = (Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Map\u003cStu, Integer\u003e map2 = new TreeMap\u003c\u003e(cmp); // 实现3 lambda 表达式 Map\u003cStu, Integer\u003e map3 = ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#treemap"},{"categories":["Java"],"content":"TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) map = new TreeMap(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Mapmap1 = new TreeMap(new Comparator() { @Override public int compare(Stu a, Stu b) { // compare(x, y) cmp = (Stu a, Stu b) - a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Mapmap2 = new TreeMap(cmp); // 实现3 lambda 表达式 Mapmap3 = ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#类实现-comparable-接口"},{"categories":["Java"],"content":"TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) map = new TreeMap(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Mapmap1 = new TreeMap(new Comparator() { @Override public int compare(Stu a, Stu b) { // compare(x, y) cmp = (Stu a, Stu b) - a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Mapmap2 = new TreeMap(cmp); // 实现3 lambda 表达式 Mapmap3 = ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#自定义-comparator-比较器"},{"categories":["Java"],"content":"Arrays import java.util.Arrays; ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#arrays"},{"categories":["Java"],"content":"二分查找查找指定值，返回下标，若未找到则返回应该插入的下标的相反数减一。需要数组升序且元素无重复。 static \u003cT\u003e int binarySearch(T[] a, T key) static \u003cT\u003e int binarySearch(T[] a, int fromIndex, int toIndex, T key) static \u003cT\u003e int binarySearch​(T[] a, T key, Comparator\u003c? super T\u003e c) static \u003cT\u003e int binarySearch​(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c) int[] arr = {1, 3, 5}; Arrays.binarySearch(arr, -1); // -1 Arrays.binarySearch(arr, 0); // -1 Arrays.binarySearch(arr, 1); // 0 Arrays.binarySearch(arr, 2); // -2 Arrays.binarySearch(arr, -4); // -1 Arrays.binarySearch(arr, 8); // -4 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#二分查找"},{"categories":["Java"],"content":"比较a 小于 b 返回 -1，等于返回 0，大于返回 1。 static \u003cT\u003e int compare(T[] a, T[] b) static \u003cT\u003e int compare​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e int compare​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e int compare​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) 相等 true，不相等 false。 static \u003cT\u003e boolean equals​(T[] a, T[] b) static \u003cT\u003e boolean equals​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e boolean equals​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e boolean equals​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) 比较多维数组 static boolean deepEquals​(Object[] a1, Object[] a2) int[][] a = { { 1, 2 }, { 3, 4 } }; int[][] b = { { 1, 2 }, { 3, 4 } }; System.out.println(a == b); // false System.out.println(a.equals(b)); // false System.out.println(Arrays.deepEquals(a, b)); // true 返回第一个不相等的下标，若全相等，返回 -1。 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#比较"},{"categories":["Java"],"content":"复制新数组长度小于原数组则截断，大于则多余元素为 null/0。 static \u003cT\u003e T[] copyOf​(T[] original, int newLength) static \u003cT,​U\u003e T[] copyOf​(U[] original, int newLength, Class\u003c? extends T[]\u003e newType) static \u003cT\u003e T[] copyOfRange​(T[] original, int from, int to) static \u003cT,​U\u003e T[] copyOfRange​(U[] original, int from, int to, Class\u003c? extends T[]\u003e newType) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#复制"},{"categories":["Java"],"content":"赋值 static \u003cT\u003e void fill(T[] a, T val) static \u003cT\u003e void fill(T[] a, int fromIndex, int toIndex, T val) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#赋值"},{"categories":["Java"],"content":"前缀操作 static \u003cT\u003e void parallelPrefix​(T[] array, BinaryOperator\u003cT\u003e op) static \u003cT\u003e void parallelPrefix​(T[] array, int fromIndex, int toIndex, BinaryOperator\u003cT\u003e op) int[] a = { 1, 2, 3 }; // 前缀和 Arrays.parallelPrefix(a, (x, y) -\u003e x + y); // [1, 3, 6] ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:5","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#前缀操作"},{"categories":["Java"],"content":"排序 static \u003cT\u003e void sort​(T[] a) static \u003cT\u003e void sort​(T[] a, Comparator\u003c? super T\u003e c) static \u003cT\u003e void sort​(T[] a, int fromIndex, int toIndex) static \u003cT\u003e void sort​(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:6","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#排序-1"},{"categories":["Java"],"content":"流 static \u003cT\u003e Stream\u003cT\u003e stream​(T[] array) static \u003cT\u003e Stream\u003cT\u003e stream​(T[] array, int startInclusive, int endExclusive) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:7","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#流"},{"categories":["Java"],"content":"转为字符串 static \u003cT\u003e String toString(T[] a) static String deepToString​(Object[] a)：可用于打印多维数组。 int[][] a = { { 1, 2 }, { 3, 4 } }; int[][] b = { { 1, 2 }, { 3, 4 } }; System.out.println(a); // [[I@36aa7bc2 System.out.println(Arrays.toString(a)); // [[I@76ccd017, [I@182decdb] System.out.println(Arrays.toString(a[0])); // [1, 2] System.out.println(Arrays.deepToString(a)); // [[1, 2], [3, 4]] ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:8","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#转为字符串"},{"categories":["Java"],"content":"Collections import java.util.Collections; // 创建空集合 // 返回的集合是不可变集合，无法向其中添加或删除元素。 List\u003cString\u003e list1 = Collections.emptyList(); List\u003cString\u003e list2 = List.of(); Map\u003cString, Integer\u003e map1 = Collections.emptyMap(); Map\u003cString, Integer\u003e map2 = Map.of(); Set\u003cString\u003e set1 = Collections.emptySet(); Set\u003cString\u003e set2 = Set.of(); // 创建单元素集合 // 返回的集合是不可变集合，无法向其中添加或删除元素。 List\u003cString\u003e list1 = Collections.singletonList(\"one\"); List\u003cString\u003e list2 = List.of(\"one\"); Map\u003cString, Integer\u003e map1 = Collections.singletonMap(\"one\", 1); Map\u003cString, Integer\u003e map2 = Map.of(\"one\", 1); Set\u003cString\u003e set1 = Collections.singleton(\"one\"); Set\u003cString\u003e set2 = Set.of(\"one\"); // 排序 // 必须传入可变 List Collections.sort(list); // 洗牌 // 必须传入可变 List Collections.shuffle(list); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#collections"},{"categories":["Java"],"content":"10.代码片段 // 数组转 List // 1.重新分配空间 List\u003cInteger\u003e myList = new ArrayList\u003c\u003e(Arrays.asList(1, 2, 3)); // 2.使用同一片空间 List\u003cInteger\u003e myList = Arrays.asList(1, 2, 3); // 禁止调整大小，若 add 或 remove // 则抛出 UnsupportedOperationException 异常 // 转换为字符串 String str = myColl.stream() .map(Object::toString) .collect(Collectors.joining(\", \")); // 求和 int sum = myColl.stream() .collect(Collectors.summingInt(E::getValue)); // 删除容器中所有指定元素 myColl.removeAll(Collections.singleton(e)); myColl.removeAll(Collections.singleton(mull)); // 容器转数组，要求容器中元素类型统一 String[] arrStr = myColl.toArray(new String[0]); Integer[] arrInt = myColl.toArray(new Integer[0]); // 1.容器去重 Collection\u003cE\u003e noDups = new HashSet\u003c\u003e(myColl); Collection\u003cE\u003e noDups = myColl.stream().collect(Collectors.toSet()); // 2.容器去重，且保持原来顺序 Collection\u003cE\u003e noDups = new LinkedHashSet\u003c\u003e(myColl); public static \u003cE\u003e Set\u003cE\u003e removeDups(Collection\u003cE\u003e myColl) { return new LinkedHashSet\u003cE\u003e(myColl); } // 取出属性值，创建集合 Set\u003cString\u003e set = people.stream() .map(Person::getName) .collect(Coll","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#10代码片段"},{"categories":["Java"],"content":"char[] 转 Character[] char[] charArray = { 'a', 'b', 'c' }; Character[] charObjectArray = ArrayUtils.toObject(charArray); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#char-转-character"},{"categories":["Java"],"content":"11.聚合操作","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#11聚合操作"},{"categories":["Java"],"content":"重写 equals 方法 对引用类型用Objects.equals()比较（避免判断null），对基本类型直接用==比较。 import java.util.Objects; public boolean equals(Object o) { if (o instanceof E) { E e = (E) o; // } return false; } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#重写-equals-方法"},{"categories":["Java"],"content":"重写 hashCode 方法 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 import java.util.Objects; class Stu { String name; int score, age; public int hashCode() { return Objects.hash(name, score, age); } } 参考： Aggregate Operations - Java Tutorials ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#重写-hashcode-方法"},{"categories":["Java"],"content":"StreamsJava 8 中引入。 import java.util.stream.Collectors; import java.util.stream.Stream; // 获取流方法1 int[] array = { 1, 2, 3 }; Stream\u003cInteger\u003e s1 = Stream.of(array); // 获取流方法2 List\u003cInteger\u003e list = List.of(1, 2, 3); Stream\u003cInteger\u003e s2 = list.stream(); // 获取流方法3 Stream\u003cInteger\u003e s3 = Stream.of(1, 2, 3); // forEach 终端操作 List\u003cInteger\u003e list = List.of(1, 2, 3); list.stream().forEach(e -\u003e System.out.println(e)); list.stream().forEach(System.out::println); // map 中间操作 List\u003cString\u003e list = list.stream().map(e -\u003e e.toString()).collect(Collectors.toList()); // collect 终端操作 List\u003cInteger\u003e list = Stream.of(1, 2, 3).collect(Collectors.toList()); String str = list.stream().map(e -\u003e e.toString()).collect(Collectors.joining(\", \")); Set\u003cInteger\u003e set = list.stream().collect(Collectors.toSet()); // filter 中间操作 List\u003cInteger\u003e list = Stream.of(1, 2, 3).filter(e -\u003e e \u003c 2).collect(Collectors.toList()); // findFirst Integer x = Stream.of(1, 2, 3).filter(e -\u003e e % 2 == 1).findFirst().orElse(null); // toArray Integer[] ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#streams"},{"categories":["Python"],"content":"常用 Python 第三方库。 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:0:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#"},{"categories":["Python"],"content":"机器学习 scikit-learn: machine learning in Python. 🌟48.1k XGBoost: Scalable, Portable and Distributed Gradient Boosting (GBDT, GBRT or GBM) Library, for Python, R, Java, Scala, C++ and more. Runs on single machine, Hadoop, Spark, Dask, Flink and DataFlow. 🌟21.9k LightGBM: A fast, distributed, high performance gradient boosting (GBT, GBDT, GBRT, GBM or MART) framework based on decision tree algorithms, used for ranking, classification and many other machine learning tasks. 🌟13.2k CatBoost: A fast, scalable, high performance Gradient Boosting on Decision Trees library, used for ranking, classification, regression and other machine learning tasks for Python, R, Java, C++. Supports computation on CPU and GPU. 🌟6.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:1:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#机器学习"},{"categories":["Python"],"content":"深度学习 TensorFlow: TensorFlow is an end-to-end open source platform for machine learning. 🌟161k Pytorch: Tensors and Dynamic neural networks in Python with strong GPU acceleration. 🌟52.4k MXNet: Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Scala, Go, Javascript and more. 🌟19.8k PaddlePaddle: PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice. 🌟17.1k JAX: Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more. 🌟15.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:2:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#深度学习"},{"categories":["Python"],"content":"超参数优化 Optuna: A hyperparameter optimization framework. 🌟5,642 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:3:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#超参数优化"},{"categories":["Python"],"content":"自动化机器学习 auto-sklearn: Automated Machine Learning with scikit-learn. 🌟5,907 PyCaret: An open-source, low-code machine learning library in Python. 🌟4,541 Auto-PyTorch: Automatic architecture search and hyperparameter optimization for PyTorch. 🌟1,464 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:4:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#自动化机器学习"},{"categories":["Python"],"content":"时间序列分析 Prophet: Tool for producing high quality forecasts for time series data that has multiple seasonality with linear or non-linear growth. 🌟13,809 tsfresh: The package provides systematic time-series feature extraction by combining established algorithms from statistics, time-series analysis, signal processing, and nonlinear dynamics with a robust feature selection algorithm. 🌟6,074 sktime: A unified framework for machine learning with time series. 🌟4,721 Kats: Kats, a kit to analyze time series data, a lightweight, easy-to-use, generalizable, and extendable framework to perform time series analysis, from understanding the key statistics and characteristics, detecting change points and anomalies, to forecasting future trends. 🌟3,308 Darts: A python library for easy manipulation and forecasting of time series. 🌟3,208 GluonTS: Probabilistic time series modeling in Python. 🌟2,351 Merlion: A Machine Learning Framework for Time Series Intelligence. 🌟2,275 tslearn: A machine learning too","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:5:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#时间序列分析"},{"categories":["Python"],"content":"计算机视觉 Face Recognition: The world’s simplest facial recognition api for Python and the command line. 🌟42.3k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:6:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#计算机视觉"},{"categories":["Python"],"content":"自然语言处理 Transformers: State-of-the-art Natural Language Processing for Pytorch, TensorFlow, and JAX. 🌟54.9k jieba: “结巴”中文分词：做最好的 Python 中文分词组件。 🌟27.4k HanLP: 中文分词 词性标注 命名实体识别 依存句法分析 成分句法分析 语义依存分析 语义角色标注 指代消解 风格转换 语义相似度 新词发现 关键词短语提取 自动摘要 文本分类聚类 拼音简繁转换 自然语言处理。 🌟24.5k spaCy: Industrial-strength Natural Language Processing (NLP) in Python. 🌟21.9k AllenNLP: An open-source NLP research library, built on PyTorch. 🌟10.7k NLTK: NLTK – the Natural Language Toolkit – is a suite of open source Python modules, data sets, and tutorials supporting research and development in Natural Language Processing. 🌟10.3k TextBlob: Simple, Pythonic, text processing–Sentiment analysis, part-of-speech tagging, noun phrase extraction, translation, and more. 🌟8k fastNLP: fastNLP 是一款面向自然语言处理（NLP）的轻量级框架，目标是快速实现NLP任务以及构建复杂模型。 🌟2.4k textacy: NLP, before and after spaCy. 🌟1.8k xmnlp: 提供中文分词, 词性标注, 命名体识别，情感分析，文本纠错，文本转拼音，文本摘要，偏旁部首等功能。 🌟736 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:7:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#自然语言处理"},{"categories":["Python"],"content":"科学计算 NumPy: The fundamental package for scientific computing with Python. 🌟18.9k SciPy: SciPy is an open-source software for mathematics, science, and engineering. It includes modules for statistics, optimization, integration, linear algebra, Fourier transforms, signal and image processing, ODE solvers, and more. 🌟8.9k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:8:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#科学计算"},{"categories":["Python"],"content":"处理数据 pandas: Flexible and powerful data analysis / manipulation library for Python, providing labeled data structures similar to R data.frame objects, statistical functions, and much more. 🌟31.8k pdfminer.six: It is a tool for extracting information from PDF documents. 🌟3.2k openpyxl: openpyxl is a Python library to read/write Excel 2010 xlsx/xlsm/xltx/xltm files. ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:9:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#处理数据"},{"categories":["Python"],"content":"可视化 Matplotlib: Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. 🌟14.6k seaborn: Seaborn is a Python visualization library based on matplotlib. It provides a high-level interface for drawing attractive statistical graphics. 🌟9k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:10:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#可视化"},{"categories":["Python"],"content":"爬虫 Requests: A simple, yet elegant, HTTP library. 🌟46.5k Scrapy: Scrapy, a fast high-level web crawling \u0026 scraping framework for Python. 🌟42.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:11:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#爬虫"},{"categories":[],"content":"Pandas 是一个优秀的数据处理库。 import pandas as pd ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":"数据结构","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#数据结构"},{"categories":[],"content":"DataFrame df = pd.DataFrame({\"c1\": [11, 21, 31], \"c2\": [12, 22, 32], \"c3\": [13, 23, 33]}, index=[\"r1\", \"r2\", \"r3\"]) df = pd.DataFrame([[11, 12, 13], [21, 22, 23], [31, 32, 33]], index=['r1', 'r2', 'r3'], columns=['c1', 'c2', 'c3']) ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#dataframe"},{"categories":[],"content":"Series","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#series"},{"categories":[],"content":"读取数据 pd.read_csv() ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#读取数据"},{"categories":[],"content":"处理缺失数据 df.dropna() df.fillna(value) ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#处理缺失数据"},{"categories":[],"content":"参考 User Guide — pandas documentation ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#参考"},{"categories":[],"content":"阿里云盘相关小技巧。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:0:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#"},{"categories":[],"content":"1）阿里云盘转存115资源 下载 Chrome 或 Edge 或 Firefox 浏览器，并安装 Tampermonkey 插件。 安装脚本。 打开阿里云盘网页版。 点击右上角多文件提取，导入 sha1 链接文件。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:1:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#1阿里云盘转存115资源"},{"categories":[],"content":"参考 如何使用第三方脚本实现阿里云盘分享文件 - 太空堡垒麦克罗斯 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:1:1","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#参考"},{"categories":[],"content":"2）绕过阿里云分享限制目前阿里云盘只能分享 txt、mp4、jpg 等特定类型的文件, 而不能分享 zip、rar、7z 等压缩文件。 下载十六进制编辑器，修改前四个数值就可以改变文件种类。 macOS：brew install hex-fiend 示例：将zip文件伪装成png文件。 打开文件，将前四个数值改为89504E47。 修改文件后缀为png。 上传阿里云盘，此时可以分享。 下载文件后打开，将前四个数值改回504B0304。 文件后缀改回zip，然后解压。 文件类型 前四个值 png 89504E47 jpg/jpeg FFD8FFE0 gif 47494638 webp 52494646 svg 3C737667 mp4 00000020 zip 504B0304 7z 377ABCAF ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:2:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#2绕过阿里云分享限制"},{"categories":[],"content":"参考 如何绕过阿里云盘文件分享种类限制 - 哔哩哔哩 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:2:1","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#参考-1"},{"categories":["位运算","力扣"],"content":"题目链接 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#"},{"categories":["位运算","力扣"],"content":"方法一：模拟","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#方法一模拟"},{"categories":["位运算","力扣"],"content":"代码 class Solution { public: int xorOperation(int n, int start) { int ans = start; for (int i = 1; i \u003c n; ++i) { ans ^= (start + i * 2); } return ans; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:1","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#代码"},{"categories":["位运算","力扣"],"content":"复杂度分析 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:2","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#复杂度分析"},{"categories":["位运算","力扣"],"content":"方法二：数学","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#方法二数学"},{"categories":["位运算","力扣"],"content":"思路首先介绍异或运算： 对于单个比特的异或，相同为0，相异为1，即： $ 0 \\oplus 0 = 0 $ $ 0 \\oplus 1 = 1 $ $ 1 \\oplus 0 = 1 $ $ 1 \\oplus 1 = 0 $ 对于整数的异或，按最低位对齐，相同位置的比特进行异或运算，如： $ \\ \\ \\ \\ 0001 \\ (1) $ $ \\underline{\\oplus \\ 0011 \\ (3)} $ $ \\ \\ \\ \\ 0010 \\ (2) $ 异或运算满足以下基本性质： $ a \\oplus a = 0 $ $ a \\oplus 0 = a $ $ a \\oplus b = b \\oplus a $ $ (a \\oplus b) \\oplus c = a \\oplus (b \\oplus c) $ 可以推导出如下性质： $ a \\oplus b \\oplus b = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i+1个a} = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i个a} = 0 $ $ \\forall i \\in \\mathbb{Z}, 有 4i \\oplus (4i+1) \\oplus (4i+2) \\oplus (4i+3) = 0 $ 回到本题，我们需要计算 $ start \\oplus (start+2) \\oplus (start+4) \\oplus \\cdots \\oplus (start+2(n-1)) $，观察公式可以知道每一项奇偶性相同，因此它们的二进制表示中的最低位或者均为1或均为0。 于是我们可以把参与运算的数的二进制位的最低位提取出来单独处理。当且仅当start为奇数且n也为奇数时，结果才为奇数，即最低位为1。令 $ e = n \\oplus start \\oplus 1 $。 此时不考虑start的最后一位，我们将start右移一位，令 $ s = \\lfloor \\frac{sta","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:1","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#思路"},{"categories":["位运算","力扣"],"content":"代码 class Solution { public: int xorOperation(int n, int start) { int s = start \u003e\u003e 1; int e = n \u0026 start \u0026 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return (ret \u003c\u003c 1) | e; } int sumXor(int x) { if (x % 4 == 0) return x; else if (x % 4 == 1) return 1; else if (x % 4 == 2) return x + 1; return 0; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:2","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#代码-1"},{"categories":["位运算","力扣"],"content":"复杂度分析 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:3","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#复杂度分析-1"},{"categories":["软件"],"content":"适用于各种平台的一些好用软件。 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:0:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#"},{"categories":["软件"],"content":"跨平台 Mark Text：简洁美观的 Markdown 编辑器。开源 免费 Visual Studio Code：代码编辑器。开源 免费 JetBrains Toolbox App：JetBrains IDE 管理器。 学生免费 PDF Reader Pro：阅读、编辑、注释、转换和签署 PDF 的最佳 PDF 软件。 付费 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:1:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#跨平台"},{"categories":["软件"],"content":"macOS Homebrew：适用于 macOS（或 Linux）缺失的软件包的管理器。 开源 免费 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Hex Fiend：适用于 macOS 的快速且智能的开源十六进制编辑器。 开源 免费 brew install --cask hex-fiend Mounty for NTFS：在 macOS 下以读写模式重新挂载写保护的 NTFS 卷的小工具。 免费 brew install --cask mounty Android File Transfer：在 Mac 计算机和 Android 设备之间浏览和传输文件。 免费 brew install --cask android-file-transfer IINA：适用于 macOS 的现代媒体播放器。 开源 免费 brew install --cask iina OpenInTerminal-Lite：适用于 macOS 的 Finder 工具栏应用程序，用于在终端、iTerm、Hyper 或 Alacritty 中打开当前目录。 开源 免费 brew install --cask openinterminal-lite brew install --cask openineditor-lite MacZip：专为 macOS 而设计的压缩软件. 免费 brew install --cask maczip CheatSheet：适用于 macOS 的列出当前应用程序所有快捷键的工具。 免费 brew install --cask cheatsheet 腾讯柠檬清理：适用于 macOS 的磁盘清理工具。 免费 QSpace：一款简洁高效的多视图文件管理器。 付费 Alfred：通过自定义操作控制你的 Mac 电脑，提高工作效率。 付费 Downie：适用于 macOS 的视频下载工具。 付费 Dash：API 文档浏览器和代码片段管理器。 付费 shottr：截图、滚动截图、抠图、测距、OCR、取色。 免费 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:2:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#macos"},{"categories":["软件"],"content":"macOS 破解软件下载 MacWk ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:2:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#macos-破解软件下载"},{"categories":["软件"],"content":"Windows Bandizip：压缩文件管理工具。 Everything：基于名称快速定位文件和文件夹。 Potplayer：多媒体播放器。 Revo Uninstaller：软件卸载和清除管理器。 MobaXterm：远程连接管理器。 Visual Studio：C++、C# 开发IDE。 Microsoft Store Windows Terminal QuickLook Files ModernFlyouts (Preview) IrfanView64 TranslucentTB ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:3:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#windows"},{"categories":["软件"],"content":"浏览器插件","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#浏览器插件"},{"categories":["软件"],"content":"Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#chrome-网上应用店需要科学上网"},{"categories":["软件"],"content":"Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#沙拉查词"},{"categories":["软件"],"content":"Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#mac-沙拉查词--alfred"},{"categories":["软件"],"content":"Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#test"},{"categories":["软件"],"content":"Edge 外接程序 BETA uBlock Origin 沙拉查词-聚合词典划词翻译 Tampermonkey Bitwarden - 免费密码管理器 Augmented Steam Edge 浏览器也可到 Chrome 网上应用店安装扩展。 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:2","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#edge-外接程序-betahttpsmicrosoftedgemicrosoftcomaddonsmicrosoft-edge-extensions-homehlzh-cn"},{"categories":[],"content":"从 YouTube 和其他视频网站下载视频的命令行程序。 ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":"一、介绍 官网 Github ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#一介绍"},{"categories":[],"content":"二、安装Windows: 下载exe，然后添加环境变量。 pip install --upgrade youtube-dl # 列出帮助菜单 youtube-dl -h/--help # 查看版本 youtube-dl --version # 升级 youtube-dl -U/--update ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#二安装"},{"categories":[],"content":"三、使用 # 列出所有清晰度和格式 youtube-dl -F/--list-formats \u003cURL\u003e # 下载对应格式或清晰度 youtube-dl -f/--format \u003cFORMAT\u003e \u003cURL\u003e # 下载后视频和音频合并 youtube-dl -f XXX+YYY \u003cURL\u003e # 下载最佳质量 youtube-dl -f bestvideo+bestaudio \u003cURL\u003e # 列出所有字幕 youtube-dl --list-subs \u003cURL\u003e # 下载英文（en）字幕，格式为 srt youtube-dl --sub-lang en --write-auto-sub --sub-format srt --skip-download \u003cURL\u003e # 代理 youtube-dl --proxy \u003cURL\u003e # cookies youtube-dl --cookies \u003cFILE\u003e # 登录 youtube-dl -u/--username \u003cUSERNAME\u003e youtube-dl -p/--password \u003cPASSWORD\u003e youtube-dl -2/--twofactor \u003cTWOFACTOR\u003e youtube-dl --video-password \u003cPASSWORD\u003e ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#三使用"},{"categories":["Hugo"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:0:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#"},{"categories":["Hugo"],"content":"1 网站配置","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#1-网站配置"},{"categories":["Hugo"],"content":"1.1 基础配置 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#11-基础配置"},{"categories":["Hugo"],"content":"1.2 完整配置 [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#12-完整配置"},{"categories":["Hugo"],"content":"2.网站图标，浏览器配置，网站清单强烈建议你把： apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在/static目录，利用 RealFaviconGenerator 可以很容易地生成这些文件。 可以自定义browserconfig.xml和site.webmanifest文件来设置 theme-color 和 background-color。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#2网站图标浏览器配置网站清单"},{"categories":["Hugo"],"content":"3.自定义样式 需使用 Hugo extended 版本 通过自定义.scss样式文件，LoveIt 主题支持自定义的样式。 包含自定义.scss样式文件的路径为assets/css。 在assets/css/_override.scss中，你可以覆盖themes/LoveIt/assets/css/_variables.scss中的变量以自定义样式。 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在assets/css/_custom.scss中，你可以添加一些 CSS 样式代码以自定义样式。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#3自定义样式"},{"categories":["Hugo"],"content":"4.多语言和 i18nHugo 配置多语言支持 一个支持英语和中文的网站配置： # [en, zh-cn, fr, pl, ...] 默认语言 defaultContentLanguage = \"zh-cn\" [languages] # 英语 [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 # 中文 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#4多语言和-i18n"},{"categories":["Hugo"],"content":"修改默认的翻译字符串翻译字符串用于在主题中使用的常见默认值。 目前提供一些语言的翻译，但你可能自定义其他语言或覆盖默认值。 要覆盖默认值，请在你项目的 i18n 目录i18n/\u003clanguageCode\u003e.toml中创建一个新文件，并从themes/LoveIt/i18n/en.toml中获得提示。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#修改默认的翻译字符串"},{"categories":["Hugo"],"content":"5.搜索基于 Lunr.js 或 algolia，LoveIt 主题支持搜索功能。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#5搜索"},{"categories":["Hugo"],"content":"5.1 输出配置为了生成搜索功能所需要的index.json，请在你的网站配置中添加JSON输出文件类型到outputs部分的home字段中。 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#51-输出配置"},{"categories":["Hugo"],"content":"5.2 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#52-搜索配置"},{"categories":["Hugo"],"content":"5.3 比较 lunr：简单，无需同步index.json，没有contentLength的限制，但占用带宽大且性能低（特别是中文需要一个较大的分词依赖库） algolia：高性能并且占用带宽低，但需要同步index.json且有contentLength的限制 文章内容被h2和h3HTML 标签切分来提高查询效果并且基本实现全文搜索。contentLength用来限制h2和h3HTML 标签开头的内容部分的最大长度。 algolia：你需要上传index.json到 algolia 来激活搜索功能，你可以使用浏览器来上传index.json文件。但是一个自动化的脚本可能效果更好，Algolia Atomic 是一个不错的选择。为了兼容 Hugo 的多语言模式，你需要上传不同语言的index.json文件到对应的 algolia index，例如zh-cn/index.json或en/index.json…… ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:3","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#53-比较"},{"categories":["Hugo"],"content":"6.内容文本内容组织 保持博客文章存放在content/posts目录，例如：content/posts/我的第一篇文章.md 保持简单的静态页面存放在content目录，例如：content/about.md 本地媒体资源引用 使用页面包中的页面资源。你可以使用适用于Resources.GetMatch的值或者直接使用相对于当前页面目录的文件路径来引用页面资源。 将本地资源放在assets目录中，默认路径是/assets。引用资源的文件路径是相对于assets目录的。 将本地资源放在static目录中，默认路径是/static。引用资源的文件路径是相对于static目录的。 引用的优先级符合以上的顺序。 在这个主题中的很多地方可以使用上面的本地资源引用，例如：链接、图片、image shortcode、music shortcode、和前置参数中的部分参数. 页面资源或者assets目录中的图片处理会在未来的版本中得到支持。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#6内容"},{"categories":["Hugo"],"content":"7.前置参数 只有在文章的参数和你的网站设置中的page部分不一致时才有必要显式设置。 --- title: \"My first blog\" # 标题 subtitle: \"\" # 副标题 date: 2020-03-04T15:58:26+08:00 # 创建日期 lastmod: 2020-03-04T15:58:26+08:00 # 修改日期 draft: true # 是否草稿 author: \"\" # 作者 authorLink: \"\" # 作者链接 description: \"\" # 内容描述 license: \"\" # 文章许可 images: [] # 页面图片,用于 Open Graph 和 Twitter Cards tags: [] # 标签 categories: [] # 分类 featuredImage: \"\" # 特色图片 featuredImagePreview: \"\" # 主页预览的图片 hiddenFromHomePage: false # 是否从主页上隐藏 hiddenFromSearch: false # 是否从搜索中隐藏 twemoji: false # 是否使用 twemoji lightgallery: true # 图片是否按照画廊形式呈现 ruby: true # 是否使用上标注释扩展语法 fraction: true # 是否使用分数扩展语法 fontawesome: true # 是否使用 Font Awesome 扩展语法 linkToMarkdown: true # 页脚是否显示指向原始 Markdown 文件的链接 rssFullText: false # RSS 中是否显示全文内容 toc: # 和 params.page.toc 部分相同 enable: true auto: true code: # 和 params.page.code 部分相同 copy: true # ... math: # 和 params.page.math 部分相同 enable: true # ... mapbox: # 和 params.page.mapbox 部分相同 accessToken: \"\" # ... share: # 和 params.page.share 部分相同 enable: true # ... c","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:7:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#7前置参数"},{"categories":["Hugo"],"content":"8.内容摘要","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:8:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#8内容摘要"},{"categories":[],"content":"You-Get 是一个轻量级命令行工具，可以方便的从一些网站上下载媒体内容（视频、音频、图像）。 ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":"一、介绍 官网 Github ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#一介绍"},{"categories":[],"content":"二、安装pip install --upgrade you-get ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#二安装"},{"categories":[],"content":"三、使用 # 查看所有可选质量与格式 you-get -i/--info \u003cURL\u003e # 自定义下载文件路径和名称 you-get -o/--output-dir \u003cPATH\u003e \u003cURL\u003e you-get -O/--output-filename \u003cFILENAME\u003e \u003cURL\u003e # 代理 you-get -x/--http-proxy \u003cPROXY_IP:PORT\u003e \u003cURL\u003e # cookies you-get --cookies/-c \u003ccookies.txt/cookies.sqlite\u003e \u003cURL\u003e ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#三使用"},{"categories":[],"content":"3.1 cookie 获取Chrome 扩展程序：Get cookies.txt ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#31-cookie-获取"},{"categories":[],"content":"四、支持网站 YouTube bilibili ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#四支持网站"},{"categories":[],"content":"FFmpeg 是视频处理最常用的开源软件。 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":"常用参数 -c：指定编码器。-c copy：直接复制，不重新编码，加快生成速度 -c:v或-vcodec：指定视频编码器。-c:v copy或-vcodec copy：不改变视频编码，直接拷贝 -c:a或-acodec：指定音频编码器。-c:a copy或-acodec copy：不改变音频编码，直接拷贝 -i：指定输入文件 -an：去除音频流 -vn：去除视频流 -preset：指定输出的视频质量，会影响生成速度。可用值：ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow -y：不经过确认，输出时直接覆盖同名文件 -hwaccel cuvid：指定使用 cuvid 硬件加速 举例： ffmpeg -y -c:a libfdk_aac -c:v libx264 -i input.mp4 -c:a libvorbis -c:v libvpx-vp9 output.webm ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#常用参数"},{"categories":[],"content":"格式转换 ffmpeg -i input.webm output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#格式转换"},{"categories":[],"content":"提取视频中的音频 ffmpeg -i input.mp4 -vn -acodec copy output.aac ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#提取视频中的音频"},{"categories":[],"content":"去除视频中的音频 ffmpeg -i input.mp4 -an -vcodec copy output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#去除视频中的音频"},{"categories":[],"content":"合并音频和视频视频不包含音频： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental output.mp4 视频包含音频，需要被替换： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental -map 0:v:0 -map 1:a:0 output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#合并音频和视频"},{"categories":[],"content":"视频截图在第 4.5s 截取一帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 1 output.png 在第 4.5s 截取 10 帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 10 output%d.png ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#视频截图"},{"categories":["算法"],"content":"常用算法模板。 ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:0:0","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#"},{"categories":["算法"],"content":"输入","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:1:0","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#输入"},{"categories":["算法"],"content":"输出","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:2:0","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#输出"},{"categories":["算法"],"content":"格式化 ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:2:1","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#格式化"},{"categories":["算法"],"content":"排序排序模板 public class SortTemplate { public static void sort(Comparable[] array) {} private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } private static void show(Comparable[] array) { for (Comparable elem : array) { System.out.print(elem + \" \"); } System.out.println(); } private static boolean isSorted(Comparable[] array) { for (int i = 1; i \u003c array.length; i++) { if (less(array[i], array[i - 1])) { return false; } } return true; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:0","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#排序"},{"categories":["算法"],"content":"1 选择排序 public class SelectionSort { public static void sort(Comparable[] array) { int len = array.length; for (int i = 0; i \u003c len; i++) { int minIdx = i; for (int j = i + 1; j \u003c len; j++) { if (less(array[j], array[minIdx])) { minIdx = j; } } exchange(array, i, minIdx); } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:1","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#1-选择排序"},{"categories":["算法"],"content":"2 插入排序 public class InsertionSort { public static void sort(Comparable[] array) { int len = array.length; for (int i = 1; i \u003c len; i++) { for (int j = i; j \u003e 0 \u0026\u0026 less(array[j], array[j - 1]); j--) { exchange(array, j, j - 1); } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:2","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#2-插入排序"},{"categories":["算法"],"content":"3 希尔排序 public class ShellSort { public static void sort(Comparable[] array) { int len = array.length; int step = 1; while (step \u003c len / 3) { // 1, 4, 13, 40, 121, 364, 1093, ... step = step * 3 + 1; } while (step \u003e= 1) { for (int i = step; i \u003c len; i++) { for (int j = i; j \u003e= step \u0026\u0026 less(array[j], array[j - step]); j -= step) { exchange(array, j, j - step); } } step /= 3; } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:3","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#3-希尔排序"},{"categories":["算法"],"content":"4 归并排序自顶向下 public class MergeSort { private static Comparable[] copy; public static void sort(Comparable[] array) { int len = array.length; copy = new Comparable[len]; sort(array, 0, len - 1); } private static void sort(Comparable[] array, int low, int high) { // [low, high] if (low \u003e= high) return; int mid = low + (high - low) / 2; sort(array, low, mid); sort(array, mid + 1, high); merge(array, low, mid, high); } private static void merge(Comparable[] array, int low, int mid, int high) { // [low, high] int i = low; int j = mid + 1; if (high + 1 - low \u003e= 0) System.arraycopy(array, low, copy, low, high + 1 - low); for (int k = low; k \u003c= high; k++) { if (i \u003e mid) { array[k] = copy[j++]; } else if (j \u003e high) { array[k] = copy[i++]; } else if (less(copy[j], copy[i])) { array[k] = copy[j++]; } else { array[k] = copy[i++]; } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } } 自底向上 public class MergeSort { private static Comparable[] copy; public stati","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:4","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#4-归并排序"},{"categories":["算法"],"content":"5 快速排序 public class QuickSort { public static void sort(Comparable[] array) { sort(array, 0, array.length - 1); } public static void sort(Comparable[] array, int low, int high) { // [low, high] if (low \u003e= high) return; int i = partition(array, low, high); sort(array, low, i - 1); sort(array, i + 1, high); } private static int partition(Comparable[] array, int low, int high) { // [low, high] int i = low; int j = high + 1; Comparable copy = array[low]; while (true) { while (less(array[++i], copy)) { if (i == high) break; } while (less(copy, array[--j])) { if (j == low) break; } if (i \u003e= j) break; exchange(array, i, j); } exchange(array, low, j); return j; } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:5","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#5-快速排序"},{"categories":["算法"],"content":"算法","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:0","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#算法"},{"categories":["算法"],"content":"滑动窗口","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:1","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#滑动窗口"},{"categories":["算法"],"content":"二分查找 int binarySearch(vector\u003cint\u003e arr, const int target) { // 升序数组 // [low, high] int low = 0, high = arr.size() - 1, mid; while (low \u003c= high) { mid = low + (high - low) / 2; if (target == arr[mid]) { return mid; } else if (target \u003e arr[mid]) { low = mid + 1; } else { high = mid - 1; } } return -1; } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:2","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#二分查找"},{"categories":["算法"],"content":"小技巧头文件 #include\u003cbits/stdc++.h\u003e 判断奇偶 if (x \u0026 1) // 奇数，等价于 x % 2 else // 偶数 快速乘除2 x \u003c\u003c= 1; // 乘2，等价于 x *= 2; x \u003e\u003e= 1; // 除2，等价于 x /= 2; 快速交换 a ^= b; // a1 = a ^ b b ^= a; // b1 = b ^ a1 = b ^ a ^ b = a a ^= b; // a2 = a1 ^ b1 = a ^ b ^ a = b 遍历字符串 for (int i = 0; s[i]; i++) 使用 emplace_back() 代替 push_back() 内置求最大公约数函数：__gcd(x, y); 使用 inline 函数 全局数组最大 $ 10^7 $，函数内数组最大 $ 10^6 $ 得到最高有效位数字 double k = log(n, 10); k -= floor(k); x = pow(10, k); 得到数字的有效位数 n = floor(log(n, 10)) + 1; 判断是否是 2 的幂（Brian Kernighan’s Algorithm） // log(n) n \u0026\u0026 (!(n \u0026 (n - 1))) C++11 内置 STL 函数 // 是否全是正数？ all_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否存在正数 any_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否全不是正数？ none_of(first, first + n, [](int x) { return x \u003e 0; }); // 复制 int source[5] = {0, 12, 34, 50, 80}; int target[5]; copy_n(source, 5, target); // 迭代 int a[5] = {0}; char c[3] = {0}; iota(a, a + 5, 10); // {10, 11, 12, 13, 14} iota(c, c + 3, 'a'); // {'a', 'b', 'c'} 二进制表示 auto number = 0b011; c","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:5:0","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#小技巧"},{"categories":["算法"],"content":"C++ 实用技巧","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:6:0","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#c-实用技巧"},{"categories":["算法"],"content":"STL 常用库 /*** 函数 ***/ #include\u003calgorithm\u003e#include\u003cfunctional\u003e // hash#include\u003cclimits\u003e // 常量#include\u003ccmath\u003e#include\u003ccstdio\u003e#include\u003ccstdlib\u003e // random#include\u003cctime\u003e#include\u003ciostream\u003e#include\u003csstream\u003e#include\u003ciomanip\u003e // 右对齐 std::right 设置宽度 std::setw(width)/*** 数据结构 ***/ #include\u003cdeque\u003e#include\u003clist\u003e#include\u003cqueue\u003e // 包括 priority_queue#include\u003cstack\u003e#include\u003cstring\u003e#include\u003cvector\u003e ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:6:1","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#stl-常用库"},{"categories":["算法"],"content":"I/O #include\u003ciostream\u003e // cin cout#include\u003ccstdio\u003e // scanf printf// cin does not concern with ’\\n’ at end of each line // however scanf or getline does concern with ’\\n’ at end of each line // ’\\n’ will be ignored when you use cin to read char. // 读取数值数据后在读取字符串 cin \u003e\u003e n; getline(cin, str) // wasted getline getline(cin, str) // real input string ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:6:2","series":null,"tags":["算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#io"},{"categories":["二分查找","力扣"],"content":"题目链接 ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:0:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#"},{"categories":["二分查找","力扣"],"content":"方法一：两次二分查找易知： 每行升序 每列升序 所以，我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e matrix, int target) { auto row = upper_bound(matrix.begin(), matrix.end(), target, [](const int b, const vector\u003cint\u003e \u0026a) { return b \u003c a[0]; }); if (row == matrix.begin()) { return false; } --row; return binary_search(row-\u003ebegin(), row-\u003eend(), target); } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int rowIndex = binarySearchFirstColumn(matrix, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], target); } public int binarySearchFirstColumn(int[][] matrix, int target) { int low = -1, high = matrix.length - 1; while (low \u003c high) { int mid = (high - low + 1) / 2 + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } public boolean binarySearchRow(int[] row, int target) { int low = 0, high = row.length - 1; while (low \u003c= high) { int mid = (h","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:1:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#方法一两次二分查找"},{"categories":["二分查找","力扣"],"content":"方法二：一次二分查找根据特性可将二维数组看作一维的升序数组，再使用二分搜索查找。（要求二维数组每行元素个数相等） class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; // 中位数映射到行和列 if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } } bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) { int m = matrixSize, n = matrixColSize[0]; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:2:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#方法二一次二分查找"},{"categories":["正则表达式"],"content":"用来描述字符串模式匹配规则的表达式。 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#"},{"categories":["正则表达式"],"content":"1.规则","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#1规则"},{"categories":["正则表达式"],"content":"1.1 单个字符匹配 正则表达式 意义 等价 a 单个指定字母 0 单个指定数字 \\\\ \\ \\* * \\. . \\n 换行符 \\f 换页符 \\t 制表符 . 单个除了换行符之外的任何字符 \\d 单个数字 [0-9] \\D 单个非数字字符 [^0-9] 、 [^\\d] \\w 单个字母或数字或下划线 [a-zA-Z0-9_] \\W 单个非字母非数字非下划线字符 [^a-zA-Z0-9_]、[^\\w] \\s 单个空白字符（空格、换行符、换页符、制表符） [ \\n\\f\\t] \\S 单个非空白字符 [^ \\n\\f\\t]、[^\\s] ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#11-单个字符匹配"},{"categories":["正则表达式"],"content":"1.2 匹配次数 正则表达式 意义 ? 匹配0或1次 * 匹配任意次（大于等于0） + 至少匹配一次（大于等于1） {a} 匹配a次 {a,b} 至少匹配a次，至多匹配b次（[a,b]） {a,} 至少匹配a次（大于等于a） {0,b} 至多匹配b次（[0,b]） ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#12-匹配次数"},{"categories":["正则表达式"],"content":"1.3 边界匹配 正则表达式 意义 \\b 单词边界 \\B 非单词边界 ^ 字符串开头 $ 字符串结尾 /规则/m 多行模式 /规则/i 忽略大小写 /规则/g 全局模式 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#13-边界匹配"},{"categories":["正则表达式"],"content":"1.4 逻辑关系 正则表达式 意义 ` ` [^] 逻辑非 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#14-逻辑关系"},{"categories":["正则表达式"],"content":"2.高级用法 回溯引用 前向查找 后向查找 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#2高级用法"},{"categories":["正则表达式"],"content":"3.代码中使用","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#3代码中使用"},{"categories":["正则表达式"],"content":"3.1 C++ #include \u003cregex\u003e // 转义字符 regex reg1(\"^[\\\\w-]+(\\\\.[\\\\w-]+)*@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); regex_match(\"google@gmail.com\", reg1); // 1 // 原生字符串 R\"(...)\" regex reg2(R\"(^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$)\"); regex_match(\"google@gmail.com\", reg2); // 1 // ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#31-c"},{"categories":["正则表达式"],"content":"3.2 Java","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#32-java"},{"categories":["正则表达式"],"content":"3.3 Python","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#33-python"},{"categories":["正则表达式"],"content":"4.常用正则表达式 整数：^-?\\d+$ 自然数（非负整数）：^\\d+$ 正整数：^[0-9]*[1-9][0-9]*$ 非正整数：^((-\\d+) ?(0+))$ 负整数：^-[0-9]*[1-9][0-9]*$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 非负浮点数：^\\d+(\\.\\d+)?$ 正浮点数：^(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*))$ 非正浮点数：^((-\\d+(\\.\\d+)?) ?(0+(\\.0+)?))$ 负浮点数：^(-(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*)))$ 下划线、数字和大小写字母：^\\w+$ 数字和大小写字母：^[A-Za-z0-9]+$ 大小写字母：^[A-Za-z]+$ 大写字母：^[A-Z]+$ 小写字母：^[a-z]+$ 中文字符：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff]，可以用来计算字符串的长度 空行：\\n[\\s ? ]*\\r，可以用来删除空白行 HTML标记：/ \u003c(.*)\u003e.* \u003c\\/\\1\u003e ? \u003c(.*) \\/\u003e/，仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 首尾空格：(^\\s*) ?(\\s*$) ^\\s* ?\\s*$，可以用来删除行首行尾的空白字符 电子邮件：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 网址（URL）：(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$ [a-zA-z]+://[^\\s]* 命名规则（字母开头，长度5-16，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 中国座机号码：\\d{3}-\\d{8} ?\\d{4}-\\d{7} QQ号：[1-9][0-9]{4,} 中国邮政编码：[1-9]\\d{5}(?!\\d) 中国身份证：\\d{15} ?\\d{18} IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#4常用正则表达式"},{"categories":["正则表达式"],"content":"5.辅助网站 Regexper：正则表达式规则可视化。 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#5辅助网站"},{"categories":["正则表达式"],"content":"参考资料 正则表达式不要背 - 掘金 C++正则表达式 - cpluspluser - 博客园 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#参考资料"},{"categories":["位运算","分治法","力扣"],"content":"题目链接 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:0:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#"},{"categories":["位运算","分治法","力扣"],"content":"方法一：逐位颠倒","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#方法一逐位颠倒"},{"categories":["位运算","分治法","力扣"],"content":"思路将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。 代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:1","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#思路"},{"categories":["位运算","分治法","力扣"],"content":"代码 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } }; public class Solution { public int reverseBits(int n) { int rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n != 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev; } } uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } var reverseBits = function(n) { let rev = 0; for (let i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev \u003e\u003e\u003e 0; }; func reverseBits(n uint32) (rev uint32) { for i := 0; i \u003c 32 \u0026\u0026 n \u003e 0; i++ { rev |= n \u0026 1 \u003c\u003c (31 - i) n \u003e\u003e= 1 } return } ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:2","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#代码"},{"categories":["位运算","分治法","力扣"],"content":"复杂度 时间复杂度：$ O(\\log n) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:3","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#复杂度"},{"categories":["位运算","分治法","力扣"],"content":"方法二：位运算分治","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#方法二位运算分治"},{"categories":["位运算","分治法","力扣"],"content":"思路若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。 由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。 对于递归的最底层，我们需要交换所有奇偶位： 取出所有奇数位和偶数位； 将奇数位移到偶数位上，偶数位移到奇数位上。 类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:1","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#思路-1"},{"categories":["位运算","分治法","力扣"],"content":"代码 class Solution { private: const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 public: uint32_t reverseBits(uint32_t n) { n = n \u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e 16 | n \u003c\u003c 16; } }; public class Solution { private static final int M1 = 0x55555555; // 01010101010101010101010101010101 private static final int M2 = 0x33333333; // 00110011001100110011001100110011 private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111 public int reverseBits(int n) { n = n \u003e\u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e\u003e 8 \u0026 M8 | (n \u0026","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:2","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#代码-1"},{"categories":["位运算","分治法","力扣"],"content":"复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:3","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#复杂度-1"},{"categories":[],"content":"一、工具 U盘（≥16G） Mac OS镜像（.dmg） 适合你的电脑的EFI文件 balenaEtcher（刻录工具） DiskGenius（分区工具） ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#一工具"},{"categories":[],"content":"二、制作U盘启动盘 插入U盘，然后打开balenaEtcher软件。 点击Select image选择Mac OS镜像。 软件会自动识别出你的U盘，最后点击Flash!。 等待刻录完成（20min左右），之后会有一个完整性检测（15min左右）。 当软件显示Flash Complete!时表示刻录成功。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#二制作u盘启动盘"},{"categories":[],"content":"三、配置Clover引导驱动 打开DiskGenius，找到U盘上的ESP分区，删除EFI文件夹。 把适合自己电脑EFI文件夹复制进去。（这里只能用快捷键复制粘贴） 保存更改。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#三配置clover引导驱动"},{"categories":[],"content":"四、制作黑苹果系统盘","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#四制作黑苹果系统盘"},{"categories":[],"content":"硬盘分区安装压缩卷（≥25G）。 选中压缩出的空闲分区，右键新建简单卷，一直点击下一步但选择不要格式化这个卷。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#硬盘分区安装"},{"categories":[],"content":"整块硬盘安装删除磁盘所有分区即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#整块硬盘安装"},{"categories":[],"content":"五、BIOS设置以技嘉（Gigabyte）主板为例： BIOS-\u003eFastBoot-\u003eDisable BIOS-\u003eWindows 8/10 Features-\u003eWindows 8/10 将操作系统类型设置为其他操作系统。从不支持Microsoft签名安全启动的第三方操作系统启动时，将“操作系统类型”设置为“其他操作系统”以获取优化的功能。 BIOS-\u003eCSM Support-\u003eDisabled 禁用CSM。兼容性支持模块（CSM）是UEFI固件的组件，该组件通过模拟BIOS环境来提供旧版BIOS兼容性，从而允许仍使用旧版操作系统和某些不支持UEFI的选件ROM。Clover和OpenCore引导都支持UEFI引导。禁用CSM使BIOS可以轻松发现Bootloader。 BIOS-\u003eLAN PXE Boot Option ROM-\u003eDisabled BIOS-\u003eStorage Boot Option Control-\u003eUEFI BIOS-\u003eOther PCI devices-\u003eUEFI Peripherals-\u003eInitial Display Output-\u003ePCIe Slot(独显)/IGFX(核显) Peripherals-\u003eAbove 4G Decoding-\u003eDisabled Peripherals-\u003eTrusted Computing-\u003eSecurity Device Support-\u003eDisable Peripherals-\u003eUSB Configuration-\u003eLegacy USB Support-\u003eDisabled 禁用旧版USB支持。 Peripherals-\u003eUSB Configuration-\u003eXHCI Hand-off-\u003eEnabled 启用XHCI切换。 Peripherals-\u003eNetwork Stack Configuration-\u003eDisabled Peripherals-\u003eSATA and RST Configuration-\u003eSATA Mode Selection-\u003eAHCI 将SATA设置为AHCI。通过高级主机控制器接口（AHCI）模式，可以在SATA驱动器上使用高级功能，例如热插拔和本机命令队列（NCQ）。AHCI还允许硬盘以比传统IDE模式更高的速度运行。 Chipset-\u003eVT-d-\u003eDisabled 禁用VT-D。VT-","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#五bios设置"},{"categories":[],"content":"六、黑苹果安装","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#六黑苹果安装"},{"categories":[],"content":"七、更改硬盘启动","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#七更改硬盘启动"},{"categories":[],"content":"八、其他问题","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#八其他问题"},{"categories":[],"content":"EFI分区扩容 分出合适空间大小，可使用Windows自带的磁盘管理或者DiskGenius。 打开DiskGenius。 找到ESP分区，右键选择备份分区到镜像文件，选择合适的文件路径并保存（选择热备份）。 删除ESP分区。 在任意分区上右键选择建立ESP/MSR分区，调整合适的分区大小并确认。 保存更改。 找到ESP分区，右键选择从镜像文件还原分区，选择刚才备份的镜像文件即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#efi分区扩容"},{"categories":[],"content":"九、参考 黑果小兵的部落阁 黑苹果MacOS Big Sur 11.0 安装教程及驱动工具 主流电脑配置的通用引导文件，包含CLOVER与OpenCorer双引导 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#九参考"},{"categories":["饥荒"],"content":"等级25级后开启制造减半后制造 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:1:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#等级"},{"categories":["饥荒"],"content":"食谱 名称 代码 时间 保质期 饥饿、san、生命 制作 效果 百奇 sorapocky 0s ∞ 37.5、20、20 浆果×6+鸡蛋×0/1/2+蜂蜜×0/1/4 速食拉面 sora_tongmian 1.6s 20d 100/70/40、10、-5 （肉度+菜度）≥2.5 喷香蛋包饭 sora_danbaofan 16s 15d 80/56/32、10、40 蛋≥1+菜度≥0.5+肉度≥0.5 可2怪物肉 默认不放树枝。 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:2:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#食谱"},{"categories":["饥荒"],"content":"药剂 名称 代码 制作 效果 公正 sora2gz 暖石×2+灰烬×40 恒定温度（15min） 诚实 sora2cs 荧光果×40+草×40+树枝×40 持续发光（15min） 谦卑 sora2qb 蜘蛛腺体×40 生命+40、生命+5/s（5min） 灵魂 sora2lh 灰烬×40+金块×20+莎草纸×10 san+40、san+5/s（5min） 荣誉 sora2ry 蜘蛛网×10+黑色羽毛×3+红色羽毛×3 移动速度+100%（5min） 英勇 sora2yy 蜂刺×40+燧石×40 攻击+50%（5min） 牺牲 sora2xs 狗牙×40+木炭×20+格罗姆的粘液×5 攻击+200%、防御-50%、生命-5/s（1min） 怜悯 sora2lm 治疗药膏×10+蜂蜜药膏×10+强心针×5 怪物生命+500/s（3min） 默认一次制作10个药剂 药剂同时只能生效一个，叠加使用会只有最后使用的产生效果 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:3:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#药剂"},{"categories":["饥荒"],"content":"装备","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#装备"},{"categories":["饥荒"],"content":"奇妙法杖 属性 属性值 代码 sora2sword 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+10% 功能 斧头、鹤嘴锄、铲子（右键开关）、锤子（右键开关）、捕虫网、鱼竿 队友能否使用 能 要求 穹10级 制作 黄金铲子×2/4/6+锤子×2/4/6+紫宝石×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#奇妙法杖"},{"categories":["饥荒"],"content":"神奇法杖 属性 属性值 代码 sora2prop 位置 手 效果 无耐久、攻击+0、攻击距离+0、移动速度+50% 功能 只能攻击队友，将其击飞，掉落其手部装备和身上的金子 队友能否使用 能 要求 穹10级 制作 活木×10/20/30+锤子×0/4/6 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#神奇法杖"},{"categories":["饥荒"],"content":"银白の锋 属性 属性值 代码 sora3sword 位置 手 效果 无耐久、攻击+59.5、攻击距离+1.25、移动速度+10% 功能 每次攻击回复0.5血量 队友能否使用 能 要求 穹10级 制作 影刀×1/3/5+触手尖刺×2/4/6+蝙蝠棒×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の锋"},{"categories":["饥荒"],"content":"银白の甲 属性 属性值 代码 sora2armor 位置 身 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 木甲×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の甲"},{"categories":["饥荒"],"content":"银白の盔 属性 属性值 代码 sora2hat 位置 头 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 猪皮帽×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の盔"},{"categories":["饥荒"],"content":"银白の翼 属性 属性值 代码 sora2bag 位置 包 效果 14格背包、移动速度+10% 功能 保鲜+50%、回san+3/min 队友能否使用 能 要求 穹10级 制作 冰块×80/200/400+电子元件×10/20/80 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の翼"},{"categories":["饥荒"],"content":"荣誉勋章 属性 属性值 代码 sora2amulet 位置 符 效果 移动速度+20%、攻击+20%（穹无效）、防御+20%（穹无效） 功能 防水+30%、回san+3/min、发光（多档调节，不同消耗速度，自动关闭）、 修复 关闭时自动修复0.1/s，也可用荧光果、蜗牛粘液、小发光浆果、发光浆果修复 队友能否使用 能 队友增幅 使用穹的便携烹饪锅、制作穹专属料理、快速采集、快速制作 要求 穹10级 制作 重生护符×1/2/3+寒冰护符×1/2/3+噩梦护符×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#荣誉勋章"},{"categories":["饥荒"],"content":"穹の采 属性 属性值 代码 sorapick 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+25% 功能 灭火、批量采集，CD60s→0s 队友能否使用 不能 要求 穹20级 制作 懒人护符×1/2/4+活木×10/20/40+橙宝石×3/6/10+燧石×40/80/400 升级（冷却时间） 每1/2/3紫宝石，CD-12s，最高提升到0s 升级（采集范围） 每1/2/3橙宝石，范围+1，最高提升到7格 升级（灭火范围） 每10/20/30e，范围+0.5，最高提升到7格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の采"},{"categories":["饥荒"],"content":"穹の愈 属性 属性值 代码 sorahealing 位置 手 效果 无耐久、攻击+15→35、攻击距离+8、移动速度+25% 功能 右键切换群体治疗或冰冻（消耗饱食度），CD60s，治疗效果30 队友能否使用 不能 要求 穹20级 制作 分解法杖×1/2/4+蜂蜜药膏×10/20/40+绿宝石×3/6/10+花瓣×40/80/400 升级（攻击） 每1/2/3紫宝石，攻击+4，最高提升到35 升级（冷却时间） 每1/2/3黄宝石，CD-10s，最高提升到10s 升级（治疗、冰冻） 每1/2/3绿宝石，治疗+10，最高提升到80（到55后可复活自己或队友） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の愈"},{"categories":["饥荒"],"content":"穹の瞬 属性 属性值 代码 soratele 位置 手 效果 无耐久、攻击+17、攻击距离+12、移动速度+50% 功能 右键瞬移（CD20s，消耗40san），斧、锄、铲、锤、捕虫网、鱼竿（立刻上钩） 队友能否使用 不能 要求 穹20级 制作 瞬移法杖×1/2/4+月石×5/10/40+紫宝石×4/4/10+红色羽毛×4/10/40 升级（冷却时间） 每1/2/3紫宝石，CD-4s，最高提升到0s 升级（施法消耗） 每10/20/30噩梦燃料，消耗san-3，最高提升到10san ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:10","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の瞬"},{"categories":["饥荒"],"content":"穹の空 属性 属性值 代码 soramagic 位置 手 效果 无耐久、攻击+20→45、攻击距离+5→10、移动速度+25% 功能 右键流星群伤技能，伤害20→120，CD30s，攻击有概率触发技能 队友能否使用 不能 要求 穹20级 制作 火焰法杖×1/2+金块×10/20+红宝石×2/6+噩梦燃料×10/20 制作（困难） 火焰法杖4+电子元件×20+红宝石×10+龙鳞×4 升级（攻击） 每5/10/15金块，攻击+0.5，最高提升到45 升级（攻击距离） 每1/2/3金丝雀羽毛，攻击距离+0.2，最高提升到10 升级（技能伤害） 每1/2/3红宝石，伤害+4，最高提升到120 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:11","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の空"},{"categories":["饥荒"],"content":"穹の护 属性 属性值 代码 soraclothes 位置 身 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 保暖+0→240、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（保暖） 每1/2/3熊皮，保暖+48，最高提升到240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:12","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の护"},{"categories":["饥荒"],"content":"穹の冠 属性 属性值 代码 sorahat 位置 头 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 防雨+0→100%（满级防水）、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（防雨） 每1/2/3巨鹿眼球，防雨+40%，最高提升到100% ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:13","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の冠"},{"categories":["饥荒"],"content":"穹の包 属性 属性值 代码 sorabag 位置 包 效果 14格背包、出生自带、移动速度+10% 功能 保鲜（默认50%）、回san、隔热 队友能否使用 不能 要求 穹20级 制作 鸭毛×5/10+牛毛×6/20+蜘蛛网×8/20 制作（困难） 鸭毛×40+黑色羽毛×20+红色羽毛×20+紫宝石×4 升级（保鲜） 每5/10/15金块，保鲜度+10%，最高提升500% 升级（回san） 每5/10/15蜂蜜，回san+1/min，最高提升到20/min 升级（隔热） 每5/10/15冰块，隔热+4，最高提升240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:14","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の包"},{"categories":["饥荒"],"content":"穹の二次元蝴蝶结 属性 属性值 代码 sorabowkno 位置 符 效果 攻击+20%、防御+20%、移动速度+20% 功能 防水+30%、回san+4.5/min、发光、消耗经验打包物品作礼物 队友能否使用 不能 要求 穹20级 制作 蝴蝶×10/20/20+格罗姆翅膀×3/5/10+彩虹宝石×1/2/4 升级（发光） 每5/10/15荧光果/萤火虫/发光浆果，发光范围+0.5格，最高提升5格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:15","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の二次元蝴蝶结"},{"categories":["饥荒"],"content":"物品","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#物品"},{"categories":["饥荒"],"content":"穹の缝纫包 属性 属性值 代码 sorarepairer 功能 重置食物新鲜度、修复装备（除了分解法杖） 制作 蜘蛛网×4/6/10+金块×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の缝纫包"},{"categories":["饥荒"],"content":"穹の打包纸 属性 属性值 代码 sora2pack 功能 一次制作6个（一般难度），打包建筑、植物、物品等。 要求 穹10级 制作 莎草纸×4/6/10+紫宝石×1+花瓣×10/20/60 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の打包纸"},{"categories":["饥荒"],"content":"魔法","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#魔法"},{"categories":["饥荒"],"content":"全部魔法 名称 代码 消耗san 效果 鸽子还没到 sora_birds 20/30/40 召唤一群鸟（20-30只） 未闻花名 sora_gardening 20/30/40 催生附近作物（包括大理石树） 提醒睡觉小助手 sora_sleep 40/50/60 催眠附近生物 都是时辰的错 sora_raining 70/90/110 下雨或天晴 空白永不败北 sora_magics 120/140/160 附近物品变化，按物品12或123循环变化 超电磁炮永世长存 sora_lighting 30/40/50 附近召唤闪电 伪典-弑君者 sora_tentacles 50/70/90 附近召唤三只触手 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#全部魔法"},{"categories":["饥荒"],"content":"空白永不败北 物品1 物品2 物品3 浆果 蜜汁浆果 蝴蝶翅膀 黄油 青蛙腿 鸟腿 花瓣 恶魔花瓣 肥料 鸟粪 石头 燧石 硝石 冰 木炭 金子 金元宝 骨片 化石碎片 月石 月亮碎片 红宝石 蓝宝石 紫宝石 绿宝石 黄宝石 橙宝石 蓝色羽毛 黑色羽毛 红色羽毛 兔毛 猪皮 触手皮 蜘蛛腺体 蚊子血袋 蜂刺 狗牙 牛毛 蜘蛛网 牛角 海象牙 羊角 龙鳞 蛤蟆皮 蝴蝶 月娥 常青树 粗壮常青树 石化树 胡萝卜（地里） 胡萝卜鼠（地里） 曼德拉草（地里） 浆果丛 浆果灌木丛 蜜汁浆果丛 树苗根 月岛树苗根 红蘑菇（树） 蓝蘑菇（树） 绿蘑菇（树） 洋葱 辣椒 大蒜 蒜粉 辣椒面 月相盘 月台 棋盘地板 卵石路 地毯地板 贝壳地板 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#空白永不败北"},{"categories":["饥荒"],"content":"建筑","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#建筑"},{"categories":["饥荒"],"content":"穹の圣诞树 属性 属性值 代码 sora2tree 要求 穹5级 功能 每天可随机领取物品 制作 木板×1/5/20+松果×1/10/40+桦木果×1/10/40 升级机制：往圣诞树里放东西，点击献祭（手柄关闭后就会自动献祭），献祭会增加经验值，达到一定经验值后树就会升级，不同的物品经验值也不同，但是不需要太在意升级因为献祭获得的经验和获得礼物而扣除的经验不成正比（一根草每天白嫖不香吗），所以应该把他当做垃圾桶更合适（小声bb） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の圣诞树"},{"categories":["饥荒"],"content":"薇诺娜的投石机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的投石机"},{"categories":["饥荒"],"content":"薇诺娜的聚光灯 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的聚光灯"},{"categories":["饥荒"],"content":"薇诺娜的发电机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+木头×2+硝石×2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的发电机"},{"categories":["饥荒"],"content":"秘法祭坛 属性 属性值 代码 sora2base 要求 制作（简单） 红月之眼+蓝月之眼+月石×6 制作（一般） 紫月之眼×2+黄月之眼×2+月石×20 制作（困难） 绿月之眼×3+橙月之眼×3+月石×40 火魔杖 自动攻击 冰魔杖 灭火器 传送魔杖 作为传送石的目的地 瞬移魔杖 消耗饥饿回san 解构魔杖 消耗饥饿回血 唤星者 大范围升温 访月者 大范围降温 魔杖放置在祭坛的第一格 若第二格不是噩梦燃料，则会提供大范围光源 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#秘法祭坛"},{"categories":["饥荒"],"content":"传送石 属性 属性值 代码 sora2stone 要求 制作 金块×2+沙漠石头×0/1/1+月石×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#传送石"},{"categories":["饥荒"],"content":"强迫の箱子 属性 属性值 代码 sora2chest 功能 25格容器，关闭时自动收集附近与第一格相同的物品，其他物品掉落（打包除外） 要求 穹10级 制作 木板×3/3/5+石砖×0/3/5+噩梦燃料×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#强迫の箱子"},{"categories":["饥荒"],"content":"寒冰の箱子 属性 属性值 代码 sora2ice 功能 25格容器，永久保鲜 要求 穹10级 制作（简单） 冰块×80+木板×10+石砖×10 制作 蓝宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#寒冰の箱子"},{"categories":["饥荒"],"content":"烈焰の箱子 属性 属性值 代码 sora2fire 功能 25格容器，烤熟食物，木头变木炭，可燃物变灰烬 要求 穹10级 制作（简单） 木炭×80+木板×10+石砖×10 制作 红宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#烈焰の箱子"},{"categories":["环境","配置"],"content":"常用软件或编程语言环境搭建及个性化配置。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#"},{"categories":["环境","配置"],"content":"Windows 添加环境变量","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#windows-添加环境变量"},{"categories":["环境","配置"],"content":"窗口化操作 打开我的电脑，右键点击左侧的此电脑，点击属性。 点击最下方的高级系统设置，然后点击环境变量。 修改系统变量：下方选择需要修改的变量，点击编辑，然后新建或者编辑变量。 新建系统变量：直接点击新建，输入变量名和变量值，然后确定。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#窗口化操作"},{"categories":["环境","配置"],"content":"误删系统环境变量的补救措施 若未关闭当前CMD。输入echo %PATH%会显示原来的 PATH 值。 若已关闭当前CMD。每个正在运行的 Windows 程序都会有自己已加载的 PATH，可以使用Process Explorer来查看当前正在运行的程序的环境变量。例如：如果你之前打开了 Chrome，且一直未关闭，按Ctrl+O打开C:\\Windows\\System32\\cmd.exe，然后输入echo %PATH%会显示原来的 PATH 值。恢复之后删除C:\\Program Files\\Google\\Chrome\\Application和用户变量中的PATH值即可。 若已重启电脑。手动恢复 PATH 到默认值%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0，其他值已丢失。 参考：如何恢复我删除的Path环境变量？ ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#误删系统环境变量的补救措施"},{"categories":["环境","配置"],"content":"VS CodeVisual Studio Code 官网 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#vs-code"},{"categories":["环境","配置"],"content":"1. C++ 安装编译器 Windows（二选一） 安装 Visual Studio 安装 MinGW-w64，推荐从 SourceForge 下载安装。 Linux: sudo apt install gcc g++ gdb build-essential Mac OS: xcode-select --install 安装 VS Code C/C++ 扩展ms-vscode.cpptools。 asd 解决头文件找不到 修改c_cpp_properties.json Linux：gcc -v -E -x c++ - Windows 10 + Visual Studio 2019 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/include/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"windows-msvc-x64\" } ], \"version\": 4 } Windows 10 + Mingw-w64 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#1-c"},{"categories":["环境","配置"],"content":"Python 建议安装3.8版本 Python 官网 Miniconda 官网 Anaconda 官网 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#python"},{"categories":["环境","配置"],"content":"pip 设置代理 Windows：%APPDATA%\\pip\\pip.ini [global] proxy = http://user:password@proxy_name:port ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#pip-设置代理"},{"categories":["环境","配置"],"content":"Conda 常用命令更新：conda update 查看环境：conda env list或conda info -e 创建环境：conda create -n \u003cENVNAME\u003e python=3.X -y 删除环境：conda remove -n \u003cENVNAME\u003e --all -y 设置代理：conda config --set proxy_servers.http http://127.0.0.1:10809 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#conda-常用命令"},{"categories":["环境","配置"],"content":"PyTorchPyTorch 官网 CPU： Anaconda: conda install pytorch torchvision torchaudio cpuonly -c pytorch Pip: pip install torch==1.8.1+cpu torchvision==0.9.1+cpu torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html GPU (CUDA 11.0)： Anaconda: conda install pytorch torchvision torchaudio cudatoolkit=11.0 -c pytorch Pip: pip install torch==1.7.1+cu110 torchvision==0.8.2+cu110 torchaudio===0.7.2 -f https://download.pytorch.org/whl/torch_stable.html 检查是否安装成功： import torch # 检查 pytorch 是否安装成功 print(torch.__version__) # 检查 CUDA 是否可用 print(torch.cuda.is_available()) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#pytorch"},{"categories":["环境","配置"],"content":"TensorFlowTensorFlow 官网 Pip: CPU and GPU: pip install tensorflow Wheel: # https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow_cpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_cpu-2.4.1-cp38-cp38-win_amd64.whl # CPU # https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl # GPU 检查是否安装成功： import tensorflow as tf # 检查 tensorflow 是否安装成功 print(tf.__version__) # 检查 CUDA 是否可用 # 输出最后一行显示 [PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')] print(tf.config.experimental.list_physical_devices('GPU')) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#tensorflow"},{"categories":["环境","配置"],"content":"Q\u0026A问题描述： 安装 CUDA 11.1 + cuDNN 8.1，tensorflow 2.4.1 检查 GPU 时报错： Could not load dynamic library 'cusolver64_10.dll'; dlerror: cusolver64_10.dll not found 解决方案： 卸载重新安装 CUDA 11.0 + cuDNN 8.0，参考 Windows 经过测试的构建配置。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:1","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#qa"},{"categories":["环境","配置"],"content":"CUDA \u0026 cuDNN CUDA 和 cuDNN 版本：Windows 经过测试的构建配置 以笔记本 RTX2060 显卡为例 NVIDIA 驱动程序下载，选择对应版本，下载安装。 CUDA 工具包下载，下载对应版本安装。 在CMD输入nvcc -V，出现如下输出表示安装成功。 nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Tue_Sep_15_19:12:04_Pacific_Daylight_Time_2020 Cuda compilation tools, release 11.1, V11.1.74 Build cuda_11.1.relgpu_drvr455TC455_06.29069683_0 cuDNN 下载，需要登陆账号，登陆后下载对应版本，解压将bin、include和lib三个文件夹的内容复制到 CUDA 安装目录下。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#cuda--cudnn"},{"categories":["环境","配置"],"content":"FFmpeg 进入官网，点击Windows builds from gyan.dev。 点击下图链接下载，然后解压，并把bin目录添加环境变量。 重新打开 CMD，输入ffmpeg -version验证安装。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:0","series":null,"tags":["环境","配置"],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#ffmpeg"},{"categories":["Git","教程"],"content":"Git 是一个开源的分布式版本控制系统。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#"},{"categories":["Git","教程"],"content":"1 Git 基本工作流程","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#1-git-基本工作流程"},{"categories":["Git","教程"],"content":"1.1 本地仓库 本地历史仓库（Repository）：存放不同版本的代码。 暂存区（Index）：代码提交前的临时存储区。 工作目录（Working Tree）：修改代码的区域。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#11-本地仓库"},{"categories":["Git","教程"],"content":"1.2 远程仓库 克隆（Clone）：将远程仓库中的内容复制到本地仓库。 推送（Push）：将本地仓库中的内容推送到远程仓库。 拉取（Pull）：更新远程仓库中的改动到本地仓库。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#12-远程仓库"},{"categories":["Git","教程"],"content":"2 Git 常用命令 # 查看 git 状态 git status # 查看日志 git log # 查看简短日志 git reflog ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#2-git-常用命令"},{"categories":["Git","教程"],"content":"2.1 本地仓库 # 初始化，创建 git 仓库 git init # 添加文件到暂存区 git add \u003cfile\u003e # 将暂存区文件提交到本地历史仓库 git commit -m \u003cmessage\u003e # 将所有修改或删除的文件提交到本地历史仓库（不包括新建文件） git commit -a -m \u003cmessage\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#21-本地仓库"},{"categories":["Git","教程"],"content":"2.2 版本切换 # git reset --hard a3a9cf1 git reset --hard \u003ccommit\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#22-版本切换"},{"categories":["Git","教程"],"content":"2.3 分支管理 切换：将HEAD指向别的分支。 合并：将main指向该分支，然后将HEAD指向main分支。 # 查看所有分支 git branch # 创建新分支 git branch \u003cbranch-name\u003e # 删除指定分支 git branch -d \u003cbranch-name\u003e # 切换到其他分支 git checkout \u003cbranch\u003e # 创建新分支，并立即切换过去 git checkout -b \u003cbranch\u003e # 将指定分支合并到当前分支 git merge \u003cbranch-name\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#23-分支管理"},{"categories":["Git","教程"],"content":"2.4 远程仓库2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add \u003cname\u003e \u003curl\u003e # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u \u003crepository\u003e \u003crefspec\u003e 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone \u003crepo\u003e # 拉取远端仓库，更新本地仓库 # git pull origin master git pull \u003crepository\u003e \u003crefspec\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#24-远程仓库"},{"categories":["Git","教程"],"content":"2.4 远程仓库2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-SSH and GPG keys-New SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-SSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#241-远程仓库创建"},{"categories":["Git","教程"],"content":"2.4 远程仓库2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-SSH and GPG keys-New SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-SSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#242-ssh-配置"},{"categories":["Git","教程"],"content":"2.4 远程仓库2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-SSH and GPG keys-New SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-SSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#243-本地仓库同步到远程仓库"},{"categories":["Git","教程"],"content":"2.4 远程仓库2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-SSH and GPG keys-New SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-SSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#244-远程仓库同步到本地仓库"},{"categories":["Git","教程"],"content":"2.5 代码冲突同一文件存在多个新版本，如下所示。需要先拉取远程仓库，手动修改冲突文件后，再次推送即可。 ! [rejected] master -\u003e master (fetch first) error: failed to push some refs to 'https://github.com/backtraxe/repo_for_test.git' 2.5.1 替换本地改动 # 丢弃当前文件修改内容 git checkout -- \u003cfile\u003e # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#25-代码冲突"},{"categories":["Git","教程"],"content":"2.5 代码冲突同一文件存在多个新版本，如下所示。需要先拉取远程仓库，手动修改冲突文件后，再次推送即可。 ! [rejected] master - master (fetch first) error: failed to push some refs to 'https://github.com/backtraxe/repo_for_test.git' 2.5.1 替换本地改动 # 丢弃当前文件修改内容 git checkout -- # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#251-替换本地改动"},{"categories":["Git","教程"],"content":"2.6 子模块 # 将一个 Git 仓库添加为当前仓库的子模块 git submodule add https://github.com/USERNAME/REPONAME.git # git clone 含有子模块的项目 # 1.项目已经克隆到了本地 git submodule init git sunmodule update # 或者 git submodule update --init # 2.项目还未克隆到本地 git clone --recurse-submodules https://github.com/USERNAME/REPONAME.git # 或者 git clone --recursive https://github.com/USERNAME/REPONAME.git ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#26-子模块"},{"categories":["Git","教程"],"content":"2.7 .gitignore工作目录中需要 git 忽略的文件目录。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#27-gitignore"},{"categories":["Git","教程"],"content":"Q\u0026A","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#qa"},{"categories":["Git","教程"],"content":"1. 无法连接服务器，报错443问： git clone或git push等操作时无法连接至服务器，报错内容如下： SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 答： 该问题由开启代理软件导致。设置-\u003e网络和Internet-\u003e代理，查看地址和端口，通过如下命令进行配置。 # git config --global http.proxy 127.0.0.1:10809 git config --global http.proxy IP_ADDRESS:PORT ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#1-无法连接服务器报错443"},{"categories":["Git","教程"],"content":"参考 Git Cheat Sheets ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#参考"},{"categories":["饥荒"],"content":"饥荒 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#"},{"categories":["饥荒"],"content":"科普 食物可通过觅食，陷阱，种植或者猎捕动物和怪兽获得。 不同的食物可以恢复不同的饥饿和一些生命以及理智。 但是如果吃下一些像是怪物肉或是榴梿之类的食物，可能反而会对玩家的生命值造成伤害，甚至是降低玩家的理智。 不同颜色的蘑菇针对生命值和理智值也都会对玩家产生不同的效果。 另外有些比较特殊的食物，比如发光莓，在吃下去后会给予玩家特别的效果。 大部分食物都可以通过在营火上烹饪来增加恢复的饥饿与生命或是减少（抵消）生吃对玩家造成的负面影响。 有些生的食物（通常为肉类）可以挂在干肉架上晒干来取得可以长久保存并能回复玩家饥饿/生命/理智的食物。 烹饪锅可以用来取得一些特殊料理，让玩家可以从食物中得到额外的好处（大部分的料理都有回复理智的效果，但直接食用大部分的食物都无法得到）。 肉类可以作为诱饵，可以招募猪人，可以进贡给猪王换取金块。 一个可以不断取得蛋的方法就是通过将肉喂给鸟笼中的鸟，肉类还可以制作复活肖像。 当玩家在物品栏中持有肉时会被兔人视为攻击目标。 蔬菜和水果可以当作草食动物的诱饵（像是兔子）或是喂给猪人来换取粪便。种子可以当作捕鸟陷阱的诱饵。 被视为游戏中最重要的物品之一，根据地图生成的不同，食物可以从很丰富到十分短缺都有可能。 食物受到季节的影响非常大，这鼓励玩家去根据季节挑选适合的食物（译注：像是冬天农田几乎不会生长、春天兔子不会跑出洞、只有夏天才有仙人掌花…等等例子）。 大多数的食物都会慢慢的腐烂，最后变成腐烂食物。 当食物的腐坏度为50%时，食物将会变为**不新鲜（黄色）**状态。可恢复2/3的饥饿，1/3的生命，不能恢复理智。 当食物的腐坏度为20%时，食物将会变为**变质（红色）**状态。可恢复1/2的饥饿，不能恢复生命，降低10点理智。 地面上的食物腐坏率为150%，冰箱中的腐坏率为50%，冬天食物的腐坏率为75%。 不新鲜和变质的食物对**WX-78（机器人）**没有影响。 堆叠的食物具有相同的腐烂程度，将腐烂程度不同的食物堆叠起来腐烂值取平均值。在游戏中可以利用这个设定来\"拯救\"快要腐烂的食物：将快腐烂的食物与新鲜的食物堆叠起来，然后ctrl+点击分开食物。 烹饪中的食物和在烹饪锅中的食物降低一般的腐坏度。 高脚鸟蛋，曼德拉草和巨鹿眼球是不会腐坏的。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#科普"},{"categories":["饥荒"],"content":"食谱 类别 详细 肉类 怪物肉 鱼类 蔬菜 胡萝卜、各种蘑菇、 水果 浆果、多汁浆果、香蕉、西瓜、火龙果、石榴、榴莲 烹饪 其他 桦树果、蝴蝶翅膀、黄油、牛奶、冰、蜂蜜、腐烂食物、各种种子、齿轮、树枝、噩梦燃料、骨头碎片、花瓣 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#食谱"},{"categories":["饥荒"],"content":"肉丸 肉度×0.5，1肉3填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 62.5 5 3 15秒 10天 食材1 食材2 食材3 食材4 怪物肉、大肉、小肉、鸡腿 浆果、冰 浆果、冰 浆果、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#肉丸"},{"categories":["饥荒"],"content":"炖肉 肉度×3，3肉1填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 150 5 12 15秒 10天 食材1 食材2 食材3 食材4 怪物肉 大肉 大肉 浆果、冰 怪物肉 大肉 小肉 小肉 大肉 大肉 鸡腿 蛙腿 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#炖肉"},{"categories":["饥荒"],"content":"火鸡大餐 鸡腿×2+肉度×0.5，2鸡腿1肉1填充物，两个鸡腿必须是生的。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 60秒 6天 食材1 食材2 食材3 食材4 鸡腿 鸡腿 怪物肉、大肉、小肉 浆果、蘑菇、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#火鸡大餐"},{"categories":["饥荒"],"content":"培根煎蛋 蛋度×2+肉度×1.5，禁蔬菜、水果。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 40秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉、大肉 大肉、小肉 高脚鸟蛋 怪物肉、大肉、小肉 怪物肉、大肉、小肉 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#培根煎蛋"},{"categories":["饥荒"],"content":"蜜汁火腿 蜂蜜×1+肉度×2，禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 30 40秒 20天 食材1 食材2 食材3 食材4 蜂蜜 怪物肉 大肉、小肉 大肉、小肉 蜂蜜 怪物肉 大肉 浆果 蜂蜜 蜂蜜 怪物肉 大肉 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#蜜汁火腿"},{"categories":["饥荒"],"content":"果仁杂烩 烤桦树果+水果×1.5，禁冰、蔬菜。 饥饿 精神 生命 烹饪时间 腐烂时间 12.5 5 30 40秒 15天 食材1 食材2 食材3 食材4 烤桦树果 浆果 浆果 浆果 烤桦树果 烤桦树果 浆果 浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#果仁杂烩"},{"categories":["饥荒"],"content":"波兰水饺 禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 20秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉 蘑菇 高脚鸟蛋 浆果 怪物肉 蘑菇 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#波兰水饺"},{"categories":["饥荒"],"content":"火龙果派 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 40 40秒 15天 食材1 食材2 食材3 食材4 火龙果 树枝、浆果 树枝、浆果 树枝、浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:8","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#火龙果派"},{"categories":["饥荒"],"content":"华夫饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 60 10秒 6天 食材1 食材2 食材3 食材4 黄油 鸡蛋、高脚鸟蛋 浆果 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:9","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#华夫饼"},{"categories":["饥荒"],"content":"炸鱼条 鱼+树枝 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 40秒 10天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:10","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#炸鱼条"},{"categories":["饥荒"],"content":"太妃糖 蜂蜜×3 饥饿 精神 生命 烹饪时间 腐烂时间 25 15 -3 40秒 15天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:11","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#太妃糖"},{"categories":["饥荒"],"content":"蝴蝶松饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 20 40秒 15天 食材1 食材2 食材3 食材4 蝴蝶翅膀 蘑菇 树枝 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:12","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#蝴蝶松饼"},{"categories":["饥荒"],"content":"粉末蛋糕 玉米+蜂蜜，腐烂时间很久。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:13","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#粉末蛋糕"},{"categories":["饥荒"],"content":"人物 mod","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#人物-mod"},{"categories":["饥荒"],"content":"宝石萝莉宝石萝莉完整攻略 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#宝石萝莉"},{"categories":["饥荒"],"content":"参考资料 Don’t Starve 中文维基 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#参考资料"},{"categories":["科学上网"],"content":"外面的世界。 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#"},{"categories":["科学上网"],"content":"1.准备工作 VPS：推荐CN2 GIA线路，其次CN2 BandwagonHost, 备用 Vultr DigitalOcean 三优云 域名 免费：Freenom 付费：NameSilo, GoDaddy DNS \u0026 CDN： Cloudflare ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#1准备工作"},{"categories":["科学上网"],"content":"2.服务端","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#2服务端"},{"categories":["科学上网"],"content":"2.1 v2ray-agentGithub 支持协议： VLESS + TCP + TLS VLESS + TCP + xtls-rprx-direct【推荐】 VLESS + gRPC + TLS VLESS + WS + TLS Trojan + TCP + TLS【推荐】 Trojan + TCP + xtls-rprx-direct【推荐】 Trojan + gRPC + TLS VMess + WS + TLS 安装： wget -P /root -N --no-check-certificate \"https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh\" \u0026\u0026 chmod 700 /root/install.sh \u0026\u0026 /root/install.sh 查看配置：vasma ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#21-v2ray-agent"},{"categories":["科学上网"],"content":"2.2 Xray_onekeyGithub 支持协议： VLESS + TCP + XTLS/TLS VLESS + TCP + XTLS/TLS 及 VLESS + WS + TLS 回落并存模式 安装： wget -N --no-check-certificate -q -O install.sh \"https://raw.githubusercontent.com/wulabing/Xray_onekey/main/install.sh\" \u0026\u0026 chmod +x install.sh \u0026\u0026 bash install.sh 查看配置：同安装 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#22-xray_onekey"},{"categories":["科学上网"],"content":"2.3 x-uiGithub 支持协议： vmess vless trojan shadowsocks dokodemo-door socks http 安装： bash \u003c(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) 查看配置：x-ui ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#23-x-ui"},{"categories":["科学上网"],"content":"3.客户端","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#3客户端"},{"categories":["科学上网"],"content":"3.1 Windows3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#31-windows"},{"categories":["科学上网"],"content":"3.1 Windows3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#311-v2rayn"},{"categories":["科学上网"],"content":"3.1 Windows3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#312-clash-for-windows"},{"categories":["科学上网"],"content":"3.1 Windows3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#qv2ray"},{"categories":["科学上网"],"content":"安卓V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 AnXray下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#安卓"},{"categories":["科学上网"],"content":"安卓V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 AnXray下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#v2rayng"},{"categories":["科学上网"],"content":"安卓V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 AnXray下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#igniter"},{"categories":["科学上网"],"content":"安卓V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 AnXray下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#clash-for-android"},{"categories":["科学上网"],"content":"安卓V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 AnXray下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#anxray"},{"categories":["科学上网"],"content":"安卓V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 AnXray下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#sagernet"},{"categories":["C++","数据结构","算法"],"content":"竞赛算法集合。 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:0:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#"},{"categories":["C++","数据结构","算法"],"content":"1 STL 小技巧","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#1-stl-小技巧"},{"categories":["C++","数据结构","算法"],"content":"1.1 头文件 /*** 函数 ***/ #include\u003calgorithm\u003e#include\u003cfunctional\u003e // hash#include\u003cclimits\u003e // 常量#include\u003ccmath\u003e#include\u003ccstdio\u003e#include\u003ccstdlib\u003e // 随机数生成 random#include\u003cctime\u003e#include\u003ciostream\u003e#include\u003csstream\u003e#include\u003ciomanip\u003e // 格式化 right 和 setw(width) /*** 数据结构 ***/ #include\u003cdeque\u003e // 双端队列#include\u003clist\u003e#include\u003cqueue\u003e // 包含 priority_queue#include\u003cstack\u003e#include\u003cstring\u003e#include\u003cvector\u003e ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#11-头文件"},{"categories":["C++","数据结构","算法"],"content":"1.2 I/O cin \u003e\u003e n; getline(cin, str); // 接收换行符 getline(cin, str); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#12-io"},{"categories":["C++","数据结构","算法"],"content":"1.3 常量 #include\u003cclimits\u003e INT_MIN INT_MAX LONG_MIN LONG_MAX LLONG_MIN LLONG_MAX (~0u) // 无穷大 (for long and long long) (~0u)\u003e\u003e2 // 无穷大 (for int) ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#13-常量"},{"categories":["C++","数据结构","算法"],"content":"1.4 数学 // 当数字很大时，用 powl 代替 pow powl(a, b); // p 的 n 方根 (int)round(p, (1.0/n)); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#14-数学"},{"categories":["C++","数据结构","算法"],"content":"1.5 初始化数组 // 一维数组 fill(arr, arr + sizeof(arr), value); fill_n(arr, sizeof(arr), value); // 二维数组，只能填充 0 或 -1 memset(arr, 0, sizeof(arr)); for (int i = 0; i \u003c row; i++) fill(a[i], a[i] + sizeof(a[i]), value); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:5","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#15-初始化数组"},{"categories":["C++","数据结构","算法"],"content":"1.6 修改序列 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:6","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#16-修改序列"},{"categories":["C++","数据结构","算法"],"content":"动态规划","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#动态规划"},{"categories":["C++","数据结构","算法"],"content":"凸包技巧https://codeforces.com/contest/319/problem/C #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003eusing namespace std; typedef long long ll; const int MAXN = 105000; int n; ll height[MAXN], tax[MAXN]; ll dp[MAXN]; vector\u003cll\u003e mvals, bvals; int cur = 0; // Suppose the last 3 lines added are : (l1, l2, l3) // Line l2 becomes irrelevant, if l1/l3 x-intersection is to the left of l1/l2 x-intersection bool bad(ll m1, ll b1, ll m2, ll b2, ll m3, ll b3) { // 转为 double 避免溢出 return 1.0 * (b1 - b3) * (m2 - m1) \u003c 1.0 * (b1 - b2) * (m3 - m1); } void add(ll m, ll b) { while ( (int) mvals.size() \u003e= 2 \u0026\u0026 bad(mvals[mvals.size() - 2], bvals[bvals.size() - 2], mvals[mvals.size() - 1], bvals[bvals.size() - 1], m, b)) { mvals.pop_back(); bvals.pop_back(); } mvals.push_back(m); bvals.pu","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#凸包技巧"},{"categories":["C++","数据结构","算法"],"content":"最长递增序列https://informatics.msk.ru/mod/statements/view3.php?id=766\u0026chapterid=1794 $O(N \\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = 1000 * 1000 * 1000; int n; int k, b, m; int a[MAXN]; int d[MAXN]; int ind[MAXN], pr[MAXN]; vector \u003cint\u003e ansv; int ans = 1; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); scanf(\"%d %d %d %d\", \u0026a[1], \u0026k, \u0026b, \u0026m); for (int i = 2; i \u003c= n; i++) a[i] = (k * a[i - 1] + b) % m; d[0] = -INF; for (int i = 1; i \u003c= n; i++) d[i] = INF; for (int i = 1; i \u003c= n; i++) { int pos = upper_bound(d + 1, d + n + 1, a[i]) - d; if (d[pos - 1] \u003c a[i] \u0026\u0026 a[i] \u003c d[pos]) { d[pos] = a[i]; ind[pos] = i; pr[i] = ind[pos - 1]; ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最长递增序列"},{"categories":["C++","数据结构","算法"],"content":"数据结构","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#数据结构"},{"categories":["C++","数据结构","算法"],"content":"笛卡尔树Balanced Binary Search Tree https://informatics.msk.ru/mod/statements/view3.php?chapterid=2782 $O(\\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int mod = 1000 * 1000 * 1000; struct node { int x, y; node *l, *r; node(int new_x, int new_y) { x = new_x; y = new_y; l = NULL; r = NULL; } }; typedef node * pnode; void merge(pnode \u0026t, pnode l, pnode r) { if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } } void split(pnode t, int x, pnode \u0026l, pnode \u0026r) { if (t == NULL) l = r = NULL; else if (t-\u003ex \u003e x) { split(t-\u003el, x, l, t-\u003el); r = t; } else { split(t-\u003er, x, t-\u003er, r); l = t; } } void add(pnode \u0026t, pnode a) { if (t == NULL) t = a; else if (a-\u003ey \u003e t-\u003ey) { split(t, a-\u003ex, a-\u003el, ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#笛卡尔树"},{"categories":["C++","数据结构","算法"],"content":"带有隐式键的笛卡尔树https://informatics.msk.ru/mod/statements/view3.php?chapterid=111240 $O(\\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003cutility\u003e#include \u003ccstring\u003e#include \u003ciomanip\u003e using namespace std; const int INF = 2 * 1000 * 1000 * 1000; struct node { int y, val; int sz, mn; bool rev; node *l, *r; node (int new_val, int new_y) { y = new_y; val = new_val; sz = 1; mn = val; rev = false; l = NULL; r = NULL; } }; typedef node * pnode; int getsize(pnode t) { if (t == NULL) return 0; return t-\u003esz; } int getmin(pnode t) { if (t == NULL) return INF; return t-\u003emn; } void update(pnode t) { if (t == NULL) return; t-\u003esz = getsize(t-\u003el) + 1 + getsize(t-\u003er); t-\u003emn = min(t-\u003eval, min(getmin(t-\u003er), getmin(t-\u003el))); } void push(pnode t) { if (t \u0026\u0026 t-\u003erev) { swap(t-\u003el, t-\u003er); if (t-\u003el) t-\u003el-\u003erev ^= true; if (t-\u003er) t-\u003er-\u003erev ^= true; t-\u003er","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#带有隐式键的笛卡尔树"},{"categories":["C++","数据结构","算法"],"content":"树状数组$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3317 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; int a[MAXN]; long long f[MAXN]; char q; int l, r; void update(int pos, int delta) { for (; pos \u003c= n; pos = (pos | (pos + 1))) f[pos] += delta; } long long sum(int pos) { long long res = 0; for (; pos \u003e 0; pos = (pos \u0026 (pos + 1)) - 1) res += f[pos]; return res; } long long sum(int l, int r) { return sum(r) - sum(l - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026a[i]); update(i, a[i]); } scanf(\"%d\\n\", \u0026m); for (int i = 1; i \u003c= m; i++) { scanf(\"%c %d %d\\n\", \u0026q, \u0026l, ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#树状数组"},{"categories":["C++","数据结构","算法"],"content":"二维树状数组$O((\\log N)^2)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3013 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 1050; int n, m; int qn; char q[10]; int f[MAXN][MAXN]; void update(int x, int y, int delta) { for (int i = x; i \u003c= n; i = i | (i + 1)) for (int j = y; j \u003c= m; j = j | (j + 1)) f[i][j] += delta; } int getSum(int x, int y) { int res = 0; for (int i = x; i \u003e 0; i = (i \u0026 (i + 1)) - 1) for (int j = y; j \u003e 0; j = (j \u0026 (j + 1)) - 1) res += f[i][j]; return res; } int getSum(int xFrom, int xTo, int yFrom, int yTo) { return getSum(xTo, yTo) - getSum(xTo, yFrom - 1) - getSum(xFrom - 1, yTo) + getSum(xFrom - 1, yFrom - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#二维树状数组"},{"categories":["C++","数据结构","算法"],"content":"隐式的线段树 时间复杂度：$O(\\log N)$ 空间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3327 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003ccstdlib\u003e using namespace std; typedef long long ll; struct Node { ll sum; Node *l, *r; Node() : sum(0), l(NULL), r(NULL) { } }; void add(Node *v, int l, int r, int q_l, int q_r, ll val) { if (l \u003e r || q_r \u003c l || q_l \u003e r) return; if (q_l \u003c= l \u0026\u0026 r \u003c= q_r) { v -\u003e sum += val; return; } int mid = (l + r) \u003e\u003e 1; if (v -\u003e l == NULL) v -\u003e l = new Node(); if (v -\u003e r == NULL) v -\u003e r = new Node(); add(v -\u003e l, l, mid, q_l, q_r, val); add(v -\u003e r, mid + 1, r, q_l, q_r, val); } ll get(Node *v, int l, int r, int pos) { if (!v || l \u003e r || pos \u003c l || pos \u003e r) return 0; if (l == r) return v -\u003e sum; int mid = (l + r) \u003e\u003e 1; return v -\u003e sum + get(v -\u003e l, l, mid, pos) + get(v -\u003e r, mid + 1, r, pos); } int n, m, t, x, y, val; char c; int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); Node *root = new Node(); scanf(\"%d\",","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:5","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#隐式的线段树"},{"categories":["C++","数据结构","算法"],"content":"最小队列 时间复杂度：$O(1)$ https://informatics.msk.ru//mod/statements/view.php?chapterid=756 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 205000; int n, m; deque \u003c pair \u003cint, int\u003e \u003e d; int a[MAXN]; void enqueue(int x) { int num = 1; while (!d.empty() \u0026\u0026 d.back().first \u003e x) { num += d.back().second; d.pop_back(); } d.push_back(make_pair(x, num)); } void dequeue() { if (d.front().second == 1) { d.pop_front(); } else { d.front().second--; } } int getMin() { return d.front().first; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); for (int i = 1; i \u003c= m; i++) { enqueue(a[i]); } printf(\"%d\\n\", getMin()); for (int i","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:6","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最小队列"},{"categories":["C++","数据结构","算法"],"content":"线段树（加法-最小间隔-最大间隔）https://codeforces.com/contest/1263/problem/E #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 1000 * 1000 + 100; const int INF = (int) 1e9; struct node { int mx, mn; int add; }; int n; int val[MAXN]; string s; int pos; node tree[4 * MAXN]; void add(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; if (L == l \u0026\u0026 R == r) { tree[v].add += val; } else { int mid = L + (R - L) / 2; add(2 * v + 1, L, mid, l, min(mid, r), val); add(2 * v + 2, mid + 1, R, max(mid + 1, l), r, val); tree[v].mx = max(tree[2 * v + 1].mx + tree[2 * v + 1].add, tree[2 * v + 2].mx + tree[2 * v + 2].add); tree[v].mn = min(tree[2 * v + 1].mn + tree[2 * v + 1].add, tree[2 * v + 2].mn + tree[2 * v + 2].add); } } int getMin(int v, ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:7","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树加法-最小间隔-最大间隔"},{"categories":["C++","数据结构","算法"],"content":"线段树（分配-求和）https://codeforces.com/gym/100093 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int zero = -1; struct node { long long sum; int val; int size; }; int n, m; char qt; int x, l, r; int a[MAXN]; vector \u003cnode\u003e tree; void build (int v, int L, int R, int a[]) { if (L == R) { tree[v].sum = tree[v].val = a[L]; tree[v].size = 1; } else { int mid = L + (R - L) / 2; build(2 * v, L, mid, a); build(2 * v + 1, mid + 1, R, a); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; tree[v].val = zero; tree[v].size = tree[2 * v + 1].size + tree[2 * v].size; } } void push(int v) { if (tree[v].val == zero) return; if (tree[v].size != 1) { tree[2 * v].val = tree[v].val; tree[2 * v + 1].val = tree[v].val; } tree[v].sum = 1l","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:8","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树分配-求和"},{"categories":["C++","数据结构","算法"],"content":"线段树（最小值-值更新） 预先计算：$O(N \\log N)$ 查询：$O(1)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = (int) 1e9; int n, num, qn; int a[MAXN]; int tree[4 * MAXN]; int l, r; int getMax(int l, int r) { l = num + l - 1; r = num + r - 1; int res = -INF; while (l \u003c= r) { if (l \u0026 1) { res = max(res, tree[l]); l++; } if (r % 2 == 0) { res = max(res, tree[r]); r--; } l /= 2; r /= 2; } return res; } void update(int pos, int val) { pos = num + pos - 1; tree[pos] = val; pos /= 2; while (pos \u003e= 1) { tree[pos] = max(tree[pos * 2], tree[pos * 2 + 1]); pos /= 2; } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); s","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:9","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树最小值-值更新"},{"categories":["C++","数据结构","算法"],"content":"稀疏表 预先计算：$O(N)$ 查询：$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 2 * 105000; const int MAXLOG = 20; int n, m; int a[MAXN]; int table[MAXLOG][MAXN]; int numlog[MAXN]; void buildTable() { numlog[1] = 0; for (int i = 2; i \u003c= n; i++) numlog[i] = numlog[i / 2] + 1; for (int i = 0; i \u003c= numlog[n]; i++) { int curlen = 1 \u003c\u003c i; for (int j = 1; j \u003c= n; j++) { if (i == 0) { table[i][j] = a[j]; continue; } table[i][j] = max(table[i - 1][j], table[i - 1][j + curlen / 2]); } } } int getMax(int l, int r) { int curlog = numlog[r - l + 1]; return max(table[curlog][l], table[curlog][r - (1 \u003c\u003c curlog) + 1]); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); /","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:10","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#稀疏表"},{"categories":["C++","数据结构","算法"],"content":"几何","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#几何"},{"categories":["C++","数据结构","算法"],"content":"最近点对 时间复杂度：$O(N \\log N)$ https://www.spoj.com/problems/CLOPPAIR/ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; #define sqr(x) ((x) * (x)) const double inf = 1e100; const int MAXN = 105000; struct point { double x, y; int ind; }; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } int n; int a[MAXN]; point p[MAXN], tmp[MAXN]; double ans = inf; int p1, p2; void updateAnswer(point a, point b) { double d = dist(a, b); if (d \u003c ans) { ans = d; p1 = a.ind; p2 = b.ind; } } void closestPair(int l, int r) { if (l \u003e= r) return; if (r - l == 1) { if (p[l].y \u003e p[r].y) swap(p[l], p[r]); updateAnswer(p[l], p[r]); return; } int m = (l + r) / 2; doubl","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最近点对"},{"categories":["C++","数据结构","算法"],"content":"凸包Graham-Andrew 方法 时间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view3.php?chapterid=638 https://informatics.msk.ru/mod/statements/view3.php?id=\u0026chapterid=290 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e using namespace std; #define sqr(x) ((x) * (x)) const double pi = acos(-1.0); struct point { double x, y; }; int n; vector \u003cpoint\u003e p, hull; double ans; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } bool eq(point a, point b) { return (a.x == b.x \u0026\u0026 a.y == b.y); } bool isCCW(point a, point b, point c) { return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) \u003e 0; } void setConvexHull(vector \u003cpoint\u003e p, vector \u003cpoint\u003e \u0026h) { sort(p.begin(), p.end(), cmp); p.erase(unique(p.begin(), p.end(), eq), p.end()); vector \u003cpoint\u003e up, down; point head = p[0], tail = p.back(); up.push_back(head); down.push_back(head); for (int i = 1; i \u003c (int) p.size(); i++) { if (i == (int) p.size()","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#凸包"},{"categories":["C++","数据结构","算法"],"content":"图","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#图"},{"categories":["C++","数据结构","算法"],"content":"Bellman-Ford 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view3.php?id=260\u0026chapterid=178 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105; const int INF = 30000; struct edge { int from, to; int w; }; int n, m; int dist[MAXN]; vector \u003cedge\u003e e; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { edge curEdge; scanf(\"%d %d %d\", \u0026curEdge.from, \u0026curEdge.to, \u0026curEdge.w); e.push_back(curEdge); } for (int i = 1; i \u003c= n; i++) dist[i] = INF; dist[1] = 0; for (int i = 1; i \u003c= n; i++) { bool changed = false; for (int j = 0; j \u003c m; j++) { int from = e[j].from, to = e[j].to, w = e[j].w; if (dist[from] != INF \u0026\u0026 dis","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#bellman-ford-算法"},{"categories":["C++","数据结构","算法"],"content":"二部图匹配Kuhn 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=1683 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105; int n, m; vector \u003cint\u003e g[MAXN]; bool used[MAXN]; int mt[MAXN]; int ans; bool kuhn(int v) { if (used[v]) return false; used[v] = true; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (mt[to] == 0 || kuhn(mt[to])) { mt[to] = v; return true; } } return false; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int can; scanf(\"%d\", \u0026can); if (can) g[i].push_back(j); } } for (int i = 1; i \u003c= n; i++) { memset(used, 0, sizeof(used","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#二部图匹配"},{"categories":["C++","数据结构","算法"],"content":"桥搜索 时间复杂度：$O(M)$ https://codeforces.com/gym/100083 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; vector \u003cint\u003e g[MAXN]; vector \u003cint\u003e ind[MAXN]; int tin[MAXN], mn[MAXN]; bool used[MAXN]; vector \u003cint\u003e bridges; int timer; void dfs(int v, int par = -1) { used[v] = true; timer++; tin[v] = timer; mn[v] = tin[v]; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { dfs(to, v); if (mn[to] == tin[to]) { bridges.push_back(ind[v][i]); } mn[v] = min(mn[v], mn[to]); } else if (to != par) { mn[v] = min(mn[v], mn[to]); } } } int main() { assert(freopen(\"bridges.in\",\"r\",stdin)); assert(freopen(\"bridges.out\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { int from, to; scanf(","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#桥搜索"},{"categories":["C++","数据结构","算法"],"content":"拓扑排序 #include\u003ciostream\u003eusing namespace std; int n = 100; int f[100]={0}, ans[100]={0}; bool g[100][100]={0} ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#拓扑排序"},{"categories":["C++","数据结构","算法"],"content":"参考资料 ADJA/algos: Competitive programming algorithms in C++ - GitHub ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:6:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#参考资料"},{"categories":[],"content":"常用 Linux 命令。 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:0:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#"},{"categories":[],"content":"快捷键 Tab 补全命令 Ctrl + C 停止当前运行中的程序 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#快捷键"},{"categories":[],"content":"cp","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#cp"},{"categories":[],"content":"ls显示目录内容。 # 指定目录，默认当前目录 ls \u003cpath\u003e # 列出详细信息 # 权限、用户、用户组、大小、修改时间、名称 ls -l # 文件大小显示更直观 ls -lh # 列出所有文件（包括隐藏） ls -a ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ls"},{"categories":[],"content":"排序 # 按修改时间从近到远排序 ls -t # 按文件大小从大到小排序 ls -S # 逆序排序 ls -r ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:1","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#排序"},{"categories":[],"content":"打印方式 # 纵向显示（一行一个） ls -1 # 横向显示（逗号分隔） ls -m ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:2","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#打印方式"},{"categories":[],"content":"文件权限drwxrwxrwx 第1位，d，文件类型。 d：目录。 -：一般文件。 第2-4位，rwx，文件创建者的权限。 第5-7位，rwx，文件创建者同用户组成员的权限。 第8-10位，rwx，其他成员的权限。 rwx r，读取权限。二进制为100，十进制即4。 w，写入权限。二进制为010，十进制即2。 x，执行权限。二进制为001，十进制即1。 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:3","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#文件权限"},{"categories":[],"content":"mv","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#mv"},{"categories":[],"content":"scp在本地主机和远程主机之间传输文件。 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#scp"},{"categories":[],"content":"本地主机的文件上传到远程主机 # 单个文件 scp \u003cfile\u003e \u003cuser\u003e@\u003cip\u003e:\u003cpath\u003e -P \u003cssh_port\u003e # 目录 scp -r \u003cfolder\u003e \u003cuser\u003e@\u003cip\u003e:\u003cpath\u003e -P \u003cssh_port\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:1","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#本地主机的文件上传到远程主机"},{"categories":[],"content":"远程主机的文件下载到本地主机 # 单个文件 scp \u003cuser\u003e@\u003cip\u003e:\u003cfile\u003e \u003cpath\u003e -P \u003cssh_port\u003e # 目录 scp -r \u003cuser\u003e@\u003cip\u003e:\u003cfolder\u003e \u003cpath\u003e -P \u003cssh_port\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:2","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#远程主机的文件下载到本地主机"},{"categories":[],"content":"ssh远程登录。 # 默认端口 22 ssh \u003cuser\u003e@\u003cip\u003e # 指定端口 ssh \u003cuser\u003e@\u003cip\u003e -p \u003cport\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ssh"},{"categories":[],"content":"ssh 免密登录 # 为当前用户生成 ssh 公钥 + 私钥。 # 默认保存在 $home/.ssh/ 文件夹中。 # id_rsa 是私钥，id_rsa.pub 是公钥。 ssh-keygen # 将当前用户的公钥复制到服务器的 ~/.ssh/authorized_keys 文件 ssh-copy-id \u003cuser\u003e@\u003cip\u003e:\u003cport\u003e # 或者手动将公钥添加到服务器的 ~/.ssh/authorized_keys 文件 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:1","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ssh-免密登录"},{"categories":["LaTeX","Cheatsheet"],"content":"LaTeX 常用数学符号、公式。 标量 - 斜体小写 - $a$ 向量 - 粗体小写 - $a$ 矩阵 - 粗体大写 - $A$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:0:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#"},{"categories":["LaTeX","Cheatsheet"],"content":"希腊字母 大写字母 代码 小写字母 代码 变量形式 代码 $\\alpha$ \\alpha $\\beta$ \\beta $\\Gamma$ \\Gamma $\\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $\\epsilon$ \\epsilon $\\Theta$ \\Theta $\\theta$ \\theta $\\Lambda$ \\Lambda $\\lambda$ \\lambda $\\mu$ \\mu $\\Pi$ \\Pi $\\pi$ \\pi $\\rho$ \\rho $\\Sigma$ \\Sigma $\\sigma$ \\sigma $\\Phi$ \\Phi $\\phi$ \\phi $\\varphi$ \\varphi $\\Psi$ \\Psi $\\psi$ \\psi $\\Omega$ \\Omega $\\omega$ \\omega ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:1:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#希腊字母"},{"categories":["LaTeX","Cheatsheet"],"content":"特殊符号 符号 代码 解释 $\\partial$ \\partial 偏导数 $\\nabla$ \\nabla 梯度 $\\ell$ \\ell $\\Complex$ \\Complex \\cnums 复数集 $\\R$ \\Reals \\reals \\R 实数集 $\\Z$ \\Z 整数集 $\\natnums$ \\natnums \\N 自然数集 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:2:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#特殊符号"},{"categories":["LaTeX","Cheatsheet"],"content":"垂直布局 符号 代码 解释 $x_n$ x_n 下标 $e^x$ e^x 上标 $_u^o$ _u^o 上下标 $\\overset{N}{\\sum}$ \\overset{N}{\\sum} 正上标 $\\underset{i=1}{\\sum}$ \\underset{i=1}{\\sum} 正下标 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:3:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#垂直布局"},{"categories":["LaTeX","Cheatsheet"],"content":"字体 符号 代码 解释 $\\sqrt{x}$ \\sqrt{x} 平方根 $\\sqrt[3]{x}$ \\sqrt[3]{x} 三次方根 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:4:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#字体"},{"categories":["LaTeX","Cheatsheet"],"content":"逻辑符与集合论 符号 代码 解释 $\\forall$ \\forall 所有 $\\exist$ \\exists \\exist 存在 $\\in$ \\in \\isin 属于 $\\notin$ \\notin 不属于 $\\subset$ \\subset 包含于 $\\supset$ \\supset 包含 $\\emptyset$ \\emptyset \\empty 空集 $\\varnothing$ \\varnothing 空集 $\\implies$ \\implies 充分 $\\impliedby$ \\impliedby 必要 $\\iff$ \\iff 充分必要 $\\neg$ \\neg \\lnot 非 $\\lor$ \\lor 或 $\\land$ \\land 与 $\\because$ \\because 因为 $\\therefore$ \\therefore 所以 $\\ne$ \\ne \\neq 不等于 $\\approx$ \\approx 约等于 $\\coloneqq$ \\coloneqq 赋值 $\\gt$ \\gt 大于 $\\ge$ \\ge \\geq 大于等于 $\\lt$ \\lt 小于 $\\le$ \\le \\leq 小于等于 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:5:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#逻辑符与集合论"},{"categories":["LaTeX","Cheatsheet"],"content":"多元运算符 符号 代码 解释 $\\sum$ \\sum 累加 $\\prod$ \\prod 累乘 $\\bigcap$ \\bigcap 累交 $\\bigcup$ \\bigcup 类并 $\\int$ \\int 一重积分 $\\iint$ \\iint 二重积分 $\\iiint$ \\iiint 三重积分 $\\oint$ \\oint 一重环路积分 $\\oiint$ \\oiint 二重环路积分 $\\oiiint$ \\oiiint 三重环路积分 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:6:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#多元运算符"},{"categories":["LaTeX","Cheatsheet"],"content":"二元运算符 符号 代码 解释 $\\bmod$ \\bmod $x \\pmod a$ x \\pmod a $\\div$ \\div $\\pm$ \\pm \\plusmn $\\oplus$ \\oplus $\\otimes$ \\otimes $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:7:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#二元运算符"},{"categories":["LaTeX","Cheatsheet"],"content":"常用数学符号 符号 代码 解释 $\\lim$ \\lim $\\ln$ \\ln $\\log$ \\log $\\exp$ \\exp $\\max$ \\max $\\min$ \\min $\\argmax$ \\argmax $\\argmin$ \\argmin $\\sin$ \\sin $\\cos$ \\cos $\\tan$ \\tan $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:8:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#常用数学符号"},{"categories":["LaTeX","Cheatsheet"],"content":"矩阵","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:9:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#矩阵"},{"categories":["LaTeX","Cheatsheet"],"content":"一行多个公式$$ \\begin{align} x\u0026=t \u0026 x\u0026=\\cos t \u0026 x\u0026=t \\notag y\u0026=2t \u0026 y\u0026=\\sin(t+1) \u0026 y\u0026=\\sin t \\end{align} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#一行多个公式"},{"categories":["LaTeX","Cheatsheet"],"content":"大括号多行公式$$ f(x)=\\begin{cases} 2x+1, \u0026 \\text{if} \u0026 x \\lt 0; \\ 0, \u0026 \\text{if} \u0026 x = 0; \\ x^2-1, \u0026 \\text{if} \u0026 x \\gt 0. \\end{cases} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:11:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#大括号多行公式"},{"categories":["LaTeX","Cheatsheet"],"content":"参考 Supported Functions - KaTeX ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:12:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#参考"},{"categories":["数据结构","算法"],"content":"常用数据结构与算法，包含理论与代码（C++、Java）。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:0:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构","算法"],"content":"1.基础存储结构： 数组：由于是紧凑连续存储，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。 链表：因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1基础"},{"categories":["数据结构","算法"],"content":"2.排序","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#2排序"},{"categories":["数据结构","算法"],"content":"1.选择排序 void selectionSort(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); for (int i = 0; i \u003c n; i++) { int minIdx = i; for (int j = i + 1; j \u003c n; j++) { minIdx = (arr[j] \u003c arr[minIdx]) ? j : minIdx; } int temp = arr[i]; arr[i] = arr[minIdx]; arr[minIdx] = temp; } } void selectionSort(int[] nums) { int len = nums.length; // 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子 for (int i = 0; i \u003c len - 1; i++) { // 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i int minIdx = i; for (int j = i + 1; j \u003c len; j++) { if (nums[j] \u003c nums[minIdx]) { minIdx = j; } } swap(nums, i, minIdx); } return nums; } void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ 特点： 不稳定 每一轮有一个元素（当前最小元素）归位 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1选择排序"},{"categories":["数据结构","算法"],"content":"2.冒泡排序 void bubbleSort(vector\u003cint\u003e\u0026 arr) { for (int step = 1; step \u003c arr.size(); step++) { for (int i = 0; i \u003c arr.size() - step; i++) { if (arr[i] \u003e arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ 特点： 稳定 每一轮有一个元素（当前最大元素）归位 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#2冒泡排序"},{"categories":["数据结构","算法"],"content":"3.插入排序 void insertionSort(vector\u003cint\u003e\u0026 arr) { for (int i = 1; i \u003c arr.size(); i++) { int temp = arr[i], j; for (j = i - 1; j \u003e= 0 \u0026\u0026 arr[j] \u003e arr[i]; j--) { arr[j + 1] = arr[j]; } arr[j + 1] = temp; } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ 特点： 稳定 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#3插入排序"},{"categories":["数据结构","算法"],"content":"归并排序 void mergeSort() { } void merge() { } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#归并排序"},{"categories":["数据结构","算法"],"content":"快速排序基本思想： 从数组中取出一个数，称之为基数（pivot）。 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域。 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。 // 把数组分为两半，返回分割中点 int partition(vector\u003cint\u003e \u0026arr, int low, int high) { // [low, high] int pivotId = low + rand() % (high - low + 1); swap(arr[low], arr[pivotId]); int pivot = arr[low]; while (low \u003c right) { while (low \u003c high \u0026\u0026 arr[high] \u003e pivot) high--; arr[low] = arr[high]; while (low \u003c high \u0026\u0026 arr[low] \u003c= pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low; } void quickSort(vector\u003cint\u003e \u0026arr, int low, int high) { if (low \u003e= high) return; int mid = partition(arr, low, high); quickSort(arr, low, mid - 1); quickSort(arr, mid + 1, high); } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:5","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#快速排序"},{"categories":["数据结构","算法"],"content":"总结 排序算法 时间复杂度 稳定性 冒泡排序 $O(n^2)$ 稳定 选择排序 $O(n^2)$ 不稳定 插入排序 $O(n^2)$ 稳定 快速排序 $O(n \\log n)$ 不稳定 归并排序 $O(n \\log n)$ 稳定 堆排序 $O(n \\log n)$ 不稳定 计数排序 $O(n)$ 稳定 基数排序 $O(n)$ 稳定 名称 数据对象 稳定性 时间复杂度 额外空间复杂度 描述 平均 最坏 冒泡排序 数组 是 $ O(n^2) $ $ O(1) $ (无序区，有序区)从无序区通过交换找出最大元素放到有序区前端。 选择排序 数组 否 $ O(n^2) $ $ O(1) $ (有序区，无序区)在无序区里找一个最小的元素放到有序区后端。对数组：比较多，交换少 链表 是 插入排序 数组、链表 是 $ O(n^2) $ $ O(1) $ (有序区，无序区)把无序区的第一个元素插入到有序区的合适位置。对数组：比较少，交换多 堆排序 数组 否 $ O(n \\log{n}) $ $ O(1) $ (最大堆，有序区)从堆顶把最大值弹出到有序区前端，然后调整堆。 归并排序 数组 是 $ O(n \\log{\\log{n}}) $ $ O(1) $ 将数据分为两段，再从两段中逐个选最小的元素移入新数据段的末尾。可自上而下，也可自下而上 $ O(n \\log{n}) $ 自上而下：$ O(n)+O(\\log{n}) $ 链表 自下而上：$ O(1) $ 快速排序 数组 否 $ O(n \\log{n}) $ $ O(n^2) $ $ O(\\log{n}) $ (小数区，基准元素，大数区)在区间中随机挑选一个元素作为基准元素，将小于该基准的元素放到基准之前，大于的放到基准之后，然后递归地对小数区和大数区进行快速排序。 希尔排序 数组 否 $ O(n \\log{\\log{n}}) $ $ O(n^2) $ $ O(1) $ 按从大到小的间距进行多次插入排序，最后一次的间距为1。 计数排序 数组、链表 是 $ O(n+m) $ $ O(n+m) $ 统计小于等于该元素值的元素的个数i，然后将该元素放在目标数组的第i个位置。 桶排序 数组、链表 是 $ O(n) $ $ O(m) $ 将值为i的元素放入第i号桶，然后依次把桶里的元素倒出来。 基数排序 数组、链表 是 $ O(k \\times","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:6","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#总结"},{"categories":["数据结构","算法"],"content":"快速幂快速求x的n次幂。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#快速幂"},{"categories":["数据结构","算法"],"content":"迭代 double fastPow(double x, int n) { if (x == 0) { return 0; } // 防止 n = -214748328 时，-n 溢出 long nn = n; double ans = 1; if (nn \u003c 0) { // 处理 n \u003c 0 x = 1 / x; nn = -nn; } while (nn \u003e 0) { if ((nn \u0026 1) == 1) { ans *= x; } x *= x; n \u003e\u003e= 1; } return ans; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#迭代"},{"categories":["数据结构","算法"],"content":"递归 double fastPow(double x, int n) { // 防止 n = -214748328 时，-n 溢出 long nn = n; if (nn \u003c 0) { // 处理 n \u003c 0 x = 1 / x; nn = -nn; } return pow(x, nn); } private double pow(double x, long n) { if (n == 0) { return 1; } else if (n == 1) { return x; } else { double half = pow(x, n \u003e\u003e 1); if ((n \u0026 1) == 1) { return half * half * x; } else { return half * half; } } } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#递归"},{"categories":["数据结构","算法"],"content":"栈","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#栈"},{"categories":["数据结构","算法"],"content":"单调栈返回第一个更大元素 vector\u003cint\u003e nextGreaterElement(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cint\u003e ans(n); stack\u003cint\u003e st; for (int i = n - 1; i \u003e= 0; i--) { while (!st.empty() \u0026\u0026 st.top() \u003c= nums[i]) { // 栈顶元素比当前元素小，弹出 st.pop(); } // 栈顶元素即为下一个更大元素 ans[i] = st.empty() ? -1 : st.top(); // 当前元素入栈 st.push(nums[i]); } return ans; } int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] ans = new int[n]; Deque\u003cInteger\u003e stack = new LinkedList\u003c\u003e(); for (int i = n - 1; i \u003e= 0; i--) { while (!stack.isEmpty() \u0026\u0026 stack.peek() \u003c= nums[i]) { stack.pop(); } ans[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(nums[i]); } return ans; } 循环数组 int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] ans = new int[n]; Stack\u003cInteger\u003e st = new Stack\u003c\u003e(); for (int i = 2 * n - 1; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 st.peek() \u003c= nums[i % n]) { st.pop(); } ans[i % n] = st.isEmpty() ? -1 : st.peek(); st.push(nums[i % n]); } return ans; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#单调栈"},{"categories":["数据结构","算法"],"content":"单调栈返回第一个更大元素 vector nextGreaterElement(vector\u0026 nums) { int n = nums.size(); vector ans(n); stack st; for (int i = n - 1; i = 0; i--) { while (!st.empty() \u0026\u0026 st.top() stack = new LinkedList(); for (int i = n - 1; i = 0; i--) { while (!stack.isEmpty() \u0026\u0026 stack.peek() st = new Stack(); for (int i = 2 * n - 1; i = 0; i--) { while (!st.isEmpty() \u0026\u0026 st.peek() ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#返回第一个更大元素"},{"categories":["数据结构","算法"],"content":"单调栈返回第一个更大元素 vector nextGreaterElement(vector\u0026 nums) { int n = nums.size(); vector ans(n); stack st; for (int i = n - 1; i = 0; i--) { while (!st.empty() \u0026\u0026 st.top() stack = new LinkedList(); for (int i = n - 1; i = 0; i--) { while (!stack.isEmpty() \u0026\u0026 stack.peek() st = new Stack(); for (int i = 2 * n - 1; i = 0; i--) { while (!st.isEmpty() \u0026\u0026 st.peek() ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#循环数组"},{"categories":["数据结构","算法"],"content":"1.数组","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1数组"},{"categories":["数据结构","算法"],"content":"打印数组 import java.utils.Arrays; int[] arr1; System.out.println(Arrays.toString()); int[][] arr2; System.out.println(Arrays.deepToString()); ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#打印数组"},{"categories":["数据结构","算法"],"content":"类型转换 // int[] 转 List\u003cInteger\u003e // 不可添加、删除、修改 int[] arr; List\u003cInteger\u003e list = List.of(arr); // int[] 转 Integer[] int[] arr; Integer[] arr2 = IntStream.of(arr).boxed() // Integer[] 转 List\u003cInteger\u003e // 不可添加、删除、修改 Integer[] arr; List\u003cInteger\u003e list = List.of(arr); // List\u003cInteger\u003e 转 Integer[] List\u003cInteger\u003e list; int[] arr2 = list.stream().mapToInt().toArray(Integer::new); ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#类型转换"},{"categories":["数据结构","算法"],"content":"树状数组树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i \u003c n - 1; i++) { add(i, nums[i]); } } public void add(int index, int val) { // 下标从 1 开始 index++; // 单点修改，增加数组 index 元素的值 while (index \u003c n) { tree[index] += val; // 更新父结点 index += lowBit(index); } } public int preSum(int index) { // 查询前缀和 int sum = 0; while (index \u003e 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#树状数组"},{"categories":["数据结构","算法"],"content":"树状数组树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#查询前缀和"},{"categories":["数据结构","算法"],"content":"树状数组树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#复杂度分析"},{"categories":["数据结构","算法"],"content":"线断树线段树是常用的用来维护区间信息的数据结构。 线段树可以在 $O(\\log n)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 class SegmentTree { private int[] tree; // 维护区间 private int[] lazy; // 惰性标记，维护修改值 public SegmentTree(int[] nums) { int n = nums.length; // 线断树有 n 个叶结点，总结点个数设为 x // 非叶结点都有 2 棵子树，则 // x - 1 = (x - n) * 2 // x = 2 * n - 1 // 根结点索引从 1 开始 tree = new int[n * 2]; lazy = new int[n * 2]; build(nums, 0, nums.length - 1, 1); } void build(int[] nums, int left, int right, int root) { // 对 [left, right] 区间建立线段树,当前根的编号为 root if (left == right) { // 叶结点 tree[root] = nums[left]; return; } // + 优先级高于 \u003e\u003e int mid = left + ((right - left) \u003e\u003e 1); build(nums, left, mid, root \u003c\u003c 1); // root * 2 // \u003c\u003c 优先级高于 | build(nums, mid + 1, right, root \u003c\u003c 1 | 1); // root * 2 + 1 // 子树信息更新父结点信息 tree[root] = tree[root \u003c\u003c 1] + tree[root \u003c\u003c 1 | 1]; } int rangeSum(int qLeft, int qRight, int left, int right, int root) { // 查询区间 [qLeft, qRight] 的元素总和 if (qLeft \u003c= left \u0026\u0026 right \u003c= qRight) { // 当前区间是查询区间的子区间 return tree[root]; } pushDown(l","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#线断树"},{"categories":["数据结构","算法"],"content":"2.链表 class ListNode { int val; ListNode next; // 双向链表 ListNode prev; } trick: 双指针（快慢指针） 虚拟头结点 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#2链表"},{"categories":["数据结构","算法"],"content":"21. 合并两个有序链表双指针 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#21-合并两个有序链表"},{"categories":["数据结构","算法"],"content":"23. 合并K个升序链表优先队列 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#23-合并k个升序链表"},{"categories":["数据结构","算法"],"content":"返回链表的倒数第 k 个节点 public static ListNode findFromEnd1(ListNode head, int k) { // 要求 1 \u003c= k \u003c= n ListNode p1 = head, p2 = head; // p1 先走 k 步 for (int i = 0; i \u003c k \u0026\u0026 p1 != null; i++) { p1 = p1.next; } // 然后 p1 和 p2 同步走，走到头 // 即 p2 走了 n - k 步，也就是倒数第 k 个 while (p1 != null) { p1 = p1.next; p2 = p2.next; } return p2; } // 不适用于多测试用例，因为 count 是静态的 // 或者每次调用前将 count 归零 public static count = 0; public static ListNode findFromEnd2(ListNode head, int k) { // 要求 1 \u003c= k \u003c= n if (head == null) { return null; } ListNode node = findFromEnd2(head.next, k); // 从尾部向前计数 count++; if (count == k) { return head; } return node; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#返回链表的倒数第-k-个节点"},{"categories":["数据结构","算法"],"content":"删除链表的倒数第 N 个结点 添加虚表头结点。 返回链表的倒数第 k+1 个节点，删除后继结点。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#删除链表的倒数第-n-个结点"},{"categories":["数据结构","算法"],"content":"单链表的中点快慢指针，慢走一步，快走两步。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:5","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#单链表的中点"},{"categories":["数据结构","算法"],"content":"判断链表是否包含环 boolean hasCycle(ListNode head) { // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; // 快慢指针相遇，说明含有环 if (slow == fast) { return true; } } // 不包含环 return false; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:6","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#判断链表是否包含环"},{"categories":["数据结构","算法"],"content":"如果链表中含有环，如何计算这个环的起点？ ListNode detectCycle(ListNode head) { ListNode fast = head, slow = head; while (fast != null \u0026\u0026 fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { break; } } if (fast == null || fast.next == null) { // 无环 return null; } /* 相遇时，slow 走了 k 步，fast 走了 2k 步 则 k 为环的长度，设相遇点距环起点距离为 m 则表头到环起点距离为 k - m，相遇点向前走到环起点距离为 k - m 则将 slow 放到表头，然后 slow 和 fast 同步走 相遇即为环起点 */ // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:7","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#如果链表中含有环如何计算这个环的起点"},{"categories":["数据结构","算法"],"content":"两个链表是否相交 让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。 ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) { p1 = headB; } else { p1 = p1.next; } // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } 如果把两条链表首尾相连，那么「寻找两条链表的交点」的问题转换成了前面讲的「寻找环起点」的问题。 预先计算两条链表的长度。 public ListNode getIntersectionNode(ListNode headA, ListNode headB) { int lenA = 0, lenB = 0; // 计算两条链表的长度 for (ListNode p1 = headA; p1 != null; p1 = p1.next) { lenA++; } for (ListNode p2 = headB; p2 != null; p2 = p2.next) { lenB++; } // 让 p1 和 p2 到达尾部的距离相同 ListNode p1 = headA, p2 = headB; if (lenA \u003e lenB) { for (int i = 0; i \u003c lenA - lenB; i++) { p1 = p1.next; } } else { for (int i = 0; i \u003c lenB - lenA; i++) { p2 = p2.next; } } // 看两个指针是否会相同，p1 == p2 时有两种情况： // 1、要么是两条链表不相交，他俩同时走到尾部空指针 // 2、要么是两条链表相交，他俩走到两条链表的相交点 while (p1 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:8","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#两个链表是否相交"},{"categories":["数据结构","算法"],"content":"递归反转整个链表 ListNode reverse(ListNode head) { if (head == null || head.next == null) { return head; } // 返回从 head.next 开始的链表的逆序的头结点 // newHead 即为原链表尾结点 ListNode newHead = reverse(head.next); // head.next 原来是待逆序链表的头结点 // 逆序后变为尾结点 // 将 head 作为新的尾结点，实现逆序 head.next.next = head; head.next = null; // 返回逆序后链表的头结点 return newHead; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:9","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#递归反转整个链表"},{"categories":["数据结构","算法"],"content":"递归反转链表前 N 个节点 // 后继结点 ListNode successor = null; ListNode reverseN(ListNode head, int n) { if (n == 1) { successor = head.next; return head; } ListNode newHead = reverseN(head.next, n - 1); head.next.next = head; // 将尾结点连接到后继结点上 head.next = successor; return newHead; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:10","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#递归反转链表前-n-个节点"},{"categories":["数据结构","算法"],"content":"递归反转链表第 M 个节点到第 N 个节点 ListNode reverseBetween(ListNode head, int m, int n) { if (m == 1) { return reverseN(head, n); } head.next = reverseBetween(head.next, m - 1, n - 1); return head; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:11","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#递归反转链表第-m-个节点到第-n-个节点"},{"categories":["数据结构","算法"],"content":"25. K 个一组翻转链表 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:12","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#25-k-个一组翻转链表"},{"categories":["数据结构","算法"],"content":"树 一棵 n 个节点的树，有 n-1 条边。 一棵 n 个节点的树，有 n 棵子树。 根节点：唯一，无入度的节点 节点的深度：节点距离根节点的距离。 typedef struct treeNode { treeNode(int x): value(x) {} int value; vector\u003ctreeNode*\u003e child; } TreeNode; class TreeNode { public int val; public TreeNode[] children; TreeNode() { this.val = 0; } } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:7:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#树"},{"categories":["数据结构","算法"],"content":"二叉树满二叉树：一个高度为 d 的二叉树，有 $2^d-1$ 个节点。即除叶节点外，每个节点都有两个孩子，即节点的出度只为 0 或 2。 完全二叉树：只有最后一层可能未满，且节点严格从左往右排列。即出度为 1 的节点一定只有左孩子；若某节点出度小于 2，则其右边的节点出度为 0。 二叉树第 $i$ 层最多有 $2^{i-1}$ 个节点。 高度为 $d$ 的二叉树最多有 $2^d-1$ 个节点。 class TreeNode(object): def __init__(self, value): self.lchild = None self.rchild = None self.value = 0 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:8:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二叉树"},{"categories":["数据结构","算法"],"content":"遍历前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { i","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:8:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#遍历"},{"categories":["数据结构","算法"],"content":"遍历前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-val preorder(root-left); preorder(root-right); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-val if (root-right) st.push(root-right); if (root-left) st.push(root-left); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-val st.push(root); root = root-left; } else { root = st.top()-right; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-left); // 处理节点值 root-val inorder(root-right); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-left; } else { // 处理节点值 st.top()-val root = st.top()-right; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { i","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:8:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#前序遍历"},{"categories":["数据结构","算法"],"content":"遍历前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-val preorder(root-left); preorder(root-right); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-val if (root-right) st.push(root-right); if (root-left) st.push(root-left); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-val st.push(root); root = root-left; } else { root = st.top()-right; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-left); // 处理节点值 root-val inorder(root-right); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-left; } else { // 处理节点值 st.top()-val root = st.top()-right; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { i","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:8:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#中序遍历"},{"categories":["数据结构","算法"],"content":"遍历前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-val preorder(root-left); preorder(root-right); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-val if (root-right) st.push(root-right); if (root-left) st.push(root-left); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-val st.push(root); root = root-left; } else { root = st.top()-right; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-left); // 处理节点值 root-val inorder(root-right); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-left; } else { // 处理节点值 st.top()-val root = st.top()-right; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { i","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:8:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#后序遍历"},{"categories":["数据结构","算法"],"content":"遍历前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-val preorder(root-left); preorder(root-right); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-val if (root-right) st.push(root-right); if (root-left) st.push(root-left); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-val st.push(root); root = root-left; } else { root = st.top()-right; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-left); // 处理节点值 root-val inorder(root-right); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-left; } else { // 处理节点值 st.top()-val root = st.top()-right; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { i","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:8:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#层序遍历"},{"categories":["数据结构","算法"],"content":"常见问题","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:8:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#常见问题"},{"categories":["数据结构","算法"],"content":"回溯算法 结果集合 def backtrack(当前路径, 可选择列表): if 可选择列表为空: 结果集合添加当前路径 return for 当前选择 in 可选择列表: 当前路径添加当前选择 可选择列表删除当前选择 backtrack(当前路径, 可选择列表) 当前路径撤销当前选择 可选择列表添加当前选择 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:9:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#回溯算法"},{"categories":["数据结构","算法"],"content":"贪心与分治理论","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:10:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#贪心与分治理论"},{"categories":["数据结构","算法"],"content":"贪心算法贪心算法理论严格来说，贪心算法并不是某些有明确指向的算法，而是代指一类算法思想。在有多种决策可选时，我们会选择一个最优的策略，即所谓的贪心算法。 举一个最简单的例子，田忌赛马。在对方出上等马的时候，我方没有任何一匹马能赢这一局，既然注定是输，那么我们希望尽量减少我们的损失。何谓损失？我们每一局都会用掉一匹马，那么对于必输的局，显然用掉最弱的马是最好的。这里就可以归类出两个名词： 局部目标：在贪心问题中，总归有一个局部的目标。例如在上述场景里，我们希望减少这一轮的损失。这就是一个局部目标。和局部目标对应的是全局目标，全局上来说我们当然希望最终能赢得比赛。 策略：在这个局部情景里，我们有多种可用的决策，例如我们可以挑选任意一匹马应战。 实际上，很多问题都可以拆解为若干个局部问题和局部策略。如果这一类问题满足： 局部问题存在最优解。 局部问题最优可以保证全局问题最优。 那么这个问题就可以通过贪心算法解决。 小技巧：局部问题又称为子问题，很多复杂的原始问题都可以拆解成若干个子问题构成，例如一盘围棋就可以拆解为每次双方执子的小问题。在不同的情景下，子问题的性质是不一样的，对应的解决办法也不一样。 例如： 子问题最优则原始问题最优——贪心算法或者动态规划算法。 子问题最优则原始问题最优，且子问题互相独立——分治算法。 子问题最优不能推导出原始问题最优——暴力搜索等。 算法中的贪心思想例一：二叉搜索树找最小值 子问题：最小值一定在根节点，左子树（如果存在），右子树（如果存在）三者之一上，因此原问题可以划分为三个子问题。 我们本来可以在左右子树上均查找一次最小值，但是根据二叉查找树的性质，如果左子树存在，那么最小值只可能存在于左子树上。这就是一个贪心的思想，通过只找一边的子树，我们可以将复杂度从O(n)降低至O(log(h))，其中h为树的高度。 例二：二分查找问题 同样，二分查找也存在贪心的思想。在确定left, mid, right后，根据target和mid的大小关系，我们同样只会继续查找左半边或者右半边，这也是因为另一边不可能有目标值了。 贪心问题解决思路那么对于原始的复杂问题，如何能够知道他是否能被贪心解决呢？ 首先，我们需要将原始问题拆解成子问题，明确子问题的局面以及局面中可进行的操作。实际上不止贪心问题，很多问题都需要这样的拆解过程。 然后我们需要考虑子问题的","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:10:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#贪心算法"},{"categories":["数据结构","算法"],"content":"贪心算法贪心算法理论严格来说，贪心算法并不是某些有明确指向的算法，而是代指一类算法思想。在有多种决策可选时，我们会选择一个最优的策略，即所谓的贪心算法。 举一个最简单的例子，田忌赛马。在对方出上等马的时候，我方没有任何一匹马能赢这一局，既然注定是输，那么我们希望尽量减少我们的损失。何谓损失？我们每一局都会用掉一匹马，那么对于必输的局，显然用掉最弱的马是最好的。这里就可以归类出两个名词： 局部目标：在贪心问题中，总归有一个局部的目标。例如在上述场景里，我们希望减少这一轮的损失。这就是一个局部目标。和局部目标对应的是全局目标，全局上来说我们当然希望最终能赢得比赛。 策略：在这个局部情景里，我们有多种可用的决策，例如我们可以挑选任意一匹马应战。 实际上，很多问题都可以拆解为若干个局部问题和局部策略。如果这一类问题满足： 局部问题存在最优解。 局部问题最优可以保证全局问题最优。 那么这个问题就可以通过贪心算法解决。 小技巧：局部问题又称为子问题，很多复杂的原始问题都可以拆解成若干个子问题构成，例如一盘围棋就可以拆解为每次双方执子的小问题。在不同的情景下，子问题的性质是不一样的，对应的解决办法也不一样。 例如： 子问题最优则原始问题最优——贪心算法或者动态规划算法。 子问题最优则原始问题最优，且子问题互相独立——分治算法。 子问题最优不能推导出原始问题最优——暴力搜索等。 算法中的贪心思想例一：二叉搜索树找最小值 子问题：最小值一定在根节点，左子树（如果存在），右子树（如果存在）三者之一上，因此原问题可以划分为三个子问题。 我们本来可以在左右子树上均查找一次最小值，但是根据二叉查找树的性质，如果左子树存在，那么最小值只可能存在于左子树上。这就是一个贪心的思想，通过只找一边的子树，我们可以将复杂度从O(n)降低至O(log(h))，其中h为树的高度。 例二：二分查找问题 同样，二分查找也存在贪心的思想。在确定left, mid, right后，根据target和mid的大小关系，我们同样只会继续查找左半边或者右半边，这也是因为另一边不可能有目标值了。 贪心问题解决思路那么对于原始的复杂问题，如何能够知道他是否能被贪心解决呢？ 首先，我们需要将原始问题拆解成子问题，明确子问题的局面以及局面中可进行的操作。实际上不止贪心问题，很多问题都需要这样的拆解过程。 然后我们需要考虑子问题的","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:10:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#贪心算法理论"},{"categories":["数据结构","算法"],"content":"贪心算法贪心算法理论严格来说，贪心算法并不是某些有明确指向的算法，而是代指一类算法思想。在有多种决策可选时，我们会选择一个最优的策略，即所谓的贪心算法。 举一个最简单的例子，田忌赛马。在对方出上等马的时候，我方没有任何一匹马能赢这一局，既然注定是输，那么我们希望尽量减少我们的损失。何谓损失？我们每一局都会用掉一匹马，那么对于必输的局，显然用掉最弱的马是最好的。这里就可以归类出两个名词： 局部目标：在贪心问题中，总归有一个局部的目标。例如在上述场景里，我们希望减少这一轮的损失。这就是一个局部目标。和局部目标对应的是全局目标，全局上来说我们当然希望最终能赢得比赛。 策略：在这个局部情景里，我们有多种可用的决策，例如我们可以挑选任意一匹马应战。 实际上，很多问题都可以拆解为若干个局部问题和局部策略。如果这一类问题满足： 局部问题存在最优解。 局部问题最优可以保证全局问题最优。 那么这个问题就可以通过贪心算法解决。 小技巧：局部问题又称为子问题，很多复杂的原始问题都可以拆解成若干个子问题构成，例如一盘围棋就可以拆解为每次双方执子的小问题。在不同的情景下，子问题的性质是不一样的，对应的解决办法也不一样。 例如： 子问题最优则原始问题最优——贪心算法或者动态规划算法。 子问题最优则原始问题最优，且子问题互相独立——分治算法。 子问题最优不能推导出原始问题最优——暴力搜索等。 算法中的贪心思想例一：二叉搜索树找最小值 子问题：最小值一定在根节点，左子树（如果存在），右子树（如果存在）三者之一上，因此原问题可以划分为三个子问题。 我们本来可以在左右子树上均查找一次最小值，但是根据二叉查找树的性质，如果左子树存在，那么最小值只可能存在于左子树上。这就是一个贪心的思想，通过只找一边的子树，我们可以将复杂度从O(n)降低至O(log(h))，其中h为树的高度。 例二：二分查找问题 同样，二分查找也存在贪心的思想。在确定left, mid, right后，根据target和mid的大小关系，我们同样只会继续查找左半边或者右半边，这也是因为另一边不可能有目标值了。 贪心问题解决思路那么对于原始的复杂问题，如何能够知道他是否能被贪心解决呢？ 首先，我们需要将原始问题拆解成子问题，明确子问题的局面以及局面中可进行的操作。实际上不止贪心问题，很多问题都需要这样的拆解过程。 然后我们需要考虑子问题的","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:10:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#算法中的贪心思想"},{"categories":["数据结构","算法"],"content":"贪心算法贪心算法理论严格来说，贪心算法并不是某些有明确指向的算法，而是代指一类算法思想。在有多种决策可选时，我们会选择一个最优的策略，即所谓的贪心算法。 举一个最简单的例子，田忌赛马。在对方出上等马的时候，我方没有任何一匹马能赢这一局，既然注定是输，那么我们希望尽量减少我们的损失。何谓损失？我们每一局都会用掉一匹马，那么对于必输的局，显然用掉最弱的马是最好的。这里就可以归类出两个名词： 局部目标：在贪心问题中，总归有一个局部的目标。例如在上述场景里，我们希望减少这一轮的损失。这就是一个局部目标。和局部目标对应的是全局目标，全局上来说我们当然希望最终能赢得比赛。 策略：在这个局部情景里，我们有多种可用的决策，例如我们可以挑选任意一匹马应战。 实际上，很多问题都可以拆解为若干个局部问题和局部策略。如果这一类问题满足： 局部问题存在最优解。 局部问题最优可以保证全局问题最优。 那么这个问题就可以通过贪心算法解决。 小技巧：局部问题又称为子问题，很多复杂的原始问题都可以拆解成若干个子问题构成，例如一盘围棋就可以拆解为每次双方执子的小问题。在不同的情景下，子问题的性质是不一样的，对应的解决办法也不一样。 例如： 子问题最优则原始问题最优——贪心算法或者动态规划算法。 子问题最优则原始问题最优，且子问题互相独立——分治算法。 子问题最优不能推导出原始问题最优——暴力搜索等。 算法中的贪心思想例一：二叉搜索树找最小值 子问题：最小值一定在根节点，左子树（如果存在），右子树（如果存在）三者之一上，因此原问题可以划分为三个子问题。 我们本来可以在左右子树上均查找一次最小值，但是根据二叉查找树的性质，如果左子树存在，那么最小值只可能存在于左子树上。这就是一个贪心的思想，通过只找一边的子树，我们可以将复杂度从O(n)降低至O(log(h))，其中h为树的高度。 例二：二分查找问题 同样，二分查找也存在贪心的思想。在确定left, mid, right后，根据target和mid的大小关系，我们同样只会继续查找左半边或者右半边，这也是因为另一边不可能有目标值了。 贪心问题解决思路那么对于原始的复杂问题，如何能够知道他是否能被贪心解决呢？ 首先，我们需要将原始问题拆解成子问题，明确子问题的局面以及局面中可进行的操作。实际上不止贪心问题，很多问题都需要这样的拆解过程。 然后我们需要考虑子问题的","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:10:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#贪心问题解决思路"},{"categories":["数据结构","算法"],"content":"分治算法复杂的原始问题可能可以拆分成若干个子问题，如果子问题之间互相独立（一个子问题的计算结果不依赖于其他子问题），那么原始问题可以被分治法解决。 分治法究竟有什么作用呢？ 简化思维逻辑：在很多情况下，原始问题是非常复杂的，例如排序问题。假设原始我们需要考虑对 1000 个数进行排序，那么利用分治思想我们可以分别对左右的 500 个数进行排序，然后考虑合并两个有序数组。当然，排序 500 个数看起来仍然不容易，但是我们可以继续分治下去，最终我们只需要考虑 1~2 个数的排序策略，这就是经典的归并排序的思想。 分布式算法：虽然在算法学习的过程中少有接触多进程和分布式等思想。但是随着 CPU core 越来越多，能够被分治法拆解的问题显然更方便进行并行计算，从而节省总体时间。因此分治思想在工程实现上具有重要的意义。 效率优化：虽然我们不常用并行解决算法问题，但是在某些情况下仍然能够帮助我们节省计算代价，代表就是快速幂算法。课程在这里不作展开，我们会在例题部分进一步详细讨论。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:10:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#分治算法"},{"categories":["数据结构","算法"],"content":"总结对于复杂的原问题： 如果子问题最优则原问题最优，贪心算法。 如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。 如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。 更加复杂的情况，我们总是可以考虑暴力搜索解决。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:10:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#总结-1"},{"categories":["数据结构","算法"],"content":"动态规划定义： 存在「重叠子问题」 具备「最优子结构」 步骤： 确定「初始条件」 确定「状态」 确定「可选择列表」 确定「状态转移方程」 数组优化时间 降维优化空间 思路： 自顶向下 def fib(n): return fib(n - 1) + fib(n - 2) 自底向上 def fib(n): for i in range(n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:11:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#动态规划"},{"categories":["数据结构","算法"],"content":"图论","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#图论"},{"categories":["数据结构","算法"],"content":"定义 // 结点 class Vertex { int id; List\u003cVertex\u003e neighbors; } // 邻接表 无边权 List\u003cInteger\u003e[] adjList1; // 邻接表 有边权 List\u003cint[]\u003e[] adjList2; // 邻接表，查询效率更高 TreeSet\u003cInteger\u003e[] adjSet; // 邻接矩阵 int[][] adjMat; 邻接表 优点：占用的空间少 缺点：无法快速判断两个节点是否相邻 适用于稀疏图 邻接矩阵 优点：占用的空间多 缺点：可以快速判断两个节点是否相邻 适用于稠密图 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#定义"},{"categories":["数据结构","算法"],"content":"遍历DFS boolean[] vis; Deque\u003cInteger\u003e trace; // 记录当前路径 boolean[] onPath; // 判断某顶点是否在当前路径上 List\u003cList\u003cInteger\u003e\u003e traces = new LinkedList\u003c\u003e(); // 记录所有路径 // 邻接表 void dfs(List\u003cInteger\u003e[] graph, int begin, int end) { if (vis[begin]) { return; } // 访问当前顶点 vis[begin] = true; onPath[begin] = true; trace.offerLast(begin); // 到达终点 if (begin == end) { // 防止已添加路径被修改 traces.add(new LinkedList\u003cInteger\u003e(trace)); // 回溯 vis[begin] = false; onPath[begin] = false; trace.pollLast(); return; } // 下个顶点 for (int next : graph[begin]) { if (!vis[next]) { dfs(graph, next, end); } } // 回溯 vis[begin] = false; onPath[begin] = false; trace.pollLast(); } boolean[] vis; Deque\u003cInteger\u003e trace; // 记录当前路径 boolean[] onPath; // 判断某顶点是否在当前路径上 List\u003cList\u003cInteger\u003e\u003e traces = new LinkedList\u003c\u003e(); // 记录所有路径 // 邻接矩阵 void dfs(int[][] graph, int begin) { if (vis[begin]) { return; } // 访问当前顶点 vis[begin] = true; onPath[begin] = true; trace.offerLast(begin); // 到达终点 if (begin == end) { // 防止已添加路径被修改 traces.add(new LinkedList\u003cInteger\u003e(trace)","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#遍历-1"},{"categories":["数据结构","算法"],"content":"遍历DFS boolean[] vis; Deque trace; // 记录当前路径 boolean[] onPath; // 判断某顶点是否在当前路径上 List traces = new LinkedList(); // 记录所有路径 // 邻接表 void dfs(List[] graph, int begin, int end) { if (vis[begin]) { return; } // 访问当前顶点 vis[begin] = true; onPath[begin] = true; trace.offerLast(begin); // 到达终点 if (begin == end) { // 防止已添加路径被修改 traces.add(new LinkedList(trace)); // 回溯 vis[begin] = false; onPath[begin] = false; trace.pollLast(); return; } // 下个顶点 for (int next : graph[begin]) { if (!vis[next]) { dfs(graph, next, end); } } // 回溯 vis[begin] = false; onPath[begin] = false; trace.pollLast(); } boolean[] vis; Deque trace; // 记录当前路径 boolean[] onPath; // 判断某顶点是否在当前路径上 List traces = new LinkedList(); // 记录所有路径 // 邻接矩阵 void dfs(int[][] graph, int begin) { if (vis[begin]) { return; } // 访问当前顶点 vis[begin] = true; onPath[begin] = true; trace.offerLast(begin); // 到达终点 if (begin == end) { // 防止已添加路径被修改 traces.add(new LinkedList(trace)","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#dfs"},{"categories":["数据结构","算法"],"content":"遍历DFS boolean[] vis; Deque trace; // 记录当前路径 boolean[] onPath; // 判断某顶点是否在当前路径上 List traces = new LinkedList(); // 记录所有路径 // 邻接表 void dfs(List[] graph, int begin, int end) { if (vis[begin]) { return; } // 访问当前顶点 vis[begin] = true; onPath[begin] = true; trace.offerLast(begin); // 到达终点 if (begin == end) { // 防止已添加路径被修改 traces.add(new LinkedList(trace)); // 回溯 vis[begin] = false; onPath[begin] = false; trace.pollLast(); return; } // 下个顶点 for (int next : graph[begin]) { if (!vis[next]) { dfs(graph, next, end); } } // 回溯 vis[begin] = false; onPath[begin] = false; trace.pollLast(); } boolean[] vis; Deque trace; // 记录当前路径 boolean[] onPath; // 判断某顶点是否在当前路径上 List traces = new LinkedList(); // 记录所有路径 // 邻接矩阵 void dfs(int[][] graph, int begin) { if (vis[begin]) { return; } // 访问当前顶点 vis[begin] = true; onPath[begin] = true; trace.offerLast(begin); // 到达终点 if (begin == end) { // 防止已添加路径被修改 traces.add(new LinkedList(trace)","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#bfs"},{"categories":["数据结构","算法"],"content":"Flood Fill岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#flood-fill"},{"categories":["数据结构","算法"],"content":"Flood Fill岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i = m || y = n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i = m || y = n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#岛屿数量"},{"categories":["数据结构","算法"],"content":"Flood Fill岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i = m || y = n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i = m || y = n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#封闭岛屿的数量"},{"categories":["数据结构","算法"],"content":"Flood Fill岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i = m || y = n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i = m || y = n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1020-飞地的数量"},{"categories":["数据结构","算法"],"content":"Flood Fill岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i = m || y = n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i = m || y = n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#695-岛屿的最大面积"},{"categories":["数据结构","算法"],"content":"Flood Fill岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i = m || y = n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i = m || y = n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1905-统计子岛屿"},{"categories":["数据结构","算法"],"content":"Flood Fill岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i = m || y = n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i = m || y = n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:12:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#694-不同岛屿的数量"},{"categories":["数据结构","算法"],"content":"字符串","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#字符串"},{"categories":["数据结构","算法"],"content":"1 KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } retu","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1-kmp-算法"},{"categories":["数据结构","算法"],"content":"1 KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#原理"},{"categories":["数据结构","算法"],"content":"1 KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#代码"},{"categories":["数据结构","算法"],"content":"1 KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#参考"},{"categories":["数据结构","算法"],"content":"2 BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar\u003cchar, int\u003e和goodSuffix[]。 代码 HashMap\u003cCharacter, Integer\u003e getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap\u003cCharacter, Integer\u003e badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#2-bm-算法"},{"categories":["数据结构","算法"],"content":"2 BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMapgetBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMapbadChar = new HashMap(); for (int i = 0; i = 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#原理-1"},{"categories":["数据结构","算法"],"content":"2 BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMapgetBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMapbadChar = new HashMap(); for (int i = 0; i = 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#代码-1"},{"categories":["数据结构","算法"],"content":"2 BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMapgetBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMapbadChar = new HashMap(); for (int i = 0; i = 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#参考-1"},{"categories":["数据结构","算法"],"content":"3 Sunday 算法原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap\u003cCharacter, Integer\u003e pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#3-sunday-算法"},{"categories":["数据结构","算法"],"content":"3 Sunday 算法原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMappos = new HashMap(); for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#原理-2"},{"categories":["数据结构","算法"],"content":"3 Sunday 算法原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMappos = new HashMap(); for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#代码-2"},{"categories":["数据结构","算法"],"content":"3 Sunday 算法原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMappos = new HashMap(); for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#参考-2"},{"categories":["数据结构","算法"],"content":"4. Rabin Karp 算法原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i \u003c m; i++) { pHash = (pHash * K + pattern[i]) % MOD; tHash = (tHash * K + text[i]) % MOD; } for (int i = 0; i + m \u003c= n; i++) { if (pHash == tHash) { boolean equal = true; // 二次判断，防止哈希冲突 for (int j = 0; j \u003c m; j++) { if (t","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#4-rabin-karp-算法"},{"categories":["数据结构","算法"],"content":"4. Rabin Karp 算法原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#原理-3"},{"categories":["数据结构","算法"],"content":"4. Rabin Karp 算法原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#代码-3"},{"categories":["数据结构","算法"],"content":"4. Rabin Karp 算法原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:13:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#参考-3"},{"categories":["数据结构","算法"],"content":"并查集 Union Find","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:14:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#并查集-union-find"},{"categories":["数据结构","算法"],"content":"二分查找","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:15:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二分查找"},{"categories":["数据结构","算法"],"content":"闭区间的二分查找 int binarySearch(int[] nums, int target) { // [left, right] int left = 0; int right = nums.length - 1; while(left \u003c= right) { // 防止整数溢出 int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { // 右侧 left = mid + 1; } else { // 左侧 right = mid - 1; } } return -1; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:15:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#闭区间的二分查找"},{"categories":["数据结构","算法"],"content":"左闭右开区间的二分查找 int binarySearch(int[] nums, int target) { // [left, right) int left = 0; int right = nums.length; while(left \u003c right) { // 防止整数溢出 int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { // 右侧 left = mid + 1; } else { // 左侧 right = mid; } } return -1; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:15:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#左闭右开区间的二分查找"},{"categories":["数据结构","算法"],"content":"左侧边界的二分查找 lower_bound // 左侧边界 // 寻找第一个大于等于 target 的元素位置 int binarySearch(int[] nums, int target) { // [left, right) int left = 0; int right = nums.length; while(left \u003c right) { // 防止整数溢出 int mid = left + (right - left) / 2; if (nums[mid] \u003e= target) { // 左侧、中间 right = mid; } else { // 右侧 left = mid + 1; } } return left; // left 范围为 [0, nums.length] // 当 left == nums.length // 或者 nums[left] != target // 说明 nums 中无 target } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:15:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#左侧边界的二分查找-lower_bound"},{"categories":["数据结构","算法"],"content":"右侧边界的二分查找 upper_bound // 右侧边界 // 寻找第一个大于 target 的元素位置 int binarySearch(int[] nums, int target) { // [left, right) int left = 0; int right = nums.length; while(left \u003c right) { // 防止整数溢出 int mid = left + (right - left) / 2; if (nums[mid] \u003e target) { // 左侧 right = mid; } else { // 中间、右侧 left = mid + 1; } } return left; // left 范围为 [0, nums.length] // 当 left == 0 // 或者 nums[left - 1] != target // 说明 nums 中无 target } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:15:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#右侧边界的二分查找-upper_bound"},{"categories":["数据结构","算法"],"content":"滑动窗口","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:16:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#滑动窗口"},{"categories":["数据结构","算法"],"content":"窗口大小可任意调整 // 窗口大小可任意调整 int left = 0; int right = 0; int ans = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 while (condition) { // 约束值满足调整窗口的条件 // 缩小窗口 // 左端点 left 操作 // 修改约束值 left++; } ans = Math.max(ans, right - left + 1); right++; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:16:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#窗口大小可任意调整"},{"categories":["数据结构","算法"],"content":"窗口大小单调递增 // 窗口大小单调递增 int left = 0; int right = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 if (condition) { // 约束值满足调整窗口的条件 // 此时左端点移动最多使窗口大小不变 // 左端点 left 操作 // 修改约束值 left++; } right++; } int ans = right - left; ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:16:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#窗口大小单调递增"},{"categories":["数据结构","算法"],"content":"排列\u0026组合\u0026子集问题","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:17:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#排列组合子集问题"},{"categories":["数据结构","算法"],"content":"无重复元素\u0026元素不可重复选择子集 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param nums 元素唯一的数组 * @return 所有子集的集合 */ List\u003cList\u003cInteger\u003e\u003e subsets(int[] nums) { dfs(nums, 0); return ans; } /** * @param nums 元素唯一的数组 * @param start 可选择元素范围[start, nums.length) */ void dfs(int[] nums, int start) { // 前序添加 ans.add(new LinkedList\u003c\u003e(set)); for (int i = start; i \u003c nums.length; i++) { set.add(nums[index]); dfs(nums, i + 1); // 回溯 set.pollLast(); } } 组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param n 元素范围[1, n] * @param k 组合中元素个数 * @return 所有长度为 k 的组合的集合 */ List\u003cList\u003cInteger\u003e\u003e combine(int n, int k) { dfs(n, k, 0); return ans; } /** * @param n 元素范围[1, n] * @param k 组合中元素个数 * @param start 可选择元素范围[start, n] */ void dfs(int n, int k, int start) { if (set.size() == k) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = start; i \u003c= n; i++) { set.add(i); dfs(n, k, i + 1); // 回溯 set.pollLast(); } } 排列 List","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:17:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#无重复元素元素不可重复选择"},{"categories":["数据结构","算法"],"content":"无重复元素\u0026元素可以重复选择组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param candidates 无重复元素的数组 * @param target 目标和 * @return 所有和为 target 的组合的集合（元素可重复） */ List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, 0, 0); return ans; } /** * @param candidates 有序数组 * @param target 目标和 * @param start 可选择元素范围[start, candidates.length) * @param sum 当前元素和 */ void dfs(int[] candidates, int target, int start, int sum) { if (sum == target) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = start; i \u003c candidates.length; i++) { // 剪枝 if (sum + candidates[i] \u003c= target) { set.add(candidates[i]); // 可选范围不变 dfs(candidates, target, i, sum + candidates[i]); set.pollLast(); } } } 排列 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param nums 无重复元素的数组 * @return 所有排列的集合（可重复选择元素） */ List\u003cList\u003cInteger\u003e\u003e permuteDup(int[] nums) { dfs(nums); return ans; } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:17:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#无重复元素元素可以重复选择"},{"categories":["数据结构","算法"],"content":"有重复元素\u0026元素不可重复选择子集 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param nums 可能存在重复元素的数组 * @return 所有非重复子集的集合 */ List\u003cList\u003cInteger\u003e\u003e subsetsWithDup(int[] nums) { Arrays.sort(nums); dfs(nums, 0); return ans; } /** * @param nums 有序数组 * @param start 可选择元素范围[start, nums.length) */ void dfs(int[] nums, int start) { ans.add(new LinkedList\u003c\u003e(set)); for (int i = start; i \u003c nums.length; i++) { // 剪枝：相同元素已经选过就不再重复选择 if (i \u003e start \u0026\u0026 nums[i - 1] == nums[i]) { continue; } set.add(nums[i]); dfs(nums, i + 1); // 回溯 set.pollLast(); } } 组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param candidates 可能存在重复元素的正数数组 * @param target 目标和 * @return 所有和为 target 的组合的集合 */ List\u003cList\u003cInteger\u003e\u003e combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, 0, 0); return ans; } /** * @param candidates 有序数组 * @param target 目标和 * @param start 可选择元素范围[start, candidates.length) * @p","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:17:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#有重复元素元素不可重复选择"},{"categories":["数据结构","算法"],"content":"缓存数据结构","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:18:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#缓存数据结构"},{"categories":["数据结构","算法"],"content":"LRU (Least Recently Used)最近最少使用算法。当容量满时，将最久没有使用过的缓存删除。 class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class BiLinkedList { final Node head, tail; final int capacity; int length; public BiLinkedList(int capacity) { this.capacity = capacity; length = 0; head = new Node(0, 0); tail = new Node(0, 0); head.next = tail; tail.prev = head; } /** * 将结点加入双向链表的尾部 * * @param node 待加入结点 */ public void addLast(Node node) { node.prev = tail.prev; node.next = tail; node.prev.next = node; tail.prev = node; length++; } /** * 将 node 从双向链表中删除 * * @param node 待加入结点 */ public void remove(Node node) { node.prev.next = node.next; node.next.prev = node.prev; length--; } /** * 将双向链表的第一个结点删除 */ public void removeFirst() { if (length == 0) { return; } head.next = head.next.next; head.next.prev = head; length--; } } class LRUCache { private BiLinkedList list; private HashMap\u003cInteger, Node\u003e keyToNode; public LRUCache(int capacity) { list = new BiLinke","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:18:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#lru-least-recently-used"},{"categories":["数据结构","算法"],"content":"LFU (Least Frequently Used) class Node { int key, value; Node prev, next; public Node (int key, int value) { this.key = key; this.value = value; } } class BiLinkedList { final Node head, tail; int length; public BiLinkedList() { this.head = new Node(0, 0); this.tail = new Node(0, 0); this.length = 0; head.next = tail; tail.prev = head; } public void addLast(Node node) { node.prev = tail.prev; node.next = tail; tail.prev.next = node; tail.prev = node; length++; } public void remove(Node node) { if (node.prev == null || node.next == null) { return; } node.prev.next = node.next; node.next.prev = node.prev; length--; } public void removeFirst() { if (length == 0) { return; } head.next.next.prev = head; head.next = head.next.next; length--; } } class LFUCache { HashMap\u003cInteger, Node\u003e keyToNode; HashMap\u003cInteger, Integer\u003e keyToFreq; HashMap\u003cInteger, BiLinkedList\u003e freqToNodes; final int capacity; int length; int minFreq; public LFUCache(int capacity) { this.keyToNode = new HashMap\u003c\u003e(); this.ke","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:18:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#lfu-least-frequently-used"},{"categories":["数据结构","算法"],"content":"动态规划（DP）Dynamic Programming ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:19:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#动态规划dp"},{"categories":["数据结构","算法"],"content":"最长递增子序列（LIS）Longest Increasing Subsequence 动态规划 int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; int ans = 1; for (int i = 0; i \u003c n; i++) { dp[i] = 1; for (int j = 0; j \u003c i; j++) { if (nums[i] \u003e nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); ans = Math.max(ans, dp[i]); } } } return ans; } $O(n^2)$ 贪心 + 二分查找 /** * list 中每个链表都是降序排列，只能将更小的值加入末尾 * 若均无法添加，则作为一个新链表加入 list * 二分查找找到能够添加的下标最小的链表，然后加入 * 最后保证了每个链表的尾结点单调递增 * list 的大小即为最长子序列的长度 */ int lengthOfLIS(int[] nums) { int[] top = new int[nums.length]; int size = 0; for (int num : nums) { int left = 0; int right = size; while (left \u003c right) { int mid = left + (right - left) / 2; if (top[mid] \u003c num) { left = mid + 1; } else { right = mid; } } top[size] = num; if (left == size) { size++; } } return size; } 二分查找 /** * 数组 d[i]，表示长度为 i 的最长上升子序列的末尾元素的最小值 * 用 len 记录目前最长上升子序列的长度 */ int lengthOfLIS(int[] nums) { int[] dis = new int[nums.length]; int len = 0; for (int num : nums) { int left = 0; int right = len; while (left \u003c","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:19:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#最长递增子序列lis"},{"categories":null,"content":"谷歌三件套包括 Google Play 商店（Google Play Store）、Google Play 服务（Google Play Services）和Google 服务框架（Google Services Framework），只有正确安装了这三件套才能访问 Google Play 商店和使用需要 Google Play 服务的 APP。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#"},{"categories":null,"content":"安装","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#安装"},{"categories":null,"content":"一键安装","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#一键安装"},{"categories":null,"content":"手动安装 访问 APKMirror。 搜索Google Services Framework，根据安卓版本选择对应的版本下载并安装。（示例：Google Services Framework 10） 搜索Google Play Services，选择最新版并进入，选择arm64-v8a + armeabi-v7a、对应的安卓版本、nodpi，下载并安装。 搜索Google Play Store，选择最新版下载并安装。 若三件套都安装完，并且正确科学上网后还是打不开Google Play 商店，尝试下载旧版本Google Play Services安装。 不推荐使用beta版本。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#手动安装"},{"categories":null,"content":"Google Play Services 版本号版本号示例：20.50.66 (100400-351698872)，其中100400说明： 第 1、2 位表示安卓版本 00 - Android 4.1 02 - Android 5.0 04 - Android 6.0 05 - Wear OS 08 - Android TV 10 - Android 9.0 12 - Android 10 15 - Android 11 第 3、4 位表示CPU架构 03 - armeabi-v7a 04 - armeabi-v7a + arm64-v8a 07 - x86 08 - x86 + x86_64 第 5、6 位表示屏幕 DPI 00 - nodpi 02 - 160dpi 04 - 240dpi 06 - 320dpi 08 - 480dpi 则100400指Android 9.0、arm64-v8a和nodpi。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#google-play-services-版本号"},{"categories":["Java","教程"],"content":"Java 是全球使用最广泛的编程语言。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#"},{"categories":["Java","教程"],"content":"0 名词解释 JVM：Java Virtual Machine，Java 虚拟机。 JRE：Java Runtime Environment，Java 运行环境，包含 JVM 和 Java 核心类库。 JDK：Java Development Kit，Java 开发工具包，包含 JRE，编译工具和运行工具。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#0-名词解释"},{"categories":["Java","教程"],"content":"1 准备","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#1-准备"},{"categories":["Java","教程"],"content":"1.1 JDK 下载 Oracle JDK Oracle OpenJDK Windows 可通过 Chocolatey 安装。 MacOS 可通过 Homebrew 安装。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#11-jdk-下载"},{"categories":["Java","教程"],"content":"1.2 环境变量配置Windows： 设置→系统→关于→高级系统设置→环境变量。 在下方的系统变量中找到Path，点击编辑。 点击新建，将JDK的路径下的bin目录粘贴进去。（示例：C:\\Users\\backs\\Downloads\\jdk-11.0.10\\bin\\） 连续点击确定，保存退出。 打开cmd，输入java -version，若有如下所示输出即为配置成功。 java version \"11.0.10\" 2021-01-19 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.10+8-LTS-162) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.10+8-LTS-162, mixed mode) 在任意位置创建 test.java，写入以下内容。 public class test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 在该文件夹下打开命令行，输入以下内容，输出应该为 Hello World!。 javac test.java java test ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#12-环境变量配置"},{"categories":["Java","教程"],"content":"1.3 IDE Download IntelliJ IDEA: 最好用，Community版免费，Ultimate版收费，学生可白嫖，推荐。 psvm public static void main(String[] args) {} sout System.out.println(); arr.fori for (int i = 0; i \u003c arr.length; i++) {} arr.forr for (int i = arr.length - 1; i \u003e= 0; i--) {} alt + 1 开/关左侧目录结构 alt + 4 开/关底部控制台 ctrl + alt + L 格式化代码 ctrl + / 单行注释 ctrl + shift + / 多行注释 shift + alt + ↑ 上移 shift + alt + ↓ 下移 ctrl + x 剪切当前行 ctrl + d 下方复制当前行 shift + enter 下方新建空行 ctrl + alt + enter 上方新建空行 ctrl + alt + v 自动定义变量来接收当前值 ctrl + alt + m 将选中代码生成独立方法 Eclipse: 开源，免费。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#13-ide-download"},{"categories":["Java","教程"],"content":"2 基础语法","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2-基础语法"},{"categories":["Java","教程"],"content":"2.1 注释 // 单行注释 /* 多行注释 */ /** 文档注释 */ ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#21-注释"},{"categories":["Java","教程"],"content":"2.2 常量 字符串常量：\"helloworld\"，\"程序员\" 整数常量：12，-3 浮点数常量：1.2，-3.4 字符常量：'a'，'\\n'，'我' 布尔常量：true，false 空常量：null ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#22-常量"},{"categories":["Java","教程"],"content":"2.3 数据类型 数据类型 关键字 内存占用（字节） 取值范围 整数 byte 1 -128~127 short 2 -32,768~32,767 int 4 -2,147,483,648~2,147,483,647 long 8 $$-2^{63} \\sim 2^{63} - 1$$ 浮点数 float 4 小数点后6位 double 8 小数点后15位 字符 char 2 0~65,535 布尔 boolean 1 true,false ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#23-数据类型"},{"categories":["Java","教程"],"content":"2.4 变量定义和使用 float a = 3.14F; // float b = 3.14f; long c = 100L; // long d = 100l; ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#24-变量定义和使用"},{"categories":["Java","教程"],"content":"2.5 读取输入 import java.util.Scanner; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); String s1 = sc.nextLine(); // 遇到换行结束，接收换行符，并丢弃。 String s2 = sc.next(); // 遇到空格或换行结束，不接收。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:5","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#25-读取输入"},{"categories":["Java","教程"],"content":"2.6 标识符定义必须： 由数字、字母、下划线、美元符号组成 不能以数字开头 不能是关键字 区分大小写 建议： 小驼峰命名法：backTraxe，常用于定义方法、变量。 大驼峰命名法：BackTraxe，常用于定义类。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:6","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#26-标识符定义"},{"categories":["Java","教程"],"content":"2.7 类型转换 隐式转换 占用空间小的数据类型会先转换为占用空间大的数据类型，然后进行运算。 byte、short和char三种数据类型在运算时会转换为int，然后进行运算。 byte a = 1, b = 2; // 错误 byte c = a + b; // 正确 int d = a + b; 显式（强制）转换 有可能产生精度损失。 byte a = 1, b = 2; byte e = (byte) (a + b); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:7","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#27-类型转换"},{"categories":["Java","教程"],"content":"2.8 运算符 单目算术运算符：自增++、自减-- 只能作用于变量。 int a = 1; int b = a++; // a = 2, b = 1 int c = ++a; // a = 3, c = 3 int d = a--; // a = 2, d = 3 int e = --a; // a = 1, e = 1 双目算术运算符：加+、减-、乘*、除/、取余% 加+：出现字符串则为连接运算符，否则为算术运算。从左到右执行。 System.out.println(1 + 2); // 3 System.out.println(2 + 1); // 3 System.out.println(1 + 'a'); // 98 System.out.println('a' + 2); // 99 System.out.println(1 + \"abc\"); // 1abc System.out.println(\"abc\" + 2); // abc2 System.out.println(true + \"abc\"); // trueabc System.out.println(\"abc\" + true); // abctrue System.out.println(\"abc\" + 1 + 2); // abc12 System.out.println(1 + 2 + \"abc\"); // 3abc System.out.println(1 + \"\" + 2 + \"abc\"); // 12abc 除/：整数除整数得整数。 System.out.println(10 / 3); // 3 System.out.println(10 / 3.0); // 3.3333333333333335 System.out.println(10.0 / 3); // 3.3333333333333335 赋值运算符：赋值=、加后赋值+=、减后赋值-=、乘后赋值*=、除后赋值/=、取余后赋值%= a 操作符= b等价于a = (a的类型) (a 操作符 (b))，隐含了强制类型转换，从右往左运算。 int a = 10; a /= 2 + 3; // 2 等价于 a = a / (2 + 3) short b = 1; b = b + 1; // 报错 b += 1; // 2 等价于 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:8","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#28-运算符"},{"categories":["Java","教程"],"content":"2.9 分支语句 if (A) { B; } if (A) { B; } else { C; } if (A) { B; } else if (C) { D; } else { E; } // case 表达式不能重复，且不能为变量。 String rank = \"First\"; switch (rank) { case \"First\": System.out.println(\"第一\"); break; case \"Second\": case \"Third\": System.out.println(\"前三\"); break; default: System.out.println(\"再接再厉\"); break; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:9","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#29-分支语句"},{"categories":["Java","教程"],"content":"2.10 循环语句 for (初始化语句; 继续循环条件判断语句; 每轮循环后执行语句) { 循环体; } while (继续循环条件判断语句) { 循环体; } // 至少执行一次 do { 循环体; } while (继续循环条件判断语句); 跳转控制语句 continue：中断本次循环，直接开始下一次循环。 break：退出循环。 // 中断多重循环 outer: for (int i = 0; i \u003c 10; i++) { for (int j = 0; j \u003c 10; j++) { if (i == 5 \u0026\u0026 j == 7) { System.out.println(i + \"\\n\" + j); break outer; } } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:10","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#210-循环语句"},{"categories":["Java","教程"],"content":"2.11 格式化输出 System.out.print(); System.out.printf(); System.out.println(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:11","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#211-格式化输出"},{"categories":["Java","教程"],"content":"2.12 随机数生成 import java.util.Random; Random r = new Random(); int a = r.nextInt(10); // [0, 10) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:12","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#212-随机数生成"},{"categories":["Java","教程"],"content":"2.13 数组 // 动态初始化。不指定元素，指定长度。默认初始化为 0 int[] arr1 = new int[3]; int[][] arr2 = new int[2][3]; // 静态初始化。指定元素，不指定长度。 int[] arr3 = new int[]{1, 2, 3}; int[][] arr4 = new int[][]{{1, 2}, {3, 4}}; int[] arr5 = {1, 2, 3}; int[][] arr6 = {{1, 2}, {3, 4}}; // 长度 arr1.length; // 3 arr2[0].length; // 3 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:13","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#213-数组"},{"categories":["Java","教程"],"content":"2.14 方法 方法不能嵌套定义 方法重载（overload）：方法名相同，参数数量或者类型不同。与返回值类型无关。 // 返回匿名数组 return new int[]{1, 2}; ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:14","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#214-方法"},{"categories":["Java","教程"],"content":"2.15 进制 二进制：以0b, 0B开头 八进制：以0开头 十六进制：以0x, 0X开头 System.out.println(10); // 10 System.out.println(0b10); // 2 System.out.println(010); // 8 System.out.println(0x10); // 16 // 10 进制转 x 进制 public static String ten2x(int num, int x) { StringBuilder str = new StringBuilder(); while (0 != num) { str.append((char) (num % x + '0')); num /= x; } str.reverse(); return str.toString(); } // x 进制转 10 进制 public static int x2ten(String str, int x) { int res = 0; for (int i = 0; i \u003c str.length(); i++) { res = res * x + str.charAt(i) - '0'; } return res; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:15","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#215-进制"},{"categories":["Java","教程"],"content":"2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String t","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#216-字符串"},{"categories":["Java","教程"],"content":"2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2161-字符串构造"},{"categories":["Java","教程"],"content":"2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2162-字符串比较"},{"categories":["Java","教程"],"content":"2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2163-字符串遍历"},{"categories":["Java","教程"],"content":"2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2164-子串"},{"categories":["Java","教程"],"content":"2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2165-其他操作"},{"categories":["Java","教程"],"content":"2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2166-字符串常量池"},{"categories":["Java","教程"],"content":"2.17 可变字符串2.17.1 StringBuilder插入 StringBuilder append(X x) StringBuilder insert(int offset, X x) 修改 void setCharAt(int index, char ch) StringBuilder replace(int start, int end, String str) StringBuilder delete(int start, int end) StringBuilder deleteCharAt(int index) StringBuilder reverse() 索引查找 char charAt(int index) 值查找 int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 比较 int compareTo(StringBuilder another) 子串 CharSequence subSequence(int start, int end) String substring(int start) String substring(int start, int end) 转换 StringBuilder(String str) String toString() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:17","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#217-可变字符串"},{"categories":["Java","教程"],"content":"2.17 可变字符串2.17.1 StringBuilder插入 StringBuilder append(X x) StringBuilder insert(int offset, X x) 修改 void setCharAt(int index, char ch) StringBuilder replace(int start, int end, String str) StringBuilder delete(int start, int end) StringBuilder deleteCharAt(int index) StringBuilder reverse() 索引查找 char charAt(int index) 值查找 int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 比较 int compareTo(StringBuilder another) 子串 CharSequence subSequence(int start, int end) String substring(int start) String substring(int start, int end) 转换 StringBuilder(String str) String toString() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:17","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2171-stringbuilder"},{"categories":["Java","教程"],"content":"2.18 复杂度分析程序耗时 long start = System.currentTimeMillis(); // 执行代码 long end = System.currentTimeMillis(); System.out.println(end - start); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:18","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#218-复杂度分析"},{"categories":["Java","教程"],"content":"2.19 static静态修饰符，可修饰变量和方法。 - 静态变量 1. 被所有实例化的对象共享。 2. 随类的加载而加载。 3. 不需要创建对象即可调用（使用类名）。 - 静态方法 1. 只能访问静态变量或静态方法。 2. 不能使用this。 3. 不需要创建对象即可调用（使用类名）。 public class Student { public static int age = 18; public static int getAge() { return age; } } Student.age; // 18 Student.getAge(); // 18 Student stu1 = new Student(); stu1.age; // 18 stu1.age = 20; Student stu2 = new Student(); stu2.age; // 20 Student.age; // 20 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:19","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#219-static"},{"categories":["Java","教程"],"content":"3 面向对象编程面向对象编程（Object Oriented Programming，OOP），是一种程序设计思想，把类作为程序的基本单元，一个类包含了变量和方法。 可以提高代码的维护性、可读性、复用性。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#3-面向对象编程"},{"categories":["Java","教程"],"content":"3.1 为什么要面向对象3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#31-为什么要面向对象"},{"categories":["Java","教程"],"content":"3.1 为什么要面向对象3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#311-分类思想"},{"categories":["Java","教程"],"content":"3.1 为什么要面向对象3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#312-分包思想"},{"categories":["Java","教程"],"content":"怎样面向对象","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#怎样面向对象"},{"categories":["Java","教程"],"content":"3.1 类3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#31-类"},{"categories":["Java","教程"],"content":"3.1 类3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#311-构造方法"},{"categories":["Java","教程"],"content":"3.2 封装隐藏实现细节，仅对外暴露公共的访问方式。可以提高代码的安全性和复用性。 针对private修饰的成员变量，如果需要被其他类使用，需要提供getXxx()和setXxx()方法。Idea 可自动生成。 public class Student { private String name; // 类外无法访问 public String getName() { return name; } public void setName(String name) { this.name = name; } public static void main(String[] args) { Student stu = new Student(); stu.setName(\"张三\"); System.out.println(stu.getName()); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:4","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#32-封装"},{"categories":["Java","教程"],"content":"3.3 继承","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#33-继承"},{"categories":["Java","教程"],"content":"3.4 多态","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:6","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#34-多态"},{"categories":["Java","教程"],"content":"4 集合可变容量的容器。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#4-集合"},{"categories":["Java","教程"],"content":"4.1 ArrayList 可变数组。 不能使用基本数据类型。 打印则直接遍历打印数组值，而不是打印地址。 构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) // 不指定类型，可添加任意类型 ArrayList l1 = new ArrayList(); // 指定类型 ArrayList\u003cInteger\u003e l2 = new ArrayList\u003c\u003e(); 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 4.1.1 遍历 // IDEA 快捷键：list.fori for (int i = 0; i \u003c list.size(); i++) { list.get(i); } // IDEA 快捷键：list.forr for (int i = list.size() - 1; i \u003e= 0; i--) { list.get(i); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#41-arraylist"},{"categories":["Java","教程"],"content":"4.1 ArrayList 可变数组。 不能使用基本数据类型。 打印则直接遍历打印数组值，而不是打印地址。 构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collectionc) // 不指定类型，可添加任意类型 ArrayList l1 = new ArrayList(); // 指定类型 ArrayList l2 = new ArrayList(); 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collectionc) boolean addAll(Collectionc) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection c) void clear() for (int i = 0; i = 0; i--) { list.get(i); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#411-遍历"},{"categories":["Java","教程"],"content":"垃圾回收垃圾回收，顾名思义就是释放垃圾占用的空间，从而提升程序性能，防止内存泄露。当一个对象不再被需要时，该对象就需要被回收并释放空间。 Java 内存运行时数据区域包括程序计数器、虚拟机栈、本地方法栈、堆等区域。其中，程序计数器、虚拟机栈和本地方法栈都是线程私有的，当线程结束时，这些区域的生命周期也结束了，因此不需要过多考虑回收的问题。而堆是虚拟机管理的内存中最大的一块，堆中的内存的分配和回收是动态的，垃圾回收主要关注的是堆空间。 调用垃圾回收器的方法 调用垃圾回收器的方法是gc，该方法在System类和Runtime类中都存在。在Runtime类中，方法gc是实例方法，方法System.gc是调用该方法的一种传统而便捷的方法。在System类中，方法gc是静态方法，该方法会调用Runtime类中的gc方法。其实，java.lang.System.gc等价于java.lang.Runtime.getRuntime.gc的简写，都是调用垃圾回收器。方法gc的作用是提示Java虚拟机进行垃圾回收，该方法由系统自动调用，不需要人为调用。该方法被调用之后，由Java虚拟机决定是立即回收还是延迟回收。 finalize 方法 与垃圾回收有关的另一个方法是finalize方法。该方法在Object类中被定义，在释放对象占用的内存之前会调用该方法。该方法的默认实现不做任何事，如果必要，子类应该重写该方法，一般建议在该方法中释放对象持有的资源。 判断对象是否可回收 垃圾回收器在对堆进行回收之前，首先需要确定哪些对象是可回收的。常用的算法有两种，引用计数算法和根搜索算法。 1.引用计数算法 引用计数算法给每个对象添加引用计数器，用于记录对象被引用的计数，引用计数为 0 的对象即为可回收的对象。 虽然引用计数算法的实现简单，判定效率也很高，但是引用计数算法无法解决对象之间循环引用的情况。如果多个对象之间存在循环引用，则这些对象的引用计数永远不为 0，无法被回收。因此 Java 语言没有使用引用计数算法。 2.根搜索算法 主流的商用程序语言都是使用根搜索算法判断对象是否可回收。根搜索算法的思路是，从若干被称为 GC Roots 的对象开始进行搜索，不能到达的对象即为可回收的对象。 在 Java 中，GC Roots 一般包含下面几种对象： 虚拟机栈中引用的对象 本地方法栈中的本地方法引","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Java","教程"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#垃圾回收"},{"categories":["Python","教程"],"content":"Python 是现在最受欢迎的语言。 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#"},{"categories":["Python","教程"],"content":"运算符 # 位运算 # 按位与 \u0026 a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a \u0026 b # 00 00 00 01 : 1 # 按位或 | a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a | b # 00 00 01 11 : 7 # 按位取反 ~ a = 3 # 00 00 00 11 ~a # 11 11 11 00 # 按位异或 ^ （相同为0，不同为1） a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a ^ b # 00 00 01 10 : 6 # 任何值与自身异或为0 a ^ a # 00 00 00 00 : 0 # 任何值与0异或不变 a ^ 0 # 00 00 00 11 : 3 # 按位左移 \u003c\u003c # 三元运算符 smaller = x if x \u003c y else y # 其他运算符 'A' in ['A', 'B', 'C'] 'D' not in ['A', 'B', 'C'] \"hello\" is \"hello\" \"Hello\" is not \"hello\" # is 对比的是两个变量的内存地址 # == 对比的是两个变量的值 # 地址不可变的类型（str 等），那么 is 和 == 完全等价 # 地址可变的类型（list，dict，tuple 等），两者不等价 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#运算符"},{"categories":["Python","教程"],"content":"异常处理 # 异常处理 try: a = 1 / 0 except ZeroDivisionError: print('除数不能为0') # 指定精度 from decimal import Decimal decimal.getcontext().prec = 4 c = Decimal(1) / Decimal(3) # 0.3333 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#异常处理"},{"categories":["Python","教程"],"content":"内置函数 # 获取类型信息 isinstance(1, int) # type() 不会认为子类是一种父类类型，不考虑继承关系 # isinstance() 会认为子类是一种父类类型，考虑继承关系 # 类型转换 int('520') # 520 float('520.52') # 520.52 str(520) # '520' # print # print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) # sep 分隔符 # end 结束符 # file 输出的文件 # flush 立即输出，不作缓存 abs(x) # 返回绝对值。若参数为复数，则返回复数的模。 divmod(a, b) # 返回 tuple(a // b, a % b) input(words) # 打印 words，读取用户输入，返回 str 类型 ord(c) # 返回字符对应的 ASCII 数值，或者 Unicode 数值 chr(i) # 返回整数（0～255，10进制或16进制）对应的 ASCII 字符。 bin(i) # 返回一个整数（int 或 long int）的二进制表示，str 类型。 any() # 是否存在大于0 all() # 是否全大于0 complex(real=0, image=0) # 复数 7.bit_length() # 3 0.25.as_integer_ratio() # (1, 4) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#内置函数"},{"categories":["Python","教程"],"content":"数据结构","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#数据结构"},{"categories":["Python","教程"],"content":"列表 a = [1] a.append(2) # [1, 2] a.pop() # 2 a.index(1) # 0 找不到报错 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#列表"},{"categories":["Python","教程"],"content":"复数 c = 12 + 3j print(c.real) # 12.0 print(c.imag) # 3.0 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#复数"},{"categories":["Python","教程"],"content":"字符串 pluto_mass = 1.303 * 10**22 earth_mass = 5.9722 * 10**24 population = 52910390 # {:.2} 2位有效数字 # {:.3%} 3位有效数字，百分数形式表示 # {:,} 数字每隔3位用逗号隔开 \"{}weighs about {:.2}kilograms ({:.3%}of Earth's mass). It is home to {:,}Plutonians.\".format( planet, pluto_mass, pluto_mass / earth_mass, population ) # Pluto weighs about 1.3e+22 kilograms (0.218% of Earth's mass). It is home to 52,910,390 Plutonians. # 根据位置使用变量 s = \"\"\"Pluto's a {0}. No, it's a {1}. {0}! {1}!\"\"\".format('planet', 'dwarf planet') # Pluto's a planet. # No, it's a dwarf planet. # planet! # dwarf planet! '123'.isdigit() # True 参考： PyFormat ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#字符串"},{"categories":["Python","教程"],"content":"字典 dict() # {} dict(a=1, b=2, c=3) # {'a': 1, 'b': 2, 'c': 3} dict(zip(['a', 'b', 'c'], [1, 2, 3])) # {'a': 1, 'b': 2, 'c': 3} dict([('a', 1), ('b', 2), ('c', 3)]) # {'a': 1, 'b': 2, 'c': 3} ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:4","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#字典"},{"categories":["Python","教程"],"content":"staticmethod声明静态方法，即可以不实例化类而直接调用该方法。类中类也可以。 class C(object): @staticmethod def f(arg1, arg2, ...): ... ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#staticmethod"},{"categories":["Python","教程"],"content":"enumerate将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和下标，一般用在 for 循环中。 enumerate(sequence, start=0) list(enumerate([1, 2, 3])) # [(0, 1), (1, 2), (2, 3)] list(enumerate((1, 2, 3))) # [(0, 1), (1, 2), (2, 3)] list(enumerate('abc')) # [(0, 'a'), (1, 'b'), (2, 'c')] list(enumerate('abc', start=1)) # [(1, 'a'), (2, 'b'), (3, 'c')] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:6","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#enumerate"},{"categories":["Python","教程"],"content":"int 若 x 为数字，返回整数部分。（不能有 base 参数，否则报错） 若 x 为字符串，则将 x 视为 base 进制的数，返回转换为 10 进制后的数。（x 不能为小数或不存在的数，否则报错） int(x, base=10) int() # 0 int(3.9) # 3 int(-3.9) # -3 int('10', 2) # 2 int('0xA', 16) # 10 int('aB', 16) # 171 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:7","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#int"},{"categories":["Python","教程"],"content":"常用内置库","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#常用内置库"},{"categories":["Python","教程"],"content":"randomrandom库 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#random"},{"categories":["Python","教程"],"content":"osos模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.pathos.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' -\u003e 'A' # 'A' -\u003e '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' -\u003e ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' -\u003e ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#os"},{"categories":["Python","教程"],"content":"osos模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.pathos.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' - 'A' # 'A' - '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' - ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' - ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#ospath"},{"categories":["Python","教程"],"content":"文件操作 open() ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#文件操作"},{"categories":["Python","教程"],"content":"技巧","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#技巧"},{"categories":["Python","教程"],"content":"数字编号前置 0 s1 = \"12\" s1.zfill(4) # \"0012\" s2 = \"-12\" s2.zfill(4) # \"-0012\" a = 12 '%04d' % a # \"0012\" ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#数字编号前置-0"},{"categories":["Python","教程"],"content":"列表推导式 [i * 2 for i in range(3)] # [0, 2, 4] [str(a) + b for a in range(2) for b in 'ab'] # ['0a', '0b', '1a', '1b'] [i * 2 if i % 2 else i for i in range(4)] # [0, 2, 2, 6] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#列表推导式"},{"categories":["Python","教程"],"content":"匿名函数 + map list(map(lambda x: 2 * x, range(3))) # [0, 2, 4] list(map(lambda x, y: str(x) + y, range(3), 'abc')) # ['0a', '1b', '2c'] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#匿名函数--map"},{"categories":["Python","教程"],"content":"zip list(zip('01', 'ab')) # [('0', 'a'), ('1', 'b')] dict(zip('01', 'ab')) # {'0': 'a', '1': 'b'} for x, y in zip('ab', 'xy'): print(x, y) # a x # b y ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:4","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#zip"},{"categories":["Python","教程"],"content":"enumerate list(enumerate('ab')) # [(0, 'a'), (1, 'b')] for i, x in enumerate('ab'): print(i, x) # 0 a # 1 b ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:5","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#enumerate-1"},{"categories":["Python","教程"],"content":"Q\u0026A","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#qa"},{"categories":["Python","教程"],"content":"UnicodeDecodeError问题描述: UnicodeDecodeError: 'gbk' codec can't decode byte 0xad in position 7: illegal multibyte sequence 解决方案: 将open(filename, 'r')改为open(filename, 'r', encoding='utf-8') ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#unicodedecodeerror"},{"categories":["Python","教程"],"content":"Python 风格规范 不要在行尾加分号，也不要用分号将两条命令放在同一行。 每行不超过80个字符。（导入和注释例外） 不要使用反斜杠连接行。（Python 会将括号中的行隐式连接起来） foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 文本字符串在一行放不下，可以使用括号来实现隐式行连接。 s = ('This will build a very long long ' 'long long long long long long string') 除非是用于实现行连接，否则不要在返回语句或条件语句中使用括号。 用4个空格来缩进代码 # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = { long_dictionary_key: value1 + value2, ... } # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... } 顶级定义之间空两行（全局类、全局函数、全局变量），方法定义之间空一行（类内函数之间、类与第一个函数之间）。 括号内表达式两端不要有空格。 在逗号、分号、冒号后面加空格，前面不加。（行尾除外） 参数列表、索引或切片的左括号前不加空格。 二元操作符两边都加上一个空格。 ‘=‘用于指示参数值或默认值时，不在其两侧使用空格。 不要用空格来垂直对齐多行间","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#python-风格规范"},{"categories":["C++","教程"],"content":"标准模板库（Standard Template Library，STL）是一组 C++ 模板类，提供常见的数据结构和函数，如列表、堆栈、数组等。它是由容器类、算法和迭代器构成的一个通用库，它的组件是参数化的。 STL 包含以下四个组件： 算法（Algorithms）：头文件\u003calgorithm\u003e定义了一组函数，作用于容器，并为容器中的内容提供各种操作方法。 容器（Containers）：用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，如 deque、list、vector、map、set、bitset 等。 函数（Functions）： 迭代器（Iterators）：遍历容器。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#"},{"categories":["C++","教程"],"content":"\u003cvector\u003evector是一个动态数组，需要#include \u003cvector\u003e。 数组大小动态改变 可以进行逻辑操作（是否相等、比较大小） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vector"},{"categories":["C++","教程"],"content":"vector1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u003cint\u003e v1; // {} vector\u003cint\u003e v2 = {1, 2, 3}; // {1, 2, 3} vector\u003cint\u003e v3({1, 2, 3}); // {1, 2, 3} vector\u003cint\u003e v4 = v3; // {1, 2, 3} vector\u003cint\u003e v5(v3); // {1, 2, 3} vector\u003cint\u003e v6(3); // {0, 0, 0} vector\u003cint\u003e v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector\u003cint\u003e v8(arr, arr + 1); // {1} vector\u003cint\u003e v9(v4.begin(), v4.begin() + 2); // {1, 2} vector\u003cvector\u003cint\u003e\u003e v10(2, vector\u003cint\u003e(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vector-1"},{"categories":["C++","教程"],"content":"vector1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector v10(2, vector(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#11-初始化"},{"categories":["C++","教程"],"content":"vector1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector v10(2, vector(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#12-添加"},{"categories":["C++","教程"],"content":"vector1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector v10(2, vector(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#13-删除"},{"categories":["C++","教程"],"content":"vector1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector v10(2, vector(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#14-容量"},{"categories":["C++","教程"],"content":"vector1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector v10(2, vector(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#15-其他操作"},{"categories":["C++","教程"],"content":"vector1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector v10(2, vector(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#16-遍历"},{"categories":["C++","教程"],"content":"vector\u003cbool\u003e基本操作同 vector。 特殊操作： void flip() noexcept 所有位都翻转 static void swap(reference ref1, reference ref2) noexcept 交换两个位置的值 vector\u003cbool\u003e mask; mask.push_back(true); mask.push_back(false); // {1 0} mask.flip(); // {0 1} mask.swap(mask[0], mask[1]); // {1 0} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vectorbool"},{"categories":["C++","教程"],"content":"\u003cstack\u003estack是一个栈，需要#include \u003cstack\u003e。 后进先出（LIFO） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#stack"},{"categories":["C++","教程"],"content":"2.1 初始化 默认底层容器是 deque 可以显式设置底层容器为 vector stack\u003cint\u003e st1; stack\u003cint\u003e st2(st1); stack\u003cint\u003e st3({1, 2, 3}); // st3.top() == 3 deque\u003cint\u003e dq(2, 3); stack\u003cint\u003e st4(dq); // 默认底层容器是 deque vector\u003cint\u003e v({1, 2, 3}); stack\u003cint, vector\u003cint\u003e\u003e st5(v); // 设置底层容器为 vector ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#21-初始化"},{"categories":["C++","教程"],"content":"2.2 操作 void push(const value_type\u0026 val) 栈顶添加元素 void emplace(Args\u0026\u0026... args) 栈顶添加元素 void pop() 栈顶弹出元素 reference\u0026 top() 返回栈顶元素 bool empty() const 判断栈是否为空 size_type size() const 返回元素个数 void swap(stack\u0026 x) noexcept 交换两个栈 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#22-操作"},{"categories":["C++","教程"],"content":"\u003clist\u003elist是一个双向链表，需要#include \u003clist\u003e。 无法按索引访问元素 插入删除元素效率高 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#list"},{"categories":["C++","教程"],"content":"3.1 基本操作基本操作同 vector。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#31-基本操作"},{"categories":["C++","教程"],"content":"3.2 特殊操作添加： void push_front(const value_type\u0026 val) 在开头插入元素 void emplace_front(Args\u0026\u0026... args) 在开头构造并插入元素 void splice(const_iterator position, list\u0026 x) 将 x 中的元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator i) 将 x 中的位置为 i 元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator first, const_iterator last) 将 x 中的 [first, last) 区间内的元素转移到指定位置 void merge(list\u0026 x) void merge(list\u0026 x, Compare comp) 删除： void pop_front() 删除第一个元素 void remove(const value_type\u0026 val) 删除值为 val 的所有元素 void remove_if(Predicate pred) 删除满足自定义一元函数的元素 void unique() 删除连续重复元素，只保留一个 void unique(BinaryPredicate binary_pred) 删除满足自定义二元函数的元素 其他： void sort() 按升序排序 void sort(Compare comp) 按自定义二元函数排序 void reverse() noexcept 逆序 list\u003cint\u003e l = {1, 1, 1, 2, 1, 2}; l.unique(); // {1, 2, 1, 2} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#32-特殊操作"},{"categories":["C++","教程"],"content":"\u003cqueue\u003equeue是一个单向队列容器，需要#include \u003clist\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#queue"},{"categories":["C++","教程"],"content":"queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue\u003cint\u003e q1; // 空 queue queue\u003cint\u003e q2(5, 2); // 大小为 5 的 queue，值均为 2 queue\u003cint\u003e q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue\u003cint\u003e q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; queue\u003cint\u003e q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue\u003cint\u003e q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#queue-1"},{"categories":["C++","教程"],"content":"queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue q1; // 空 queue queue q2(5, 2); // 大小为 5 的 queue，值均为 2 queue q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; queue q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#411-初始化"},{"categories":["C++","教程"],"content":"queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue q1; // 空 queue queue q2(5, 2); // 大小为 5 的 queue，值均为 2 queue q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; queue q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#412-操作"},{"categories":["C++","教程"],"content":"priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue\u003cint\u003e pq1; // 空 priority_queue priority_queue\u003cint\u003e pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue\u003cint\u003e pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue\u003cint\u003e pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; priority_queue\u003cint\u003e pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue\u003cint\u003e pq6(v); // 复制 vector priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e pq7; // 最大优先队列（最大堆） priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq8; // 最小优先队列（最小堆） 4.2.2 操作 void push(const value_type\u0026 val) 添加元素 void emplace(Args\u0026\u0026... args) 添加元素 void pop() 删除队首（堆顶）元素 const_reference top() const 返回队首（堆顶）元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(priority_queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#priority_queue"},{"categories":["C++","教程"],"content":"priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue pq1; // 空 priority_queue priority_queue pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; priority_queue pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue pq6(v); // 复制 vector priority_queue, less pq7; // 最大优先队列（最大堆） priority_queue, greater pq8; // 最小优先队列（最小堆） 4.2.2 操作 void push(const value_type\u0026 val) 添加元素 void emplace(Args\u0026\u0026... args) 添加元素 void pop() 删除队首（堆顶）元素 const_reference top() const 返回队首（堆顶）元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(priority_queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#421-初始化"},{"categories":["C++","教程"],"content":"priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue pq1; // 空 priority_queue priority_queue pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; priority_queue pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue pq6(v); // 复制 vector priority_queue, less pq7; // 最大优先队列（最大堆） priority_queue, greater pq8; // 最小优先队列（最小堆） 4.2.2 操作 void push(const value_type\u0026 val) 添加元素 void emplace(Args\u0026\u0026... args) 添加元素 void pop() 删除队首（堆顶）元素 const_reference top() const 返回队首（堆顶）元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(priority_queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#422-操作"},{"categories":["C++","教程"],"content":"\u003cdeque\u003edeque是一个双端队列容器，需要#include \u003cdeque\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#deque"},{"categories":["C++","教程"],"content":"5.1 初始化 deque\u003cint\u003e dq1; // 空 deque deque\u003cint\u003e dq2(5, 2); // 大小为 5 的 deque，值均为 2 deque\u003cint\u003e dq3(dq2); // 复制 deque deque\u003cint\u003e dq4(dq2.begin(), dq2.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 int arr[] = {1, 2, 3}; deque\u003cint\u003e dq5(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; deque\u003cint\u003e dq6(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 deque\u003cint\u003e dq7 = dq6; deque\u003cint\u003e dq8 = {1, 2, 3}; ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#51-初始化"},{"categories":["C++","教程"],"content":"5.2 修改 void push_back(const value_type\u0026 val) 队尾添加元素 void push_front(const value_type\u0026 val) 队首添加元素 void emplace_back(Args\u0026\u0026... args) 队尾添加元素 void emplace_front(Args\u0026\u0026... args) 队首添加元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, const value_type\u0026 val) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 迭代器指定位置前面添加 n 个相同元素 iterator insert(const_iterator position, InputIterator first, InputIterator last) 迭代器指定位置前面添加 [first, last) 区间内元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) void pop_back() 删除队尾 void pop_front() 删除队首 iterator erase(iterator position) 删除迭代器指向元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 区间内元素 void clear() noexcept 清空 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#52-修改"},{"categories":["C++","教程"],"content":"5.3 遍历 deque\u003cint\u003e dq; for (auto it = dq.begin(); it != dq.end(); it++) {*it;} for (auto it = dq.rbegin(); it != dq.rend(); it++) {*it;} for (int e : dq) {e;} for (int\u0026 e : dq) {e;} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#53-遍历"},{"categories":["C++","教程"],"content":"5.4 操作 size_type size() const noexcept 返回大小 void resize(size_type n) 调整大小为 n，调大补 0，调小末尾截断 void resize(size_type n, const value_type\u0026 val) 调整大小为 n，调大补 val，调小末尾截断 bool empty() const noexcept 判断是否为空 reference operator[](size_type n) 访问指定位置元素，越界报错 reference at(size_type n) 访问指定位置元素，越界抛出 out_of_range 异常 const_reference back() const 返回队尾元素 const_reference front() const 返回队首元素 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:4","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#54-操作"},{"categories":["C++","教程"],"content":"\u003cmap\u003emap是一个有序键值对容器，每个元素由关键字（key）和该关键字对应的值（value）组合而成。需要#include \u003cmap\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#map"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map\u003cchar, int\u003e m1; map\u003cchar, int\u003e m2(m1); map\u003cchar, int\u003e m3(m1.begin(), m1.end()); map\u003cchar, int, less\u003cchar\u003e\u003e m4; // 按 key 升序排列，相当于 map\u003cchar, int\u003e map\u003cchar, int, greater\u003cchar\u003e\u003e m5; // 按 key 降序排列 6.2 添加 map\u003cchar, int\u003e m1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair\u003cchar, int\u003e('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 map\u003cchar, int\u003e m; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-\u003efirst; it-\u003esecond; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-\u003efirst; it-\u003esecond; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#map-1"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#61-初始化"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#62-添加"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#63-删除"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#64-遍历"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#65-其他操作"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#66-排序"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#661-按-key-排序"},{"categories":["C++","教程"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 mapm1; mapm2(m1); mapm3(m1.begin(), m1.end()); map m4; // 按 key 升序排列，相当于 mapmap m5; // 按 key 降序排列 6.2 添加 mapm1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 mapm; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-first; it-second; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-first; it-second; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() cons","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#662-按-value-排序"},{"categories":["C++","教程"],"content":"multimap key允许重复 默认按key升序排列 底层二叉搜索树实现，速度比unordered_multimap慢 基本使用方法同 map。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#multimap"},{"categories":["C++","教程"],"content":"\u003cunordered_map\u003e","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_map"},{"categories":["C++","教程"],"content":"unordered_map key唯一且不能修改，可以添加或删除 无序 速度比map快 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_map-1"},{"categories":["C++","教程"],"content":"unordered_multimap","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_multimap"},{"categories":["C++","教程"],"content":"\u003cset\u003eset是一个有序集合容器。需要#include \u003cset\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#set"},{"categories":["C++","教程"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set\u003cint\u003e s1; // {} set\u003cint\u003e s2 = {1, 2, 3}; // { 1 2 3 } set\u003cint\u003e s3 = s2; // { 1 2 3 } set\u003cint\u003e s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set\u003cint\u003e s5(arr, arr + 3); // { 1 2 3 } set\u003cint\u003e s6(arr, arr + 1); // { 1 } set\u003cint\u003e s7(s4); // { 1 2 3 } set\u003cint\u003e s8(s4.begin(), s4.end()); // { 1 2 3 } set\u003cint\u003e s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set\u003cint, CompClass\u003e s10; // { 1 2 3 } 修改 pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args) 添加一个元素 pair\u003citerator, bool\u003e insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list\u003cvalue_type\u003e il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#set-1"},{"categories":["C++","教程"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left s10; // { 1 2 3 } 修改 pairemplace(Args\u0026\u0026... args) 添加一个元素 pairinsert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#初始化"},{"categories":["C++","教程"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left s10; // { 1 2 3 } 修改 pairemplace(Args\u0026\u0026... args) 添加一个元素 pairinsert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#修改"},{"categories":["C++","教程"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left s10; // { 1 2 3 } 修改 pairemplace(Args\u0026\u0026... args) 添加一个元素 pairinsert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#容量"},{"categories":["C++","教程"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left s10; // { 1 2 3 } 修改 pairemplace(Args\u0026\u0026... args) 添加一个元素 pairinsert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#遍历"},{"categories":["C++","教程"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left s10; // { 1 2 3 } 修改 pairemplace(Args\u0026\u0026... args) 添加一个元素 pairinsert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#操作"},{"categories":["C++","教程"],"content":"multiset 允许重复元素 元素默认升序 速度比unordered_set慢 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#multiset"},{"categories":["C++","教程"],"content":"\u003cunordered_set\u003eunordered_set是一个无序集合容器。需要#include \u003cunordered_set\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_set"},{"categories":["C++","教程"],"content":"unordered_set 元素唯一 无序 底层哈希表实现，速度比set快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_set-1"},{"categories":["C++","教程"],"content":"unordered_multiset 允许重复元素 无序 速度比multiset快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_multiset"},{"categories":["C++","教程"],"content":"\u003cbitset\u003ebitset模拟一个 bool 数组，每个元素只能是 0 或 1. ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#bitset"},{"categories":["C++","教程"],"content":"初始化 bitset\u003c4\u003e b1; // 0000 bitset\u003c4\u003e b2(\"100\"); // 0100, b2[0] == 0 bitset\u003c4\u003e b3(\"1100\"); // 1100 bitset\u003c4\u003e b4(\"11100\"); // 1110 bitset\u003c4\u003e b5(b2); // 0100 string s = \"1010\"; bitset\u003c4\u003e b6(s); // 1010 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#初始化-1"},{"categories":["C++","教程"],"content":"位运算 bitset\u003c4\u003e a(\"1001\"), b(\"1010\"); a \u0026 b; // 1000 AND a | b; // 1011 OR a ^ b; // 0011 XOR ~a; // 0110 NOT a \u003c\u003c 1; // 0010 SHL a \u003e\u003e 1; // 0100 SHR a == b; // false a != b; // true ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#位运算"},{"categories":["C++","教程"],"content":"操作 reference operator[](size_t pos) 访问指定位置，0 是最右边一位，即最低位 size_t count() const noexcept 返回 1 的 个数 size_t size() const noexcept 返回长度 bool test(size_t pos) const 判断指定位置是否为 1 bool any() const noexcept 判断是否存在某一位是 1 bool none() const noexcept 判断是否全是 0 bool all() const noexcept 判断是否全是 1 bitset\u0026 set() noexcept 全部置为 1 bitset\u0026 set(size_t pos, bool val = true) 指定位置置为 1 bitset\u0026 reset() noexcept 全部置为 0 bitset\u0026 reset(size_t pos) 指定位置置为 0 bitset\u0026 flip() noexcept 翻转 bitset\u0026 flip(size_t pos) 翻转指定位置 string to_string() const 返回该二进制数的字符串 unsigned long to_ulong() const 返回该 2 进制数对应的整数，类型 unsigned long unsigned long long to_ullong() const 返回该 2 进制数对应的整数，类型 unsigned long long ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#操作-1"},{"categories":["C++","教程"],"content":"\u003calgorithm\u003e","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#algorithm"},{"categories":["C++","教程"],"content":"sort数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector\u003cint\u003e v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#sort"},{"categories":["C++","教程"],"content":"sort数组排序 bool cmp(int a, int b) { return a b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#数组排序"},{"categories":["C++","教程"],"content":"sort数组排序 bool cmp(int a, int b) { return a b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#类结构体排序"},{"categories":["C++","教程"],"content":"reverse","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#reverse"},{"categories":["C++","教程"],"content":"lower_bound","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#lower_bound"},{"categories":["C++","教程"],"content":"upper_bound","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:4","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#upper_bound"},{"categories":["C++","教程"],"content":"search","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:5","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#search"},{"categories":["C++","教程"],"content":"\u003ctuple\u003etuple将不同类型的许多元素打包成一个对象，便于访问，（就像定义了一个只有属性的类，并且属性只定义了类型，未定义名字）。需要#include \u003ctuple\u003e。 元素类型任意 元素数量任意 tuple\u003cint, string\u003e t1; tuple\u003cint, string\u003e t2{t1}; tuple\u003cint, string\u003e t3(t2); tuple\u003cint, string\u003e t4{1, \"one\"}; get\u003c0\u003e(t4); // 1 get\u003c1\u003e(t4); // one get\u003cint\u003e(t4); // 1 get\u003cstring\u003e(t4); // one make_tuple(2, string(\"two\")); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#tuple"},{"categories":["C++","教程"],"content":"\u003cnumeric\u003e该头文件包括了一组对数组进行某些操作的算法。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#numeric"},{"categories":["C++","教程"],"content":"accumulate T accumulate(InputIterator first, InputIterator last, T init)：默认求和 T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)：自定义函数 int res = 0; int arr[3] = {1, 2, 3}; vector\u003cint\u003e vec(arr, arr + 3); accumulate(arr, arr + 3, res); // 求和，6 accumulate(vec.begin(), vec.end(), res); // 求和，6 accumulate(arr, arr + 3, res, minus\u003cint\u003e()); // 累减，-6 accumulate(arr, arr + 3, res, [z](int x, int y) { return x + 2 * y; }); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#accumulate"},{"categories":["C++","教程"],"content":"参考 Standard C++ Library Reference - cplusplus.com ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:14:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#参考"},{"categories":["PowerShell","教程"],"content":"PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 所有指令或参数均不区分大小写！ PowerShell Bash ls、dir、Get-ChildItem、gci ls -l ls -force ls -a ls -name ls mkdir、New-Item -itemtype \"directory\" mkdir echo、Write-Output、write echo ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["PowerShell","教程"],"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/#"},{"categories":["Hugo"],"content":"本文介绍了如何使用 Hugo 的 DoIt 主题搭建一个博客，并使用 Github Action 自动部署到 Github Pages。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#"},{"categories":["Hugo"],"content":"1 安装 到 Github 下载hugo_extended_0.XX.X_Windows-64bit.zip，解压并将hugo.exe所在目录添加到系统环境变量。 到 Git 官网 下载安装 Git。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#1-安装"},{"categories":["Hugo"],"content":"2 创建网站 hugo new site MyBlog cd MyBlog git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt 可在 Hugo Themes 找到更多主题。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#2-创建网站"},{"categories":["Hugo"],"content":"3 添加内容输入hugo new posts/My-First-Blog.md，然后打开刚创建的My-First-Blog.md，显示如下： --- title: \"My First Blog\" date: 2021-02-04T16:18:47+08:00 draft: true --- 所有页面均作为草稿创建。文章完成后，如果想要渲染这些页面，请修改为draft: false。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#3-添加内容"},{"categories":["Hugo"],"content":"3.1 在文章中添加图片Hugo 的配置文件和文章中引用图片都是以static文件夹作为根目录的。 也就是说文章中插入/xxx/yyy.jpg，实际图片存放位置为/static/xxx/yyy.jpg。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#31-在文章中添加图片"},{"categories":["Hugo"],"content":"4 本地部署 hugo server/serve hugo server -D # 渲染草稿，即也渲染 draft: true 的内容 浏览器打开 localhost:1313 即可看到部署在本地的网站。 网站部署后，当配置文件或博客内容发生更改时，页面会自动刷新，不用重新部署。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#4-本地部署"},{"categories":["Hugo"],"content":"5 主题自定义主题配置文件为MyBlog根目录下的config.toml文件。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#5-主题自定义"},{"categories":["Hugo"],"content":"5.1 简单配置 # 域名 baseURL = \"https://backtraxe.github.io/\" # 默认语言 [en, zh-cn, ...] defaultContentLanguage = \"zh-cn\" # 语言 [zh-CN, en-us, ...] languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 标题 title = \"traXe\" # 主题 theme = \"DoIt\" [params] # 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是Backsided的博客\" # 作者配置 [author] name = \"Backsided\" email = \"\" link = \"\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#51-简单配置"},{"categories":["Hugo"],"content":"高级配置（可选）","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#高级配置可选"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#params"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsapp"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssearch"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsheader"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsfooter"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssection"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramslist"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramshome"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssocial"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspage"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagetoc"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagecode"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagemath"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagemapbox"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspageshare"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagecomment"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagelibrary"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspageseo"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramstypeit"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsverification"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsseo"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsanalytics"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscookieconsent"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscdn"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 abs","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscompatibility"},{"categories":["Hugo"],"content":"[markup] # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:4","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#markup"},{"categories":["Hugo"],"content":"[author] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:5","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#author"},{"categories":["Hugo"],"content":"[sitemap] # 网站地图配置 [sitemap] changefreq = \"weekly\" filename = \"sitemap.xml\" priority = 0.5 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:6","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#sitemap"},{"categories":["Hugo"],"content":"[Permalinks] # Permalinks 配置 [Permalinks] # posts = \":year/:month/:filename\" posts = \":filename\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:7","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#permalinks"},{"categories":["Hugo"],"content":"[privacy] # 隐私信息配置 [privacy] [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:8","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#privacy"},{"categories":["Hugo"],"content":"[mediaTypes] # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\"text/plain\"] suffixes = [\"md\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:9","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#mediatypes"},{"categories":["Hugo"],"content":"[outputFormats.MarkDown] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \"text/plain\" isPlainText = true isHTML = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:10","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#outputformatsmarkdown"},{"categories":["Hugo"],"content":"[outputs] # 用于 Hugo 输出文档的设置 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] page = [\"HTML\", \"MarkDown\"] section = [\"HTML\", \"RSS\"] taxonomy = [\"HTML\", \"RSS\"] taxonomyTerm = [\"HTML\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:11","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#outputs"},{"categories":["Hugo"],"content":"6 发布","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#6-发布"},{"categories":["Hugo"],"content":"6.1 静态页面发布输入hugo，渲染后的静态页面在 ./public 文件夹中，可将该文件夹中的内容发布。 可用-d/--destination或在config.toml中修改publishdir来指定输出地址。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#61-静态页面发布"},{"categories":["Hugo"],"content":"6.2 Github Pages 发布在 Github 新建两个仓库：\u003cUSERNAME\u003e.github.io.data 存放内容，\u003cUSERNAME\u003e.github.io 部署页面。 其中，\u003cUSERNAME\u003e.github.io.data可以设为私人仓库。 git remote add origin https://github.com/backtraxe/backtraxe.github.io.data.git git add --all git commit -m \"init blog\" git push --set-upstream origin master -f 创建一个 Personal access token，命名随意，勾选repo。 进入\u003cUSERNAME\u003e.github.io.data仓库，点击Settings-\u003eSecrets，填入刚才的token；点击Actions-\u003eNew workflow-\u003eset up a workflow yourself，写入如下内容。 name:Hugo Deploy # 名称随意修改on:push:branches:[master ] # 修改为你当前分支jobs:build:runs-on:ubuntu-latest # 指定系统版本steps:- uses:actions/checkout@v2 # 克隆仓库with:submodules:true# 启用子模块fetch-depth:1- name:Setup Hugo # 安装 hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'# 指定 hugo 版本- name:Build Hugo # hugo 生成网站run:hugo- name:Deploy Hugo # 部署网站uses:peaceiris/actions-gh-pages@v3with:personal_token:${{ secrets.ACCESS_TOKEN }} # 与 secrets 里的 token 名称对应external_repository:backtraxe/backtraxe.github.io # 指定发布的仓库publish_branch:master # 指定发布仓库的分支publish_d","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#62-github-pages-发布"},{"categories":["Hugo"],"content":"6.3 环境迁移git clone --recursive https://github.com/backtraxe/backtraxe.github.io.data.git ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#63-环境迁移"},{"categories":["Hugo"],"content":"7 全局详细配置 # 域名 baseURL = \"\" # 构建时包含草稿 buildDrafts = false # 内容文件夹 contentDir = \"content\" # 数据文件夹 dataDir = \"data\" # 内容默认语言（中文：zh-cn） defaultContentLanguage = \"en\" # 根目录跳转到默认语言目录 defaultContentLanguageInSubdir = false # 禁用指定类型页面：page, home, section, taxonomy, term, RSS, sitemap, robotsTXT, 404 disableKinds = [] # 禁用实时重载 disableLiveReload = false # 禁用将 url/path 转小写字母 disablePathToLower = false # 启用 Emoji enableEmoji = false # 使用文件的最后 git 提交日期更新 Lastmod 参数 enableGitInfo = false # 启用 inline shortcode enableInlineShortcodes = false # 是否生成 robots.txt 文件 enableRobotsTXT = false # 日期设置 [frontmatter] # 脚注锚的前缀 footnoteAnchorPrefix = \"\" # 脚注返回链接显示的文本 footnoteReturnLinkContents = \"\" # Google Analytics 跟踪 ID googleAnalytics = \"\" # 自动检测内容中的中文/日文/韩文 hasCJKLanguage = false # 图片设置 [imaging] # 语言设置 [languages] # 启用日志 log = false # 日志保存目录 logFile = \"\" # 主题设置 [markup] # 目录设置 [menu] # 最小化构建设置 [minify] # 模块设置 [module] # 每页的默认文章数量 paginate = 10 # 固定链接 [permalinks] # 生成静态网页的目录 publishDir = \"public\" # 相关设置 [rel","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:7:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#7-全局详细配置"},{"categories":["Hugo"],"content":"8 参考 Quick Start | Hugo GitHub Pages 文档 - GitHub Docs Host on GitHub - Hugo 主题文档 - 基本概念 - LoveIt How to Create Your First Hugo Blog: a Practical Guide 创建 GitHub Pages 站点 - Github 使用Hugo和GitHub搭建博客 - Félix | Medium ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:8:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#8-参考"},{"categories":["Markdown"],"content":"Markdown 是一种轻量级的「标记语言」，易读易写，简洁至上，被广泛使用。这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例。 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#"},{"categories":["Markdown"],"content":"一、标题 # 一级标题 h1 ## 二级标题 h2 ### 三级标题 h3 #### 四级标题 h4 ##### 五级标题 h5 ###### 六级标题 h6 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#一标题"},{"categories":["Markdown"],"content":"二、强调 **加粗** *斜体* ~~删除线~~ ***斜体加粗*** ~~**删除线加粗**~~ ~~*斜体删除线*~~ ~~***斜体删除线加粗***~~ 加粗、斜体、删除线、斜体加粗、删除线加粗、斜体删除线、斜体删除线加粗 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#二强调"},{"categories":["Markdown"],"content":"三、引用 \u003e 引用 \u003e\u003e 嵌套引用 引用 嵌套引用 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#三引用"},{"categories":["Markdown"],"content":"四、分割线 --- *** ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#四分割线"},{"categories":["Markdown"],"content":"五、图片 ![Backsided's World](https://backtraxe.github.io/apple-touch-icon.png \"Backtraxe's World\") \u003cimg src=\"https://backtraxe.github.io/apple-touch-icon.png\" alt=\"Backtraxe's World\" width=\"30%\" height=\"30%\"\u003e Backtraxe's WorldBacksided\u0026rsquo;s World \" Backtraxe's World ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#五图片"},{"categories":["Markdown"],"content":"六、超链接 [Backsided's World](https://backtraxe.github.io/) \u003chttps://backtraxe.github.io/\u003e 这个链接用 1 作为网址变量 [Google][1] 这个链接用 runoob 作为网址变量 [Runoob][runoob] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [runoob]: http://www.runoob.com/ Backsided’s World https://backtraxe.github.io/ 这个链接用 1 作为网址变量 traXe 这个链接用 runoob 作为网址变量 traXe 然后在文档的结尾为变量赋值（网址） ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#六超链接"},{"categories":["Markdown"],"content":"七、列表","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#七列表"},{"categories":["Markdown"],"content":"无序列表 - 北京 - 上海 - 广州 - 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#无序列表"},{"categories":["Markdown"],"content":"有序列表 1. 北京 1. 上海 1. 广州 1. 深圳 或者 1. 北京 2. 上海 3. 广州 4. 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#有序列表"},{"categories":["Markdown"],"content":"列表嵌套 - 北京 - 上海 - 广东 1. 广州 2. 深圳 北京 上海 广东 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:3","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#列表嵌套"},{"categories":["Markdown"],"content":"八、表格 姓名|分数|排名 --|:--:|--: 张三|100|1 李四|85|2 王五|60|3 姓名 分数 排名 张三 100 1 李四 85 2 王五 60 3 --，:-- : 左对齐 :--: : 居中 --: : 右对齐 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#八表格"},{"categories":["Markdown"],"content":"九、代码","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#九代码"},{"categories":["Markdown"],"content":"单行代码 `print(\"Hello World!\")` print(\"Hello World!\") ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#单行代码"},{"categories":["Markdown"],"content":"多行代码 \\```cpp #include\u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } \\``` #include\u003ciostream\u003eint main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#多行代码"},{"categories":["Markdown"],"content":"十、流程图 \\```flow st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop \\``` st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#十流程图"},{"categories":["Markdown"],"content":"十一、LaTeX公式","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#十一latex公式"},{"categories":["Markdown"],"content":"行内公式 $ E=mc^2 $ $ E=mc^2 $ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#行内公式"},{"categories":["Markdown"],"content":"多行公式 $$ \\sum_{i=1}^n a_i=0 $$ $$ f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$ \\sum_{i=1}^n a_i=0 $$ $$ f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#多行公式"}]