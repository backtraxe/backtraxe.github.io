[{"categories":[],"content":"工具、娱乐、资源、软件…… ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:0:0","series":null,"tags":[],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"在线工具 在线PDF工具 easy PDF PDF24 Tools iLovePDF 在线图片处理 iLoveIMG IMG365 无需上传的图片格式转换器 AI人工智能图片放大 图像压缩 快速AI自动抠图 在线图片去底 在线GIF制作和编辑 EasyScreenOCR ONLINE OCR 小米风格Logo生成器 favicon图标制作工具 favicon图标生成器 在线音频/视频处理 网易见外工作台 编程 W3school Overleaf KaTeX - Supported Functions Linux 命令列表 Ubuntu Pastebin OnlineGDB C++ shell regex101 Learn Git Branching 天梯图 桌面CPU性能天梯图 桌面GPU性能天梯图 笔记本CPU性能天梯图 笔记本GPU性能天梯图 手机CPU性能天梯图 手机影像DxO综合榜 Steam历史价格查询 全球Apple产品比价 极简简历模板PoleBrief 萝卜工坊 - 模拟手写字体 ProcessOn - 在线思维导图、流程图 英文字体转换 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:0","series":null,"tags":[],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"在线观看 影视 低端影视 奈菲影视 看片狂人 NO视频 动漫 AGE动漫 ZzzFun 樱花动漫 漫岛动漫 EDD动漫 漫画 漫画DB 动漫之家 体育 CCTV-5体育频道高清直播 直播6 比赛直播 JRKAN直播 55直播 直播吧 64体育 七星直播 足球巴巴 极速体育 147体育 310看球网 jrs直播 低调看吧 来球网 纪录片天地 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:0","series":null,"tags":[],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"资源下载 影视 高清MP4粉 片源网 BT天堂 SubDH FIX字幕侠 牛牛美剧 音范丝 Nyaa RARBG 字幕 SubHD 字幕库 A4k字幕网 90分钟足球网 知轩藏书 动漫 动漫领域 肥羊-Raws 11周年Peach 不移之火资源网 漫猫动漫BT下载 爱恋动漫BT下载 磁力 磁力爬 GFW 八爪鱼磁搜 搜番 吃力网 电影淘淘 Torrent Kitty - 免费种子转磁力网站 云盘狗 搜盘么 Office Word联盟 优品PPT PPT超级市场 第1PPT PPT演示设计网址导航 图片 Dribbble Pinterest Freepik Unsplash DeviantArt Behance 极简壁纸1 极简壁纸2 Wallpaper Abyss wallhaven 图标 Worldvectorlogo Iconduck StickPNG Iconfont-阿里巴巴矢量图标库 设计之家 插画 Storyset StickPNG Iconfont-阿里巴巴矢量图标库 设计 Figma 摄影 天空之城 游戏 Liquipedia DST-MOD Wikri 叽哩叽哩游戏网ACG（G站） 小爱同学音色网 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:3:0","series":null,"tags":[],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"软件 MSDN,我告诉你 吾爱破解 异星软件空间 易酷软件 果核剥壳 Easy To Direct Download Pc Software Crack Softwares 下载免费Wondows个人电脑游戏及软件 捷径库 反斗软件 Mergeek - 发现好产品 Appwall Today - iOS 每日限免 Awesome Windows 必备 ShareX Snipaste Clover uTools Bandizip 天若OCR Everything RubberTranslator CopyTranslator ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:4:0","series":null,"tags":[],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"导航 不死鸟 - 分享为王 福利吧 缙哥哥博客 - 福利分享 好棒的羊毛站 创造狮导航 A+医学百科 wikiHow - 万事指南 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:5:0","series":null,"tags":[],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"推荐 The best Programming books 历史剧网 油猴插件 Greasy Fork 雷利子 秒传链接提取 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:6:0","series":null,"tags":[],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"汇集网上的各种学习资料。 面试 CS-Notes：在线 Coding Interview University：中文 算法 The Algorithms labuladong 的算法小抄：在线阅读：GitHub Pages，Gitbook，Gitee Pages 算法珠玑：在线 《algorithm-note》中文版：在线 社区 阿里云天池 Kaggle Dataquest AI研习社 AMiner 博客 『A Course in Machine Learning』by Hal Daumé III AI算法工程师手册 论文 Papers With Code CVF Open Access Best Paper Awards in CS SCI-Hub论文下载可用网址链接 企鹅论文 一键下载 Deep learning: Technical introduction：深度学习综述 What Do We Understand About Convolutional Networks?：CNN 综述 Bringing Old Photos Back to Life：修复旧照片 深度学习论文翻译 深度学习入门教程, 优秀文章 AiLearning: 机器学习：在线 机器学习原理：在线 Data-Science-Notes CS229 课程讲义中文翻译：在线 斯坦福大学2014（吴恩达）机器学习教程中文笔记：在线 《神经网络与深度学习》 邱锡鹏：在线 Deep Learning with PaddlePaddle：在线 教程 简单粗暴 TensorFlow 2 | 在线 20210715 30天吃掉那只TensorFlow2 20210527 TensorFlow 2.0 Tutorials 20200923 20天吃掉那只Pytorch 20210704 深度学习500问 20210317 nlp-tutorial 20210502 Machine Learning for Beginners - A Curriculum 20210721 《Deep Learning》 《The Elements of Statistical Learning》中文版 《Interpretable machine learning》 | 在线 20210713 《动手学深度学习》李沐 | 在线 20210717 《神经网络与深度学习》邱锡鹏 | 在线 20210518 公开课 机器学习 - 吴恩达 | Coursera WordTEX 网络安全 项目 HelloGitHub pandas Joyful-Pandas | 在线 20210331 User Guide — pandas Java How2J 的 Java教程 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:0","series":null,"tags":[],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":[],"content":"大神自制油猴脚本，可以配合 115 网盘的 sha1 链接转存到阿里云盘。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%BD%AC%E5%AD%98115%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/:0:0","series":null,"tags":[],"title":"阿里云盘转存115网盘资源","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%BD%AC%E5%AD%98115%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/"},{"categories":[],"content":"步骤 下载 Chrome 或 Edge 或 Firefox 浏览器，并安装 Tampermonkey 插件。 安装脚本。 打开阿里云盘网页版。 点击右上角多文件提取，导入 sha1 链接文件。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%BD%AC%E5%AD%98115%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/:1:0","series":null,"tags":[],"title":"阿里云盘转存115网盘资源","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%BD%AC%E5%AD%98115%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/"},{"categories":[],"content":"参考 如何使用第三方脚本实现阿里云盘分享文件 - 太空堡垒麦克罗斯 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%BD%AC%E5%AD%98115%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/:2:0","series":null,"tags":[],"title":"阿里云盘转存115网盘资源","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%BD%AC%E5%AD%98115%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/"},{"categories":[],"content":"des content $$ Pr(Class_i|Object) \\times Pr(Object) \\times IOU_{pred}^{truth} = Pr(Class_i) \\times IOU_{pred}^{truth} $$ ","date":"2021-07-20","objectID":"/posts/you-only-look-once/:0:0","series":null,"tags":[],"title":"You Only Look Once","uri":"/posts/you-only-look-once/"},{"categories":[],"content":"计算机组成原理。 ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:0:0","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"1 计算机系统概述 ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:0","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"1.1 计算机系统层次结构 冯·诺伊曼体系结构： 由运算器、存储器、控制器、输入设备和输出设备5大部件组成。 指令和数据以同等地位存储在存储器中，并可按地址寻访。 指令和数据均用二进制代码表示。 指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。 指令在存储器内按顺序存放。 早期的冯·诺伊曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据。现代计算机已发展为以存储器为中心，使I/O操作尽可能地绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率。 计算机的功能部件： 输入设备 输出设备 ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:1","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"存储器 运算器：算术运算和逻辑运算。 算术逻辑单元（Arithmetic and Logical Unit，ALU） 累加寄存器（ACC） 乘商寄存器（MQ） 操作数寄存器（X） 程序状态寄存器（PSW）： 控制器 程序计数器（Program Counter，PC）：存放当前欲执行指令的地址，可以自动加1以形成下一条指令的地址，它与主存的MAR之间有一条直接通路。 指令寄存器（Instruction Register，IR）：存放当前的指令，内容来自主存的MDR。 控制单元（Control Unit，CU） ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:0","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"1.3 计算机的性能指标 机器字长：计算机进行一次整数运算所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。一般等于内部寄存器的大小。 数据通路带宽： 主存容量：主存所能存储信息的最大容量，可用字数×字长（如512K×16位）来表示。 运算速度： ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:1","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"2 数据的表示和运算 ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:0","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"2.1 数制和编码 ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:1","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"2.2 定点数的表示和运算 表示 无符号数 有符号数 定点小数 定点整数 原码 反码 补码 移码 运算 移位 算术移位 逻辑移位 循环移位 ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:2","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"2.3 原码加法 符号相同 数值相加 符号不变 符号不同 比较两数绝对值大小 绝对值大的数的绝对值减去绝对值小的数的绝对值 结果的符号是绝对值大的数的符号 补码加法 符号和数值一起运算 单符号位：若溢出则结果错误。 变形补码（双符号位）：符号位为 01 或 10 则溢出。 最高位溢出舍弃 $$ [X+Y]_补=[X]_补+[Y]_补 $$ $$ [X-Y]_补=[X]_补+[-Y]_补 $$ $$ [[X]_补]_补=[X]_原 $$ 原码一位乘法 $$ [X]_原=X_SX_1X_2…X_n $$ $$ [Y]_原=Y_SY_1Y_2…Y_n $$ $$ [X \\times Y]_S=X \\oplus Y $$ $$ [X \\times Y]_D=X_1X_2…X_n \\times Y_1Y_2…Y_n $$ 定点补码一位乘法 $$ [X \\times Y]_补=[X]_补 \\times Y_1Y_2…Y_n - [X]_补 \\times Y_S $$ ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:3","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":[],"content":"参考资料 《计算机组成原理考研复习指导》 - 王道考研系列 《计算机组成原理高分笔记》 - 天勤计算机考研高分笔记系列 ","date":"2021-07-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:4:0","series":null,"tags":[],"title":"计算机组成原理","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["力扣每日一题"],"content":"题目链接 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":["力扣每日一题"],"content":"方法一：模拟 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":["力扣每日一题"],"content":"代码 class Solution { public: int xorOperation(int n, int start) { int ans = start; for (int i = 1; i \u003c n; ++i) { ans ^= (start + i * 2); } return ans; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:1","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":["力扣每日一题"],"content":"复杂度分析 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:2","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":["力扣每日一题"],"content":"方法二：数学 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":["力扣每日一题"],"content":"思路 首先介绍异或运算： 对于单个比特的异或，相同为0，相异为1，即： $ 0 \\oplus 0 = 0 $ $ 0 \\oplus 1 = 1 $ $ 1 \\oplus 0 = 1 $ $ 1 \\oplus 1 = 0 $ 对于整数的异或，按最低位对齐，相同位置的比特进行异或运算，如： $ \\ \\ \\ \\ 0001 \\ (1) $ $ \\underline{\\oplus \\ 0011 \\ (3)} $ $ \\ \\ \\ \\ 0010 \\ (2) $ 异或运算满足以下基本性质： $ a \\oplus a = 0 $ $ a \\oplus 0 = a $ $ a \\oplus b = b \\oplus a $ $ (a \\oplus b) \\oplus c = a \\oplus (b \\oplus c) $ 可以推导出如下性质： $ a \\oplus b \\oplus b = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i+1个a} = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i个a} = 0 $ $ \\forall i \\in \\mathbb{Z}, 有 4i \\oplus (4i+1) \\oplus (4i+2) \\oplus (4i+3) = 0 $ 回到本题，我们需要计算 $ start \\oplus (start+2) \\oplus (start+4) \\oplus \\cdots \\oplus (start+2(n-1)) $，观察公式可以知道每一项奇偶性相同，因此它们的二进制表示中的最低位或者均为1或均为0。 于是我们可以把参与运算的数的二进制位的最低位提取出来单独处理。当且仅当start为奇数且n也为奇数时，结果才为奇数，即最低位为1。令 $ e = n \\oplus start \\oplus 1 $。 此时不考虑start的最后一位，我们将start右移一位，令 $ s = \\lfloor \\frac{start}{2} \\rfloor $，公式转化为 $ s \\oplus (s+1) \\oplus (s+2) \\oplus \\cdots \\oplus (s+n-1) + e $。 这样我们可以自定义函数sumXor(x)来计算 $ 0 \\oplus 1 \\oplus 2 \\oplus \\cdots \\oplus x $，根据上面异或运算的推导性质第4条，可以得出如下结论： $ 当x=4i + 0,i \\in \\mathbb{Z}时，sumXor(x) = x $ $ 当x=4i + 1,i \\in \\mathbb{Z}时，sumXor(x) = (x-1) \\oplus x = 1 $ $ 当x=4i + 2,i \\in \\mathbb{Z}时，sumXor(x) = (x-2) \\oplus (x-1) \\oplus x = x + 1 $ $ 当x=4i + 3,i \\in \\mathbb{Z}时，sumXor(x) = 0 $ 所以，最终结果为 $ [(sumXor(s+n-1) \\oplus sumXor(s-1)) \\times 2] \\oplus e $。 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:1","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":["力扣每日一题"],"content":"代码 class Solution { public: int xorOperation(int n, int start) { int s = start \u003e\u003e 1; int e = n \u0026 start \u0026 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return (ret \u003c\u003c 1) | e; } int sumXor(int x) { if (x % 4 == 0) return x; else if (x % 4 == 1) return 1; else if (x % 4 == 2) return x + 1; return 0; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:2","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":["力扣每日一题"],"content":"复杂度分析 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:3","series":null,"tags":["位运算"],"title":"力扣每日一题 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"},{"categories":[],"content":"机器学习是一门通过编程让计算机从数据中进行学习的科学。 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"机器学习简介 机器学习的对象是数据。从数据出发，提取数据特征，发现数据中的知识，然后又回到对数据的分析预测中去。因此，在机器学习的假设中有很重要的一个假设，那就是假设同类数据的数据有一定的统计特性。这样机器学习通过考虑学习什么样的模型以及如何学习的问题，使得模型能读数据进行准确的预测与分析。 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"机器学习分类 根据训练期间接受的监督数量和监督类型分类： 监督学习（Supervised Learning） 可以由训练集（Training Set）中学到或建立一个模式，并依此模式推测新的实例。训练集是由输入（通常是矩阵）和预期输出所组成。函数的输出可以是一个连续的值（回归，Regression），或是一个离散的类别标签（分类，Classification）。 一个监督学习的任务在观察完一些训练范例（输入和预期输出）后，去预测这个函数对任何可能出现的输入的值的输出。要达到此目的，学习者必须以\"合理\"（见归纳偏向）的方式从现有的资料中一般化到非观察到的情况。在人类和动物感知中，则通常被称为概念学习（Concept Learning）。 监督学习有两种形态的模型。最一般的，监督式学习产生一个全域模型，会将输入对应到预期输出。而另一种，则是将这种对应实作在一个区域模型。（如案例推论及最近邻居法）。 常用分类器：人工神经网络（ANN）、支持向量机（SVM）、K-近邻算法（KNN）、高斯混合模型（GMM）、朴素贝叶斯分类器（NBC）、决策树（DT）和径向基函数（RBF）。 无监督学习（Unsupervised Learning） 目的是去对原始资料进行分类，以便了解资料内部结构。有别于监督式学习网络，无监督式学习网络在学习时并不知道其分类结果是否正确，亦即没有受到监督式增强(告诉它何种学习是正确的)。其特点是仅对此种网络提供输入范例，而它会自动从这些范例中找出其潜在类别规则。当学习完毕并经测试后，也可以将之应用到新的案例上。 无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。 半监督学习（Semi-supervised Learning） 给定一个来自某未知分布的样本集S=L∪U, 其中L 是已标签样本集L={(x1,y1),(x2,y2), … ,(x |L|,y|L|)}, U是一个未标签样本集U={x’1,x’2,…,x’|U|},希望得到函数f:X → Y可以准确地对样本x预测其标签y，这个函数可能是参数的，如最大似然法；可能是非参数的，如最邻近法、神经网络法、支持向量机法等；也可能是非数值的，如决策树分类。其中, x与x’ 均为d 维向量, yi∈Y 为样本x i 的标签, |L| 和|U| 分别为L 和U 的大小, 即所包含的样本数。半监督学习就是在样本集S 上寻找最优的学习器。如何综合利用已标签样例和未标签样例,是半监督学习需要解决的问题。 半监督学习问题从样本的角度而言是利用少量标注样本和大量未标注样本进行机器学习，从概率学习角度可理解为研究如何利用训练样本的输入边缘概率 P( x )和条件输出概率P ( y | x )的联系设计具有良好性能的分类器。这种联系的存在是建立在某些假设的基础上的，即聚类假设(cluster assumption)和流形假设(maniford assumption)。 强化学习（Reinforcement Learning） 强化学习是从动物学习、参数扰动自适应控制等理论发展而来，其基本原理是：如果Agent的某个行为策略导致环境正的奖赏(强化信号)，那么Agent以后产生这个行为策略的趋势便会加强。Agent的目标是在每个离散状态发现最优策略以使期望的折扣奖赏和最大。 强化学习把学习看作试探评价过程，Agent选择一个动作用于环境，环境接受该动作后状态发生变化，同时产生一个强化信号(奖或惩)反馈给Agent，Agent根据强化信号和环境当前状态再选择下一个动作，选择的原则是使受到正强化(奖)的概率增大。选择的动作不仅影响立即强化值，而且影响环境下一时刻的状态及最终的强化值。 强化学习不同于连接主义学习中的监督学习，主要表现在教师信号上，强化学习中由环境提供的强化信号是Agent对所产生动作的好坏作一种评价(通常为标量信号)，而不是告诉Agent如何去产生正确的动作。由于外部环境提供了很少的信息，Agent必须靠自身的经历进行学习。通过这种方式，Agent在行动一一评价的环境中获得知识，改进行动方案以适应环境。 强化学习系统学习的目标是动态地调整参数，以达到强化信号最大。若已知r/A梯度信息，则可直接可以使用监督学习算法。因为强化信号r与Agent产生的动作A没有明确的函数形式描述，所以梯度信息r/A无法得到。因此，在强化学习系统中，需要某种随机单元，使用这种随机单元，Agent在可能动作空间中进行搜索并发现正确的动作。 是否可以从传入的数据流中进行增量学习： 在线学习（Online Learning） 可以进行增量学习。 训练快速，资源需求低。 快速学习新数据。 需要持续的输入数据流，同时也对输入敏感。 批量学习（Batch Learning） 无法进行增量学习。 需要大量时间和计算资源。 通常离线完成。 如需要学习新数据，需要重新训练。 如何在未见过的示例上进行预测（泛化）： 基于实例的学习（Based on Instance Learning） 用相似度度量来比较新实例和已经学习的实例（或它们的子集），从而泛化新实例。 基于模型的学习（Based on Model Learning） 从已知实例中构建模型，然后用模型来进行预测。 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"过拟合与欠拟合 机器学习的主要挑战任务是我们的模型能够在先前未观测的新输入上表现良好，而不是仅仅在训练数据集上效果良好。这儿，将在先前未观测输入上的表现能力称之为泛化（generalization）。 通过训练数据集训练模型后在训练数据上进行的一些误差计算称之为训练误差（training error） 在进行机器学习建模时我们不仅希望我们的训练误差很小，同时我们的最终目的是使得测试误差（test error）很小，也就是泛化误差（Generalization error）很小。 $$ \\frac{1}{m^{(train)}}||X^{(train)}w-y^{(train)}||_2^2 $$ $$ \\frac{1}{m^{(test)}}||X^{(test)}w-y^{(test)}||_2^2 $$ ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"评价指标 机器学习适用于： 有解决方案（但解决方案需要进行大量人工微调或需要遵循大量规则）的问题。 传统方法难以解决的复杂问题。 环境有波动。 洞察复杂问题和大量数据。 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"线性回归 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"范数正则与Lasso详解 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"最大似然估计 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"线性判别式分析 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"决策树 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"ID3 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"C4.5 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"朴素贝叶斯 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"感知机 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"最大熵模型 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"支持向量机 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"支持向量回归机 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:9:1","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"神经网络 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"前向传播 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:10:1","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"反向传播 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:10:2","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"激活函数 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:10:3","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"损失函数 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:10:4","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"集成学习 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"boosting 与 bagging ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"随机森林 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:11:2","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"聚类 ","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"K-Means","date":"2021-05-03","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/:12:1","series":null,"tags":[],"title":"机器学习教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Windows： AnyDesk：远程桌面软件。 Bandizip：压缩文件管理工具。 Everything：基于名称快速定位文件和文件夹。 Potplayer：多媒体播放器。 Revo Uninstaller：软件卸载和清除管理器。 MobaXterm：远程连接管理器。 Visual Studio Code：代码编辑器。 JetBrains Toolbox：JetBrains IDE 管理器。 Visual Studio：C++、C# 开发IDE。 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:0:0","series":null,"tags":[],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"},{"categories":[],"content":"description 标题 An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling 作者 Shaojie Bai, J. Zico Kolter, Vladlen Koltun 日期 2018.03 引用 1180 地址 https://arxiv.org/pdf/1803.01271.pdf ","date":"2021-04-19","objectID":"/posts/an-empirical-evaluation-of-generic-convolutional-and-recurrent-networks-for-sequence-modeling/:0:0","series":null,"tags":[],"title":"An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling","uri":"/posts/an-empirical-evaluation-of-generic-convolutional-and-recurrent-networks-for-sequence-modeling/"},{"categories":[],"content":"参考 Sequence Modeling Benchmarks and Temporal Convolutional Networks (TCN) - Github Keras TCN Temporal Convolutional Networks and Forecasting - Medium TCN 时间卷积网络 - 知乎 ","date":"2021-04-19","objectID":"/posts/an-empirical-evaluation-of-generic-convolutional-and-recurrent-networks-for-sequence-modeling/:1:0","series":null,"tags":[],"title":"An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling","uri":"/posts/an-empirical-evaluation-of-generic-convolutional-and-recurrent-networks-for-sequence-modeling/"},{"categories":[],"content":"从 YouTube 和其他视频网站下载视频的命令行程序。 ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"一、介绍 官网 Github ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"二、安装 Windows: 下载exe，然后添加环境变量。 pip install --upgrade youtube-dl # 列出帮助菜单 youtube-dl -h/--help # 查看版本 youtube-dl --version # 升级 youtube-dl -U/--update ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"三、使用 # 列出所有清晰度和格式 youtube-dl -F/--list-formats \u003cURL\u003e # 下载对应格式或清晰度 youtube-dl -f/--format \u003cFORMAT\u003e \u003cURL\u003e # 下载后视频和音频合并 youtube-dl -f XXX+YYY \u003cURL\u003e # 下载最佳质量 youtube-dl -f bestvideo+bestaudio \u003cURL\u003e # 列出所有字幕 youtube-dl --list-subs \u003cURL\u003e # 下载英文（en）字幕，格式为 srt youtube-dl --sub-lang en --write-auto-sub --sub-format srt --skip-download \u003cURL\u003e # 代理 youtube-dl --proxy \u003cURL\u003e # cookies youtube-dl --cookies \u003cFILE\u003e # 登录 youtube-dl -u/--username \u003cUSERNAME\u003e youtube-dl -p/--password \u003cPASSWORD\u003e youtube-dl -2/--twofactor \u003cTWOFACTOR\u003e youtube-dl --video-password \u003cPASSWORD\u003e ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"文件 项目结构： app \u003e java \u003e com.example.myfirstapp \u003e MainActivity：这是主 activity。它是应用的入口点。当您构建和运行应用时，系统会启动此 Activity 的实例并加载其布局。 app \u003e res \u003e layout \u003e activity_main.xml：此 XML 文件定义了 activity 界面 (UI) 的布局。 app \u003e manifests \u003e AndroidManifest.xml：清单文件描述应用的基本特性并定义其每个组件。 Gradle Scripts \u003e build.gradle：有两个使用此名称的文件：一个针对项目“Project: My First App”，另一个针对应用模块“Module: app”。每个模块均有自己的 build.gradle 文件，但此项目当前仅有一个模块。使用每个模块的 build.gradle 文件控制 Gradle 插件构建应用的方式。 ","date":"2021-04-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Android 开发教程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"运行应用 ","date":"2021-04-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Android 开发教程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"在真实设备上运行 手机 USB 连接到电脑。 手机打开开发者选项。 对于 MIUI，进入设置 \u003e 全部参数 \u003e MIUI 版本，连续点击七次，然后进入设置 \u003e 更多设置 \u003e 开发者选项中打开USB 调试和USB安装。 在 Android Studio 中，从顶部的设备下拉菜单中选择你的手机。 ","date":"2021-04-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"Android 开发教程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"在模拟器上运行 在 Android Studio 中创建一个 Android 虚拟设备 (AVD)，模拟器可以使用该设备安装和运行您的应用。 在 Android Studio 中，从顶部的设备下拉菜单中选择你的 AVD。 ","date":"2021-04-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"Android 开发教程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"界面 ","date":"2021-04-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Android 开发教程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"构建简单的界面 Android 应用的界面 (UI) 以布局和微件的层次结构形式构建而成。布局是 ViewGroup 对象，即控制其子视图在屏幕上的放置方式的容器。微件是 View 对象，即按钮和文本框等界面组件。 Android 提供了 ViewGroup 和 View 类的 XML 词汇表，因此界面的大部分内容都在 XML 文件中定义。布局编辑器会在您拖放视图构建布局时为您编写 XML 代码。 布局编辑器： 打开app \u003e res \u003e layout \u003e activity_main.xml。 如果您的编辑器显示 XML 源代码，请点击窗口右上角的Design。 点击(Select Design Surface)，然后选择Blueprint。 点击布局编辑器工具栏中的(View Options)，并确保选中Show All Constraints。 确保 Autoconnect 处于关闭状态。当 Autoconnect 处于关闭状态时，工具栏中的提示会显示(Enable Autoconnection to Parent)。 点击工具栏中的(Default Margins)，然后选择16。 点击工具栏中的(Device for Preview)，然后选择5.5, 1440 × 2560, 560 dpi (Pixel XL)。 左下方的 Component Tree 面板显示布局的视图层次结构。 ConstraintLayout是一种布局，它根据同级视图和父布局的约束条件定义每个视图的位置。这样一来，使用扁平视图层次结构既可以创建简单布局，又可以创建复杂布局。这种布局无需嵌套布局。 添加文本框： 在 Component Tree 面板中点击 TextView，然后按 Delete 键。 在 Palette 面板中，点击 Text 以显示可用的文本控件。 将 Plain Text 拖动到设计编辑器中，并将其放在靠近布局顶部的位置。这是一个接受纯文本输入的 EditText 微件。 点击并按住顶边上的锚点，将其向上拖动，直至其贴靠到布局顶部，然后将其释放。这是一个约束条件：它会将视图约束在已设置的默认外边距内。 更改界面字符串： 打开app \u003e res \u003e values \u003e strings.xml。这是一个字符串资源文件，您可在此文件中指定所有界面字符串。您可以利用该文件在一个位置管理所有界面字符串，使字符串的查找、更新和本地化变得更加容易。 点击窗口顶部的 Open editor。此时将打开 Translations Editor，它提供了一个可以添加和修改默认字符串的简单界面。它还有助于让所有已翻译的字符串井然有序。 Material Design Training Courses | Android Developers ","date":"2021-04-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":[],"title":"Android 开发教程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"},{"categories":["Hugo"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:0:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"1 网站配置 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"1.1 基础配置 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"1.2 完整配置 [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = false # 目录配置 [params.page.toc] # 是否使用目录 enable = true # 是否保持使用文章前面的静态目录 keepStatic = true # 是否使侧边目录自动折","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"2.网站图标，浏览器配置，网站清单 强烈建议你把： apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在/static目录，利用 RealFaviconGenerator 可以很容易地生成这些文件。 可以自定义browserconfig.xml和site.webmanifest文件来设置 theme-color 和 background-color。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"3.自定义样式 需使用 Hugo extended 版本 通过自定义.scss样式文件，LoveIt 主题支持自定义的样式。 包含自定义.scss样式文件的路径为assets/css。 在assets/css/_override.scss中，你可以覆盖themes/LoveIt/assets/css/_variables.scss中的变量以自定义样式。 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在assets/css/_custom.scss中，你可以添加一些 CSS 样式代码以自定义样式。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"4.多语言和 i18n Hugo 配置多语言支持 一个支持英语和中文的网站配置： # [en, zh-cn, fr, pl, ...] 默认语言 defaultContentLanguage = \"zh-cn\" [languages] # 英语 [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 # 中文 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 然后，对于每个新页面，将语言代码附加到文件名中。 单个文件my-page.md需要分为三个文件： 英语：my-page.en.md 中文：my-page.zh-cn.md 也可使用 文章前置参数 来翻译文章。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值。 目前提供一些语言的翻译，但你可能自定义其他语言或覆盖默认值。 要覆盖默认值，请在你项目的 i18n 目录i18n/\u003clanguageCode\u003e.toml中创建一个新文件，并从themes/LoveIt/i18n/en.toml中获得提示。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"5.搜索 基于 Lunr.js 或 algolia，LoveIt 主题支持搜索功能。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"5.1 输出配置 为了生成搜索功能所需要的index.json，请在你的网站配置中添加JSON输出文件类型到outputs部分的home字段中。 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"5.2 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"5.3 比较 lunr：简单，无需同步index.json，没有contentLength的限制，但占用带宽大且性能低（特别是中文需要一个较大的分词依赖库） algolia：高性能并且占用带宽低，但需要同步index.json且有contentLength的限制 文章内容被h2和h3HTML 标签切分来提高查询效果并且基本实现全文搜索。contentLength用来限制h2和h3HTML 标签开头的内容部分的最大长度。 algolia：你需要上传index.json到 algolia 来激活搜索功能，你可以使用浏览器来上传index.json文件。但是一个自动化的脚本可能效果更好，Algolia Atomic 是一个不错的选择。为了兼容 Hugo 的多语言模式，你需要上传不同语言的index.json文件到对应的 algolia index，例如zh-cn/index.json或en/index.json…… ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:3","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"6.内容 文本内容组织 保持博客文章存放在content/posts目录，例如：content/posts/我的第一篇文章.md 保持简单的静态页面存放在content目录，例如：content/about.md 本地媒体资源引用 使用页面包中的页面资源。你可以使用适用于Resources.GetMatch的值或者直接使用相对于当前页面目录的文件路径来引用页面资源。 将本地资源放在assets目录中，默认路径是/assets。引用资源的文件路径是相对于assets目录的。 将本地资源放在static目录中，默认路径是/static。引用资源的文件路径是相对于static目录的。 引用的优先级符合以上的顺序。 在这个主题中的很多地方可以使用上面的本地资源引用，例如：链接、图片、image shortcode、music shortcode、和前置参数中的部分参数. 页面资源或者assets目录中的图片处理会在未来的版本中得到支持。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"7.前置参数 只有在文章的参数和你的网站设置中的page部分不一致时才有必要显式设置。 --- title: \"My first blog\" # 标题 subtitle: \"\" # 副标题 date: 2020-03-04T15:58:26+08:00 # 创建日期 lastmod: 2020-03-04T15:58:26+08:00 # 修改日期 draft: true # 是否草稿 author: \"\" # 作者 authorLink: \"\" # 作者链接 description: \"\" # 内容描述 license: \"\" # 文章许可 images: [] # 页面图片,用于 Open Graph 和 Twitter Cards tags: [] # 标签 categories: [] # 分类 featuredImage: \"\" # 特色图片 featuredImagePreview: \"\" # 主页预览的图片 hiddenFromHomePage: false # 是否从主页上隐藏 hiddenFromSearch: false # 是否从搜索中隐藏 twemoji: false # 是否使用 twemoji lightgallery: true # 图片是否按照画廊形式呈现 ruby: true # 是否使用上标注释扩展语法 fraction: true # 是否使用分数扩展语法 fontawesome: true # 是否使用 Font Awesome 扩展语法 linkToMarkdown: true # 页脚是否显示指向原始 Markdown 文件的链接 rssFullText: false # RSS 中是否显示全文内容 toc: # 和 params.page.toc 部分相同 enable: true auto: true code: # 和 params.page.code 部分相同 copy: true # ... math: # 和 params.page.math 部分相同 enable: true # ... mapbox: # 和 params.page.mapbox 部分相同 accessToken: \"\" # ... share: # 和 params.page.share 部分相同 enable: true # ... comment: # 和 params.page.comment 部分相同 enable: true # ... library: # 和 params.page.library 部分相同 css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: # 和 params.page.seo 部分相同 images: [] # ... --- ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:7:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":["Hugo"],"content":"8.内容摘要","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:8:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"categories":[],"content":"You-Get 是一个轻量级命令行工具，可以方便的从一些网站上下载媒体内容（视频、音频、图像）。 ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"一、介绍 官网 Github ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"二、安装 pip install --upgrade you-get ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"三、使用 # 查看所有可选质量与格式 you-get -i/--info \u003cURL\u003e # 自定义下载文件路径和名称 you-get -o/--output-dir \u003cPATH\u003e \u003cURL\u003e you-get -O/--output-filename \u003cFILENAME\u003e \u003cURL\u003e # 代理 you-get -x/--http-proxy \u003cPROXY_IP:PORT\u003e \u003cURL\u003e # cookies you-get --cookies/-c \u003ccookies.txt/cookies.sqlite\u003e \u003cURL\u003e ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"3.1 cookie 获取 Chrome 扩展程序：Get cookies.txt ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"四、支持网站 YouTube bilibili ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"FFmpeg 是视频处理最常用的开源软件。 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"常用参数 -c：指定编码器。-c copy：直接复制，不重新编码，加快生成速度 -c:v或-vcodec：指定视频编码器。-c:v copy或-vcodec copy：不改变视频编码，直接拷贝 -c:a或-acodec：指定音频编码器。-c:a copy或-acodec copy：不改变音频编码，直接拷贝 -i：指定输入文件 -an：去除音频流 -vn：去除视频流 -preset：指定输出的视频质量，会影响生成速度。可用值：ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow -y：不经过确认，输出时直接覆盖同名文件 -hwaccel cuvid：指定使用 cuvid 硬件加速 举例： ffmpeg -y -c:a libfdk_aac -c:v libx264 -i input.mp4 -c:a libvorbis -c:v libvpx-vp9 output.webm ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"格式转换 ffmpeg -i input.webm output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"提取视频中的音频 ffmpeg -i input.mp4 -vn -acodec copy output.aac ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"去除视频中的音频 ffmpeg -i input.mp4 -an -vcodec copy output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"合并音频和视频 视频不包含音频： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental output.mp4 视频包含音频，需要被替换： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental -map 0:v:0 -map 1:a:0 output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"视频截图 在第 4.5s 截取一帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 1 output.png 在第 4.5s 截取 10 帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 10 output%d.png ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":[],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"常用算法模板库。 ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:0:0","series":null,"tags":[],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/"},{"categories":[],"content":"滑动窗口 ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:1:0","series":null,"tags":[],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/"},{"categories":[],"content":"二分查找 int binarySearch(vector\u003cint\u003e arr, const int target) { // 升序数组 // [low, high] int low = 0, high = arr.size() - 1, mid; while (low \u003c= high) { mid = low + (high - low) / 2; if (target == arr[mid]) { return mid; } else if (target \u003e arr[mid]) { low = mid + 1; } else { high = mid - 1; } } return -1; } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:2:0","series":null,"tags":[],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/"},{"categories":[],"content":"小技巧 头文件 #include\u003cbits/stdc++.h\u003e 判断奇偶 if (x \u0026 1) // 奇数，等价于 x % 2 else // 偶数 快速乘除2 x \u003c\u003c= 1; // 乘2，等价于 x *= 2; x \u003e\u003e= 1; // 除2，等价于 x /= 2; 快速交换 a ^= b; // a1 = a ^ b b ^= a; // b1 = b ^ a1 = b ^ a ^ b = a a ^= b; // a2 = a1 ^ b1 = a ^ b ^ a = b 遍历字符串 for (int i = 0; s[i]; i++) 使用 emplace_back() 代替 push_back() 内置求最大公约数函数：__gcd(x, y); 使用 inline 函数 全局数组最大 $ 10^7 $，函数内数组最大 $ 10^6 $ 得到最高有效位数字 double k = log(n, 10); k -= floor(k); x = pow(10, k); 得到数字的有效位数 n = floor(log(n, 10)) + 1; 判断是否是 2 的幂（Brian Kernighan’s Algorithm） // log(n) n \u0026\u0026 (!(n \u0026 (n - 1))) C++11 内置 STL 函数 // 是否全是正数？ all_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否存在正数 any_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否全不是正数？ none_of(first, first + n, [](int x) { return x \u003e 0; }); // 复制 int source[5] = {0, 12, 34, 50, 80}; int target[5]; copy_n(source, 5, target); // 迭代 int a[5] = {0}; char c[3] = {0}; iota(a, a + 5, 10); // {10, 11, 12, 13, 14} iota(c, c + 3, 'a'); // {'a', 'b', 'c'} 二进制表示 auto number = 0b011; cout \u003c\u003c number; // 3 Using Range based for loop ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:0","series":null,"tags":[],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/"},{"categories":["二分查找","力扣每日一题"],"content":"题目链接 ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:0:0","series":null,"tags":["二分查找"],"title":"力扣每日一题 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"},{"categories":["二分查找","力扣每日一题"],"content":"方法一：两次二分查找 易知： 每行升序 每列升序 所以，我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e matrix, int target) { auto row = upper_bound(matrix.begin(), matrix.end(), target, [](const int b, const vector\u003cint\u003e \u0026a) { return b \u003c a[0]; }); if (row == matrix.begin()) { return false; } --row; return binary_search(row-\u003ebegin(), row-\u003eend(), target); } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int rowIndex = binarySearchFirstColumn(matrix, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], target); } public int binarySearchFirstColumn(int[][] matrix, int target) { int low = -1, high = matrix.length - 1; while (low \u003c high) { int mid = (high - low + 1) / 2 + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } public boolean binarySearchRow(int[] row, int target) { int low = 0, high = row.length - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; if (row[mid] == target) { return true; } else if (row[mid] \u003e target) { high = mid - 1; } else { low = mid + 1; } } return false; } } int binarySearchFirstColumn(int** matrix, int matrixSize, int target) { int low = -1, high = matrixSize - 1; while (low \u003c high) { int mid = (high - low + 1) / 2 + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } bool binarySearchRow(int* row, int rowSize, int target) { int low = 0, high = rowSize - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; if (row[mid] == target) { return true; } else if (row[mid] \u003e target) { high = mid - 1; } else { low = mid + 1; } } return false; } bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) { int rowIndex = binarySearchFirstColumn(matrix, matrixSize, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target); } var searchMatrix = function(matrix, target) { const rowIndex = binarySearchFirstColumn(matrix, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], target); }; const binarySearchFirstColumn = (matrix, target) =\u003e { let low = -1, high = matrix.length - 1; while (low \u003c high) { const mid = Math.floor((high - low + 1) / 2) + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } const binarySearchRow = (row, target) =\u003e { let low = 0, high = row.length - 1; while (low \u003c= high) { const mid = Math.floor((high - low) / 2) + low; if (row[mid] == target) { return true; } else if (row[mid] \u003e target) { high = mid - 1; } else { low = mid + 1; } } return false; } func searchMatrix(matrix [][]int, target int) bool { row := sort.Search(len(matrix), func(i int) bool { return matrix[i][0] \u003e target }) - 1 if row \u003c 0 { return false } col := sort.SearchInts(matrix[row], target) return col \u003c len(matrix[row]) \u0026\u0026 matrix[row][col] == target } 时间复杂度：$ O(\\log m + \\log n)=O(\\log mn) $ ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:1:0","series":null,"tags":["二分查找"],"title":"力扣每日一题 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"},{"categories":["二分查找","力扣每日一题"],"content":"方法二：一次二分查找 根据特性可将二维数组看作一维的升序数组，再使用二分搜索查找。（要求二维数组每行元素个数相等） class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; // 中位数映射到行和列 if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } } bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) { int m = matrixSize, n = matrixColSize[0]; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } var searchMatrix = function(matrix, target) { const m = matrix.length, n = matrix[0].length; let low = 0, high = m * n - 1; while (low \u003c= high) { const mid = Math.floor((high - low) / 2) + low; const x = matrix[Math.floor(mid / n)][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; }; func searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) i := sort.Search(m*n, func(i int) bool { return matrix[i/n][i%n] \u003e= target }) return i \u003c m*n \u0026\u0026 matrix[i/n][i%n] == target } 时间复杂度：$ O(\\log mn) $ ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:2:0","series":null,"tags":["二分查找"],"title":"力扣每日一题 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"},{"categories":[],"content":"Java ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:0:0","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"ActiveMQ 消息中间件 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:0","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"1.什么是 ActiveMQ ？ ActiveMQ 是一种开源的，实现了 JMS1.1 规范的，面向消息（MOM）的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:1","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"2.ActiveMQ 服务器宕机怎么办？ 这得从 ActiveMQ 的储存机制说起。在通常的情况下，非持久化消息是存储在内存中的，持久化消息是存储在文件中的，它们的最大限制在配置文件的\u003csystemUsage\u003e节点中配置。但是，在非持久化消息堆积到一定程度，内存告急的时候，ActiveMQ 会将内存中的非持久化消息写入临时文件中，以腾出内存。虽然都保存到了文件里，但它和持久化消息的区别是，重启后持久化消息会从文件中恢复，非持久化的临时文件会直接删除。 那如果文件增大到达了配置中的最大限制的时候会发生什么？我做了以下实验： 设置 2G 左右的持久化文件限制，大量生产持久化消息直到文件达到最大限制，此时生产者阻塞，但消费者可正常连接并消费消息，等消息消费掉一部分，文件删除又腾出空间之后，生产者又可继续发送消息，服务自动恢复正常。 设置 2G 左右的临时文件限制，大量生产非持久化消息并写入临时文件，在达到最大限制时，生产者阻塞，消费者可正常连接但不能消费消息，或者原本慢速消费的消费者，消费突然停止。整个系统可连接，但是无法提供服务，就这样挂了。 具体原因不详，解决方案：尽量不要用非持久化消息，非要用的话，将临时文件限制尽可能的调大。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:2","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"3.丢消息怎么办？ 这得从 java 的 java.net.SocketException 异常说起。简单点说就是当网络发送方发送一堆数据，然后调用 close 关闭连接之后。这些发送的数据都在接收者的缓存里，接收者如果调用 read 方法仍旧能从缓存中读取这些数据，尽管对方已经关闭了连接。但是当接收者尝试发送数据时，由于此时连接已关闭，所以会发生异常，这个很好理解。不过需要注意的是，当发生 SocketException 后，原本缓存区中数据也作废了，此时接收者再次调用 read 方法去读取缓存中的数据，就会报 Software caused connection abort: recv failed 错误。 通过抓包得知，ActiveMQ 会每隔 10 秒发送一个心跳包，这个心跳包是服务器发送给客户端的，用来判断客户端死没死。如果你看过上面第一条，就会知道非持久化消息堆积到一定程度会写到文件里，这个写的过程会阻塞所有动作，而且会持续 20 到 30 秒，并且随着内存的增大而增大。当客户端发完消息调用 connection.close() 时，会期待服务器对于关闭连接的回答，如果超过 15 秒没回答就直接调用 socket 层的 close 关闭 tcp 连接了。这时客户端发出的消息其实还在服务器的缓存里等待处理，不过由于服务器心跳包的设置，导致发生了 java.net.SocketException 异常，把缓存里的数据作废了，没处理的消息全部丢失。 解决方案：用持久化消息，或者非持久化消息及时处理不要堆积，或者启动事务，启动事务后，commit() 方法会负责任的等待服务器的返回，也就不会关闭连接导致消息丢失了。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:3","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"4.持久化消息非常慢 默认的情况下，非持久化的消息是异步发送的，持久化的消息是同步发送的，遇到慢一点的硬盘，发送消息的速度是无法忍受的。但是在开启事务的情况下，消息都是异步发送的，效率会有 2 个数量级的提升。所以在发送持久化消息时，请务必开启事务模式。其实发送非持久化消息时也建议开启事务，因为根本不会影响性能。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:4","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"5.消息的不均匀消费 有时在发送一些消息之后，开启 2 个消费者去处理消息。会发现一个消费者处理了所有的消息，另一个消费者根本没收到消息。原因在于 ActiveMQ 的 prefetch 机制。当消费者去获取消息时，不会一条一条去获取，而是一次性获取一批，默认是 1000 条。这些预获取的消息，在还没确认消费之前，在管理控制台还是可以看见这些消息的，但是不会再分配给其他消费者，此时这些消息的状态应该算作“已分配未消费”，如果消息最后被消费，则会在服务器端被删除，如果消费者崩溃，则这些消息会被重新分配给新的消费者。但是如果消费者既不消费确认，又不崩溃，那这些消息就永远躺在消费者的缓存区里无法处理。更通常的情况是，消费这些消息非常耗时，你开了 10 个消费者去处理，结果发现只有一台机器吭哧吭哧处理，另外 9 台啥事不干。 解决方案：将 prefetch 设为 1，每次处理 1 条消息，处理完再去取，这样也慢不了多少。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:5","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"6.死信队列 如果你想在消息处理失败后，不被服务器删除，还能被其他消费者处理或重试，可以关闭 AUTO_ACKNOWLEDGE，将 ack 交由程序自己处理。那如果使用了 AUTO_ACKNOWLEDGE，消息是什么时候被确认的，还有没有阻止消息确认的方法？有。 消费消息有 2 种方法，一种是调用 consumer.receive() 方法，该方法将阻塞直到获得并返回一条消息。这种情况下，消息返回给方法调用者之后就自动被确认了。另一种方法是采用 listener 回调函数，在有消息到达时，会调用 listener 接口的 onMessage 方法。在这种情况下，在 onMessage 方法执行完毕后，消息才会被确认，此时只要在方法中抛出异常，该消息就不会被确认。那么问题来了，如果一条消息不能被处理，会被退回服务器重新分配，如果只有一个消费者，该消息又会重新被获取，重新抛异常。就算有多个消费者，往往在一个服务器上不能处理的消息，在另外的服务器上依然不能被处理。难道就这么退回–获取–报错死循环了吗？ 在重试 6 次后，ActiveMQ 认为这条消息是“有毒”的，将会把消息丢到死信队列里。如果你的消息不见了，去 ActiveMQ.DLQ 里找找，说不定就躺在那里。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:6","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"7. ActiveMQ 中的消息重发时间间隔和重发次数吗？ ActiveMQ：是 Apache 出品，最流行的，能力强劲的开源消息总线。是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。JMS（Java 消息服务）：是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 首先，我们得大概了解下，在哪些情况下，ActiveMQ 服务器会将消息重发给消费者，这里为简单起见，假定采用的消息发送模式为队列（即消息发送者和消息接收者）。 如果消息接收者在处理完一条消息的处理过程后没有对 MOM 进行应答，则该消息将由 MOM 重发. 如果我们队某个队列设置了预读参数（consumer.prefetchSize），如果消息接收者在处理第一条消息时（没向 MOM 发送消息接收确认）就宕机了，则预读数量的所有消息都将被重发! 如果 Session 是事务的，则只要消息接收者有一条消息没有确认，或发送消息期间 MOM 或客户端某一方突然宕机了，则该事务范围中的所有消息 MOM 都将重发。 说到这里，大家可能会有疑问，ActiveMQ 消息服务器怎么知道消费者客户端到底是消息正在处理中还没来得急对消息进行应答还是已经处理完成了没有应答或是宕机了根本没机会应答呢？其实在所有的客户端机器上，内存中都运行着一套客户端的 ActiveMQ 环境，该环境负责缓存发来的消息，负责维持着和 ActiveMQ 服务器的消息通讯，负责失效转移（fail-over）等，所有的判断和处理都是由这套客户端环境来完成的。 我们可以来对 ActiveMQ 的重发策略（Redelivery Policy）来进行自定义配置，其中的配置参数主要有以下几个： 属性 默认值 说明 collisionAvoidanceFactor 0.15 设置防止冲突范围的正负百分比，只有启用 useCollisionAvoidance 参数时才生效 maximumRedeliveries 6 最大重传次数，达到最大重连次数后抛出异常。为 -1 时不限制次 数，为 0 时表示不进行重传 maximumRedeliveryDelay -1 最大传送延迟，只在 useExponentialBackOff 为 true 时有效 （V5.5），假设首次重连间隔为 10ms，倍数为 2，那么第二次重连时间间隔为 20ms，第三次重连时间 间隔为 40ms，当重连时间间隔大的最大重连时间间隔时，以后每次重连时间间隔都为最大重连时间间隔 initialRedeliveryDelay 1000L 初始重发延迟时间 redeliveryDelay 1000L 重发延迟时间，当 initialRedeliveryDelay=0 时生效（v5.4） useCollisionAvoidance false 启用防止冲突功能，因为消息接收时是可以使用多线程并发处理的，应该是为了重发的安全性，避开所有并发线程都在同一个时间点进行消息接收处理。所有线程在同一个时间点处理时会发生什么问题呢？应该没有问题，只是为了平衡 broker 处理性能，不会有时很忙， 有时很空闲 useExponentialBackOff false 启用指数倍数递增的方式增加延迟时间 backOffMultiplier 5 重连时间间隔递增倍数，只有值大于 1 和启用 useExponentialBackOff 参数时才生效 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:7","series":null,"tags":[],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/"},{"categories":[],"content":"规则 [abc]a 或 b 或 c ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"常用正则表达式 整数：^-?\\d+$ 自然数（非负整数）：^\\d+$ 正整数：^[0-9]*[1-9][0-9]*$ 非正整数：^((-\\d+) ?(0+))$ 负整数：^-[0-9]*[1-9][0-9]*$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 非负浮点数：^\\d+(\\.\\d+)?$ 正浮点数：^(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*))$ 非正浮点数：^((-\\d+(\\.\\d+)?) ?(0+(\\.0+)?))$ 负浮点数：^(-(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*)))$ 下划线、数字和大小写字母：^\\w+$ 数字和大小写字母：^[A-Za-z0-9]+$ 大小写字母：^[A-Za-z]+$ 大写字母：^[A-Z]+$ 小写字母：^[a-z]+$ 中文字符：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff]，可以用来计算字符串的长度 空行：\\n[\\s ? ]*\\r，可以用来删除空白行 HTML标记：/ \u003c(.*)\u003e.* \u003c\\/\\1\u003e ? \u003c(.*) \\/\u003e/，仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 首尾空格：(^\\s*) ?(\\s*$) ^\\s* ?\\s*$，可以用来删除行首行尾的空白字符 规则： ^\\S+[a-z A-Z]$：非空、大小写字母 电子邮件：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 网址（URL）：(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$ [a-zA-z]+://[^\\s]* 命名规则（字母开头，长度5-16，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 中国座机号码：\\d{3}-\\d{8} ?\\d{4}-\\d{7} QQ号：[1-9][0-9]{4,} 中国邮政编码：[1-9]\\d{5}(?!\\d) 中国身份证：\\d{15} ?\\d{18} IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/"},{"categories":["力扣每日一题"],"content":"题目链接 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:0:0","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"方法一：逐位颠倒 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:0","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"思路 将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。 代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:1","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"代码 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } }; public class Solution { public int reverseBits(int n) { int rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n != 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev; } } uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } var reverseBits = function(n) { let rev = 0; for (let i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev \u003e\u003e\u003e 0; }; func reverseBits(n uint32) (rev uint32) { for i := 0; i \u003c 32 \u0026\u0026 n \u003e 0; i++ { rev |= n \u0026 1 \u003c\u003c (31 - i) n \u003e\u003e= 1 } return } ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:2","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"复杂度 时间复杂度：$ O(\\log n) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:3","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"方法二：位运算分治 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:0","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"思路 若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。 由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。 对于递归的最底层，我们需要交换所有奇偶位： 取出所有奇数位和偶数位； 将奇数位移到偶数位上，偶数位移到奇数位上。 类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:1","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"代码 class Solution { private: const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 public: uint32_t reverseBits(uint32_t n) { n = n \u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e 16 | n \u003c\u003c 16; } }; public class Solution { private static final int M1 = 0x55555555; // 01010101010101010101010101010101 private static final int M2 = 0x33333333; // 00110011001100110011001100110011 private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111 public int reverseBits(int n) { n = n \u003e\u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e\u003e 16 | n \u003c\u003c 16; } } const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 uint32_t reverseBits(uint32_t n) { n = n \u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e 16 | n \u003c\u003c 16; } var reverseBits = function(n) { const M1 = 0x55555555; // 01010101010101010101010101010101 const M2 = 0x33333333; // 00110011001100110011001100110011 const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const M8 = 0x00ff00ff; // 00000000111111110000000011111111 n = n \u003e\u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return (n \u003e\u003e\u003e 16 | n \u003c\u003c 16) \u003e\u003e\u003e 0; }; const ( m1 = 0x55555555 // 01010101010101010101010101010101 m2 = 0x33333333 // 00110011001100110011001100110011 m4 = 0x0f0f0f0f // 00001111000011110000111100001111 m8 = 0x00ff00ff // 00000000111111110000000011111111 ) func reverseBits(n uint32) uint32 { n = n\u003e\u003e1\u0026m1 | n\u0026m1\u003c\u003c1 n = n\u003e\u003e2\u0026m2 | n\u0026m2\u003c\u003c2 n = n\u003e\u003e4\u0026m4 | n\u0026m4\u003c\u003c4 n = n\u003e\u003e8\u0026m8 | n\u0026m8\u003c\u003c8 return n\u003e\u003e16 | n\u003c\u003c16 } ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:2","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["力扣每日一题"],"content":"复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:3","series":null,"tags":["位运算","分治法"],"title":"力扣每日一题 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":[],"content":"1.假设检验 在总体的分布函数完全未知或只知其形式、但不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。我们要根据样本对所提出的假设作出是接受，还是拒绝的决策。假设检验是作出这一决策的过程。 步骤： 提出原假设（$H_0$）和备择假设（$H_1$）。 找到合适的检验统计量。 带入数据计算看结果是否落入拒绝域。 若结果在拒绝域中，则拒绝原假设。 得到拒绝原假设的结论。 两类错误： 第Ⅰ类错误（弃真）：$H_0$实际上为真时拒绝$H_0$。 第Ⅱ类错误（取伪）：$H_0$实际上为假时接受$H_0$。 我们应尽可能使犯两类错误的概率都较小，但是，当样本容量固定时，若减小犯一类错误的概率，则犯另一类错误的概率往往增大。若要使犯两类错误的概率都减小，除非增加样本容量。 一般来说，我们总是控制犯第Ⅰ类错误的概率，使它不大于$\\alpha$，而不考虑犯第Ⅱ类错误的概率的检验，称为显著性检验。 假设类型： 双边检验：$H_0:\\mu=\\mu_0,H_1:\\mu\\ne\\mu_0$ 单边检验 右边检验：$H_0:\\mu\\le\\mu_0,H_1:\\mu\\gt\\mu_0$ 左边检验：$H_0:\\mu\\ge\\mu_0,H_1:\\mu\\lt\\mu_0$ ","date":"2021-03-28","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:1:0","series":null,"tags":[],"title":"概率论与数理统计 08 假设检验","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":[],"content":"正态总体均值的假设检验 ","date":"2021-03-28","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:2:0","series":null,"tags":[],"title":"概率论与数理统计 08 假设检验","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":[],"content":"1.1.正态总体，检验期望（期望未知，方差已知） ","date":"2021-03-28","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:2:1","series":null,"tags":[],"title":"概率论与数理统计 08 假设检验","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":[],"content":"1.2.正态总体，检验期望（期望未知，方差未知） ","date":"2021-03-28","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:2:2","series":null,"tags":[],"title":"概率论与数理统计 08 假设检验","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":[],"content":"1.3.正态总体，检验方差","date":"2021-03-28","objectID":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:2:3","series":null,"tags":[],"title":"概率论与数理统计 08 假设检验","uri":"/posts/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-08-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["LaTeX"],"content":"源文件：.tex 生成文件：.pdf ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Preamble % preamble start \\documentclass[12pt, letterpaper]{article} \\usepackage[utf8]{inputenc} \\title{LaTeX Tutorials} \\author{Backsided \\thanks{funded by the Overleaf team}} \\date{December 2020} % preamble end \\begin{document} Hello World LaTeX! \\end{document} \\documentclass[12pt, letterpaper]{article} define the type of document (article). article for short documents and journal articles, most commonly used. report for longer documents and dissertations. book for write books. letter for letters. slides for slides, rarely used. beamer for slides in the Beamer class format. set the font size (12pt), the default size is 10pt. set the paper size (letterpaper), others like: A4(default), legalpaper. twocolumn for two-column format. twoside for two-side paper sheet printing. \\usepackage[utf8]{inputenc} the encoding for the document. utf8 is recommended. ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Title \\documentclass[12pt, letterpaper, twoside]{article} \\usepackage[utf8]{inputenc} \\title{LaTeX Tutorials} \\author{Backsided \\thanks{funded by the Overleaf team}} \\date{December 2020} \\begin{document} \\begin{titlepage} \\maketitle \\end{titlepage} Hello World LaTeX! \\end{document} \\title{LaTeX Tutorials} title \\author{Backsided \\thanks{funded by the Overleaf team}} author (optional) \\thanks{} for a superscript and a footnote. \\date{December 2020} date \\today for updated automatically each time compiled. \\begin{titlepage} \\end{titlepage} individual first page \\maketitle print the title, the author and the date ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Abstract, paragraphs and newlines \\begin{abstract} \\end{abstract} abstract \\begin{document} paragraph 1 paragraph \\\\ 2 \\end{document} a blank line for new paragraph paragraphs indent before the first line \\\\ or \\newline for a new line ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Comments \\begin{document} Hello World LaTeX! % This is a single line comment. \\end{document} \\usepackage{comment} \\begin{comment} This is a multi-line comment. \\end{comment} ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Chinese for Overleaf https://cn.overleaf.com/learn/how-to/Changing_compiler Menu-\u003eCompiler-\u003eXeLaTeX ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"ctex \\documentclass{ctexart} % 中文article \\begin{document} \\tableofcontents % 目录 \\begin{abstract} % 摘要 这是简介及摘要。 \\end{abstract} \\section{前言} % 第一章 \\section{关于数学部分} % 第二章 数学、中英文皆可以混排。You can intersperse math, Chinese and English (Latin script) without adding extra environments. 這是繁體中文。 \\end{document} \\documentclass{ctexart} 文章类型：ctexart、ctexrep、ctexbook、ctexbeamer \\setCJKmainfont{} % 全局字体 \\setCJKsansfont{} % 英文字体 \\setCJKmonofont{} % 等宽字体 Chinese fonts available on Overleaf \\documentclass{UniThesis} \\usepackage{ctex} different document class still like to use the ctex bundle ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"xeCJK with XeLaTeX you just want to typeset some Chinese characters \\documentclass{article} \\usepackage{xeCJK} \\begin{document} \\section{前言} \\section{关于数学部分} 数学、中英文皆可以混排。You can intersperse math, Chinese and English (Latin script) without adding extra environments. 這是繁體中文。 \\end{document} The xeCJK package only works when compiled with XeLaTeX. ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"CJKutf8 with pdfLaTeX only convenient for documents in English with bits of Chinese text or vice-versa \\documentclass{article} \\usepackage{CJKutf8} \\begin{document} \\begin{CJK*}{UTF8}{gbsn} \\section{前言} \\section{关于数学部分} 数学、中英文皆可以混排。You can intersperse math, Chinese and English (Latin script) without adding extra environments. \\end{CJK*} \\bigskip %% Just some white space You can also insert Latin text in your document \\bigskip %% Just some white space \\begin{CJK*}{UTF8}{bsmi} 這是繁體中文。 \\end{CJK*} \\end{document} \\usepackage{CJKutf8} enables utf8 encoding for Chinese, Japanese and Korean fonts. \\begin{CJK*}{UTF8}{gbsn} \\end{CJK*} gbsn or gkai fonts for simplified characters. bsmi or bkai fonts for traditional characters. Using the CTeX Package on Overleaf (在Overleaf平台上使用CTeX) ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Algorithms ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Algorithm2e \\documentclass{article} \\usepackage[ruled,vlined]{algorithm2e} \\begin{document} \\begin{algorithm}[H] \\SetAlgoLined \\KwResult{Write here the result } initialization\\; \\While{While condition}{ instructions\\; \\eIf{condition}{ instructions1\\; instructions2\\; }{ instructions3\\; } } \\caption{How to write algorithms} \\end{algorithm} \\end{document} ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Algorithmic \\documentclass{article} \\usepackage{algorithmic} \\begin{document} \\begin{algorithmic} \\STATE $i\\gets10$ \\IF {$i\\geq5$} \\STATE $i\\getsi-1$ \\ELSE \\IF {$i\\leq3$} \\STATE $i\\getsi+2$ \\ENDIF \\ENDIF \\end{algorithmic} \\end{document} ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":["LaTeX"],"content":"Listings \\documentclass{article} \\usepackage{listings} \\begin{document} \\lstset{numbers=left, numberstyle=\\tiny, stepnumber=1, numbersep=5pt} \\lstinputlisting[language=c]{c.c} \\end{document} \\lstinputlisting[language=c]{c.c} \\lstset{language=Pascal} tiny line numbers on the left, each second line, with 5pt distance to the listing: \\lstset{numbers=left, numberstyle=\\tiny, stepnumber=1, numbersep=5pt} ","date":"2021-03-28","objectID":"/posts/latex-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["LaTeX"],"title":"LaTeX 教程","uri":"/posts/latex-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Example Marp CLI example --- marp: true theme: gaia _class: lead paginate: true backgroundColor: #fff backgroundImage: url('https://marp.app/assets/hero-background.jpg') --- ![bg left:40% 80%](https://marp.app/assets/marp.svg) # **Marp** Markdown Presentation Ecosystem https://marp.app/ --- # How to write slides Split pages by horizontal ruler (`---`). It's very simple! :satisfied: ​```markdown # Slide 1 foobar --- # Slide 2 foobar ​``` ![](Markdown for PPT.assets/marp-for-vs-code.png) ","date":"2021-03-28","objectID":"/posts/markdown-for-ppt/:1:0","series":null,"tags":[],"title":"Markdown for PPT","uri":"/posts/markdown-for-ppt/"},{"categories":[],"content":"Introduction --- marp: true --- ","date":"2021-03-28","objectID":"/posts/markdown-for-ppt/:2:0","series":null,"tags":[],"title":"Markdown for PPT","uri":"/posts/markdown-for-ppt/"},{"categories":[],"content":"Advanced --- marp: true size: 4:3 theme: default --- ","date":"2021-03-28","objectID":"/posts/markdown-for-ppt/:3:0","series":null,"tags":[],"title":"Markdown for PPT","uri":"/posts/markdown-for-ppt/"},{"categories":[],"content":"Directive Global Directive Local Directive \u003c!--_backgroundColor: orange --\u003e：改变本张幻灯片的背景颜色。 这里单独说明一下控制是否使用标题级别直接作为分页标志的全局命令 headingDivider。如果 Markdown 文档本身层级组织较好，可以将它设置为 ture 并且不用再通过分割线为幻灯片分页，在输出幻灯的同时也能保证输出 Markdown 文档时不会因为出现大量的分割线影响效果。 此外，Marp 还保留了一个 \u003c!-- fit --\u003e 命令用于标题的自适应，将它放在Markdown 标题的 # 后可以使得标题自动填充幻灯片的大小，比较适合于首页大标题等场景。 ","date":"2021-03-28","objectID":"/posts/markdown-for-ppt/:3:1","series":null,"tags":[],"title":"Markdown for PPT","uri":"/posts/markdown-for-ppt/"},{"categories":[],"content":"Reference Marp Marpit reveal.js slides Slideas for Mac impress.js demo ","date":"2021-03-28","objectID":"/posts/markdown-for-ppt/:4:0","series":null,"tags":[],"title":"Markdown for PPT","uri":"/posts/markdown-for-ppt/"},{"categories":[],"content":"1 Neural Networks and Deep Learning ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:1:0","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"1.1 Introduction to Deep Learning ![Simple Neural Networks](吴恩达深度学习.assets/屏幕截图 2020-09-18 165126.png) Machine Learning Classification Supervised Learning: we already know the correct output called label. Unsupervised Learning: with no label. Data Classification Structued Data: Table, Records … Unstructured Data: Audio, Image, Text … ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:1:1","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"1.2 Basics of Neural Network programming Math Notations $m$: the number of training samples, $m_{train},m_{test}$. $n$: the number of features. $(x, y)$: all samples. $(x^{(i)},y^{(i)})$: one sample, $x^{(i)}$ is a $(n \\times 1)$ matrix, $y^{(i)}$ is a number. $$ x^{(i)}=\\begin{bmatrix} x^{(i)}_1 \\ x^{(i)}2 \\ … \\ x^{(i)}{n} \\end{bmatrix} $$ $X$: training set, is a $(n \\times m)$ matrix. $$ X=[x^{(1)},x^{(2)},…,x^{(i)},…,x^{(m)}] $$ $Y$: label set, is a $(1 \\times m)$ matrix. $$ Y=\\begin{bmatrix} y^{(1)}, y^{(2)},…,y^{(m)} \\end{bmatrix} $$ Binary Classification with Logistic Regression $\\hat y=P(y=1|x), 0 \\le \\hat y \\le 1$ Parameters: $w$: weights, a $(n \\times 1)$ matrix. $b$: threshold (bias), a $(1 \\times m)$ matrix with all values are the same. $$ w=\\begin{bmatrix} w_1 \\ w_2 \\ … \\ w_n \\end{bmatrix}, b=\\begin{bmatrix} b_0,b_0,…,b_0 \\end{bmatrix} \\ \\hat y = \\sigma(w^Tx+b) $$ Another Notation: Parameters: $\\theta$: a $((n+1) \\times 1)$ matrix. $x^{(i)}$: a $((n+1) \\times 1)$ matrix. $X$: a $((n+1) \\times m)$ matrix. $$ \\theta = \\begin{bmatrix} b_0 \\ w_1 \\ w_2 \\ … \\ w_n \\end{bmatrix}, x^{(i)} = \\begin{bmatrix} 1 \\ x^{(i)}_1 \\ x^{(i)}_2 \\ … \\ x^{(i)}_n \\end{bmatrix}, X = \\begin{bmatrix} 1 \u0026 1 \u0026 … \u0026 1 \\ x^{(1)}_1 \u0026 x^{(2)}_1 \u0026 … \u0026 x^{(m)}_1 \\ x^{(1)}_2 \u0026 x^{(2)}_2 \u0026 … \u0026 x^{(m)}_2 \\ … \u0026 … \u0026 … \u0026 … \\ x^{(1)}_n \u0026 x^{(2)}_n \u0026 … \u0026 x^{(m)}_n \\end{bmatrix} $$ $$ \\begin{aligned} w^Tx^{(i)}+b_0 \u0026= w_1 \\cdot x^{(i)}_1 + w_2 \\cdot x^{(i)}_2 + … + w_n \\cdot x^{(i)}_n + b_0 \\cdot 1 \\ \u0026= \\begin{bmatrix} b_0 \\ w_1 \\ w_2 \\ … \\ w_n \\end{bmatrix}^T \\cdot \\begin{bmatrix} 1 \\ x^{(i)}_1 \\ x^{(i)}_2 \\ … \\ x^{(i)}_n \\end{bmatrix} \\ \u0026= \\theta^Tx^{(i)} \\ w^Tx+b \u0026= \\begin{bmatrix} w^Tx^{(1)},w^Tx^{(2)},…,w^Tx^{(m)} \\end{bmatrix} \\begin{bmatrix} b_0,b_0,…,b_0 \\end{bmatrix} \\ \u0026= \\begin{bmatrix} w^Tx^{(1)}+b_0,w^Tx^{(2)}+b_0,…,w^Tx^{(m)}+b_0 \\end{bmatrix} \\ \u0026= \\begin{bmatrix} \\theta^Tx^{(1)},\\theta^Tx^{(2)},…,\\theta^Tx^{(m)} \\end{bmatrix} \\ \u0026= \\theta^Tx \\end{aligned} \\ \\hat y = \\sigma(\\theta^Tx) $$ Cost Function: error of all training examples. $$ \\begin{aligned} \\mathcal J(w,b) \u0026= \\frac{1}{m}\\sum_{i=1}^{m}\\mathcal L(\\hat y^{(i)},y^{(i)}) \\ \u0026= -\\frac{1}{m}\\sum_{i=1}^{m}[y^{(i)}\\log{(\\hat y^{(i)})}+(1-y^{(i)})\\log{(1-\\hat y^{(i)})}] \\end{aligned} $$ Reduction: $$ If \\ \\ y=1: \\ P(y|x)=\\hat y \\ If \\ \\ y=0: \\ P(y|x)=1-\\hat y \\ Suppose \\ P(y|x)=\\hat y^y(1-\\hat y)^{(1-y)} \\ Then \\ \\log{P(y|x)}=y\\log{(\\hat y)}+(1-y)\\log{(1-\\hat y)} $$ Loss (error) function: error of single training example. $$ \\mathcal L(\\hat y,y)=-y\\log{(\\hat y)}-(1-y)\\log{(1-\\hat y)} $$ Gradient Descend: $$ w=w-\\alpha\\frac{\\part \\mathcal J(w,b)}{\\part w} \\ b=b-\\alpha\\frac{\\part \\mathcal J(w,b)}{\\part b} $$ def GradientDescend(x, y, learning_rate): n_samples, n_features = x.shape n_samples, n_features = x.shape J = 0 w = np.zeros([1, n_features]) dw = np.zeros([1, n_features]) b = 0 db = 0 alpha = 0.05 for i in range(m): z = np.dot(x, w.T) + b y_hat = sigmoid(z) J += -y[i] * np.log(y_hat) - (1 - y[i]) * np.log(1 - y_hat) dw = db = w -= alpha * dw b -= alpha * db Initialize weights to zero will make no sense, all weights in same layer will be the same. ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:1:2","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"1.3 One hidden layer Neural Networks ![2-layer Neural Network](吴恩达深度学习.assets/屏幕截图 2020-09-27 103709.png) Input Layer: We don’t count input layer as an official layer. Hidden Layer Output Layer ![Calculation in a neuron](吴恩达深度学习.assets/屏幕截图 2020-09-27 103212.png) Activation Function Activation Function must be nonlinear function. Sigmoid $$ \\begin{aligned} \\sigma(z) \u0026= \\frac{1}{1+e^{-z}} \\ \\sigma'(z) \u0026= \\sigma(z)\\cdot(1-\\sigma(z)) \\end{aligned} $$ ![Sigmoid](吴恩达深度学习.assets/屏幕截图 2020-09-18 171904.png) def sigmoid(z): return 1 / (1 + np.exp(-z)) Tanh $$ \\begin{aligned} \\tanh(z) \u0026= \\frac{e^z-e^{-z}}{e^z+e^{-z}} \\ (\\tanh(z))' \u0026= 1-(\\tanh(z))^2 \\end{aligned} $$ def tanh(z): return (np.exp(z) - np.exp(-z)) / (np.exp(z) + np.exp(-z)) ReLU (Rectified Linear Unit): Optimal. $$ g(z)=\\max(0,z) \\ \\begin{equation} g'(z)=\\begin{cases} 0, \u0026 \\text{if} \\ z \\lt 0; \\ 1, \u0026 \\text{if} \\ z \\ge 0. \\end{cases} \\end{equation} $$ ![ReLU](吴恩达深度学习.assets/屏幕截图 2020-09-28 095206.png) def relu(z): return np.maximum(0, z) Leaky ReLU $$ g(z)=\\max(0.01z,z) \\ \\begin{aligned} g'(z)=\\begin{cases} 0.01, \u0026 \\text{if} \\ z \\lt 0; \\ 1, \u0026 \\text{if} \\ z \\ge 0. \\end{cases} \\end{aligned} $$ ![Leaky ReLU](吴恩达深度学习.assets/屏幕截图 2020-09-28 095353.png) def leaky_relu(z): return np.maximum(0.01 * z, z) ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:1:3","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"1.4 Deep Neural Networks Forward propagation: Input: $a^{[l-1]}$ Output: $a^{[l]}$ Cache: $z^{[l]}, W^{[l]}, b^{[l]}$ Backward propagation: Input: $da^{[l]}$ Output: $da^{[l-1]}, dW^{[l]}, db^{[l]}$ Parameters vs Hyperparameters Parameters: $W,b$ Hyperparameters: $\\alpha,iterations,hiddenLayers,hiddenUnits,activationFunctions$ Optimal hyperparameters will change. ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:1:4","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"2 Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:2:0","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"2.1 Setting up your ML application Datasets Train sets: Dev sets: Test sets: evaluation Bias and Variance high variance: Dev set error » Train set error. More data/Regularization to solve. high bias: Dev set error » 0 \u0026 Train set error \u003e 0. Bigger network to solve. Regularization L1 Regularization $$ \\mathcal J(w,b)=\\frac{1}{m}\\sum_{i=1}^m\\mathcal L(\\hat y^{(i)},y^{(i)})+\\frac{\\lambda}{2m}\\left| w \\right|_1 \\ \\left| w \\right|_1=\\sum_{j=1}^n|w_j| $$ L2 Regularization $$ \\mathcal J(w,b)=\\frac{1}{m}\\sum_{i=1}^m\\mathcal L(\\hat y^{(i)},y^{(i)})+\\frac{\\lambda}{2m}\\left| w \\right|_2^2 \\ \\left| w \\right|_2^2=\\sum_{j=1}^nw_j^2=W^TW $$ $\\lambda:$ regularization parameter Dropout regularization Inverted dropout keep-prop: the percentage of keeping neuron. Data augmentation revolve flip zoom distortion Normalizing inputs $x=x-\\mu=x-\\frac{1}{m}\\sum_{i=1}^mx^{(i)}$ $x=\\frac{x}{\\sigma^2}=\\frac{x}{\\frac{1}{m}\\sum_{i=1}^m(x^{(i)})^2}$ Vanishing/Exploding gradients Weight initialization ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:2:1","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"2.2 Optimization Algorithms Mini-batch gradient descent Stochastic gradient descent Exponentially weighted averages Gradient descent with momentum $$ \\begin{aligned} v_{dW}\u0026=\\beta v_{dW}+(1-\\beta)dW \\ v_{db}\u0026=\\beta v_{db}+(1-\\beta)db \\ W\u0026=W-\\alpha v_{dW} \\ b\u0026=b-\\alpha v_{db} \\end{aligned} $$ RMSprop (Root Mean Square prop) $$ \\begin{aligned} S_{dW}\u0026=\\beta S_{dW}+(1-\\beta)dW^2 \\ S_{db}\u0026=\\beta S_{db}+(1-\\beta)db^2 \\ W\u0026=W-\\alpha \\frac{dW}{\\sqrt{S_{dW}}} \\ b\u0026=b-\\alpha \\frac{db}{\\sqrt{S_{db}}} \\end{aligned} $$ Adam (Adaptive Moment Estimation) Optimization Algorithm $$ \\begin{aligned} v_{dW}\u0026=\\beta_1 v_{dW}+(1-\\beta_1)dW \\ v_{db}\u0026=\\beta_1 v_{db}+(1-\\beta_1)db \\ S_{dW}\u0026=\\beta_2 S_{dW}+(1-\\beta_2)dW^2 \\ S_{db}\u0026=\\beta_2 S_{db}+(1-\\beta_2)db^2 \\ v_{dW}^{corrected}\u0026=\\frac{v_{dW}}{1-\\beta_1^t} \\ v_{db}^{corrected}\u0026=\\frac{v_{db}}{1-\\beta_1^t} \\ S_{dW}^{corrected}\u0026=\\frac{S_{dW}}{1-\\beta_2^t} \\ S_{db}^{corrected}\u0026=\\frac{S_{db}}{1-\\beta_2^t} \\ W\u0026=W-\\alpha\\frac{v_{dW}^{corrected}}{\\sqrt{S_{dW}^{corrected}}+\\epsilon} \\ b\u0026=b-\\alpha\\frac{v_{db}^{corrected}}{\\sqrt{S_{db}^{corrected}}+\\epsilon} \\end{aligned} $$ $\\alpha$: needs to be tune $\\beta_1$: 0.9 $\\beta_2$: 0.999 $\\epsilon: \\ 10^{-8}$ Learning rate decay $$ \\begin{aligned} \\alpha\u0026=\\frac{1}{1+decay_rate \\times epoch_number}\\alpha_0 \\ \\alpha\u0026=0.95^{epoch_number}\\alpha_0 \\ \\alpha\u0026=\\frac{k}{\\sqrt{epoch_number}}\\alpha_0 \\end{aligned} $$ ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:2:2","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"2.3 Hyperparameter tuning Hyperparameter advices Try random values: don’t use a grid. We don’t know which hyperparameter is more important. Coarse to fine search. Batch Norm $$ \\begin{aligned} \\mu\u0026=\\frac{1}{m}\\sum_iz^{(i)} \\ \\sigma^2\u0026=\\frac{1}{m}\\sum_i(z^{(i)}-\\mu)^2 \\ z_{norm}^{(i)}\u0026=\\frac{z^{(i)}-\\mu}{\\sqrt{\\sigma^2+\\epsilon}} \\ \\tilde z^{(i)}\u0026=\\gamma \\cdot z_{norm}^{(i)}+\\beta \\end{aligned} $$ Softmax Regression $$ \\mathcal L(\\hat y,y)=-\\sum_{i=1}^Cy_i\\log\\hat y_i $$ ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:2:3","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"3 Structuring your Machine Learning project ML strategy Collect more data Collect more diverse training set Train algorithm longer with gradient descent Try Adam instead of gradient descent Try bigger/smaller network Try dropout Add $L_2$ regularization Network architecture Activation functions hidden units number Orthogonalization modifying an instruction or a component of an algorithm will not create or propagate side effects to other components of the system. Fit training set well in cost function If not, the use of a bigger neural network or switching to a better optimization algorithm might help. Fit development set well on cost function If not, regularization or using bigger training set might help. Fit test set well on cost function If not, the use of a bigger development set might help. Performs well in real world If not, the development test set is not set correctly or the cost function is not evaluating the right thing. Evaluation Metrics Positive Negitive True TP FN (Type 2) False FP (Type 1) TN Accuracy: $Acc=\\frac{TP+TN}{TP+TN+FP+FN}$ Precision (P): ratio of TRUE in test POSITIVE, $P=\\frac{TP}{TP+FP}$ Recall (R): ratio of test POSITIVE in actually TRUE, $R=\\frac{TP}{TP+FN}$ F1 Score: harmonic mean of P and R, $\\frac{1}{F1}=\\frac{1}{2}(\\frac{1}{P}+\\frac{1}{R}) \\rightarrow F1=\\frac{2PR}{P+R}$ F Score: $\\frac{1}{F}=\\frac{\\beta^2}{1+\\beta^2}(\\frac{1}{P}+\\frac{1}{R})$ ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:3:0","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"4 Convolutional Neural Networks ","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:4:0","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"5 Natural Language Processing: Building sequence models","date":"2021-03-28","objectID":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:5:0","series":null,"tags":[],"title":"吴恩达深度学习","uri":"/posts/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"对分类任务来说，在所有相关概率都已知的理想情形下，贝叶斯决策论（Bayesian decision theory）考虑如何基于这些概率和误判损失来选择最优的类别标记。 以多分类任务为例。 假设有$N$种可能的类别标记，即$Y={c_1,c_2,…,c_N}$，$\\lambda_{ij}$是将一个真实标记为$c_j$的样本**误分类**为$c_i$所产生的损失。 基于后验概率$P(c_i|x)$可获得将样本$x$分类为$c_i$所产生的期望损失（expected loss），即在样本$x$上的“条件风险“（conditional risk）：$R(c_i|x)=\\sum_{j=1}^N\\lambda_{ij}P(c_j|x)$ 我们要找到一个判定准则$h:X\\rightarrow Y$以最小化总体风险$R(h)=\\mathbb{E}_x[R(h(x)|x)]$ 显然，对每个样本$x$，若$h$能最小化条件风险$R(h(x)|x)$，则总体风险$R(h)$也将最小化。 贝叶斯判定准则（Bayes decision rule）：为最小化总体风险，只需在每个样本上选择那个能使条件风险$R(c|x)$最小的类别标记，即$h^*(x)=argmin_{c\\in y}R(c|x)$ $h^(x)$称为贝叶斯最优分类器（Bayes optional classifier），与之对应的总体风险$R(h^)$称为贝叶斯风险（Bayes risk）。 $1-R(h^*)$反映了分类器所能达到的最好性能，即通过机器学习所能产生的模型精度的理论上限。 若目标是最小化分类错误率，则误判损失$\\lambda_{ij}$可写为 $\\begin{equation} \\lambda_{ij}=\\left{ \\begin{aligned} \u00260,if \\ i=j \\ \u00261,otherwise \\end{aligned} \\right. \\end{equation}$ 此时，条件风险$R(c|x)=1-P(c|x)$，则最小化分类错误率的贝叶斯最优分类器为$h^*(x)=argmax_{c \\in y}P(c|x)$，即对每个样本$x$，选择能使后验概率$P(c|x)$最大的类别标记。 使用贝叶斯判定准则来最小化决策风险，首先需要获得后验概率$P(c|x)$，这在现实中很难获得。 机器学习所要实现的是基于有限的训练样本集尽可能准确的估计出后验概率$P(c|x)$ 给定$x$，通过直接建模$P(c|x)$来预测$c$，这样得到的是”判别式模型“（discriminative models），如决策树，BP神经网络，支持向量机等 先对联合概率密度分布$P(x,c)$建模，然后得出$P(c|x)$，这样得到的是”生成式模型“（generative models） 对于生成式模型来说，$P(c|x)=\\frac{P(x,c)}{P(x)}$，基于贝叶斯定理，$P(c|x)$可写为$P(c|x)=\\frac{P(c)P(x|c)}{P(x)}$ $P(c)$是类”先验“（prior）概率 $P(x|c)$是样本$x$相对于类标记$c$的类条件概率（class-conditional probability），或称为”似然“（likelihood） $P(x)$是用于归一化的”证据“（evidence）因子 对于给定样本$x$，证据因子$P(x)$与类标记无关，因此估计$P(c|x)$的问题就转化为如何基于训练数据$D$来估计先验$P(c)$和似然$P(x|c)$。 ","date":"2021-03-28","objectID":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/:0:0","series":null,"tags":[],"title":"贝叶斯分类器","uri":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"},{"categories":[],"content":"唐雨迪 正向概率：初始条件已知，求某个事件发生的概率。 ​ 例：求从一袋球中拿出黑球的概率。 逆向概率：已知结果来推测初始条件。 ​ 例：已知拿出的是黑球，求这球是从A袋还是B袋拿出的概率。 贝叶斯公式：$P(A|B)=\\frac{P(AB)}{P(B)}=\\frac{P(A)P(B|A)}{P(B)}=\\frac{P(A)P(B|A)}{P(A)P(B|A)+P(\\bar A)P(B|\\bar A)}$ 先验概率（Prior Probability）： 最大似然估计： 奥卡姆剃刀： ","date":"2021-03-28","objectID":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/:1:0","series":null,"tags":[],"title":"贝叶斯分类器","uri":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"},{"categories":[],"content":"StatQuest 朴素贝叶斯：假设特征之间相互独立，即$P(AB)=P(A)P(B)$。 多项式朴素贝叶斯分类器（Multinomial Naive Bayes Classifier）： 高斯朴素贝叶斯分类器（Gaussian Naive Bayes Classification）： 垃圾邮件分类： 正常邮件（Normal）：8封 Dear：8 Friend：5 Lunch：3 Money：1 $P(Dear|Normal)=\\frac{8}{17} \\ P(Friend|Normal)=\\frac{5}{17} \\ P(Lunch|Normal)=\\frac{3}{17} \\ P(Money|Normal)=\\frac{1}{17}$ 垃圾邮件（Spam）：4封 Dear：2 Friend：1 Lunch：0 Money：4 $P(Dear|Spam)=\\frac{2}{7} \\ P(Friend|Spam)=\\frac{1}{7} \\ P(Lunch|Spam)=\\frac{0}{7} \\ P(Money|Spam)=\\frac{4}{7}$ 先验概率（Prior Probability）： $P(Normal)=\\frac{8}{12} \\ P(Spam)=\\frac{4}{12}$ 出现Dear Friend的邮件是正常邮件的概率： $P(Normal|Dear,Friend)=\\frac{P(Normal,Dear,Friend)}{P(Dear,Friend)}=\\frac{P(Normal)P(Dear,Friend|Normal)}{P(Dear,Friend|Normal)+P(Dear,Friend|Spam)}$ 朴素贝叶斯：假设特征之间相互独立，这里忽视单词顺序。 $P(Dear,Friend) = P(Dear)P(Friend) \\ P(Dear,Friend|Normal) = P(Dear|Normal)P(Friend|Normal) \\ P(Dear,Friend|Spam) = P(Dear|Spam)P(Friend|Spam)$ 则：$P(Normal|Dear,Friend)=\\frac{P(Normal)P(Dear|Normal)P(Friend|Normal)}{P(Normal)P(Dear|Normal)P(Friend|Normal)+P(Spam)P(Dear|Spam)P(Friend|Spam)}\\approx 0.87$ 出现Lunch Money Money Money Money的邮件是垃圾邮件的概率： $P(Spam|Lunch,Money,Money,Money,Money)=\\frac{P(Spam)P(Lunch|Spam)P^4(Money|Spam)}{P(Spam)P(Lunch|Spam)P^4(Money|Spam)+P(Normal)P(Lunch|Normal)P^4(Money|Normal)}=0$ 这不符合实际情况。 为了防止词频出现0，设置$\\alpha=1$，即每个词的词频增加$\\alpha$个。 概率（Probability）： 可能性（Likelihood）： ","date":"2021-03-28","objectID":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/:2:0","series":null,"tags":[],"title":"贝叶斯分类器","uri":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"},{"categories":[],"content":"阮一峰 贝叶斯分类是一种分类算法的总称，这种算法均以贝叶斯定理为基础，故统称为贝叶斯分类。贝叶斯分类器的分类原理是通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类。 $n$项特征：$F_1,F_2,…F_n$ $m$个类别：$C_1,C_2,…,C_m$ 贝叶斯分类器就是计算出概率最大的那个分类，即求$P(C|F_1F_2…F_n)=\\frac{P(C)P(F_1F_2…F_n|C)}{P(F_1F_2…F_n)}$的最大值。 由于$P(F_1F_2…F_n)$对于所有的类别都是相同的，可以省略，问题就变成了找出使$P(C)P(F_1F_2…F_n|C)$的值最大的类别C。 朴素贝叶斯分类器 朴素贝叶斯分类器假设所有特征都彼此独立，因此$P(C)P(F_1F_2…F_n|C)=P(C)P(F_1|C)P(F_2|C)…P(F_n|C)$，可计算出每个类别对应的概率，找出概率最大的那个类。 连续值变为离散值 划分有限个区间。（样本数量少一般难以划分） 假设分布状况。(例如：根据样本计算均值$\\mu$和方差$\\sigma^2$，根据正态分布进行计算) $正态分布概率密度函数：f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$ ","date":"2021-03-28","objectID":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/:3:0","series":null,"tags":[],"title":"贝叶斯分类器","uri":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"},{"categories":[],"content":"参考","date":"2021-03-28","objectID":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/:4:0","series":null,"tags":[],"title":"贝叶斯分类器","uri":"/posts/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"},{"categories":["饥荒"],"content":"等级 25级后开启制造减半后制造 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:1:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"食谱 名称 代码 时间 保质期 饥饿、san、生命 制作 效果 百奇 sorapocky 0s ∞ 37.5、20、20 浆果×6+鸡蛋×0/1/2+蜂蜜×0/1/4 速食拉面 sora_tongmian 1.6s 20d 100/70/40、10、-5 （肉度+菜度）≥2.5 喷香蛋包饭 sora_danbaofan 16s 15d 80/56/32、10、40 蛋≥1+菜度≥0.5+肉度≥0.5 可2怪物肉 默认不放树枝。 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:2:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"药剂 名称 代码 制作 效果 公正 sora2gz 暖石×2+灰烬×40 恒定温度（15min） 诚实 sora2cs 荧光果×40+草×40+树枝×40 持续发光（15min） 谦卑 sora2qb 蜘蛛腺体×40 生命+40、生命+5/s（5min） 灵魂 sora2lh 灰烬×40+金块×20+莎草纸×10 san+40、san+5/s（5min） 荣誉 sora2ry 蜘蛛网×10+黑色羽毛×3+红色羽毛×3 移动速度+100%（5min） 英勇 sora2yy 蜂刺×40+燧石×40 攻击+50%（5min） 牺牲 sora2xs 狗牙×40+木炭×20+格罗姆的粘液×5 攻击+200%、防御-50%、生命-5/s（1min） 怜悯 sora2lm 治疗药膏×10+蜂蜜药膏×10+强心针×5 怪物生命+500/s（3min） 默认一次制作10个药剂 药剂同时只能生效一个，叠加使用会只有最后使用的产生效果 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:3:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"装备 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"奇妙法杖 属性 属性值 代码 sora2sword 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+10% 功能 斧头、鹤嘴锄、铲子（右键开关）、锤子（右键开关）、捕虫网、鱼竿 队友能否使用 能 要求 穹10级 制作 黄金铲子×2/4/6+锤子×2/4/6+紫宝石×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"神奇法杖 属性 属性值 代码 sora2prop 位置 手 效果 无耐久、攻击+0、攻击距离+0、移动速度+50% 功能 只能攻击队友，将其击飞，掉落其手部装备和身上的金子 队友能否使用 能 要求 穹10级 制作 活木×10/20/30+锤子×0/4/6 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"银白の锋 属性 属性值 代码 sora3sword 位置 手 效果 无耐久、攻击+59.5、攻击距离+1.25、移动速度+10% 功能 每次攻击回复0.5血量 队友能否使用 能 要求 穹10级 制作 影刀×1/3/5+触手尖刺×2/4/6+蝙蝠棒×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"银白の甲 属性 属性值 代码 sora2armor 位置 身 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 木甲×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"银白の盔 属性 属性值 代码 sora2hat 位置 头 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 猪皮帽×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"银白の翼 属性 属性值 代码 sora2bag 位置 包 效果 14格背包、移动速度+10% 功能 保鲜+50%、回san+3/min 队友能否使用 能 要求 穹10级 制作 冰块×80/200/400+电子元件×10/20/80 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"荣誉勋章 属性 属性值 代码 sora2amulet 位置 符 效果 移动速度+20%、攻击+20%（穹无效）、防御+20%（穹无效） 功能 防水+30%、回san+3/min、发光（多档调节，不同消耗速度，自动关闭）、 修复 关闭时自动修复0.1/s，也可用荧光果、蜗牛粘液、小发光浆果、发光浆果修复 队友能否使用 能 队友增幅 使用穹的便携烹饪锅、制作穹专属料理、快速采集、快速制作 要求 穹10级 制作 重生护符×1/2/3+寒冰护符×1/2/3+噩梦护符×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の采 属性 属性值 代码 sorapick 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+25% 功能 灭火、批量采集，CD60s→0s 队友能否使用 不能 要求 穹20级 制作 懒人护符×1/2/4+活木×10/20/40+橙宝石×3/6/10+燧石×40/80/400 升级（冷却时间） 每1/2/3紫宝石，CD-12s，最高提升到0s 升级（采集范围） 每1/2/3橙宝石，范围+1，最高提升到7格 升级（灭火范围） 每10/20/30e，范围+0.5，最高提升到7格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の愈 属性 属性值 代码 sorahealing 位置 手 效果 无耐久、攻击+15→35、攻击距离+8、移动速度+25% 功能 右键切换群体治疗或冰冻（消耗饱食度），CD60s，治疗效果30 队友能否使用 不能 要求 穹20级 制作 分解法杖×1/2/4+蜂蜜药膏×10/20/40+绿宝石×3/6/10+花瓣×40/80/400 升级（攻击） 每1/2/3紫宝石，攻击+4，最高提升到35 升级（冷却时间） 每1/2/3黄宝石，CD-10s，最高提升到10s 升级（治疗、冰冻） 每1/2/3绿宝石，治疗+10，最高提升到80（到55后可复活自己或队友） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の瞬 属性 属性值 代码 soratele 位置 手 效果 无耐久、攻击+17、攻击距离+12、移动速度+50% 功能 右键瞬移（CD20s，消耗40san），斧、锄、铲、锤、捕虫网、鱼竿（立刻上钩） 队友能否使用 不能 要求 穹20级 制作 瞬移法杖×1/2/4+月石×5/10/40+紫宝石×4/4/10+红色羽毛×4/10/40 升级（冷却时间） 每1/2/3紫宝石，CD-4s，最高提升到0s 升级（施法消耗） 每10/20/30噩梦燃料，消耗san-3，最高提升到10san ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:10","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の空 属性 属性值 代码 soramagic 位置 手 效果 无耐久、攻击+20→45、攻击距离+5→10、移动速度+25% 功能 右键流星群伤技能，伤害20→120，CD30s，攻击有概率触发技能 队友能否使用 不能 要求 穹20级 制作 火焰法杖×1/2+金块×10/20+红宝石×2/6+噩梦燃料×10/20 制作（困难） 火焰法杖4+电子元件×20+红宝石×10+龙鳞×4 升级（攻击） 每5/10/15金块，攻击+0.5，最高提升到45 升级（攻击距离） 每1/2/3金丝雀羽毛，攻击距离+0.2，最高提升到10 升级（技能伤害） 每1/2/3红宝石，伤害+4，最高提升到120 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:11","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の护 属性 属性值 代码 soraclothes 位置 身 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 保暖+0→240、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（保暖） 每1/2/3熊皮，保暖+48，最高提升到240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:12","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の冠 属性 属性值 代码 sorahat 位置 头 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 防雨+0→100%（满级防水）、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（防雨） 每1/2/3巨鹿眼球，防雨+40%，最高提升到100% ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:13","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の包 属性 属性值 代码 sorabag 位置 包 效果 14格背包、出生自带、移动速度+10% 功能 保鲜（默认50%）、回san、隔热 队友能否使用 不能 要求 穹20级 制作 鸭毛×5/10+牛毛×6/20+蜘蛛网×8/20 制作（困难） 鸭毛×40+黑色羽毛×20+红色羽毛×20+紫宝石×4 升级（保鲜） 每5/10/15金块，保鲜度+10%，最高提升500% 升级（回san） 每5/10/15蜂蜜，回san+1/min，最高提升到20/min 升级（隔热） 每5/10/15冰块，隔热+4，最高提升240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:14","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の二次元蝴蝶结 属性 属性值 代码 sorabowkno 位置 符 效果 攻击+20%、防御+20%、移动速度+20% 功能 防水+30%、回san+4.5/min、发光、消耗经验打包物品作礼物 队友能否使用 不能 要求 穹20级 制作 蝴蝶×10/20/20+格罗姆翅膀×3/5/10+彩虹宝石×1/2/4 升级（发光） 每5/10/15荧光果/萤火虫/发光浆果，发光范围+0.5格，最高提升5格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:15","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"物品 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の缝纫包 属性 属性值 代码 sorarepairer 功能 重置食物新鲜度、修复装备（除了分解法杖） 制作 蜘蛛网×4/6/10+金块×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の打包纸 属性 属性值 代码 sora2pack 功能 一次制作6个（一般难度），打包建筑、植物、物品等。 要求 穹10级 制作 莎草纸×4/6/10+紫宝石×1+花瓣×10/20/60 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"魔法 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"全部魔法 名称 代码 消耗san 效果 鸽子还没到 sora_birds 20/30/40 召唤一群鸟（20-30只） 未闻花名 sora_gardening 20/30/40 催生附近作物（包括大理石树） 提醒睡觉小助手 sora_sleep 40/50/60 催眠附近生物 都是时辰的错 sora_raining 70/90/110 下雨或天晴 空白永不败北 sora_magics 120/140/160 附近物品变化，按物品12或123循环变化 超电磁炮永世长存 sora_lighting 30/40/50 附近召唤闪电 伪典-弑君者 sora_tentacles 50/70/90 附近召唤三只触手 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"空白永不败北 物品1 物品2 物品3 浆果 蜜汁浆果 蝴蝶翅膀 黄油 青蛙腿 鸟腿 花瓣 恶魔花瓣 肥料 鸟粪 石头 燧石 硝石 冰 木炭 金子 金元宝 骨片 化石碎片 月石 月亮碎片 红宝石 蓝宝石 紫宝石 绿宝石 黄宝石 橙宝石 蓝色羽毛 黑色羽毛 红色羽毛 兔毛 猪皮 触手皮 蜘蛛腺体 蚊子血袋 蜂刺 狗牙 牛毛 蜘蛛网 牛角 海象牙 羊角 龙鳞 蛤蟆皮 蝴蝶 月娥 常青树 粗壮常青树 石化树 胡萝卜（地里） 胡萝卜鼠（地里） 曼德拉草（地里） 浆果丛 浆果灌木丛 蜜汁浆果丛 树苗根 月岛树苗根 红蘑菇（树） 蓝蘑菇（树） 绿蘑菇（树） 洋葱 辣椒 大蒜 蒜粉 辣椒面 月相盘 月台 棋盘地板 卵石路 地毯地板 贝壳地板 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"建筑 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"穹の圣诞树 属性 属性值 代码 sora2tree 要求 穹5级 功能 每天可随机领取物品 制作 木板×1/5/20+松果×1/10/40+桦木果×1/10/40 升级机制：往圣诞树里放东西，点击献祭（手柄关闭后就会自动献祭），献祭会增加经验值，达到一定经验值后树就会升级，不同的物品经验值也不同，但是不需要太在意升级因为献祭获得的经验和获得礼物而扣除的经验不成正比（一根草每天白嫖不香吗），所以应该把他当做垃圾桶更合适（小声bb） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"薇诺娜的投石机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"薇诺娜的聚光灯 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"薇诺娜的发电机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+木头×2+硝石×2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"秘法祭坛 属性 属性值 代码 sora2base 要求 制作（简单） 红月之眼+蓝月之眼+月石×6 制作（一般） 紫月之眼×2+黄月之眼×2+月石×20 制作（困难） 绿月之眼×3+橙月之眼×3+月石×40 火魔杖 自动攻击 冰魔杖 灭火器 传送魔杖 作为传送石的目的地 瞬移魔杖 消耗饥饿回san 解构魔杖 消耗饥饿回血 唤星者 大范围升温 访月者 大范围降温 魔杖放置在祭坛的第一格 若第二格不是噩梦燃料，则会提供大范围光源 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"传送石 属性 属性值 代码 sora2stone 要求 制作 金块×2+沙漠石头×0/1/1+月石×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"强迫の箱子 属性 属性值 代码 sora2chest 功能 25格容器，关闭时自动收集附近与第一格相同的物品，其他物品掉落（打包除外） 要求 穹10级 制作 木板×3/3/5+石砖×0/3/5+噩梦燃料×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"寒冰の箱子 属性 属性值 代码 sora2ice 功能 25格容器，永久保鲜 要求 穹10级 制作（简单） 冰块×80+木板×10+石砖×10 制作 蓝宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":["饥荒"],"content":"烈焰の箱子 属性 属性值 代码 sora2fire 功能 25格容器，烤熟食物，木头变木炭，可燃物变灰烬 要求 穹10级 制作（简单） 木炭×80+木板×10+石砖×10 制作 红宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/"},{"categories":[],"content":"一、工具 U盘（≥16G） Mac OS镜像（.dmg） 适合你的电脑的EFI文件 balenaEtcher（刻录工具） DiskGenius（分区工具） ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"二、制作U盘启动盘 插入U盘，然后打开balenaEtcher软件。 点击Select image选择Mac OS镜像。 软件会自动识别出你的U盘，最后点击Flash!。 等待刻录完成（20min左右），之后会有一个完整性检测（15min左右）。 当软件显示Flash Complete!时表示刻录成功。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"三、配置Clover引导驱动 打开DiskGenius，找到U盘上的ESP分区，删除EFI文件夹。 把适合自己电脑EFI文件夹复制进去。（这里只能用快捷键复制粘贴） 保存更改。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"四、制作黑苹果系统盘 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"硬盘分区安装 压缩卷（≥25G）。 选中压缩出的空闲分区，右键新建简单卷，一直点击下一步但选择不要格式化这个卷。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"整块硬盘安装 删除磁盘所有分区即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"五、BIOS设置 以技嘉（Gigabyte）主板为例： BIOS-\u003eFastBoot-\u003eDisable BIOS-\u003eWindows 8/10 Features-\u003eWindows 8/10 将操作系统类型设置为其他操作系统。从不支持Microsoft签名安全启动的第三方操作系统启动时，将“操作系统类型”设置为“其他操作系统”以获取优化的功能。 BIOS-\u003eCSM Support-\u003eDisabled 禁用CSM。兼容性支持模块（CSM）是UEFI固件的组件，该组件通过模拟BIOS环境来提供旧版BIOS兼容性，从而允许仍使用旧版操作系统和某些不支持UEFI的选件ROM。Clover和OpenCore引导都支持UEFI引导。禁用CSM使BIOS可以轻松发现Bootloader。 BIOS-\u003eLAN PXE Boot Option ROM-\u003eDisabled BIOS-\u003eStorage Boot Option Control-\u003eUEFI BIOS-\u003eOther PCI devices-\u003eUEFI Peripherals-\u003eInitial Display Output-\u003ePCIe Slot(独显)/IGFX(核显) Peripherals-\u003eAbove 4G Decoding-\u003eDisabled Peripherals-\u003eTrusted Computing-\u003eSecurity Device Support-\u003eDisable Peripherals-\u003eUSB Configuration-\u003eLegacy USB Support-\u003eDisabled 禁用旧版USB支持。 Peripherals-\u003eUSB Configuration-\u003eXHCI Hand-off-\u003eEnabled 启用XHCI切换。 Peripherals-\u003eNetwork Stack Configuration-\u003eDisabled Peripherals-\u003eSATA and RST Configuration-\u003eSATA Mode Selection-\u003eAHCI 将SATA设置为AHCI。通过高级主机控制器接口（AHCI）模式，可以在SATA驱动器上使用高级功能，例如热插拔和本机命令队列（NCQ）。AHCI还允许硬盘以比传统IDE模式更高的速度运行。 Chipset-\u003eVT-d-\u003eDisabled 禁用VT-D。VT-d特别是IOMMU规范。扩展允许您访问虚拟机下的物理硬件（例如，运行Linux的系统可以在虚拟机上运行Windows。如果没有VT-d，则视频卡会被仿真，并且游戏速度会很慢。视频卡可以进入直通模式，并且可以在Windows下作为真实硬件（可以安装nvidia驱动程序）进行访问，并且视频卡的性能类似于运行本机Windows实时预览的情况。但是对于许多黑苹果用户，VT-D不会造成任何问题，但是如果您是新手，则尝试安装和配置Hackintosh禁用VT-D并安装。您可以在安装后根据需要启用VT-D。 Chipset-\u003eIOAPIC 24-119 Entries-\u003eEnabled ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"六、黑苹果安装 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"七、更改硬盘启动 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"八、其他问题 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"EFI分区扩容 分出合适空间大小，可使用Windows自带的磁盘管理或者DiskGenius。 打开DiskGenius。 找到ESP分区，右键选择备份分区到镜像文件，选择合适的文件路径并保存（选择热备份）。 删除ESP分区。 在任意分区上右键选择建立ESP/MSR分区，调整合适的分区大小并确认。 保存更改。 找到ESP分区，右键选择从镜像文件还原分区，选择刚才备份的镜像文件即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"九、参考 黑果小兵的部落阁 黑苹果MacOS Big Sur 11.0 安装教程及驱动工具 主流电脑配置的通用引导文件，包含CLOVER与OpenCorer双引导 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":[],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["力扣每日一题"],"content":"题目链接 读题，易知： 若 t 是 s 的子序列，则 m（s 的长度）大于等于 n（t 的长度），即当 m 小于 n 时直接返回 0。 在 m 大于等于 n 的条件下，用 dp[i][j] 来表示 s[i:] 的子序列中 t[j:] 的个数。 首先考虑边界情况： 当 j = n 时，t[j:] 为空串，由于空串是任何字符串的子串，因此，对任意$0 \\le i \\le m$ ","date":"2021-03-17","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/:0:0","series":null,"tags":["动态规划"],"title":"力扣每日一题 0115 不同的子序列","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-0115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"},{"categories":[],"content":"常用软件或程序语言环境搭建。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"Windows 添加环境变量 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"窗口化操作 打开我的电脑，右键点击左侧的此电脑，点击属性。 点击最下方的高级系统设置，然后点击环境变量。 修改系统变量：下方选择需要修改的变量，点击编辑，然后新建或者编辑变量。 新建系统变量：直接点击新建，输入变量名和变量值，然后确定。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"误删系统环境变量的补救措施 若未关闭当前CMD。输入echo %PATH%会显示原来的 PATH 值。 若已关闭当前CMD。每个正在运行的 Windows 程序都会有自己已加载的 PATH，可以使用Process Explorer来查看当前正在运行的程序的环境变量。例如：如果你之前打开了 Chrome，且一直未关闭，按Ctrl+O打开C:\\Windows\\System32\\cmd.exe，然后输入echo %PATH%会显示原来的 PATH 值。恢复之后删除C:\\Program Files\\Google\\Chrome\\Application和用户变量中的PATH值即可。 若已重启电脑。手动恢复 PATH 到默认值%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0，其他值已丢失。 参考：如何恢复我删除的Path环境变量？ ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"VS Code ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"C++ 编译器 Windows（二选一） 安装 Visual Studio 安装 MinGW-w64，SourceForge Linux: sudo apt install gcc g++ gdb build-essential VS Code 安装 ms-cpp-tools 3.解决头文件找不到，修改c_cpp_properties.json。 # Linux gcc -v -E -x c++ - c_cpp_properties.json Windows 10 + Visual Studio 2019 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/include/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"windows-msvc-x64\" } ], \"version\": 4 } Windows 10 + Mingw-w64 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Portable/mingw64/bin/g++.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\" } ], \"version\": 4 } 参考 关闭 Windows Defender “首次看到时阻止”： 问题描述： 编译运行程序的时候总是弹出一个 Microsoft Defender 防病毒程序窗口，提示“需要扫描当前程序”。 解决方法： 按Win+R，输入gpedit.msc，打开本地组策略编辑器。 左侧选择计算机配置-\u003e管理模板-\u003eWindows 组件-Microsoft Defender 防病毒-\u003eMAPS。 右侧双击配置“首次看到时阻止”功能，选择已禁用，然后点击确定，保存退出。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"Python Python 官网，建议安装3.8版本。 Anaconda 官网。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"pip 设置代理 Windows：%APPDATA%\\pip\\pip.ini [global] proxy = http://user:password@proxy_name:port ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"Anaconda # 更新 conda update # 创建环境 conda create -n ENVNAME python=3.X -y # 启用环境 conda activate ENVNAME # 退出环境 conda deactivate # 删除环境 conda remove -n ENVNAME --all -y # 查看环境列表 conda info -e # 或者 conda env list # 设置 proxy_server conda config --set proxy_servers.http http://127.0.0.1:10809 conda config --set proxy_servers.https http://127.0.0.1:10809 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"PyTorch PyTorch 官网 CPU： Anaconda: conda install pytorch torchvision torchaudio cpuonly -c pytorch Pip: pip install torch==1.8.1+cpu torchvision==0.9.1+cpu torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html GPU (CUDA 11.0)： Anaconda: conda install pytorch torchvision torchaudio cudatoolkit=11.0 -c pytorch Pip: pip install torch==1.7.1+cu110 torchvision==0.8.2+cu110 torchaudio===0.7.2 -f https://download.pytorch.org/whl/torch_stable.html 检查是否安装成功： import torch # 检查 pytorch 是否安装成功 print(torch.__version__) # 检查 CUDA 是否可用 print(torch.cuda.is_available()) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"TensorFlow TensorFlow 官网 Pip: CPU and GPU: pip install tensorflow Wheel: # https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow_cpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_cpu-2.4.1-cp38-cp38-win_amd64.whl # CPU # https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl # GPU 检查是否安装成功： import tensorflow as tf # 检查 tensorflow 是否安装成功 print(tf.__version__) # 检查 CUDA 是否可用 # 输出最后一行显示 [PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')] print(tf.config.experimental.list_physical_devices('GPU')) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"Q\u0026A 问题描述： 安装 CUDA 11.1 + cuDNN 8.1，tensorflow 2.4.1 检查 GPU 时报错： Could not load dynamic library 'cusolver64_10.dll'; dlerror: cusolver64_10.dll not found 解决方案： 卸载重新安装 CUDA 11.0 + cuDNN 8.0，参考 Windows 经过测试的构建配置。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:1","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"CUDA \u0026 cuDNN CUDA 和 cuDNN 版本：Windows 经过测试的构建配置 以笔记本 RTX2060 显卡为例 NVIDIA 驱动程序下载，选择对应版本，下载安装。 CUDA 工具包下载，下载对应版本安装。 在CMD输入nvcc -V，出现如下输出表示安装成功。 nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Tue_Sep_15_19:12:04_Pacific_Daylight_Time_2020 Cuda compilation tools, release 11.1, V11.1.74 Build cuda_11.1.relgpu_drvr455TC455_06.29069683_0 cuDNN 下载，需要登陆账号，登陆后下载对应版本，解压将bin、include和lib三个文件夹的内容复制到 CUDA 安装目录下。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"FFmpeg 进入官网，点击Windows builds from gyan.dev。 点击下图链接下载，然后解压，并把bin目录添加环境变量。 重新打开 CMD，输入ffmpeg -version验证安装。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:7:0","series":null,"tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"Git is the open source distributed version control system. ","date":"2021-03-11","objectID":"/posts/git-tutorials/:0:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Install Git Download Git for Windows, MacOS and Linux. ","date":"2021-03-11","objectID":"/posts/git-tutorials/:1:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Configure Tooling Configure user information for all local repositories. # Sets the name you want attached to your commit transactions git config --global user.name \"USERNAME\" # Sets the email you want attached to your commit transactions git config --global user.email \"USERNAME@email.com\" ","date":"2021-03-11","objectID":"/posts/git-tutorials/:2:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Create Repositories Start a new repository or obtain one from an existing URL. # Creates a new local repository with the specified name git init [PROJECT-NAME] # Downloads a project and its entire version history git clone https://github.com/username/repo-name.git ","date":"2021-03-11","objectID":"/posts/git-tutorials/:3:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Make Changes Review edits and craft a commit transaction. # Lists all new or modified files to be commited git status # Shows file differences not yet staged git diff # Snapshots the file in preparation for versioning git add FILENAME # Shows file differences between staging and the last file version git diff --staged # Unstages the file, but preserve its contents git reset FILENAME # Records file snapshots permanently in version history git commit -m \"DESCRIPTIONS\" ","date":"2021-03-11","objectID":"/posts/git-tutorials/:4:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Group Changes Name a series of commits and combine completed efforts. # Lists all local branches in the current repository git branch # Creates a new branch git branch BRANCH-NAME # Switches to the specified branch and updates the working directory git checkout BRANCH-NAME # Combines the specified branch’s history into the current branch git merge BRANCH-NAME # Deletes the specified branch git branch -d BRANCH-NAME ","date":"2021-03-11","objectID":"/posts/git-tutorials/:5:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Refactor Filenames Relocate and remove versioned files. # Deletes the file from the working directory and stages the deletion git rm FILENAME # Removes the file from version control but preserves the file locally git rm --cached FILENAME # Changes the file name and prepares it for commit git mv OLD-FILENAME NEW-FILENAME ","date":"2021-03-11","objectID":"/posts/git-tutorials/:6:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Suppress Tracking Exclude temporary files and paths. A text file named .gitignore suppresses accidental versioning of files and paths matching the specified patterns. *.log build/ temp-* # Lists all ignored files in this project git ls-files --other --ignored --exclude-standard ","date":"2021-03-11","objectID":"/posts/git-tutorials/:7:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Save Fragments Shelve and restore incomplete changes. # Temporarily stores all modified tracked files git stash # Restores the most recently stashed files git stash pop # Lists all stashed changesets git stash list # Discards the most recently stashed changeset git stash drop ","date":"2021-03-11","objectID":"/posts/git-tutorials/:8:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Review History Browse and inspect the evolution of project files. # Lists version history for the current branch git log # Lists version history for a file, including renames git log --follow FILENAME # Shows content differences between two branches git diff BRANCH-1-NAME BRANCH-2-NAME # Outputs metadata and content changes of the specified commit git show COMMIT-ID ","date":"2021-03-11","objectID":"/posts/git-tutorials/:9:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Redo Commits Erase mistakes and craft replacement history. # Undoes all commits after COMMIT-ID, preserving changes locally git reset COMMIT-ID # Discards all history and changes back to the specified commit git reset --hard COMMIT-ID ","date":"2021-03-11","objectID":"/posts/git-tutorials/:10:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Synchronize Changes Register a repository bookmark and exchange version history. # Downloads all history from the repository bookmark git fetch BOOKMARK # Combines bookmark’s branch into current local branch git merge BOOKMARK/BRANCH-NAME # Uploads all local branch commits to GitHub git push ALIAS BRANCH-NAME # Downloads bookmark history and incorporates changes git pull ","date":"2021-03-11","objectID":"/posts/git-tutorials/:11:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"References Git Cheat Sheets ","date":"2021-03-11","objectID":"/posts/git-tutorials/:12:0","series":null,"tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Git 命令 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"本地仓库 # 初始化 git init # 查看文件改动 git diff FILENAME # 添加需要 commit 的文件 git add FILENAME # 提交一个版本，附带描述信息 git commit -m \"descriptions\" # 所有被修改或者已删除的文件提交（不包括新建文件） git commit -a -m \"descriptions\" ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"远端仓库 # 克隆仓库 git clone https://github.com/USERNAME/REPONAME.git # 为本地仓库添加远端 GitHub 仓库 git remote add origin https://github.com/USERNAME/REPONAME.git # 将已提交的版本推送到远端仓库，方便其他设备同步 git push origin \u003cBRANCH_NAME\u003e # 取回远端仓库版本，对本地仓库进行更新 git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"分支 # 创建一个分支 git branch \u003cBRANCH_NAME\u003e # 切换分支 git checkout \u003cBRANCH_NAME\u003e # 创建一个分支，并切换过去 git checkout -b \u003cBRANCH_NAME\u003e # 合并分支 git merge \u003cBRANCH_NAME\u003e # 删除分支 git branch -d \u003cBRANCH_NAME\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"子模块 # 将一个 Git 仓库添加为当前仓库的子模块 git submodule add https://github.com/USERNAME/REPONAME.git # git clone 含有子模块的项目 # 1.项目已经克隆到了本地 git submodule init git sunmodule update # 或者 git submodule update --init # 2.项目还未克隆到本地 git clone --recurse-submodules https://github.com/USERNAME/REPONAME.git # 或者 git clone --recursive https://github.com/USERNAME/REPONAME.git ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"替换本地改动 # 丢弃当前文件修改内容 git checkout -- FILENAME # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:5","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"本地创建仓库并上传至 GitHub 配置 Git。 git bash 输入如下指令： git init git add --all # git add . git commit -m \"descriptions\" git remote add origin https://github.com/USERNAME/REPONAME.git git push -u origin master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:6","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"配置 Git 将your_email@youremail.com改为你的 Github 账号的邮箱，然后一路回车。 ssh-keygen -t rsa -C \"your_email@youremail.com\" 成功的话会在${USERNAME}/下生成.ssh文件夹，进入该文件夹，打开id_rsa.pub文件，复制里面的内容。 回到 Github 网页，登录，点击右上角头像，选择Settings-\u003eSSH and GPG keys-\u003eNew SSH key，Title随便填，Key粘贴你刚复制的内容，然后点击Add SSH key。 测试，git bash 输入如下指令： ssh -T git@github.com 配置用户名和邮箱： git config --global user.name \"USERNAME\" git config --global user.email \"username@email.com\" ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Q\u0026A ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"无法连接服务器，报错443 问题： git clone 或 git push 等操作时无法连接至服务器，报错内容如下： SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 答案： 该问题由开启代理软件导致。 到设置-\u003e网络和Internet-\u003e代理中查看地址和端口。 git bash 中输入如下命令（IP_ADDRESS和PORT改为刚才查看的地址和端口）： git config --global http.proxy IP_ADDRESS:PORT # git config --global http.proxy 127.0.0.1:10809 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"参考 Git Cheat Sheets ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"饥荒 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"科普 食物可通过觅食，陷阱，种植或者猎捕动物和怪兽获得。 不同的食物可以恢复不同的饥饿和一些生命以及理智。 但是如果吃下一些像是怪物肉或是榴梿之类的食物，可能反而会对玩家的生命值造成伤害，甚至是降低玩家的理智。 不同颜色的蘑菇针对生命值和理智值也都会对玩家产生不同的效果。 另外有些比较特殊的食物，比如发光莓，在吃下去后会给予玩家特别的效果。 大部分食物都可以通过在营火上烹饪来增加恢复的饥饿与生命或是减少（抵消）生吃对玩家造成的负面影响。 有些生的食物（通常为肉类）可以挂在干肉架上晒干来取得可以长久保存并能回复玩家饥饿/生命/理智的食物。 烹饪锅可以用来取得一些特殊料理，让玩家可以从食物中得到额外的好处（大部分的料理都有回复理智的效果，但直接食用大部分的食物都无法得到）。 肉类可以作为诱饵，可以招募猪人，可以进贡给猪王换取金块。 一个可以不断取得蛋的方法就是通过将肉喂给鸟笼中的鸟，肉类还可以制作复活肖像。 当玩家在物品栏中持有肉时会被兔人视为攻击目标。 蔬菜和水果可以当作草食动物的诱饵（像是兔子）或是喂给猪人来换取粪便。种子可以当作捕鸟陷阱的诱饵。 被视为游戏中最重要的物品之一，根据地图生成的不同，食物可以从很丰富到十分短缺都有可能。 食物受到季节的影响非常大，这鼓励玩家去根据季节挑选适合的食物（译注：像是冬天农田几乎不会生长、春天兔子不会跑出洞、只有夏天才有仙人掌花…等等例子）。 大多数的食物都会慢慢的腐烂，最后变成腐烂食物。 当食物的腐坏度为50%时，食物将会变为**不新鲜（黄色）**状态。可恢复2/3的饥饿，1/3的生命，不能恢复理智。 当食物的腐坏度为20%时，食物将会变为**变质（红色）**状态。可恢复1/2的饥饿，不能恢复生命，降低10点理智。 地面上的食物腐坏率为150%，冰箱中的腐坏率为50%，冬天食物的腐坏率为75%。 不新鲜和变质的食物对**WX-78（机器人）**没有影响。 堆叠的食物具有相同的腐烂程度，将腐烂程度不同的食物堆叠起来腐烂值取平均值。在游戏中可以利用这个设定来\"拯救\"快要腐烂的食物：将快腐烂的食物与新鲜的食物堆叠起来，然后ctrl+点击分开食物。 烹饪中的食物和在烹饪锅中的食物降低一般的腐坏度。 高脚鸟蛋，曼德拉草和巨鹿眼球是不会腐坏的。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"食谱 类别 详细 肉类 怪物肉 鱼类 蔬菜 胡萝卜、各种蘑菇、 水果 浆果、多汁浆果、香蕉、西瓜、火龙果、石榴、榴莲 烹饪 其他 桦树果、蝴蝶翅膀、黄油、牛奶、冰、蜂蜜、腐烂食物、各种种子、齿轮、树枝、噩梦燃料、骨头碎片、花瓣 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"肉丸 肉度×0.5，1肉3填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 62.5 5 3 15秒 10天 食材1 食材2 食材3 食材4 怪物肉、大肉、小肉、鸡腿 浆果、冰 浆果、冰 浆果、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"炖肉 肉度×3，3肉1填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 150 5 12 15秒 10天 食材1 食材2 食材3 食材4 怪物肉 大肉 大肉 浆果、冰 怪物肉 大肉 小肉 小肉 大肉 大肉 鸡腿 蛙腿 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"火鸡大餐 鸡腿×2+肉度×0.5，2鸡腿1肉1填充物，两个鸡腿必须是生的。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 60秒 6天 食材1 食材2 食材3 食材4 鸡腿 鸡腿 怪物肉、大肉、小肉 浆果、蘑菇、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"培根煎蛋 蛋度×2+肉度×1.5，禁蔬菜、水果。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 40秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉、大肉 大肉、小肉 高脚鸟蛋 怪物肉、大肉、小肉 怪物肉、大肉、小肉 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"蜜汁火腿 蜂蜜×1+肉度×2，禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 30 40秒 20天 食材1 食材2 食材3 食材4 蜂蜜 怪物肉 大肉、小肉 大肉、小肉 蜂蜜 怪物肉 大肉 浆果 蜂蜜 蜂蜜 怪物肉 大肉 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"果仁杂烩 烤桦树果+水果×1.5，禁冰、蔬菜。 饥饿 精神 生命 烹饪时间 腐烂时间 12.5 5 30 40秒 15天 食材1 食材2 食材3 食材4 烤桦树果 浆果 浆果 浆果 烤桦树果 烤桦树果 浆果 浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"波兰水饺 禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 20秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉 蘑菇 高脚鸟蛋 浆果 怪物肉 蘑菇 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"火龙果派 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 40 40秒 15天 食材1 食材2 食材3 食材4 火龙果 树枝、浆果 树枝、浆果 树枝、浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:8","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"华夫饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 60 10秒 6天 食材1 食材2 食材3 食材4 黄油 鸡蛋、高脚鸟蛋 浆果 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:9","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"炸鱼条 鱼+树枝 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 40秒 10天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:10","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"太妃糖 蜂蜜×3 饥饿 精神 生命 烹饪时间 腐烂时间 25 15 -3 40秒 15天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:11","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"蝴蝶松饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 20 40秒 15天 食材1 食材2 食材3 食材4 蝴蝶翅膀 蘑菇 树枝 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:12","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"粉末蛋糕 玉米+蜂蜜，腐烂时间很久。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:13","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"人物 mod ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"宝石萝莉 宝石萝莉完整攻略 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":["饥荒"],"content":"参考资料 Don’t Starve 中文维基 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Google, Youtube, Facebook, Twitter, Instagram, Reddit, … ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"准备工作 VPS：推荐CN2 GIA线路，其次CN2 Bandwagon Vultr DigitalOcean UUUVPS 域名 免费：Freenom 购买：NameSilo, GoDaddy DNS \u0026 CDN：Cloudflare ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Freenom 免费域名申请 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"域名托管到 Cloudflare ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"脚本 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"v2ray-agent Github 支持： VLESS + TCP + TLS VLESS + TCP + XTLS VLESS + gRPC + TLS VLESS + WS + TLS VMess + TCP + TLS VMess + WS + TLS Trojan Trojan-Go + WS 安装： wget -P /root -N --no-check-certificate \"https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh\" \u0026\u0026 chmod 700 /root/install.sh \u0026\u0026 /root/install.sh 查看配置：vasma ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Xray_onekey Github 支持： VLESS + TCP + XTLS/TLS VLESS + TCP + XTLS/TLS 及 VLESS + WS + TLS 回落并存模式 安装： wget -N --no-check-certificate -q -O install.sh \"https://raw.githubusercontent.com/wulabing/Xray_onekey/main/install.sh\" \u0026\u0026 chmod +x install.sh \u0026\u0026 bash install.sh 查看配置：同安装 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"客户端 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"Windows v2rayN 下载 Clash for Windows 下载 Qv2ray 下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"安卓 V2rayNG 下载 igniter 只支持 Trojan 下载 Clash for Android 下载 AnXray 下载 SagerNet 下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":[],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"用于算法竞赛（如ACM、ICPC）的不同算法的集合。 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:0:0","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"动态规划 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:0","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"凸包技巧 https://codeforces.com/contest/319/problem/C #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003eusing namespace std; typedef long long ll; const int MAXN = 105000; int n; ll height[MAXN], tax[MAXN]; ll dp[MAXN]; vector\u003cll\u003e mvals, bvals; int cur = 0; // Suppose the last 3 lines added are : (l1, l2, l3) // Line l2 becomes irrelevant, if l1/l3 x-intersection is to the left of l1/l2 x-intersection bool bad(ll m1, ll b1, ll m2, ll b2, ll m3, ll b3) { // 转为 double 避免溢出 return 1.0 * (b1 - b3) * (m2 - m1) \u003c 1.0 * (b1 - b2) * (m3 - m1); } void add(ll m, ll b) { while ( (int) mvals.size() \u003e= 2 \u0026\u0026 bad(mvals[mvals.size() - 2], bvals[bvals.size() - 2], mvals[mvals.size() - 1], bvals[bvals.size() - 1], m, b)) { mvals.pop_back(); bvals.pop_back(); } mvals.push_back(m); bvals.push_back(b); } void setCur(ll x) { if (cur \u003e (int) mvals.size() - 1) cur = (int) mvals.size() - 1; // Best-line pointer goes to the right only when queries are non-decreasing (x argument grows) while (cur \u003c (int) mvals.size() - 1 \u0026\u0026 1.0 * mvals[cur + 1] * x + bvals[cur + 1] \u003c= 1.0 * mvals[cur] * x + bvals[cur]) cur++; } int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026height[i]); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026tax[i]); // Formula is dp[i] = min(tax[j] * height[i] + dp[j] | j = 1 .. i - 1) // Here tax[j] is considered as m value, and dp[j] as b value in line equation y = m * x + b for (int i = 1; i \u003c= n; i++) { if (i == 1) { dp[i] = 0; } else { setCur(height[i]); dp[i] = mvals[cur] * height[i] + bvals[cur]; } add(tax[i], dp[i]); } cout \u003c\u003c dp[n]; return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:1","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"最长递增序列 https://informatics.msk.ru/mod/statements/view3.php?id=766\u0026chapterid=1794 $O(N \\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = 1000 * 1000 * 1000; int n; int k, b, m; int a[MAXN]; int d[MAXN]; int ind[MAXN], pr[MAXN]; vector \u003cint\u003e ansv; int ans = 1; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); scanf(\"%d %d %d %d\", \u0026a[1], \u0026k, \u0026b, \u0026m); for (int i = 2; i \u003c= n; i++) a[i] = (k * a[i - 1] + b) % m; d[0] = -INF; for (int i = 1; i \u003c= n; i++) d[i] = INF; for (int i = 1; i \u003c= n; i++) { int pos = upper_bound(d + 1, d + n + 1, a[i]) - d; if (d[pos - 1] \u003c a[i] \u0026\u0026 a[i] \u003c d[pos]) { d[pos] = a[i]; ind[pos] = i; pr[i] = ind[pos - 1]; if (pos \u003e ans) { ans = pos; } } } if (ans == 1) { printf(\"%d\", a[1]); } else { int cur = ind[ans]; while (cur != 0) { ansv.push_back(a[cur]); cur = pr[cur]; } for (int i = (int) ansv.size() - 1; i \u003e= 0; i--) printf(\"%d \", ansv[i]); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:2","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"数据结构 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:0","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"笛卡尔树 Balanced Binary Search Tree https://informatics.msk.ru/mod/statements/view3.php?chapterid=2782 $O(\\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int mod = 1000 * 1000 * 1000; struct node { int x, y; node *l, *r; node(int new_x, int new_y) { x = new_x; y = new_y; l = NULL; r = NULL; } }; typedef node * pnode; void merge(pnode \u0026t, pnode l, pnode r) { if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } } void split(pnode t, int x, pnode \u0026l, pnode \u0026r) { if (t == NULL) l = r = NULL; else if (t-\u003ex \u003e x) { split(t-\u003el, x, l, t-\u003el); r = t; } else { split(t-\u003er, x, t-\u003er, r); l = t; } } void add(pnode \u0026t, pnode a) { if (t == NULL) t = a; else if (a-\u003ey \u003e t-\u003ey) { split(t, a-\u003ex, a-\u003el, a-\u003er); t = a; } else { if (t-\u003ex \u003c a-\u003ex) add(t-\u003er, a); else add(t-\u003el, a); } } int next(pnode t, int x) { int ans = -1; while (t != NULL) { if (t-\u003ex \u003c x) t = t-\u003er; else { if (ans == -1 || ans \u003e t-\u003ex) ans = t-\u003ex; t = t-\u003el; } } return ans; } int n, ans, x; char qt, prev_qt; pnode root = NULL, num; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\\n\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%c %d\\n\", \u0026qt, \u0026x); if (qt == '+') { if (prev_qt == '?') x = (x + ans) % mod; num = new node(x, rand()); add(root, num); } else { ans = next(root, x); printf(\"%d\\n\", ans); } prev_qt = qt; } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:1","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"带有隐式键的笛卡尔树 https://informatics.msk.ru/mod/statements/view3.php?chapterid=111240 $O(\\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003cutility\u003e#include \u003ccstring\u003e#include \u003ciomanip\u003e using namespace std; const int INF = 2 * 1000 * 1000 * 1000; struct node { int y, val; int sz, mn; bool rev; node *l, *r; node (int new_val, int new_y) { y = new_y; val = new_val; sz = 1; mn = val; rev = false; l = NULL; r = NULL; } }; typedef node * pnode; int getsize(pnode t) { if (t == NULL) return 0; return t-\u003esz; } int getmin(pnode t) { if (t == NULL) return INF; return t-\u003emn; } void update(pnode t) { if (t == NULL) return; t-\u003esz = getsize(t-\u003el) + 1 + getsize(t-\u003er); t-\u003emn = min(t-\u003eval, min(getmin(t-\u003er), getmin(t-\u003el))); } void push(pnode t) { if (t \u0026\u0026 t-\u003erev) { swap(t-\u003el, t-\u003er); if (t-\u003el) t-\u003el-\u003erev ^= true; if (t-\u003er) t-\u003er-\u003erev ^= true; t-\u003erev = false; } } void merge(pnode \u0026t, pnode l, pnode r) { push(l); push(r); if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } update(t); } void split(pnode t, pnode \u0026l, pnode \u0026r, int x, int add = 0) { push(t); if (t == NULL) { l = r = NULL; return; } int key = getsize(t-\u003el) + 1 + add; if (x \u003c= key) { split(t-\u003el, l, t-\u003el, x, add); r = t; } else { split(t-\u003er, t-\u003er, r, x, add + getsize(t-\u003el) + 1); l = t; } update(t); } void reverse(pnode t, int l, int r) { pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); a-\u003erev ^= true; merge(t, t, a); merge(t, t, b); } int getmin(pnode t, int l, int r) { int ans; pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); ans = getmin(a); merge(t, t, a); merge(t, t, b); return ans; } int n, m; int qt, l, r; pnode root = NULL, add; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int x; scanf(\"%d\", \u0026x); add = new node(x, rand()); merge(root, root, add); } for (int i = 1; i \u003c= m; i++) { scanf(\"%d %d %d\",\u0026qt, \u0026l, \u0026r); if (qt == 1) { reverse(root, l, r); } else { printf(\"%d\\n\", getmin(root, l, r)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:2","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"树状数组 $O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3317 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; int a[MAXN]; long long f[MAXN]; char q; int l, r; void update(int pos, int delta) { for (; pos \u003c= n; pos = (pos | (pos + 1))) f[pos] += delta; } long long sum(int pos) { long long res = 0; for (; pos \u003e 0; pos = (pos \u0026 (pos + 1)) - 1) res += f[pos]; return res; } long long sum(int l, int r) { return sum(r) - sum(l - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026a[i]); update(i, a[i]); } scanf(\"%d\\n\", \u0026m); for (int i = 1; i \u003c= m; i++) { scanf(\"%c %d %d\\n\", \u0026q, \u0026l, \u0026r); if (q == 's') { cout \u003c\u003c sum(l, r) \u003c\u003c \" \"; } else { int delta = r - a[l]; a[l] = r; update(l, delta); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:3","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"二维树状数组 $O((\\log N)^2)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3013 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 1050; int n, m; int qn; char q[10]; int f[MAXN][MAXN]; void update(int x, int y, int delta) { for (int i = x; i \u003c= n; i = i | (i + 1)) for (int j = y; j \u003c= m; j = j | (j + 1)) f[i][j] += delta; } int getSum(int x, int y) { int res = 0; for (int i = x; i \u003e 0; i = (i \u0026 (i + 1)) - 1) for (int j = y; j \u003e 0; j = (j \u0026 (j + 1)) - 1) res += f[i][j]; return res; } int getSum(int xFrom, int xTo, int yFrom, int yTo) { return getSum(xTo, yTo) - getSum(xTo, yFrom - 1) - getSum(xFrom - 1, yTo) + getSum(xFrom - 1, yFrom - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026qn); m = n; for (int i = 1; i \u003c= qn; i++) { scanf(\"%s\", \u0026q); if (q[0] == 'A') { int x, y; scanf(\"%d %d\\n\", \u0026x, \u0026y); update(x, y, 1); } else { int xFrom, xTo, yFrom, yTo; scanf(\"%d %d %d %d\\n\", \u0026xFrom, \u0026yFrom, \u0026xTo, \u0026yTo); if (xFrom \u003e xTo) swap(xFrom, xTo); if (yFrom \u003e yTo) swap(yFrom, yTo); printf(\"%d\\n\", getSum(xFrom, xTo, yFrom, yTo)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:4","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"隐式的线段树 时间复杂度：$O(\\log N)$ 空间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3327 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003ccstdlib\u003e using namespace std; typedef long long ll; struct Node { ll sum; Node *l, *r; Node() : sum(0), l(NULL), r(NULL) { } }; void add(Node *v, int l, int r, int q_l, int q_r, ll val) { if (l \u003e r || q_r \u003c l || q_l \u003e r) return; if (q_l \u003c= l \u0026\u0026 r \u003c= q_r) { v -\u003e sum += val; return; } int mid = (l + r) \u003e\u003e 1; if (v -\u003e l == NULL) v -\u003e l = new Node(); if (v -\u003e r == NULL) v -\u003e r = new Node(); add(v -\u003e l, l, mid, q_l, q_r, val); add(v -\u003e r, mid + 1, r, q_l, q_r, val); } ll get(Node *v, int l, int r, int pos) { if (!v || l \u003e r || pos \u003c l || pos \u003e r) return 0; if (l == r) return v -\u003e sum; int mid = (l + r) \u003e\u003e 1; return v -\u003e sum + get(v -\u003e l, l, mid, pos) + get(v -\u003e r, mid + 1, r, pos); } int n, m, t, x, y, val; char c; int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); Node *root = new Node(); scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026x); add(root, 0, n - 1, i, i, x); } scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"\\n%c\", \u0026c); if (c == 'a') { scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026val); add(root, 0, n - 1, --x, --y, val); } else { scanf(\"%d\", \u0026x); printf(\"%I64d \", get(root, 0, n - 1, --x)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:5","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"最小队列 时间复杂度：$O(1)$ https://informatics.msk.ru//mod/statements/view.php?chapterid=756 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 205000; int n, m; deque \u003c pair \u003cint, int\u003e \u003e d; int a[MAXN]; void enqueue(int x) { int num = 1; while (!d.empty() \u0026\u0026 d.back().first \u003e x) { num += d.back().second; d.pop_back(); } d.push_back(make_pair(x, num)); } void dequeue() { if (d.front().second == 1) { d.pop_front(); } else { d.front().second--; } } int getMin() { return d.front().first; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); for (int i = 1; i \u003c= m; i++) { enqueue(a[i]); } printf(\"%d\\n\", getMin()); for (int i = m + 1; i \u003c= n; i++) { dequeue(); enqueue(a[i]); printf(\"%d\\n\", getMin()); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:6","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"线段树（加法-最小间隔-最大间隔） https://codeforces.com/contest/1263/problem/E #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 1000 * 1000 + 100; const int INF = (int) 1e9; struct node { int mx, mn; int add; }; int n; int val[MAXN]; string s; int pos; node tree[4 * MAXN]; void add(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; if (L == l \u0026\u0026 R == r) { tree[v].add += val; } else { int mid = L + (R - L) / 2; add(2 * v + 1, L, mid, l, min(mid, r), val); add(2 * v + 2, mid + 1, R, max(mid + 1, l), r, val); tree[v].mx = max(tree[2 * v + 1].mx + tree[2 * v + 1].add, tree[2 * v + 2].mx + tree[2 * v + 2].add); tree[v].mn = min(tree[2 * v + 1].mn + tree[2 * v + 1].add, tree[2 * v + 2].mn + tree[2 * v + 2].add); } } int getMin(int v, int L, int R, int l, int r) { if (l \u003e r) { return INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mn + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + min(getMin(2 * v + 1, L, mid, l, min(mid, r)), getMin(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int getMax(int v, int L, int R, int l, int r) { if (l \u003e r) { return -INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mx + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + max(getMax(2 * v + 1, L, mid, l, min(mid, r)), getMax(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\\n\", \u0026n); getline(cin, s); pos = 0; for (int i = 0; i \u003c (int) s.length(); i++) { if (s[i] == 'L') { if (pos \u003e 0) pos--; } else if (s[i] == 'R') { pos++; } else { int newVal = 0; if (s[i] == '(') { newVal = 1; } else if (s[i] == ')') { newVal = -1; } int delta = newVal - val[pos]; val[pos] = newVal; add(0, 0, n - 1, pos, n - 1, delta); } int mn = getMin(0, 0, n - 1, 0, n - 1); int lastVal = getMin(0, 0, n - 1, n - 1, n - 1); if (mn \u003c 0 || lastVal != 0) { printf(\"%d \", -1); } else { printf(\"%d \", getMax(0, 0, n - 1, 0, n - 1)); } } cout \u003c\u003c endl; return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:7","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"线段树（分配-求和） https://codeforces.com/gym/100093 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int zero = -1; struct node { long long sum; int val; int size; }; int n, m; char qt; int x, l, r; int a[MAXN]; vector \u003cnode\u003e tree; void build (int v, int L, int R, int a[]) { if (L == R) { tree[v].sum = tree[v].val = a[L]; tree[v].size = 1; } else { int mid = L + (R - L) / 2; build(2 * v, L, mid, a); build(2 * v + 1, mid + 1, R, a); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; tree[v].val = zero; tree[v].size = tree[2 * v + 1].size + tree[2 * v].size; } } void push(int v) { if (tree[v].val == zero) return; if (tree[v].size != 1) { tree[2 * v].val = tree[v].val; tree[2 * v + 1].val = tree[v].val; } tree[v].sum = 1ll * tree[v].size * tree[v].val; tree[v].val = zero; } void assign(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; push(v); if (L == l \u0026\u0026 R == r) { tree[v].val = val; tree[v].sum = 1ll * val * tree[v].size; } else { int mid = L + (R - L) / 2; assign(2 * v, L, mid, l, min(mid, r), val); assign(2 * v + 1, mid + 1, R, max(mid + 1, l), r, val); push(2 * v); push(2 * v + 1); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; } push(v); } long long getsum(int v, int L, int R, int l, int r) { if (l \u003e r) return 0; push(v); if (l == L \u0026\u0026 r == R) return tree[v].sum; int mid = L + (R - L) / 2; long long res = getsum(2 * v, L, mid, l, min(mid, r)) + getsum(2 * v + 1, mid + 1, R, max(l, mid + 1), r); return res; } int main() { assert(freopen(\"sum.in\",\"r\",stdin)); assert(freopen(\"sum.out\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026m); tree.resize(4 * n); build(1, 1, n, a); for (int i = 1; i \u003c= m; i++) { scanf(\"%c\", \u0026qt); if (qt == 'A') { scanf(\"%d %d %d\\n\", \u0026l, \u0026r, \u0026x); assign(1, 1, n, l, r, x); } else { scanf(\"%d %d\\n\", \u0026l, \u0026r); cout \u003c\u003c getsum(1, 1, n, l, r) \u003c\u003c endl; } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:8","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"线段树（最小值-值更新） 预先计算：$O(N \\log N)$ 查询：$O(1)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = (int) 1e9; int n, num, qn; int a[MAXN]; int tree[4 * MAXN]; int l, r; int getMax(int l, int r) { l = num + l - 1; r = num + r - 1; int res = -INF; while (l \u003c= r) { if (l \u0026 1) { res = max(res, tree[l]); l++; } if (r % 2 == 0) { res = max(res, tree[r]); r--; } l /= 2; r /= 2; } return res; } void update(int pos, int val) { pos = num + pos - 1; tree[pos] = val; pos /= 2; while (pos \u003e= 1) { tree[pos] = max(tree[pos * 2], tree[pos * 2 + 1]); pos /= 2; } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); num = 1; while (num \u003c n) num *= 2; for (int i = num; i \u003c 2 * num; i++) { if (i - num + 1 \u003c= n) tree[i] = a[i - num + 1]; else tree[i] = -INF; } for (int i = num - 1; i \u003e= 1; i--) { tree[i] = max(tree[i * 2], tree[i * 2 + 1]); } scanf(\"%d\", \u0026qn); for (int i = 1; i \u003c= qn; i++) { scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:9","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"稀疏表 预先计算：$O(N)$ 查询：$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 2 * 105000; const int MAXLOG = 20; int n, m; int a[MAXN]; int table[MAXLOG][MAXN]; int numlog[MAXN]; void buildTable() { numlog[1] = 0; for (int i = 2; i \u003c= n; i++) numlog[i] = numlog[i / 2] + 1; for (int i = 0; i \u003c= numlog[n]; i++) { int curlen = 1 \u003c\u003c i; for (int j = 1; j \u003c= n; j++) { if (i == 0) { table[i][j] = a[j]; continue; } table[i][j] = max(table[i - 1][j], table[i - 1][j + curlen / 2]); } } } int getMax(int l, int r) { int curlog = numlog[r - l + 1]; return max(table[curlog][l], table[curlog][r - (1 \u003c\u003c curlog) + 1]); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); buildTable(); scanf(\"%d\", \u0026m); for (int i = 1; i \u003c= m; i++) { int l, r; scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:10","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"几何 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:0","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"最近点对 时间复杂度：$O(N \\log N)$ https://www.spoj.com/problems/CLOPPAIR/ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; #define sqr(x) ((x) * (x)) const double inf = 1e100; const int MAXN = 105000; struct point { double x, y; int ind; }; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } int n; int a[MAXN]; point p[MAXN], tmp[MAXN]; double ans = inf; int p1, p2; void updateAnswer(point a, point b) { double d = dist(a, b); if (d \u003c ans) { ans = d; p1 = a.ind; p2 = b.ind; } } void closestPair(int l, int r) { if (l \u003e= r) return; if (r - l == 1) { if (p[l].y \u003e p[r].y) swap(p[l], p[r]); updateAnswer(p[l], p[r]); return; } int m = (l + r) / 2; double mx = p[m].x; closestPair(l, m); closestPair(m + 1, r); int lp = l, rp = m + 1, sz = 1; while (lp \u003c= m || rp \u003c= r) { if (lp \u003e m || ((rp \u003c= r \u0026\u0026 p[rp].y \u003c p[lp].y))) { tmp[sz] = p[rp]; rp++; } else { tmp[sz] = p[lp]; lp++; } sz++; } for (int i = l; i \u003c= r; i++) p[i] = tmp[i - l + 1]; sz = 0; for (int i = l; i \u003c= r; i++) if (abs(p[i].x - mx) \u003c ans) { sz++; tmp[sz] = p[i]; } for (int i = 1; i \u003c= sz; i++) { for (int j = i - 1; j \u003e= 1; j--) { if (tmp[i].y - tmp[j].y \u003e= ans) break; updateAnswer(tmp[i], tmp[j]); } } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%lf %lf\", \u0026p[i].x, \u0026p[i].y); p[i].ind = i - 1; } sort(p + 1, p + n + 1, cmp); closestPair(1, n); printf(\"%d %d %.6lf\\n\", min(p1, p2), max(p1, p2), ans); return 0; } #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e using namespace std; #define sqr(a) ((a)*(a)) const double inf = 1e100; const int MAXN = 55000; struct point { double x, y; int ind; void read() { scanf(\"%lf%lf\", \u0026x, \u0026y); } double dist_to(point\u0026 r) { return sqrt(sqr(x - r.x) + sqr(y - r.y)); } bool operator\u003c(const point\u0026r) const { return x \u003c r.x || (x == r.x \u0026\u0026 y \u003c r.y); } }; point aux[MAXN], P[MAXN], v[MAXN]; int vn; int a, b, n; double ans = inf; // ans contains closest distance, a, b - indices of points. void closest_pair(point p[], int n) { if (n \u003c= 1) return ; if (n == 2) { if (p[0].y \u003e p[1].y) swap(p[0], p[1]); double d = p[0].dist_to(p[1]); if (d \u003c ans) ans = d, a = p[0].ind, b = p[1].ind; return; } int m = n / 2; double x = p[m].x; closest_pair(p, m); // left closest_pair(p + m, n - m); //right int il = 0, ir = m, i = 0; while (il \u003c m \u0026\u0026 ir \u003c n) { // merging two halves if (p[il].y \u003c p[ir].y) aux[i ++] = p[il ++]; else aux[i ++] = p[ir ++]; } while (il \u003c m) aux[i ++] = p[il ++]; while (ir \u003c n) aux[i ++] = p[ir ++]; vn = 0; for (int j = 0 ; j \u003c n ; j ++) { // copying back into p p[j] = aux[j]; if (fabs(p[j].x - x) \u003c ans) // looking at the strip of width 2*ans v[vn ++] = p[j]; } for (int j = 0 ; j \u003c vn ; j ++) { // (2*ans) x (ans) box for (int k = j + 1 ; k \u003c vn \u0026\u0026 v[k].y - v[j].y \u003c ans ; k ++) { double d = v[j].dist_to(v[k]); if (ans \u003e d) { ans = d; a = v[k].ind, b = v[j].ind; } } } } int main() { scanf(\"%d\", \u0026n); for (int i = 0 ; i \u003c n ; i++) { P[i].read(); P[i].ind = i; } sort(P, P + n); closest_pair(P, n); printf(\"%d %d %lf\\n\", min(a, b), max(a, b), ans); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:1","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"凸包 Graham-Andrew 方法 时间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view3.php?chapterid=638 https://informatics.msk.ru/mod/statements/view3.php?id=\u0026chapterid=290 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e using namespace std; #define sqr(x) ((x) * (x)) const double pi = acos(-1.0); struct point { double x, y; }; int n; vector \u003cpoint\u003e p, hull; double ans; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } bool eq(point a, point b) { return (a.x == b.x \u0026\u0026 a.y == b.y); } bool isCCW(point a, point b, point c) { return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) \u003e 0; } void setConvexHull(vector \u003cpoint\u003e p, vector \u003cpoint\u003e \u0026h) { sort(p.begin(), p.end(), cmp); p.erase(unique(p.begin(), p.end(), eq), p.end()); vector \u003cpoint\u003e up, down; point head = p[0], tail = p.back(); up.push_back(head); down.push_back(head); for (int i = 1; i \u003c (int) p.size(); i++) { if (i == (int) p.size() - 1 || !isCCW(tail, head, p[i])) { while ( (int) up.size() \u003e= 2 \u0026\u0026 isCCW(up[up.size() - 2], up.back(), p[i]) ) up.pop_back(); up.push_back(p[i]); } if (i == (int) p.size() - 1 || isCCW(tail, head, p[i])) { while ( (int) down.size() \u003e= 2 \u0026\u0026 !isCCW(down[down.size() - 2], down.back(), p[i]) ) down.pop_back(); down.push_back(p[i]); } } h.clear(); for (int i = 0; i \u003c (int) up.size(); i++) h.push_back(up[i]); for (int i = (int) down.size() - 2; i \u003e 0; i--) h.push_back(down[i]); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } double getPerimeter(vector \u003cpoint\u003e p) { double per = 0; for (int i = 1; i \u003c (int) p.size(); i++) per += dist(p[i - 1], p[i]); per += dist(p.back(), p[0]); return per; } int main() { freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { point tmp; scanf(\"%lf %lf\", \u0026tmp.x, \u0026tmp.y); p.push_back(tmp); } setConvexHull(p, hull); ans = getPerimeter(hull); printf(\"%.1lf\", ans); return 0; } 时间复杂度：$O(sort) + O(N)$ #include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e using namespace std; #define sqr(x) ((x) * (x)) const double inf = 1e100, eps = 1e-12; struct point { double x, y; void read() { scanf(\"%lf%lf\", \u0026x, \u0026y); } double r() { return sqrt(x*x+y*y); } void print() { printf(\"%lf %lf\\n\", x, y); } bool operator\u003c(const point\u0026 r) const { if (x \u003c r.x) return 1; if (x \u003e r.x) return 0; return y \u003c r.y; } point operator-(point\u0026 r) { point res = {x - r.x, y - r.y}; return res; } double slope() { if (x == 0.0 \u0026\u0026 y == 0.0) return -inf; if (x == 0.0) return inf; return y/x; } double operator*(const point\u0026 r) { return x*r.y - y*r.x; } double dist_to(point\u0026 r) { return sqrt(sqr(x-r.x)+sqr(y-r.y)); } }; point O; // left-most lower point bool BY_SLOPE(point l, point r) { double ls = (l-O).slope(), rs = (r-O).slope(); if (ls \u003c rs) return 1; if (ls \u003e rs) return 0; return l.dist_to(O) \u003c r.dist_to(O); } // pre: N \u003e= 0, [p, p + N) - points vector\u003cpoint\u003e convex_hull(point *p, int N) { if (N \u003c= 2) return vector\u003cpoint\u003e(p, p + N); sort(p, p + N); O = p[0]; sort(p + 1, p + N, BY_SLOPE); vector\u003cpoint\u003e hull; for (int i = 0 ; i \u003c N ; i ++) { if (i \u003c 3) hull.push_back(p[i]); else { int sz = hull.size(); while (sz \u003e= 2 \u0026\u0026 (p[i] - hull[sz-2])*(hull[sz-1]-hull[sz-2]) \u003e= 0) hull.pop_back(), sz --; hull.push_back(p[i]); } } return hull; }// post: convex hull in hull, given in ccw order vector\u003cpoint\u003e v; int n; point P[21100]; int main() { scanf(\"%d\", \u0026n); for (int i = 0 ; i \u003c n ; i ++) P[i].read(); v = convex_hull(P, n); double p = 0.0, s = 0.0; for (int i = 0 ; i \u003c v.size() ; i ++) { p += (v[i]-v[(i+1)%v.size()]).r(); s += .5*(v[i]*v[(i+1)%v.size()]); } printf(\"%e\\n%e\\n\", p, s); //printf(\"%.1lf\\n\", p); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:2","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"图 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:0","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"Bellman-Ford 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view3.php?id=260\u0026chapterid=178 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105; const int INF = 30000; struct edge { int from, to; int w; }; int n, m; int dist[MAXN]; vector \u003cedge\u003e e; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { edge curEdge; scanf(\"%d %d %d\", \u0026curEdge.from, \u0026curEdge.to, \u0026curEdge.w); e.push_back(curEdge); } for (int i = 1; i \u003c= n; i++) dist[i] = INF; dist[1] = 0; for (int i = 1; i \u003c= n; i++) { bool changed = false; for (int j = 0; j \u003c m; j++) { int from = e[j].from, to = e[j].to, w = e[j].w; if (dist[from] != INF \u0026\u0026 dist[from] + w \u003c dist[to]) { dist[to] = dist[from] + w; changed = true; } } if (!changed) break; } for (int i = 1; i \u003c= n; i++) printf(\"%d \", dist[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:1","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"二部图匹配 Kuhn 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=1683 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105; int n, m; vector \u003cint\u003e g[MAXN]; bool used[MAXN]; int mt[MAXN]; int ans; bool kuhn(int v) { if (used[v]) return false; used[v] = true; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (mt[to] == 0 || kuhn(mt[to])) { mt[to] = v; return true; } } return false; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int can; scanf(\"%d\", \u0026can); if (can) g[i].push_back(j); } } for (int i = 1; i \u003c= n; i++) { memset(used, 0, sizeof(used)); if (kuhn(i)) ans++; } printf(\"%d\\n\", ans); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:2","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"桥搜索 时间复杂度：$O(M)$ https://codeforces.com/gym/100083 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; vector \u003cint\u003e g[MAXN]; vector \u003cint\u003e ind[MAXN]; int tin[MAXN], mn[MAXN]; bool used[MAXN]; vector \u003cint\u003e bridges; int timer; void dfs(int v, int par = -1) { used[v] = true; timer++; tin[v] = timer; mn[v] = tin[v]; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { dfs(to, v); if (mn[to] == tin[to]) { bridges.push_back(ind[v][i]); } mn[v] = min(mn[v], mn[to]); } else if (to != par) { mn[v] = min(mn[v], mn[to]); } } } int main() { assert(freopen(\"bridges.in\",\"r\",stdin)); assert(freopen(\"bridges.out\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { int from, to; scanf(\"%d %d\", \u0026from, \u0026to); g[from].push_back(to); ind[from].push_back(i); g[to].push_back(from); ind[to].push_back(i); } for (int i = 1; i \u003c= n; i++) if (!used[i]) dfs(i); sort(bridges.begin(), bridges.end()); printf(\"%d\\n\", (int) bridges.size()); for (int i = 0; i \u003c (int) bridges.size(); i++) printf(\"%d\\n\", bridges[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:3","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"参考资料 ADJA/algos: Competitive programming algorithms in C++ - GitHub ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:0","series":null,"tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"扩展程序是简单的工具，可自定义浏览器体验并提供更多控制。 ","date":"2021-02-21","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/:0:0","series":null,"tags":null,"title":"浏览器扩展程序","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词-聚合词典划词翻译 Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-02-21","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/:1:0","series":null,"tags":null,"title":"浏览器扩展程序","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"Edge 外接程序 BETA uBlock Origin 沙拉查词-聚合词典划词翻译 Tampermonkey Bitwarden - 免费密码管理器 Augmented Steam Edge 浏览器也可到 Chrome 网上应用店安装扩展。 ","date":"2021-02-21","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/:2:0","series":null,"tags":null,"title":"浏览器扩展程序","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/"},{"categories":[],"content":" Tab 补全命令 Ctrl + C 停止当前运行中的程序 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:0:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":[],"content":"scp scp 是 Linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。 # 1.从本地复制到远程 # 1.1.单文件 scp -P \u003cSSH_PORT\u003e \u003cLOCAL_FILE\u003e \u003cUSERNAME\u003e@\u003cIP_ADDRESS\u003e:\u003cREMOTE_FOLDER\u003e # 1.2.目录 scp -P \u003cSSH_PORT\u003e -r \u003cLOCAL_FOLDER\u003e \u003cUSERNAME\u003e@\u003cIP_ADDRESS\u003e:\u003cREMOTE_FOLDER\u003e # 2.从远程复制到本地 # 1.1.单文件 scp -P \u003cSSH_PORT\u003e \u003cUSERNAME\u003e@\u003cIP_ADDRESS\u003e:\u003cREMOTE_FILE\u003e \u003cLOCAL_FOLDER\u003e # 2.2.目录 scp -P \u003cSSH_PORT\u003e -r \u003cUSERNAME\u003e@\u003cIP_ADDRESS\u003e:\u003cREMOTE_FOLDER\u003e \u003cLOCAL_FOLDER\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":null,"content":"Chocolatey https://chocolatey.org/ @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" \u0026\u0026 SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) ","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:0","series":null,"tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"Scoop https://scoop.sh/ https://github.com/lukesampson/scoop Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh') ","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:0","series":null,"tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"Windows Package Manager CLI (winget) https://github.com/microsoft/winget-cli ","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:3:0","series":null,"tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"参考资料","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:4:0","series":null,"tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"A 常量指针： 常量指针本质上是个指针，只不过这个指针指向的对象是常量。 特点： const 的位置在指针声明运算符 * 的左侧。只要 const 位于 * 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。 （可以这样理解，* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。） const int * p1; int const * p2; const int c_var = 8; int var = 6; const int *p3 = \u0026c_var; *p3 = 6; // error C3892: “p3”: 不能给常量赋值 p3 = \u0026var; // 可以赋值 指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。 虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。 指针常量： 指针常量的本质上是个常量，只不过这个常量的值是一个指针。 特点： const 位于指针声明操作符右侧，表明该对象本身是一个常量，* 左侧表示该指针指向的类型，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。 const int c_var = 8; int var = 6; int * const c_p1 = \u0026c_var; // error C2440: “初始化”: 无法从“const int *”转换为“int *” int * const c_p2 = \u0026var; c_p1 = \u0026var; // error C3892: “c_p1”: 不能给常量赋值 *c_p2 = 6; 指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。 指针的内容可以改变。 ","date":"2021-02-19","objectID":"/posts/c++-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"C++ 教程","uri":"/posts/c++-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"B 重载： 是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。 class A { public: void fun(int tmp); void fun(float tmp); // 重载 参数类型不同（相对于上一个函数） void fun(int tmp, float tmp1); // 重载 参数个数不同（相对于上一个函数） void fun(float tmp, int tmp1); // 重载 参数顺序不同（相对于上一个函数） int fun(int tmp); // error C2556: “int A::fun(int)”: 重载函数与“void A::fun(int)”只是在返回类型上不同 }; 隐藏： 是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。 class Base { public: void fun(int tmp, float tmp1) { cout \u003c\u003c \"Base::fun(int tmp, float tmp1)\" \u003c\u003c endl; } }; class Derive : public Base { public: void fun(int tmp) { cout \u003c\u003c \"Derive::fun(int tmp)\" \u003c\u003c endl; } // 隐藏基类中的同名函数 }; int main() { Derive ex; ex.fun(1); // Derive::fun(int tmp) ex.fun(1, 0.01); // error C2660: “Derive::fun”: 函数不接受 2 个参数 return 0; } 重写(覆盖)： 是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。 class Base { public: virtual void fun(int tmp) { cout \u003c\u003c \"Base::fun(int tmp)\" \u003c\u003c endl; } }; class Derive : public Base { public: virtual void fun(int tmp) { cout \u003c\u003c \"Derive::fun(int tmp)\" \u003c\u003c endl; } // 重写基类中的同名函数 }; int main() { Base *p = new Derive(); p-\u003efun(3); // Derive::fun(int) return 0; } ","date":"2021-02-19","objectID":"/posts/c++-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":null,"title":"C++ 教程","uri":"/posts/c++-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"freeCodeCamp 2018 年新版课程，包括响应式 Web 设计、算法和数据结构、前端库和框架、数据可视化、API 和微服务、信息安全和质量保证和面试攻略等方面。 ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:0:0","series":null,"tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"响应式 Web 设计 ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:0","series":null,"tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"HTML 基础 HTML的全称是HyperText Markup Language（超文本标记语言），它是一种用来描述网页结构的标记语言。 文档类型和结构 \u003c!DOCTYPE html\u003e \u003c!--DOCTYPE 一定要大写；html 表示版本为 HTML5，大小写均可--\u003e \u003chtml\u003e \u003chead\u003e \u003c!--link、meta、title 和 style 都应该放入 head 标签--\u003e \u003ctitle\u003etitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eheader\u003c/h1\u003e \u003cp\u003etext\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 常用标签 \u003c!--标题--\u003e \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch4\u003e四级标题\u003c/h4\u003e \u003ch5\u003e五级标题\u003c/h5\u003e \u003ch6\u003e六级标题\u003c/h6\u003e \u003c!--文本媒体--\u003e \u003cp\u003e段落\u003c/p\u003e \u003cmain\u003e主要内容\u003c/main\u003e \u003cimg src=\"https://test.jpg\" alt=\"图片\"\u003e \u003cdiv\u003e\u003c/div\u003e \u003chr\u003e \u003c!--特效--\u003e \u003cstrong\u003e加粗\u003c/strong\u003e \u003cem\u003e斜体\u003c/em\u003e \u003cu\u003e下划线\u003c/u\u003e \u003cs\u003e删除线\u003c/s\u003e \u003c!--锚点--\u003e \u003ca href=\"https://test.jpg\" target=\"_blank\"\u003e锚点-1-新标签页网页间跳转\u003c/a\u003e \u003ca href=\"#contacts-header\"\u003e锚点-2-网页内跳转\u003c/a\u003e \u003ch2 id=\"contacts-header\"\u003eContacts\u003c/h2\u003e \u003ca href=\"#\"\u003e锚点-3-固定链接\u003c/a\u003e \u003c!--列表--\u003e \u003cul\u003e \u003cli\u003e无序列表1\u003c/li\u003e \u003cli\u003e无序列表2\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli\u003e有序列表1\u003c/li\u003e \u003cli\u003e有序列表2\u003c/li\u003e \u003c/ol\u003e lorem ipsum text: 占位符 表单 \u003cform action=\"/url\"\u003e \u003cinput type=\"text\" placeholder=\"占位符\" required\u003e \u003c!--必填--\u003e \u003c!--label 标签设置 for 属性，让其值与按钮的 id 属性值相等--\u003e \u003c!--所有关联的单选按钮应该拥有相同的 name 属性--\u003e \u003clabel for=\"A\"\u003e\u003cinput type=\"radio\" id=\"A\" name=\"A-B\"\u003e单选按钮-A\u003c/label\u003e \u003clabel for=\"B\"\u003e\u003cinput type=\"radio\" id=\"B\" name=\"A-B\" checked\u003e单选按钮-B\u003c/label\u003e \u003c!--默认选中--\u003e \u003clabel for=\"C\"\u003e\u003cinput type=\"checkbox\" id=\"C\" name=\"C-D\"\u003e多选按钮-C\u003c/label\u003e \u003clabel for=\"D\"\u003e\u003cinput type=\"checkbox\" id=\"D\" name=\"C-D\"\u003e多选按钮-D\u003c/label\u003e \u003cbutton type=\"submit\"\u003e提交按钮\u003c/button\u003e \u003c/form\u003e ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:1","series":null,"tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"CSS 基础 CSS的全称是Cascading Style Sheet（层叠样式表），它主要用来控制网页的样式。 CSS 的选择器区分大小写，因此要谨慎使用大写。 内联样式和内部样式 使用 CSS 的三种方式： 内联样式：直接在 HTML 元素里使用style属性。 内部样式：在style标签里编写样式规则。 外部样式：创建一个单独的.css文件，然后在文件中编写样式规则，最后在文档中引用该文件。（常用） \u003c!-- 内联样式 --\u003e \u003ch2 style=\"color: red;\"\u003eheader\u003c/h2\u003e \u003c!-- 内部样式，style 定义在 head 标签中 --\u003e \u003cstyle\u003e .blue-class { color: blue; } \u003c/style\u003e \u003cp class=\"blue-class\"\u003etext\u003c/p\u003e 外部样式 h2 {} /* 标签选择器 */ .class-selector {} /* class 选择器 */ #id-selector {} /* id 选择器*/ .links {} /* 超链接选择器 */ a:hover {} /* 锚点的悬停状态选择器 */ [type=\"radio\"] {} /* 属性选择器 */ 调整元素边距 所有的 HTML 元素基本都是以矩形为基础。 每个 HTML 元素周围的矩形空间由三个重要的属性来控制：padding（内边距），margin（外边距）和border（边框）。 .red-box { background-color: red; color: black; border-style: solid; border-color: black; border-width: 5px; /* border: 5px solid black; */ padding: 20px; /* padding-top: 40px; padding-right: 20px; padding-bottom: 20px; padding-left: 40px; padding: 40px 20px 20px 40px; /* 上右下左 */ */ margin: 20px; /* 若为负值，元素会变得更大 */ /* margin-top: 40px; margin-right: 20px; margin-bottom: 20px; margin-left: 40px; margin: 40px 20px 20px 40px; /* 上右下左 */ */ } 长度单位 px 像素，绝对单位 in 英寸，绝对单位 mm 毫米，绝对单位 em 相对单位，基于元素的字体的 font-size 值 rem 相对单位 样式的继承与优先级 若子标签未声明样式规则，则继承父标签的样式。 相同级别选择器之间，后声明的优先级高于先声明的 class选择器优先级高于标签选择器 id选择器优先级高于class选择器 内联样式的优先级高于id选择器 important的优先级最高 .pink-text { color: pink !important; } CSS 变量 :root { --dog-color: brown; /* 定义 CSS 全局变量 */ } .dog { --dog-color: white; /* 定义 CSS 局部变量，覆盖同名全局变量 */ background-color: var(--dog-color, black); /* 使用 CSS 变量，同时设置一个备用值 */ } ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:2","series":null,"tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"应用视觉设计 Applied Visual Design Challenges（应用视觉设计）结合了排版、色彩理论、图形、动画和页面布局等。 常用属性值 color 可用英语颜色单词、#000000、#000、rgb(0,0,0)、rgba(255,255,255,0.5) 0 代表完全透明，1 代表完全不透明 color: red; 文本颜色 background-color: blue; 背景颜色 font font-size: 20px; 文本大小 font-weight: bold; 文本加粗，相当于\u003cstrong\u003e\u003c/strong\u003e font-weight: 600; 文本粗细 font-family: sans-serif, monospace, serif; 文本字体，当前面字体不可用时后面字体作为备用 font-style: italic; 文本斜体，相当于\u003cem\u003e\u003c/em\u003e border border-color: red; 边框颜色 border-width: 2px; 边框粗细 border-style: solid; 边框类型 border-radius: 10px; 圆角，50% 就是圆形 text text-align: left; 文本左对齐 text-align: center; 文本居中 text-align: right; 文本右对齐 text-align: justify; 文本两端对齐 text-decoration: underline; 文本下划线，相当于\u003cu\u003e\u003c/u\u003e text-decoration: line-through; 文本删除线，相当于\u003cs\u003e\u003c/s\u003e text-transform: lowercase; 英文字母全小写 text-transform: uppercase; 英文字母全大写 text-transform: capitalize; 英文字母首字母大写 text-transform: initial; 默认值 text-transform: inherit; 继承父元素的 text-transform text-transform: none; 不改变 line-height: 25px; 行高、行间距 box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23); 水平偏移量、垂直偏移量、模糊距离、阴影尺寸、颜色 opacity: 0.5; 透明度。1 代表不透明，0.5 代表半透明，0 代表透明 z-index: 2; 指定元素的堆叠次序，取整数，数值大的元素优先显示 位置 在 CSS 里一切 HTML 元素皆为盒子，也就是通常所说的盒模型。块级元素自动从新的一行开始（比如标题、段落以及 div），行内元素排列在上一个元素后（比如图片以及 span）。元素默认按照这种方式布局称为文档的普通流，同时 CSS 提供了position属性来覆盖它。 top、bottom、left和right定义了元素在相应方位的偏移距离。元素将从当前位置，向属性相反的方向偏移。 relative 当元素position: relative;时，它允许你通过 CSS 指定该元素在当前普通流页面下的相对偏移量。 position: relative;并不会改变该元素在普通流布局所占的位置，也不会对其它元素的位置产生影响。 absolute 当元素position: absolute;时，会将元素从当前的文档流里面移除，周围的元素会忽略它。absolute定位参照于最近的已定位祖先元素，如果它的父元素没有添加定位规则（默认是relative），浏览器会继续寻找直到默认的 body 标签。 fixed 当元素position: fixed;时，会将元素从当前的文档流里面移除，其它元素会忽略它。 fixed定位和absolute定位的最明显的区别是fixed定位元素不会随着屏幕滚动而移动。 float 通过元素的float属性来设置。浮动元素不在文档流中，它向左或向右浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。通常需要用width属性来指定浮动元素占据的水平空间。可以float: left;或float: right;。 ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:3","series":null,"tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":["LaTeX","Cheatsheet"],"content":"LaTeX 常用数学符号、公式。 标量 - 斜体小写 - $a$ 向量 - 粗体小写 - $a$ 矩阵 - 粗体大写 - $A$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:0:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"希腊字母 大写字母 代码 小写字母 代码 变量形式 代码 $\\alpha$ \\alpha $\\beta$ \\beta $\\Gamma$ \\Gamma $\\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $\\epsilon$ \\epsilon $\\Theta$ \\Theta $\\theta$ \\theta $\\Lambda$ \\Lambda $\\lambda$ \\lambda $\\mu$ \\mu $\\Pi$ \\Pi $\\pi$ \\pi $\\rho$ \\rho $\\Sigma$ \\Sigma $\\sigma$ \\sigma $\\Phi$ \\Phi $\\phi$ \\phi $\\varphi$ \\varphi $\\Psi$ \\Psi $\\psi$ \\psi $\\Omega$ \\Omega $\\omega$ \\omega ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:1:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"特殊符号 符号 代码 解释 $\\partial$ \\partial 偏导数 $\\nabla$ \\nabla 梯度 $\\ell$ \\ell $\\Complex$ \\Complex \\cnums 复数集 $\\R$ \\Reals \\reals \\R 实数集 $\\Z$ \\Z 整数集 $\\natnums$ \\natnums \\N 自然数集 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:2:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"垂直布局 符号 代码 解释 $x_n$ x_n 下标 $e^x$ e^x 上标 $_u^o$ _u^o 上下标 $\\overset{N}{\\sum}$ \\overset{N}{\\sum} 正上标 $\\underset{i=1}{\\sum}$ \\underset{i=1}{\\sum} 正下标 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:3:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"字体 符号 代码 解释 $\\sqrt{x}$ \\sqrt{x} 平方根 $\\sqrt[3]{x}$ \\sqrt[3]{x} 三次方根 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:4:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"逻辑符与集合论 符号 代码 解释 $\\forall$ \\forall 所有 $\\exist$ \\exists \\exist 存在 $\\in$ \\in \\isin 属于 $\\notin$ \\notin 不属于 $\\subset$ \\subset 包含于 $\\supset$ \\supset 包含 $\\emptyset$ \\emptyset \\empty 空集 $\\varnothing$ \\varnothing 空集 $\\implies$ \\implies 充分 $\\impliedby$ \\impliedby 必要 $\\iff$ \\iff 充分必要 $\\neg$ \\neg \\lnot 非 $\\lor$ \\lor 或 $\\land$ \\land 与 $\\because$ \\because 因为 $\\therefore$ \\therefore 所以 $\\ne$ \\ne \\neq 不等于 $\\approx$ \\approx 约等于 $\\coloneqq$ \\coloneqq 赋值 $\\gt$ \\gt 大于 $\\ge$ \\ge \\geq 大于等于 $\\lt$ \\lt 小于 $\\le$ \\le \\leq 小于等于 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:5:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"多元运算符 符号 代码 解释 $\\sum$ \\sum 累加 $\\prod$ \\prod 累乘 $\\bigcap$ \\bigcap 累交 $\\bigcup$ \\bigcup 类并 $\\int$ \\int 一重积分 $\\iint$ \\iint 二重积分 $\\iiint$ \\iiint 三重积分 $\\oint$ \\oint 一重环路积分 $\\oiint$ \\oiint 二重环路积分 $\\oiiint$ \\oiiint 三重环路积分 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:6:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"二元运算符 符号 代码 解释 $\\bmod$ \\bmod $x \\pmod a$ x \\pmod a $\\div$ \\div $\\pm$ \\pm \\plusmn $\\oplus$ \\oplus $\\otimes$ \\otimes $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:7:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"常用数学符号 符号 代码 解释 $\\lim$ \\lim $\\ln$ \\ln $\\log$ \\log $\\exp$ \\exp $\\max$ \\max $\\min$ \\min $\\argmax$ \\argmax $\\argmin$ \\argmin $\\sin$ \\sin $\\cos$ \\cos $\\tan$ \\tan $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:8:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"矩阵 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:9:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"一行多个公式 $$ \\begin{align} x\u0026=t \u0026 x\u0026=\\cos t \u0026 x\u0026=t \\notag y\u0026=2t \u0026 y\u0026=\\sin(t+1) \u0026 y\u0026=\\sin t \\end{align} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"大括号多行公式 $$ f(x)=\\begin{cases} 2x+1, \u0026 \\text{if} \u0026 x \\lt 0; \\ 0, \u0026 \\text{if} \u0026 x = 0; \\ x^2-1, \u0026 \\text{if} \u0026 x \\gt 0. \\end{cases} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:11:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["LaTeX","Cheatsheet"],"content":"参考 Supported Functions - KaTeX ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:12:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["数据结构","算法"],"content":"数据结构，是抽象的表示数据的方式；算法，则是计算的一系列有效、通用的步骤。算法与数据结构是程序设计中相辅相成的两个方面，是计算机学科的重要基石。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:0:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"1.基础 存储结构： 数组：由于是紧凑连续存储，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。 链表：因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"2.排序 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"1.选择排序 void selectionSort(vector\u003cint\u003e\u0026 arr) { for (int i = 0; i \u003c arr.size(); i++) { int minIdx = i; for (int j = i + 1; j \u003c arr.size(); j++) { minIdx = (arr[j] \u003c arr[minIdx]) ? j : minIdx; } int temp = arr[i]; arr[i] = arr[minIdx]; arr[minIdx] = temp; } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ 特点： 不稳定 每一轮有一个元素（当前最小元素）归位 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"2.冒泡排序 void bubbleSort(vector\u003cint\u003e\u0026 arr) { for (int step = 1; step \u003c arr.size(); step++) { for (int i = 0; i \u003c arr.size() - step; i++) { if (arr[i] \u003e arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ 特点： 稳定 每一轮有一个元素（当前最大元素）归位 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"3.插入排序 void insertionSort(vector\u003cint\u003e\u0026 arr) { for (int i = 1; i \u003c arr.size(); i++) { int temp = arr[i], j; for (j = i - 1; j \u003e= 0 \u0026\u0026 arr[j] \u003e arr[i]; j--) { arr[j + 1] = arr[j]; } arr[j + 1] = temp; } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ 特点： 稳定 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"归并排序 void mergeSort() { } void merge() { } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"快速排序 基本思想： 从数组中取出一个数，称之为基数（pivot）。 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域。 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。 // 把数组分为两半，返回分割中点 int partition(vector\u003cint\u003e arr, int low, int high) { int pivot = arr[low]; while (low \u003c right) { while (low \u003c high \u0026\u0026 arr[high] \u003e pivot) high--; arr[low] = arr[high]; while (low \u003c high \u0026\u0026 arr[low] \u003c= pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low; } void quickSort(vector\u003cint\u003e arr, int low, int high) { if (low \u003e= high) return; int mid = partition(arr, low, high); quickSort(arr, low, mid - 1); quickSort(arr, mid + 1, high); } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:5","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"总结 排序算法 时间复杂度 稳定性 冒泡排序 $O(n^2)$ 稳定 选择排序 $O(n^2)$ 不稳定 插入排序 $O(n^2)$ 稳定 快速排序 $O(n \\log n)$ 不稳定 归并排序 $O(n \\log n)$ 稳定 堆排序 $O(n \\log n)$ 不稳定 计数排序 $O(n)$ 稳定 基数排序 $O(n)$ 稳定 名称 数据对象 稳定性 时间复杂度 额外空间复杂度 描述 平均 最坏 冒泡排序 数组 是 $ O(n^2) $ $ O(1) $ (无序区，有序区)从无序区通过交换找出最大元素放到有序区前端。 选择排序 数组 否 $ O(n^2) $ $ O(1) $ (有序区，无序区)在无序区里找一个最小的元素放到有序区后端。对数组：比较多，交换少 链表 是 插入排序 数组、链表 是 $ O(n^2) $ $ O(1) $ (有序区，无序区)把无序区的第一个元素插入到有序区的合适位置。对数组：比较少，交换多 堆排序 数组 否 $ O(n \\log{n}) $ $ O(1) $ (最大堆，有序区)从堆顶把最大值弹出到有序区前端，然后调整堆。 归并排序 数组 是 $ O(n \\log{\\log{n}}) $ $ O(1) $ 将数据分为两段，再从两段中逐个选最小的元素移入新数据段的末尾。可自上而下，也可自下而上 $ O(n \\log{n}) $ 自上而下：$ O(n)+O(\\log{n}) $ 链表 自下而上：$ O(1) $ 快速排序 数组 否 $ O(n \\log{n}) $ $ O(n^2) $ $ O(\\log{n}) $ (小数区，基准元素，大数区)在区间中随机挑选一个元素作为基准元素，将小于该基准的元素放到基准之前，大于的放到基准之后，然后递归地对小数区和大数区进行快速排序。 希尔排序 数组 否 $ O(n \\log{\\log{n}}) $ $ O(n^2) $ $ O(1) $ 按从大到小的间距进行多次插入排序，最后一次的间距为1。 计数排序 数组、链表 是 $ O(n+m) $ $ O(n+m) $ 统计小于等于该元素值的元素的个数i，然后将该元素放在目标数组的第i个位置。 桶排序 数组、链表 是 $ O(n) $ $ O(m) $ 将值为i的元素放入第i号桶，然后依次把桶里的元素倒出来。 基数排序 数组、链表 是 $ O(k \\times n) $ $ O(n^2) $ 一种多关键字的排序算法，可用桶排序实现。 参考文章 当我谈排序时，我在谈些什么🤔 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:6","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"树 一棵 n 个节点的树，有 n-1 条边。 一棵 n 个节点的树，有 n 棵子树。 根节点：唯一，无入度的节点 节点的深度：节点距离根节点的距离。 typedef struct treeNode { treeNode(int x): value(x) {} int value; vector\u003ctreeNode*\u003e child; } TreeNode; ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"二叉树 满二叉树：一个高度为 d 的二叉树，有 $2^d-1$ 个节点。即除叶节点外，每个节点都有两个孩子，即节点的出度只为 0 或 2。 完全二叉树：只有最后一层可能未满，且节点严格从左往右排列。即出度为 1 的节点一定只有左孩子；若某节点出度小于 2，则其右边的节点出度为 0。 二叉树第 $i$ 层最多有 $2^{i-1}$ 个节点。 高度为 $d$ 的二叉树最多有 $2^d-1$ 个节点。 class TreeNode(object): def __init__(self, value): self.lchild = None self.rchild = None self.value = 0 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"遍历 前序遍历 递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { if (!root) return; postorder(root-\u003eleft); postorder(root-\u003eright); // 处理节点值 root-\u003eval } 非递归法： 前序遍历的非递归方法先左后右，最后逆序即可 void postorder(TreeNode* root) { if (!root) return; vector\u003cint\u003e res; // 保存遍历结果 stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root-\u003eval); // 保存节点值 if (root-\u003eleft) st.push(st-\u003eleft); if (root-\u003eright) st.push(st-\u003eright); } reverse(res.begin(), res.end()); // 逆序 } 层序遍历 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"常见问题 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"回溯算法 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"N 皇后问题 题目描述：将 N 个皇后放在 N×N 的棋盘上，需保证任意两个皇后不能处于同行、同列或同斜线上。 vector\u003cvector\u003cchar\u003e\u003e solve(int n) { } void dfs(vector\u003cvector\u003cchar\u003e\u003e\u0026 chessboard, int rowNo, int n) { } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"贪心与分治理论 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"贪心算法 贪心算法理论 严格来说，贪心算法并不是某些有明确指向的算法，而是代指一类算法思想。在有多种决策可选时，我们会选择一个最优的策略，即所谓的贪心算法。 举一个最简单的例子，田忌赛马。在对方出上等马的时候，我方没有任何一匹马能赢这一局，既然注定是输，那么我们希望尽量减少我们的损失。何谓损失？我们每一局都会用掉一匹马，那么对于必输的局，显然用掉最弱的马是最好的。这里就可以归类出两个名词： 局部目标：在贪心问题中，总归有一个局部的目标。例如在上述场景里，我们希望减少这一轮的损失。这就是一个局部目标。和局部目标对应的是全局目标，全局上来说我们当然希望最终能赢得比赛。 策略：在这个局部情景里，我们有多种可用的决策，例如我们可以挑选任意一匹马应战。 实际上，很多问题都可以拆解为若干个局部问题和局部策略。如果这一类问题满足： 局部问题存在最优解。 局部问题最优可以保证全局问题最优。 那么这个问题就可以通过贪心算法解决。 小技巧：局部问题又称为子问题，很多复杂的原始问题都可以拆解成若干个子问题构成，例如一盘围棋就可以拆解为每次双方执子的小问题。在不同的情景下，子问题的性质是不一样的，对应的解决办法也不一样。 例如： 子问题最优则原始问题最优——贪心算法或者动态规划算法。 子问题最优则原始问题最优，且子问题互相独立——分治算法。 子问题最优不能推导出原始问题最优——暴力搜索等。 算法中的贪心思想 例一：二叉搜索树找最小值 子问题：最小值一定在根节点，左子树（如果存在），右子树（如果存在）三者之一上，因此原问题可以划分为三个子问题。 我们本来可以在左右子树上均查找一次最小值，但是根据二叉查找树的性质，如果左子树存在，那么最小值只可能存在于左子树上。这就是一个贪心的思想，通过只找一边的子树，我们可以将复杂度从O(n)降低至O(log(h))，其中h为树的高度。 例二：二分查找问题 同样，二分查找也存在贪心的思想。在确定left, mid, right后，根据target和mid的大小关系，我们同样只会继续查找左半边或者右半边，这也是因为另一边不可能有目标值了。 贪心问题解决思路 那么对于原始的复杂问题，如何能够知道他是否能被贪心解决呢？ 首先，我们需要将原始问题拆解成子问题，明确子问题的局面以及局面中可进行的操作。实际上不止贪心问题，很多问题都需要这样的拆解过程。 然后我们需要考虑子问题的最优，是否能保证全局最优。如果能的话，我们就可以只考虑如何解子问题，否则就可能需要动态规划或者搜索解了。 最后，我们需要考虑如何使子问题最优，可能有些问题存在乍一看可行的策略，但是我们仍然需要仔细思考甚至证明。以保证没有漏掉什么细节情况。 小技巧：对于第三点，很多同学这里会经常犯错。比如以为贪心做法是对的，但是实际上有问题。例如错误地用贪心解决 01 背包问题（子问题最优，原问题不一定最优）等。所以如果我们觉得某道题目存在贪心策略，最好自己证明一下正确性再实现。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"分治算法 复杂的原始问题可能可以拆分成若干个子问题，如果子问题之间互相独立（一个子问题的计算结果不依赖于其他子问题），那么原始问题可以被分治法解决。 分治法究竟有什么作用呢？ 简化思维逻辑：在很多情况下，原始问题是非常复杂的，例如排序问题。假设原始我们需要考虑对 1000 个数进行排序，那么利用分治思想我们可以分别对左右的 500 个数进行排序，然后考虑合并两个有序数组。当然，排序 500 个数看起来仍然不容易，但是我们可以继续分治下去，最终我们只需要考虑 1~2 个数的排序策略，这就是经典的归并排序的思想。 分布式算法：虽然在算法学习的过程中少有接触多进程和分布式等思想。但是随着 CPU core 越来越多，能够被分治法拆解的问题显然更方便进行并行计算，从而节省总体时间。因此分治思想在工程实现上具有重要的意义。 效率优化：虽然我们不常用并行解决算法问题，但是在某些情况下仍然能够帮助我们节省计算代价，代表就是快速幂算法。课程在这里不作展开，我们会在例题部分进一步详细讨论。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"总结 对于复杂的原问题： 如果子问题最优则原问题最优，贪心算法。 如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。 如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。 更加复杂的情况，我们总是可以考虑暴力搜索解决。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据结构","算法"],"content":"动态规划 考虑能否将问题规模减小 将问题规模减小的方式有很多种，一些典型的减小方式是动态规划分类的依据，例如线性，区间，树形等。这里考虑数组上常用的两种思路： 每次减少一半：如果每次将问题规模减少一半，原问题有[10,9,2,5]，和[3,7,101,18]，两个子问题的最优解分别为 [2,5] 和 [3,7,101]，但是找不到好的组合方式将两个子问题最优解组合为原问题最优解 [2,5,7,101]。 每次减少一个：记 f(n)f(n) 为以第 nn 个数结尾的最长子序列，每次减少一个，将原问题分为 f(n-1)f(n−1), f(n-2)f(n−2), …, f(1)f(1)，共 n - 1n−1 个子问题。n - 1 = 7n−1=7 个子问题以及答案如下： 以上组合方式可以写成一个式子，即状态转移方程 总结： 解决动态规划问题最难的地方有两点： 如何定义 f(n)f(n) 如何通过 f(1)f(1), f(2)f(2), … f(n - 1)f(n−1) 推导出 f(n)f(n)，即状态转移方程 递归 有了状态转移方程，实际上已经可以直接用递归进行实现了。 自顶向下（记忆化） 递归的解法需要非常多的重复计算，如果有一种办法能避免这些重复计算，可以节省大量计算时间。记忆化就是基于这个思路的算法。在递归地求解子问题 f(1)f(1), f(2)f(2)… 过程中，将结果保存到一个表里，在后续求解子问题中如果遇到求过结果的子问题，直接查表去得到答案而不计算。 对于这种将问题规模不断减少的做法，我们把它称为自顶向下的方法。 自底向上（迭代） 在自顶向下的算法中，由于递归的存在，程序运行时有额外的栈的消耗。 有了状态转移方程，我们就知道如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止。在这个过程中，我们同样地可以记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。 但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。参考后面的例题。但是有一些问题迭代法方向是不确定的，这时可以退而求其次用记忆化来做，参考后面的例题。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:7:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"谷歌三件套包括 Google Play 商店（Google Play Store）、Google Play 服务（Google Play Services）和Google 服务框架（Google Services Framework），只有正确安装了这三件套才能访问 Google Play 商店和使用需要 Google Play 服务的 APP。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"安装 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一键安装 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"手动安装 访问 APKMirror。 搜索Google Services Framework，根据安卓版本选择对应的版本下载并安装。（示例：Google Services Framework 10） 搜索Google Play Services，选择最新版并进入，选择arm64-v8a + armeabi-v7a、对应的安卓版本、nodpi，下载并安装。 搜索Google Play Store，选择最新版下载并安装。 若三件套都安装完，并且正确科学上网后还是打不开Google Play 商店，尝试下载旧版本Google Play Services安装。 不推荐使用beta版本。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Google Play Services 版本号 版本号示例：20.50.66 (100400-351698872)，其中100400说明： 第 1、2 位表示安卓版本 00 - Android 4.1 02 - Android 5.0 04 - Android 6.0 05 - Wear OS 08 - Android TV 10 - Android 9.0 12 - Android 10 15 - Android 11 第 3、4 位表示CPU架构 03 - armeabi-v7a 04 - armeabi-v7a + arm64-v8a 07 - x86 08 - x86 + x86_64 第 5、6 位表示屏幕 DPI 00 - nodpi 02 - 160dpi 04 - 240dpi 06 - 320dpi 08 - 480dpi 则100400指Android 9.0、arm64-v8a和nodpi。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Android Debug Bridge (ADB) 是一种功能多样的命令行工具，可让您与安卓设备进行通信。ADB 命令可用于执行各种设备操作（例如安装和调试应用），并提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。 ","date":"2021-02-08","objectID":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","series":null,"tags":null,"title":"ADB 常用命令","uri":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"准备 手机打开开发者模式。 进入开发者选项，打开USB调试。 手机 USB 连接电脑。 电脑下载 Android SDK Platform Tools，解压后进入文件夹。 运行 cmd，输入以下内容。 ","date":"2021-02-08","objectID":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":null,"title":"ADB 常用命令","uri":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"命令 提取已安装 APP 的 APK 安装包 # 1.列出所有已安装APP的包名 adb shell pm list packages # 2.获取所需APP的APK文件的完整路径 adb shell pm path XXX.XXX.XXX # 3.根据上一步的输出，提取安装包到电脑当前目录 adb pull /data/app/XXX.XXX.XXX.apk . ","date":"2021-02-08","objectID":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":null,"title":"ADB 常用命令","uri":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"Java 是全球使用最广泛的编程语言。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"准备 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"JDK 下载 Oracle JDK Oracle OpenJDK ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"环境变量配置 设置→系统→关于→高级系统设置→环境变量。 在下方的系统变量中找到Path，点击编辑。 点击新建，将JDK的路径下的bin目录粘贴进去。（示例：C:\\Users\\backs\\Downloads\\portable\\jdk-11.0.10\\bin\\） 连续点击确定，保存退出。 打开cmd，输入java -version，若有如下所示输出即为配置成功。 java version \"11.0.10\" 2021-01-19 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.10+8-LTS-162) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.10+8-LTS-162, mixed mode) 在任意位置创建 test.java，写入以下内容。 public class test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 在该文件夹下打开 cmd，输入以下内容，输出应该为 Hello World!。 javac test.java java test ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"IDE Download IntelliJ IDEA: 最好用，Community版免费，Ultimate版收费，学生可白嫖，推荐。 Eclipse: 开源，免费。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Usage ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"GC 垃圾回收，顾名思义就是释放垃圾占用的空间，从而提升程序性能，防止内存泄露。当一个对象不再被需要时，该对象就需要被回收并释放空间。 Java 内存运行时数据区域包括程序计数器、虚拟机栈、本地方法栈、堆等区域。其中，程序计数器、虚拟机栈和本地方法栈都是线程私有的，当线程结束时，这些区域的生命周期也结束了，因此不需要过多考虑回收的问题。而堆是虚拟机管理的内存中最大的一块，堆中的内存的分配和回收是动态的，垃圾回收主要关注的是堆空间。 调用垃圾回收器的方法 调用垃圾回收器的方法是gc，该方法在System类和Runtime类中都存在。在Runtime类中，方法gc是实例方法，方法System.gc是调用该方法的一种传统而便捷的方法。在System类中，方法gc是静态方法，该方法会调用Runtime类中的gc方法。其实，java.lang.System.gc等价于java.lang.Runtime.getRuntime.gc的简写，都是调用垃圾回收器。方法gc的作用是提示Java虚拟机进行垃圾回收，该方法由系统自动调用，不需要人为调用。该方法被调用之后，由Java虚拟机决定是立即回收还是延迟回收。 finalize 方法 与垃圾回收有关的另一个方法是finalize方法。该方法在Object类中被定义，在释放对象占用的内存之前会调用该方法。该方法的默认实现不做任何事，如果必要，子类应该重写该方法，一般建议在该方法中释放对象持有的资源。 判断对象是否可回收 垃圾回收器在对堆进行回收之前，首先需要确定哪些对象是可回收的。常用的算法有两种，引用计数算法和根搜索算法。 1.引用计数算法 引用计数算法给每个对象添加引用计数器，用于记录对象被引用的计数，引用计数为 0 的对象即为可回收的对象。 虽然引用计数算法的实现简单，判定效率也很高，但是引用计数算法无法解决对象之间循环引用的情况。如果多个对象之间存在循环引用，则这些对象的引用计数永远不为 0，无法被回收。因此 Java 语言没有使用引用计数算法。 2.根搜索算法 主流的商用程序语言都是使用根搜索算法判断对象是否可回收。根搜索算法的思路是，从若干被称为 GC Roots 的对象开始进行搜索，不能到达的对象即为可回收的对象。 在 Java 中，GC Roots 一般包含下面几种对象： 虚拟机栈中引用的对象 本地方法栈中的本地方法引用的对象 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 3.引用的分类 引用计数算法和根搜索算法都需要通过判断引用的方式判断对象是否可回收。 在 JDK 1.2 之后，Java 将引用分成四种，按照引用强度从高到低的顺序依次是： 强引用：在程序代码中普遍存在的引用。垃圾回收器永远不会回收被强引用关联的对象。 软引用：还有用但并非必需的对象。只有在系统将要发生内存溢出异常时，被软引用关联的对象才会被回收。在 JDK 1.2 之后，提供了SoftReference类实现软引用。 弱引用：非必需的对象，其强度低于软引用。被弱引用关联的对象只能存活到下一次垃圾回收发生之前，当垃圾回收器工作时，被弱引用关联的对象一定会被回收。在 JDK 1.2 之后，提供了WeakReference类实现弱引用。 虚引用：最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。在 JDK 1.2 之后，提供了PhantomReference类实现虚引用。 垃圾回收算法 1.标记—清除算法 标记—清除算法是最基础的垃圾回收算法，后续的垃圾收集算法都是基于标记—清除算法进行改进而得到的。标记—清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 标记—清除算法有两个主要缺点。一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 2.复制算法 复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将还存活着的对象复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 复制算法解决了效率问题。由于每次都是对整个半区进行内存回收，因此在内存分配时不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。复制算法的优点是实现简单，运行高效，缺点是将内存缩小为了原来的一半，以及在对象存活率较高时复制操作的次数较多，导致效率降低。 3.标记—整理算法 标记—整理算法是根据老年代的特点提出的。标记过程与标记—清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向一端移动，然后清除边界以外的内存。 4.分代收集算法 分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。 一般把 Java 堆分为新生代和老年代。在新生代中，大多数对象的生命周期都很短，因此选用复制算法。在老年代中，对象存活率高，因此选用标记—清除算法或标记—整理算法。 分配内存与回收策略 Java 堆可以分成新生代和老年代，新生代又可以细分成Eden区、From Survivor区、To Survivor区等。对于不同的对象，有相应的内存分配规则。 1.Minor GC 和 Full GC Minor GC指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此Minor GC会频繁执行，一般回收速度也比较快。 Full GC也称Major GC，指发生在老年代的垃圾回收操作。出现了Full GC，经常会伴随至少依次的Minor GC。老年代对象的存活时间长，因此Full GC很少执行，而且执行速度会比Minor GC慢很多。 2.对象优先在 Eden 区分配 大多数情况下，对象在新生代Eden区分配，当Eden区空间不够时，发起Minor GC。 3.大对象直接进入老年代 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间分配给大对象。 将大对象直接在老年代中分配的目的是避免在Eden区和Survivor区之间出现大量内存复制。 4.长期存活的对象进入老年代 虚拟机采用分代收集的思想管理内存，因此需要识别每个对象应该放在新生代还是老年代。虚拟机给每个对象定义了年龄计数器，对象在Eden区出生之后，如果经过第一次Minor GC之后仍然存活，将进入Survivor区，同时对象年龄变为 1，对象在Survivor区每经过一次Minor GC且存活，年龄就增加 1，增加到一定阈值时则进入老年代（阈值默认为 15）。 5.动态对象年龄判定 为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor区中相同年龄的所有对象的空间总和大于Survivor区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 6.空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么Minor GC可以确保是安全的。 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"Python 是现在最受欢迎的语言。 # 三元运算符 smaller = x if x \u003c y else y # 其他运算符 'A' in ['A', 'B', 'C'] 'D' not in ['A', 'B', 'C'] \"hello\" is \"hello\" \"Hello\" is not \"hello\" # is 对比的是两个变量的内存地址 # == 对比的是两个变量的值 # 地址不可变的类型（str 等），那么 is 和 == 完全等价 # 地址可变的类型（list，dict，tuple 等），两者不等价 # 异常处理 try: a = 1 / 0 except ZeroDivisionError: print('除数不能为0') # 指定精度 from decimal import Decimal decimal.getcontext().prec = 4 c = Decimal(1) / Decimal(3) # 0.3333 # 获取类型信息 isinstance(1, int) # type() 不会认为子类是一种父类类型，不考虑继承关系 # isinstance() 会认为子类是一种父类类型，考虑继承关系 # 类型转换 int('520') # 520 float('520.52') # 520.52 str(520) # '520' # print # print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) # sep 分隔符 # end 结束符 # file 输出的文件 # flush 立即输出，不作缓存 # 数据存储 # 计算机内部使用补码存储数据 # 以 int8 为例 # 原码：第一位为符号位（正0负1），其余位为该数绝对值的二进制表示 # 3 : 00 00 00 11 # -3 : 10 00 00 11 # 反码：正数同原码，负数为原码符号位不变，其余位取反 # 3 : 00 00 00 11 # -3 : 11 11 11 00 # 补码：正数同原码，负数为反码加1 # 3 : 00 00 00 11 # -3 : 11 11 11 01 # 位运算 # 按位与 \u0026 a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a \u0026 b # 00 00 00 01 : 1 # 按位或 | a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a | b # 00 00 01 11 : 7 # 按位取反 ~ a = 3 # 00 00 00 11 ~a # 11 11 11 00 # 按位异或 ^ （相同为0，不同为1） a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a ^ b # 00 00 01 10 : 6 # 任何值与自身异或为0 a ^ a # 00 00 00 00 : 0 # 任何值与0异或不变 a ^ 0 # 00 00 00 11 : 3 # 按位左移 \u003c\u003c ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"list a = [1] a.append(2) # [1, 2] a.pop() # 2 a.index(1) # 0 找不到报错 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"complex number c = 12 + 3j print(c.real) # 12.0 print(c.imag) # 3.0 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"string pluto_mass = 1.303 * 10**22 earth_mass = 5.9722 * 10**24 population = 52910390 # {:.2} 2位有效数字 # {:.3%} 3位有效数字，百分数形式表示 # {:,} 数字每隔3位用逗号隔开 \"{}weighs about {:.2}kilograms ({:.3%}of Earth's mass). It is home to {:,}Plutonians.\".format( planet, pluto_mass, pluto_mass / earth_mass, population ) # Pluto weighs about 1.3e+22 kilograms (0.218% of Earth's mass). It is home to 52,910,390 Plutonians. # 根据位置使用变量 s = \"\"\"Pluto's a {0}. No, it's a {1}. {0}! {1}!\"\"\".format('planet', 'dwarf planet') # Pluto's a planet. # No, it's a dwarf planet. # planet! # dwarf planet! '123'.isdigit() # True 参考： PyFormat ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"dict dict() # {} dict(a=1, b=2, c=3) # {'a': 1, 'b': 2, 'c': 3} dict(zip(['a', 'b', 'c'], [1, 2, 3])) # {'a': 1, 'b': 2, 'c': 3} dict([('a', 1), ('b', 2), ('c', 3)]) # {'a': 1, 'b': 2, 'c': 3} ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"Python 内置函数 abs(x) # 返回绝对值。若参数为复数，则返回复数的模。 divmod(a, b) # 返回 tuple(a // b, a % b) input(words) # 打印 words，读取用户输入，返回 str 类型 ord(c) # 返回字符对应的 ASCII 数值，或者 Unicode 数值 chr(i) # 返回整数（0～255，10进制或16进制）对应的 ASCII 字符。 bin(i) # 返回一个整数（int 或 long int）的二进制表示，str 类型。 any() # 是否存在大于0 all() # 是否全大于0 complex(real=0, image=0) # 复数 7.bit_length() # 3 0.25.as_integer_ratio() # (1, 4) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"staticmethod 声明静态方法，即可以不实例化类而直接调用该方法。类中类也可以。 class C(object): @staticmethod def f(arg1, arg2, ...): ... ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"enumerate 将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和下标，一般用在 for 循环中。 enumerate(sequence, start=0) list(enumerate([1, 2, 3])) # [(0, 1), (1, 2), (2, 3)] list(enumerate((1, 2, 3))) # [(0, 1), (1, 2), (2, 3)] list(enumerate('abc')) # [(0, 'a'), (1, 'b'), (2, 'c')] list(enumerate('abc', start=1)) # [(1, 'a'), (2, 'b'), (3, 'c')] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"int 若 x 为数字，返回整数部分。（不能有 base 参数，否则报错） 若 x 为字符串，则将 x 视为 base 进制的数，返回转换为 10 进制后的数。（x 不能为小数或不存在的数，否则报错） int(x, base=10) int() # 0 int(3.9) # 3 int(-3.9) # -3 int('10', 2) # 2 int('0xA', 16) # 10 int('aB', 16) # 171 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"常用内置库 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"random random库 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"os os模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.path os.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' -\u003e 'A' # 'A' -\u003e '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' -\u003e ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' -\u003e ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"文件操作 open() ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"tricks ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"python 自动给数字前面补 0 的方法 s1 = \"12\" s1.zfill(4) # \"0012\" s2 = \"-12\" s2.zfill(4) # \"-0012\" a = 12 '%04d' % a # \"0012\" ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"Q\u0026A ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"UnicodeDecodeError 问题描述: UnicodeDecodeError: 'gbk' codec can't decode byte 0xad in position 7: illegal multibyte sequence 解决方案: 将open(filename, 'r')改为open(filename, 'r', encoding='utf-8') ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["Python","教程"],"content":"Python 风格规范 不要在行尾加分号，也不要用分号将两条命令放在同一行。 每行不超过80个字符。（导入和注释例外） 不要使用反斜杠连接行。（Python 会将括号中的行隐式连接起来） foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 文本字符串在一行放不下，可以使用括号来实现隐式行连接。 s = ('This will build a very long long ' 'long long long long long long string') 除非是用于实现行连接，否则不要在返回语句或条件语句中使用括号。 用4个空格来缩进代码 # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = { long_dictionary_key: value1 + value2, ... } # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... } 顶级定义之间空两行（全局类、全局函数、全局变量），方法定义之间空一行（类内函数之间、类与第一个函数之间）。 括号内表达式两端不要有空格。 在逗号、分号、冒号后面加空格，前面不加。（行尾除外） 参数列表、索引或切片的左括号前不加空格。 二元操作符两边都加上一个空格。 ‘=‘用于指示参数值或默认值时，不在其两侧使用空格。 不要用空格来垂直对齐多行间的标记。（如’#'、'='、':‘等） 类注释和函数注释规范 class SampleClass(object): \"\"\"Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. \"\"\" def __init__(self, likes_spam=False): \"\"\"Inits SampleClass with blah.\"\"\" self.likes_spam = likes_spam self.eggs = 0 def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): \"\"\"Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: {'Serak': ('Rigel VII', 'Preparer'), 'Zim': ('Irk', 'Invader'), 'Lrrr': ('Omicron Persei 8', 'Emperor')} If a key from the keys argument is missing from the dictionary, then that row was not found in the table. Raises: IOError: An error occurred accessing the bigtable.Table object. \"\"\" pass 行注释应距离代码2个空格。 为临时代码使用 TODO 注释。 # TODO(kl@gmail.com): Use a \"*\" here for string repetition. # TODO(Zeke) Change this to use relations. 如果一个类不继承其它类，就显式继承 object。 字符串合并规范 x = a + b # not % x = '%s, %s!' % (imperative, expletive) x = '{}, {}!'.format(imperative, expletive) # not + x = 'name: %s; score: %d' % (name, n) # not + x = 'name: {}; score: {}'.format(name, n) # not + 避免在循环中用+和+=操作符来累加字符串。可以将每个子串加入列表，然后在循环结束后用 ‘'.join() 连接列表。 在文件和 sockets 结束时，显式的关闭它。 推荐使用 with 打开文件。 with open(\"hello.txt\") as hello_file: for line in hello_file: print line 不支持使用 with 语句的类似文件的对象，使用 contextlib.closing()。 import contextlib with contextlib.closing(urllib.urlopen(\"http://www.python.org/\")) as front_page: for line in front_page: print line 每个导入应该独占一行。 导入总应该放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前。 导入应该按照标准库、第三方库、应用程序指定导入的顺序分组。每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写。 通常每个语句应该独占一行。（if 语句只有在没有 else 时才能同处一行） 命名规范：module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name。 命名约定： 单下划线开头的变量或函数表示 protected（使用 from module import * 时不会包含）。 双下划线开头的变量或函数表示 private。 将相关的类和全局函数放在同一个模块里。 主功能应该放在一个 main() 函数中。 def main(): pass if __name__ == '__main__': main() 参考： Google Python 风格指南 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"标准模板库（Standard Template Library，STL）是一组 C++ 模板类，提供常见的数据结构和函数，如列表、堆栈、数组等。它是由容器类、算法和迭代器构成的一个通用库，它的组件是参数化的。 STL 包含以下四个组件： 算法（Algorithms）：头文件\u003calgorithm\u003e定义了一组函数，作用于容器，并为容器中的内容提供各种操作方法。 容器（Containers）：用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，如 deque、list、vector、map、set、bitset 等。 函数（Functions）： 迭代器（Iterators）：遍历容器。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cvector\u003e vector是一个动态数组，需要#include \u003cvector\u003e。 数组大小动态改变 可以进行逻辑操作（是否相等、比较大小） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u003cint\u003e v1; // {} vector\u003cint\u003e v2 = {1, 2, 3}; // {1, 2, 3} vector\u003cint\u003e v3({1, 2, 3}); // {1, 2, 3} vector\u003cint\u003e v4 = v3; // {1, 2, 3} vector\u003cint\u003e v5(v3); // {1, 2, 3} vector\u003cint\u003e v6(3); // {0, 0, 0} vector\u003cint\u003e v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector\u003cint\u003e v8(arr, arr + 1); // {1} vector\u003cint\u003e v9(v4.begin(), v4.begin() + 2); // {1, 2} vector\u003cvector\u003cint\u003e\u003e v10(2, vector\u003cint\u003e(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定位置构造并插入元素 iterator insert(const_iterator position, const value_type\u0026 val) 在指定位置插入元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 在指定位置插入 n 个 val iterator insert(const_iterator position, InputIterator first, InputIterator last) 在指定位置插入数组或迭代器 [first, last) 区间内的元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) 在指定位置插入指定列表中的元素 vector\u003cpair\u003cstring, int\u003e\u003e v; v.push_back(make_pair(\"Mike\", 1)); v.emplace_back(\"John\", 2); // 隐式地构造了 pair 并插入末尾 1.3 删除 void pop_back() 删除最后一个元素 iterator erase(const_iterator position) 删除指定位置的元素 iterator erase(const_iterator first, const_iterator last) 删除迭代器 [first, last) 区间内的元素 void clear() noexcept 清空 1.4 容量 bool empty() const 判断容器是否为空 size_type size() const 返回元素个数 size_type capacity() const noexcept 返回已分配存储容量的大小 void resize(size_type n) 改变大小，变小截断，变大补 0 void resize(size_type n, const value_type\u0026 val) 改变大小，变小截断，变大补 val 1.5 其他操作 void assign(size_type n, const value_type\u0026 val) 赋值为 n 个 val void assign(InputIterator first, InputIterator last) 赋值为数组或迭代器 [first, last) 区间内的元素 void assign(initializer_list\u003cvalue_type\u003e il) 赋值为指定列表中的元素 void swap(vector\u0026 x) 交换两个 vector 1.6 遍历 reference operator[](size_type n) 返回位置为 n 的元素的引用，越界发生未知错误（不推荐） reference at(size_type n) 返回位置为 n 的元素的引用，越界抛出 out_of_range 异常（推荐） reference front() 返回第一个元素的引用 reference back() 返回最后一个元素的引用 for (auto it = v.begin(); it != v.end(); it++) {*it;} // 正向遍历，有迭代器 for (auto it = v.rbegin(); it != v.rend(); it++) {*it;} // 反向遍历，有迭代器 for (int\u0026 e : v) {e;} // 正向遍历，无索引 for (int e : v) {e;} // 正向遍历，无索引，不改变原数据 for (int i = 0; i \u003c v.size(); i++) {v.at(i);} // 正向遍历，有索引 for (int i = v.size() - 1; i \u003e= 0; i--) {v.at(i);} // 反向遍历，有索引 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"vector\u003cbool\u003e 基本操作同 vector。 特殊操作： void flip() noexcept 所有位都翻转 static void swap(reference ref1, reference ref2) noexcept 交换两个位置的值 vector\u003cbool\u003e mask; mask.push_back(true); mask.push_back(false); // {1 0} mask.flip(); // {0 1} mask.swap(mask[0], mask[1]); // {1 0} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cstack\u003e stack是一个栈，需要#include \u003cstack\u003e。 后进先出（LIFO） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"2.1 初始化 默认底层容器是 deque 可以显式设置底层容器为 vector stack\u003cint\u003e st1; stack\u003cint\u003e st2(st1); stack\u003cint\u003e st3({1, 2, 3}); // st3.top() == 3 deque\u003cint\u003e dq(2, 3); stack\u003cint\u003e st4(dq); // 默认底层容器是 deque vector\u003cint\u003e v({1, 2, 3}); stack\u003cint, vector\u003cint\u003e\u003e st5(v); // 设置底层容器为 vector ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"2.2 操作 void push(const value_type\u0026 val) 栈顶添加元素 void emplace(Args\u0026\u0026... args) 栈顶添加元素 void pop() 栈顶弹出元素 reference\u0026 top() 返回栈顶元素 bool empty() const 判断栈是否为空 size_type size() const 返回元素个数 void swap(stack\u0026 x) noexcept 交换两个栈 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003clist\u003e list是一个双向链表，需要#include \u003clist\u003e。 无法按索引访问元素 插入删除元素效率高 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"3.1 基本操作 基本操作同 vector。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"3.2 特殊操作 添加： void push_front(const value_type\u0026 val) 在开头插入元素 void emplace_front(Args\u0026\u0026... args) 在开头构造并插入元素 void splice(const_iterator position, list\u0026 x) 将 x 中的元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator i) 将 x 中的位置为 i 元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator first, const_iterator last) 将 x 中的 [first, last) 区间内的元素转移到指定位置 void merge(list\u0026 x) void merge(list\u0026 x, Compare comp) 删除： void pop_front() 删除第一个元素 void remove(const value_type\u0026 val) 删除值为 val 的所有元素 void remove_if(Predicate pred) 删除满足自定义一元函数的元素 void unique() 删除连续重复元素，只保留一个 void unique(BinaryPredicate binary_pred) 删除满足自定义二元函数的元素 其他： void sort() 按升序排序 void sort(Compare comp) 按自定义二元函数排序 void reverse() noexcept 逆序 list\u003cint\u003e l = {1, 1, 1, 2, 1, 2}; l.unique(); // {1, 2, 1, 2} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cqueue\u003e queue是一个单向队列容器，需要#include \u003clist\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue\u003cint\u003e q1; // 空 queue queue\u003cint\u003e q2(5, 2); // 大小为 5 的 queue，值均为 2 queue\u003cint\u003e q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue\u003cint\u003e q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; queue\u003cint\u003e q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue\u003cint\u003e q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue\u003cint\u003e pq1; // 空 priority_queue priority_queue\u003cint\u003e pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue\u003cint\u003e pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue\u003cint\u003e pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; priority_queue\u003cint\u003e pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue\u003cint\u003e pq6(v); // 复制 vector priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e pq7; // 最大优先队列（最大堆） priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq8; // 最小优先队列（最小堆） 4.2.2 操作 void push(const value_type\u0026 val) 添加元素 void emplace(Args\u0026\u0026... args) 添加元素 void pop() 删除队首（堆顶）元素 const_reference top() const 返回队首（堆顶）元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(priority_queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cdeque\u003e deque是一个双端队列容器，需要#include \u003cdeque\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.1 初始化 deque\u003cint\u003e dq1; // 空 deque deque\u003cint\u003e dq2(5, 2); // 大小为 5 的 deque，值均为 2 deque\u003cint\u003e dq3(dq2); // 复制 deque deque\u003cint\u003e dq4(dq2.begin(), dq2.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 int arr[] = {1, 2, 3}; deque\u003cint\u003e dq5(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; deque\u003cint\u003e dq6(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 deque\u003cint\u003e dq7 = dq6; deque\u003cint\u003e dq8 = {1, 2, 3}; ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.2 修改 void push_back(const value_type\u0026 val) 队尾添加元素 void push_front(const value_type\u0026 val) 队首添加元素 void emplace_back(Args\u0026\u0026... args) 队尾添加元素 void emplace_front(Args\u0026\u0026... args) 队首添加元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, const value_type\u0026 val) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 迭代器指定位置前面添加 n 个相同元素 iterator insert(const_iterator position, InputIterator first, InputIterator last) 迭代器指定位置前面添加 [first, last) 区间内元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) void pop_back() 删除队尾 void pop_front() 删除队首 iterator erase(iterator position) 删除迭代器指向元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 区间内元素 void clear() noexcept 清空 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.3 遍历 deque\u003cint\u003e dq; for (auto it = dq.begin(); it != dq.end(); it++) {*it;} for (auto it = dq.rbegin(); it != dq.rend(); it++) {*it;} for (int e : dq) {e;} for (int\u0026 e : dq) {e;} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.4 操作 size_type size() const noexcept 返回大小 void resize(size_type n) 调整大小为 n，调大补 0，调小末尾截断 void resize(size_type n, const value_type\u0026 val) 调整大小为 n，调大补 val，调小末尾截断 bool empty() const noexcept 判断是否为空 reference operator[](size_type n) 访问指定位置元素，越界报错 reference at(size_type n) 访问指定位置元素，越界抛出 out_of_range 异常 const_reference back() const 返回队尾元素 const_reference front() const 返回队首元素 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:4","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cmap\u003e map是一个有序键值对容器，每个元素由关键字（key）和该关键字对应的值（value）组合而成。需要#include \u003cmap\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map\u003cchar, int\u003e m1; map\u003cchar, int\u003e m2(m1); map\u003cchar, int\u003e m3(m1.begin(), m1.end()); map\u003cchar, int, less\u003cchar\u003e\u003e m4; // 按 key 升序排列，相当于 map\u003cchar, int\u003e map\u003cchar, int, greater\u003cchar\u003e\u003e m5; // 按 key 降序排列 6.2 添加 map\u003cchar, int\u003e m1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair\u003cchar, int\u003e('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 map\u003cchar, int\u003e m; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-\u003efirst; it-\u003esecond; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-\u003efirst; it-\u003esecond; } for (auto \u0026p : m) { p.first; p.second; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() const noexcept 判断是否为空 void swap(map\u0026 x) 交换两个 map iterator find(const key_type\u0026 k) 查找 key 值为 k 的元素，未找到返回 map::end() size_type count(const key_type\u0026 k) const 返回 key 值为 k 的元素的数量，由于 key 唯一，则存在返回 1，不存在返回 0 iterator lower_bound(const key_type\u0026 k) 返回指向第一个 key 大于等于 k 的元素的迭代器 iterator upper_bound(const key_type\u0026 k) 返回指向第一个 key 大于 k 的元素的迭代器 pair\u003citerator, iterator\u003e equal_range(const key_type\u0026 k) 返回指向 key 等于 k 的所有元素的范围的边界元素的迭代器 [first, second) map\u003cchar, int\u003e m; m['a'] = 0; m.find('b'); // m.end() m.count('a'); // 1 m.count('b'); // 0 6.6 排序 map没有随机迭代器，只有顺序迭代器，所以不能用sort 6.6.1 按 key 排序 key 升序，value 随机 默认情况，map\u003cint, char\u003e，相当于map\u003cint, char, less\u003cint\u003e\u003e。 当 key 为自定义类时： typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; return a.two \u003c b.two; } }; map\u003cGrade, int, Cmp\u003e m; typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; return a.two \u003c b.two; } }; map\u003cGrade, int, Cmp\u003e m; key 降序，value 随机 map\u003cint, char, greater\u003cint\u003e\u003e 6.6.2 按 value 排序 key 降序，value 随机 key 降序，value 随机 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"multimap key允许重复 默认按key升序排列 底层二叉搜索树实现，速度比unordered_multimap慢 基本使用方法同 map。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cunordered_map\u003e ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_map key唯一且不能修改，可以添加或删除 无序 速度比map快 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_multimap ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cset\u003e set是一个有序集合容器。需要#include \u003cset\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set\u003cint\u003e s1; // {} set\u003cint\u003e s2 = {1, 2, 3}; // { 1 2 3 } set\u003cint\u003e s3 = s2; // { 1 2 3 } set\u003cint\u003e s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set\u003cint\u003e s5(arr, arr + 3); // { 1 2 3 } set\u003cint\u003e s6(arr, arr + 1); // { 1 } set\u003cint\u003e s7(s4); // { 1 2 3 } set\u003cint\u003e s8(s4.begin(), s4.end()); // { 1 2 3 } set\u003cint\u003e s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set\u003cint, CompClass\u003e s10; // { 1 2 3 } 修改 pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args) 添加一个元素 pair\u003citerator, bool\u003e insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list\u003cvalue_type\u003e il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair\u003citerator, iterator\u003e equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"multiset 允许重复元素 元素默认升序 速度比unordered_set慢 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cunordered_set\u003e unordered_set是一个无序集合容器。需要#include \u003cunordered_set\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_set 元素唯一 无序 底层哈希表实现，速度比set快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_multiset 允许重复元素 无序 速度比multiset快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cbitset\u003e bitset模拟一个 bool 数组，每个元素只能是 0 或 1. ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"初始化 bitset\u003c4\u003e b1; // 0000 bitset\u003c4\u003e b2(\"100\"); // 0100, b2[0] == 0 bitset\u003c4\u003e b3(\"1100\"); // 1100 bitset\u003c4\u003e b4(\"11100\"); // 1110 bitset\u003c4\u003e b5(b2); // 0100 string s = \"1010\"; bitset\u003c4\u003e b6(s); // 1010 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"位运算 bitset\u003c4\u003e a(\"1001\"), b(\"1010\"); a \u0026 b; // 1000 AND a | b; // 1011 OR a ^ b; // 0011 XOR ~a; // 0110 NOT a \u003c\u003c 1; // 0010 SHL a \u003e\u003e 1; // 0100 SHR a == b; // false a != b; // true ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"操作 reference operator[](size_t pos) 访问指定位置，0 是最右边一位，即最低位 size_t count() const noexcept 返回 1 的 个数 size_t size() const noexcept 返回长度 bool test(size_t pos) const 判断指定位置是否为 1 bool any() const noexcept 判断是否存在某一位是 1 bool none() const noexcept 判断是否全是 0 bool all() const noexcept 判断是否全是 1 bitset\u0026 set() noexcept 全部置为 1 bitset\u0026 set(size_t pos, bool val = true) 指定位置置为 1 bitset\u0026 reset() noexcept 全部置为 0 bitset\u0026 reset(size_t pos) 指定位置置为 0 bitset\u0026 flip() noexcept 翻转 bitset\u0026 flip(size_t pos) 翻转指定位置 string to_string() const 返回该二进制数的字符串 unsigned long to_ulong() const 返回该 2 进制数对应的整数，类型 unsigned long unsigned long long to_ullong() const 返回该 2 进制数对应的整数，类型 unsigned long long ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:3","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003calgorithm\u003e ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector\u003cint\u003e v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"reverse ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:2","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"lower_bound ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:3","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"upper_bound ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:4","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"search ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:5","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003ctuple\u003e tuple将不同类型的许多元素打包成一个对象，便于访问，（就像定义了一个只有属性的类，并且属性只定义了类型，未定义名字）。需要#include \u003ctuple\u003e。 元素类型任意 元素数量任意 tuple\u003cint, string\u003e t1; tuple\u003cint, string\u003e t2{t1}; tuple\u003cint, string\u003e t3(t2); tuple\u003cint, string\u003e t4{1, \"one\"}; get\u003c0\u003e(t4); // 1 get\u003c1\u003e(t4); // one get\u003cint\u003e(t4); // 1 get\u003cstring\u003e(t4); // one make_tuple(2, string(\"two\")); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"参考 Standard C++ Library Reference - cplusplus.com ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:0","series":null,"tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Windows 终端是一个面向命令行工具和 shell（如命令提示符、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL)）用户的新式终端应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，你还可用它来创建你自己的主题并自定义文本、颜色、背景和快捷方式。 ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一、安装 推荐从 Microsoft Store 安装，也可从 官方Github 下载安装。 ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"二、自定义配色方案 打开 Windows Terminal，点击当前标签页顶端右侧向下的箭头，出现下拉菜单，点击设置。 Ctrl + Alt + , (逗号) ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"三、自定义背景 ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"四、命令行参数 使用三个窗格从 PowerShell 打开 Windows 终端（左窗格运行命令提示符配置文件，右窗格拆分为两个，上面用于 PowerShell，下面用于命令提示符）： wt -p cmd `; split-pane -p powershell `; split-pane -H cmd ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"参考文章 新生代 Windows 终端：Windows Terminal 的全面自定义 - 少数派 Windows 终端 - Microsoft ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"PowerShell 所有指令或参数均不区分大小写！ ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":null,"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"帮助 help | Get-Help [[-Name] \u003cstring\u003e] # 本地查询某命令的用法 [-Online] # 微软官方文档查询某命令的用法 ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"查看目录 ls | dir | gci | Get-ChildItem [[-Path] \u003cstring[]\u003e] # [[-Filter] \u003cstring\u003e] [-Include \u003cstring[]\u003e] [-Exclude \u003cstring[]\u003e] [-Recurse] # 递归列出文件夹中内容 [-Depth \u003cuint32\u003e] # 限制递归层数 [-Force] [-Name] [-Attributes \u003cFlagsExpression[FileAttributes]\u003e] [-FollowSymlink] [-Directory] [-File] [-Hidden] [-ReadOnly] [-System] [\u003cCommonParameters\u003e] 文件属性：ddirectory, a(archive), r(read-only), h(hidden), l(link), ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":null,"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/"},{"categories":["Hugo"],"content":"本文介绍了如何使用 Hugo 的 DoIt 主题搭建一个博客，并使用 Github Action 自动部署到 Github Pages。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"1 安装 到 Github 下载hugo_extended_0.XX.X_Windows-64bit.zip，解压并将hugo.exe所在目录添加到系统环境变量。 到 Git 官网 下载安装 Git。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"2 创建网站 hugo new site MyBlog cd MyBlog git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt 可在 Hugo Themes 找到更多主题。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"3 添加内容 输入hugo new posts/My-First-Blog.md，然后打开刚创建的My-First-Blog.md，显示如下： --- title: \"My First Blog\" date: 2021-02-04T16:18:47+08:00 draft: true --- 所有页面均作为草稿创建。文章完成后，如果想要渲染这些页面，请修改为draft: false。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"3.1 在文章中添加图片 Hugo 的配置文件和文章中引用图片都是以static文件夹作为根目录的。 也就是说文章中插入/xxx/yyy.jpg，实际图片存放位置为/static/xxx/yyy.jpg。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"4 本地部署 hugo server/serve hugo server -D # 渲染草稿，即也渲染 draft: true 的内容 浏览器打开 localhost:1313 即可看到部署在本地的网站。 网站部署后，当配置文件或博客内容发生更改时，页面会自动刷新，不用重新部署。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"5 主题自定义 主题配置文件为MyBlog根目录下的config.toml文件。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"5.1 简单配置 # 域名 baseURL = \"https://backtraxe.github.io/\" # 默认语言 [en, zh-cn, ...] defaultContentLanguage = \"zh-cn\" # 语言 [zh-CN, en-us, ...] languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 标题 title = \"traXe\" # 主题 theme = \"DoIt\" [params] # 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是Backsided的博客\" # 作者配置 [author] name = \"Backsided\" email = \"\" link = \"\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"高级配置（可选） ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.home] # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 [params.social] # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true [params.page] # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = false [params.page.toc] # 目录配置 [params.page.toc] # 是否使用目录 enable = true # 是否保持使用文章前","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[markup] # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:4","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[author] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:5","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[sitemap] # 网站地图配置 [sitemap] changefreq = \"weekly\" filename = \"sitemap.xml\" priority = 0.5 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:6","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[Permalinks] # Permalinks 配置 [Permalinks] # posts = \":year/:month/:filename\" posts = \":filename\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:7","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[privacy] # 隐私信息配置 [privacy] [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:8","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[mediaTypes] # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\"text/plain\"] suffixes = [\"md\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:9","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[outputFormats.MarkDown] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \"text/plain\" isPlainText = true isHTML = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:10","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[outputs] # 用于 Hugo 输出文档的设置 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] page = [\"HTML\", \"MarkDown\"] section = [\"HTML\", \"RSS\"] taxonomy = [\"HTML\", \"RSS\"] taxonomyTerm = [\"HTML\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:11","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"6 发布 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"6.1 静态页面发布 输入hugo，渲染后的静态页面在 ./public 文件夹中，可将该文件夹中的内容发布。 可用-d/--destination或在config.toml中修改publishdir来指定输出地址。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"6.2 Github Pages 发布 在 Github 新建两个仓库：\u003cUSERNAME\u003e.github.io.data 存放内容，\u003cUSERNAME\u003e.github.io 部署页面。 其中，\u003cUSERNAME\u003e.github.io.data可以设为私人仓库。 git remote add origin https://github.com/backtraxe/backtraxe.github.io.data.git git add --all git commit -m \"init blog\" git push --set-upstream origin master -f 创建一个 Personal access token，命名随意，勾选repo。 进入\u003cUSERNAME\u003e.github.io.data仓库，点击Settings-\u003eSecrets，填入刚才的token；点击Actions-\u003eNew workflow-\u003eset up a workflow yourself，写入如下内容。 name:Hugo Deploy # 名称随意修改on:push:branches:[master ] # 修改为你当前分支jobs:build:runs-on:ubuntu-latest # 指定系统版本steps:- uses:actions/checkout@v2 # 克隆仓库with:submodules:true# 启用子模块fetch-depth:1- name:Setup Hugo # 安装 hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'# 指定 hugo 版本- name:Build Hugo # hugo 生成网站run:hugo- name:Deploy Hugo # 部署网站uses:peaceiris/actions-gh-pages@v3with:personal_token:${{ secrets.ACCESS_TOKEN }} # 与 secrets 里的 token 名称对应external_repository:backtraxe/backtraxe.github.io # 指定发布的仓库publish_branch:master # 指定发布仓库的分支publish_dir:./public # 指定要发布的目录 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"6.3 环境迁移 git clone --recursive https://github.com/backtraxe/backtraxe.github.io.data.git ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"7 全局详细配置 # 域名 baseURL = \"\" # 构建时包含草稿 buildDrafts = false # 内容文件夹 contentDir = \"content\" # 数据文件夹 dataDir = \"data\" # 内容默认语言（中文：zh-cn） defaultContentLanguage = \"en\" # 根目录跳转到默认语言目录 defaultContentLanguageInSubdir = false # 禁用指定类型页面：page, home, section, taxonomy, term, RSS, sitemap, robotsTXT, 404 disableKinds = [] # 禁用实时重载 disableLiveReload = false # 禁用将 url/path 转小写字母 disablePathToLower = false # 启用 Emoji enableEmoji = false # 使用文件的最后 git 提交日期更新 Lastmod 参数 enableGitInfo = false # 启用 inline shortcode enableInlineShortcodes = false # 是否生成 robots.txt 文件 enableRobotsTXT = false # 日期设置 [frontmatter] # 脚注锚的前缀 footnoteAnchorPrefix = \"\" # 脚注返回链接显示的文本 footnoteReturnLinkContents = \"\" # Google Analytics 跟踪 ID googleAnalytics = \"\" # 自动检测内容中的中文/日文/韩文 hasCJKLanguage = false # 图片设置 [imaging] # 语言设置 [languages] # 启用日志 log = false # 日志保存目录 logFile = \"\" # 主题设置 [markup] # 目录设置 [menu] # 最小化构建设置 [minify] # 模块设置 [module] # 每页的默认文章数量 paginate = 10 # 固定链接 [permalinks] # 生成静态网页的目录 publishDir = \"public\" # 相关设置 [related] # 网站地图设置 [sitemap] # 静态文件目录设置 staticDir = \"static\" # 分类设置 [taxonomies] # 主题 theme = \"\" # 主题目录 themesDir = \"themes\" # 标题 title = \"\" 参考：Configure Hugo ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:7:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"8 参考 Quick Start | Hugo GitHub Pages 文档 - GitHub Docs Host on GitHub - Hugo 主题文档 - 基本概念 - LoveIt How to Create Your First Hugo Blog: a Practical Guide 创建 GitHub Pages 站点 - Github 使用Hugo和GitHub搭建博客 - Félix | Medium ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:8:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Markdown"],"content":"Markdown 是一种轻量级的「标记语言」，易读易写，简洁至上，被广泛使用。这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例。 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"一、标题 # 一级标题 h1 ## 二级标题 h2 ### 三级标题 h3 #### 四级标题 h4 ##### 五级标题 h5 ###### 六级标题 h6 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"二、强调 **加粗** *斜体* ~~删除线~~ ***斜体加粗*** ~~**删除线加粗**~~ ~~*斜体删除线*~~ ~~***斜体删除线加粗***~~ 加粗、斜体、删除线、斜体加粗、删除线加粗、斜体删除线、斜体删除线加粗 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"三、引用 \u003e 引用 \u003e\u003e 嵌套引用 引用 嵌套引用 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"四、分割线 --- *** ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"五、图片 ![Backsided's World](https://backtraxe.github.io/apple-touch-icon.png \"Backtraxe's World\") \u003cimg src=\"https://backtraxe.github.io/apple-touch-icon.png\" alt=\"Backtraxe's World\" width=\"30%\" height=\"30%\"\u003e Backtraxe's WorldBacksided\u0026rsquo;s World \" Backtraxe's World ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"六、超链接 [Backsided's World](https://backtraxe.github.io/) \u003chttps://backtraxe.github.io/\u003e 这个链接用 1 作为网址变量 [Google][1] 这个链接用 runoob 作为网址变量 [Runoob][runoob] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [runoob]: http://www.runoob.com/ Backsided’s World https://backtraxe.github.io/ 这个链接用 1 作为网址变量 traXe 这个链接用 runoob 作为网址变量 traXe 然后在文档的结尾为变量赋值（网址） ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"七、列表 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"无序列表 - 北京 - 上海 - 广州 - 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"有序列表 1. 北京 1. 上海 1. 广州 1. 深圳 或者 1. 北京 2. 上海 3. 广州 4. 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"列表嵌套 - 北京 - 上海 - 广东 1. 广州 2. 深圳 北京 上海 广东 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:3","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"八、表格 姓名|分数|排名 --|:--:|--: 张三|100|1 李四|85|2 王五|60|3 姓名 分数 排名 张三 100 1 李四 85 2 王五 60 3 --，:-- : 左对齐 :--: : 居中 --: : 右对齐 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"九、代码 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"单行代码 `print(\"Hello World!\")` print(\"Hello World!\") ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"多行代码 \\```cpp #include\u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } \\``` #include\u003ciostream\u003eint main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"十、流程图 \\```flow st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop \\``` st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"十一、LaTeX公式 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"行内公式 $ E=mc^2 $ $ E=mc^2 $ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"多行公式 $$ \\sum_{i=1}^n a_i=0 $$ $$ f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$ \\sum_{i=1}^n a_i=0 $$ $$ f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}]