[{"categories":["导航"],"content":" 在线工具 PDF：easy PDF|PDF24 Tools|iLovePDF 图片：iLoveIMG|Bigjpg|Recompressor|BgRemover|ezGIF|jpgRM|jpgHD Remove Background by PhotoRoom：去除背景。 Remove Background by ClipDrop：去除背景。 Erase.bg by PixelBin.io：去除背景。 Remove Objects by PhotoRoom：抠背景。 CleanUp.pictures：抠背景。 Upscaler by ClipDrop：提高分辨率。 Upscale.media by PixelBin.io：提高分辨率。 Shrink.media by PixelBin.io：图片压缩。 WatermarkRemover.io by PixelBin.io：去除水印。 视频：bigmp4 音频：网易见外 OCR：EasyScreenOCR|Online OCR 图标：小米风格Logo|图标制作|Favicon生成器 背景：Figen|fffuel Meshy：Generate beautiful mesh gradients. 图表：ProcessOn|Diagram 数学：Mathway Apple：The Mac index Steam：SteamDB 字体：萝卜工坊|Weird Fonts LaTeX：Overleaf|公式编辑器 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#在线工具"},{"categories":["导航"],"content":" 在线娱乐影视：低端影视|奈菲影视|看片狂人|NO视频 动漫：AGE动漫|樱花动漫|ZzzFun|漫岛动漫|EDD动漫 漫画：漫画DB|动漫之家|包子漫画 小说：天天看小说 体育：CCTV5|JRKAN 小说：小说排版助手 工具书：新华字典、汉语词典、英语词典、成语词典、诗词古文、作文大全、汉字笔顺、汉字组词、近义词、反义词、词语造句、双语小说、童话故事、谜语大全、谚语大全、歇后语大全、名人名言、周公解梦、实用工具、网名大全、好词好句、特殊符号。 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#在线娱乐"},{"categories":["导航"],"content":" 程序开发IDE：OnlineGDB|C++ shell|futurecoder|KalkiCode Compiler Explorer：查看各种语言编译后的汇编代码或字节码。Github Replit：在线 IDE。 Git：Learn Git 正则表达式：regex101|RegexLearn 破解：吾爱破解 数据结构和算法动态可视化 uiverse.io：HTML 和 CSS 样式库。 Carbon：代码截图。 CodeToImg：代码截图。 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:3:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#程序开发"},{"categories":["导航"],"content":" 资源下载搜索：搜番|磁力爬|八爪鱼 影视：高清MP4|片源网|BT天堂|WebHD|FIX字幕侠|牛牛美剧|音范丝|Nyaa|RARBG|纪录片天地|BTNull 动漫：动漫领域|肥羊-Raws|动漫花园|萌番组|不移之火 trackers：ngosang/trackerslist|ACGTracker 字幕：SubHD|字幕库|A4k字幕网 体育：90分钟足球网 小说：知轩藏书 游戏：叽哩叽哩 Office：Word联盟|优品PPT|PPT超级市场|第1PPT 图片：Unsplash|DeviantArt|Pinterest|天空之城|NegativeSpace|Free Stock Images 壁纸：极简壁纸1|极简壁纸2|Wallpaper Abyss|wallhaven Ocean of Wallpapers Rare Gallery 素材：Freepik|Storyset|StickPNG 图标：Worldvectorlogo|Iconduck|StickPNG|Iconfont|设计之家|Notion Icons 5.0 iOS Icon Gallery macOS Icon Gallery watchOS Icon Gallery 配色：Color Hunt|Color Palettes|Hello Color|NIPPON COLORS|中国色|Blend|ColorSpace 系统：Windows 11 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:4:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#资源下载"},{"categories":["导航"],"content":" 导航资讯游戏：Liquipedia|DST-MOD Wiki 资源：不死鸟|好棒的羊毛站 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:5:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#导航资讯"},{"categories":["导航"],"content":" 软件APP安卓：APKMirror|APKCombo|果核剥壳|异星软件空间|易酷软件 Windows：果核剥壳|Downloadastro|Crack Softwares|Easy To Direct Download Pc Software Mac：MacWk|腾讯柠檬精选 iOS：捷径库 每日限免：反斗限免|Appwall Today|Mergeek 软件推荐：小众软件|反斗软件|Awesome Windows|Best Windows Apps 推荐软件 安卓：MiXplorer Silver|1DM+|FolderSync|Tachiyomi|全是漫画|阅读3.0 iOS： Windows：ShareX|Snipaste|uTools|Bandizip|Everything|Honeycam|PDFPatcher|Rufus|Ventoy|微PE工具箱|AS SSD Benchmark|GPU-Z|CPU-Z|adb \u0026 fastboot Mac： Linux： 浏览器扩展：沙拉查词|Chrono下载管理器|Tampermonkey 油猴插件：AC-baidu|秒传链接提取|网盘直链下载助手 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:6:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#软件app"},{"categories":["导航"],"content":" 简历 vCard：vCard is a fully responsive personal portfolio website, responsive for all devices. ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#简历"},{"categories":["导航"],"content":" C++ Modern CPP Tricks：This is the list of modern CPP tricks often used in Coding Interviews and Competitive Programming. 《Effective Modern C++》解读笔记 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#c"},{"categories":["导航"],"content":" C/C++ 《Effective Debugging》中文版：Effective Debugging by Michael Yan，讲述了如何更有效率地调试大型程序（以C/C++为例）的方法和技能。书中例子不仅丰富而且都是从实际的工作经验提取，观点和方法有效且具有可行性。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#cc"},{"categories":["导航"],"content":" Go 《Go 入门指南》：《The Way to Go》中文版。 《Go 语言原本》：本书就是一本讨论 Go 语言源码工程中的技术原理及其演进历程的书籍。 Golang-Internal-Notes：Go 源码分析。 《玩转 GO》：《Mastering GO》中文版。 Go Course：Master the fundamentals and advanced features of the Go programming language. Golang 编译器代码浅析 《Go语言定制指南》 《µGo语言实现》：从头开发一个迷你 Go 语言编译器。 《Go 语言设计与实现》 Golang资料补给包 《Go语言标准库》：2022/3/6 Go Standard Library By Example：2018/1/10 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#go"},{"categories":["导航"],"content":" 深度学习 AI on Ubuntu Platform：AI 实验环境搭建和深度学习算法。 《Neural Networks For Chess》 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#深度学习"},{"categories":["导航"],"content":" 数据库 Let’s Build a Simple Database：Writing a sqlite clone from scratch in C. 从零开始写数据库：500行代码实现 LSM 数据库 Use The Index, Luke!：A site explaining SQL indexing to developers. ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:6:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#数据库"},{"categories":["导航"],"content":" 算法 LeetCode难题代码和算法要点分析：C++/Python 实现。2022/7/18 《Algorithms》：by Jeff Erickson. 图解算法数据结构：《剑指 Offer》 Python, Java, C++ 解题代码，LeetBook《图解算法数据结构》配套代码仓。 《Algorithms》：4th Edition by Robert Sedgewick and Kevin Wayne. 《算法新解》 1500 most common data structures and algorithms solutions ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#算法"},{"categories":["导航"],"content":" 计算机网络 不为人知的网络编程 通透，23 个问题 TCP 疑难杂症全解析 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:8:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#计算机网络"},{"categories":["导航"],"content":" 操作系统 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:9:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#操作系统"},{"categories":["导航"],"content":" Linux Advanced Bash-Scripting Guide Linux内核学习资料 Linux操作系统内核学习 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:10:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#linux"},{"categories":["导航"],"content":" 软件工程 《Software Engineering at Google》中文版 Google Style Guides：Style guides for Google-originated open-source projects. ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:11:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#软件工程"},{"categories":["导航"],"content":" 正则表达式 Learn Regex the Easy Way RegExp Example：正则表达式实例搜集，通过实例来学习正则表达式。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:12:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#正则表达式"},{"categories":["导航"],"content":" Matplotlib 40000 字！全网最强 Matplotlib 实操指南! ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:13:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#matplotlib"},{"categories":["导航"],"content":" 区块链 区块链黑暗森林自救手册 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:14:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#区块链"},{"categories":["导航"],"content":" 博客 为什么这么设计系列文章 Ops School Curriculum：Ops School is a comprehensive program that will help you learn to be an operations engineer. ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:15:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#博客"},{"categories":["导航"],"content":" 工具 DBER：数据库建表工具。 godeng：生成各种类型的测试数据。 RapidOCR (捷智OCR) F2：命令行批量重命名工具。 Gradio：Build Machine Learning Web Apps. 未分类 设计数据密集型应用 - 中文翻译 Awesome Software Architecture Awesome Algorithms ReallyConfused Awesome Roadmaps PptxGenJS: Create JavaScript PowerPoint Presentations 程序员应该访问的最佳网站中文版 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:16:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#工具"},{"categories":["导航"],"content":" 公开课 清华大学计算机系课程攻略 浙江大学课程攻略共享计划 上海交通大学课程分享 哈工大（深圳）计算机专业课程攻略 CS自学指南 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:17:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#公开课"},{"categories":["导航"],"content":" 1.编程基础 环境搭建 环境搭建 Arch Linux 安装使用教程 Psyduck：XMind 记录 CS 基础问题。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:18:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#1编程基础"},{"categories":["导航"],"content":" 1.1 操作系统 操作系统 逸仙OS简明教程 Systems Programming Cheat Sheet 从零开始制作一个操作系统 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:18:1","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#11-操作系统"},{"categories":["导航"],"content":" 1.2 数据库 数据库 SQLBolt: interactive lessons and exercises 设计数据密集型应用 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:18:2","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#12-数据库"},{"categories":["导航"],"content":" 1.3 云 Docker Getting Started Tutorial: Docker入门。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:18:3","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#13-云"},{"categories":["导航"],"content":" 1.4 正则表达式 Regex-vis：正则表达式可视化。 Regular Expression Tester and Visualizer ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:18:4","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#14-正则表达式"},{"categories":["导航"],"content":" 1.5 Linux Linux命令行与Shell脚本教程 Linux网络编程与加密 explainshell.com Linux常用命令行小技巧 LinuxGuide ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:18:5","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#15-linux"},{"categories":["导航"],"content":" 1.6 计算机网络 计算机网络知识点全面总结 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:18:6","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#16-计算机网络"},{"categories":["导航"],"content":" 编程语言 Bit Twiddling Hacks: 位运算奇淫巧计。 Cheatsheet for regex syntaxes: Read Online ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#编程语言"},{"categories":["导航"],"content":" C C Programming Course ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:1","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#c"},{"categories":["导航"],"content":" C++ cplusplus.com C++那些事：这是一个适合初学者从入门到进阶的仓库，解决了面试者与学习者想要深入 C++及如何入坑 C++的问题。除此之外，本仓库拓展了更加深入的源码分析，多线程并发等的知识，是一个比较全面的 C++ 学习从入门到进阶提升的仓库。 在拥挤和变化的世界中茁壮成长：C++ 2006–2020 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:2","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#c-1"},{"categories":["导航"],"content":" Go mmcgrana/gobyexample：使用带注释的示例程序进行 Go 操作的实践介绍。 Go by Example quii/learn-go-with-tests：通过编写测试学习 Go 语言。 Learn Go with tests Tutorial: Get started with Go：Go 官方教程。 Practical Go Lessons Introduction-to-Golang：最全空降 golang 资料补给包（满血战斗），包含文章，书籍，作者论文，理论分析，开源框架，云原生，大佬视频，大厂实战分享 ppt。 《Go入门指南》 Go 101 Go语言101 Go语言精进之路 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:3","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#go"},{"categories":["导航"],"content":" Java Java SE Documentation：Java SE 文档。 JDK 11 API JDK 8 API How2J 的 Java教程 深入浅出Java多线程 toBeBetterJavaer JavaGuide guide-rpc-framework ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:4","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#java"},{"categories":["导航"],"content":" Javascript clean-code-javascript: Clean Code concepts adapted for JavaScript ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:5","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#javascript"},{"categories":["导航"],"content":" Python Python-Mini-Projects: 一组简单的 Python 迷你项目来增强你的 Python 技能。 《Python Cookbook in Chinese》 3rd Edition 翻译 爬取你要的数据：爬虫技术 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:6","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#python"},{"categories":["导航"],"content":" Rust 使用 Rust 迈出第一步: 打下使用 Rust 构建快速、高效的程序所需的知识基础。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:7","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#rust"},{"categories":["导航"],"content":" Typescript 深入理解 TypeScript: TypeScript Deep Dive的中文翻译版 在线阅读 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:19:8","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#typescript"},{"categories":["导航"],"content":" 工具 论文 SCI-Hub论文下载可用网址链接 企鹅论文 一键下载 WordTEX Learn LaTeX Darling: Darling is a runtime environment for macOS applications. scrcpy: 显示和控制您的 Android 设备。 Tesseract OCR: Tesseract 开源 OCR 引擎。 PDF.js: 使用 HTML5 构建的 PDF 查看器。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:20:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#工具"},{"categories":["导航"],"content":" 前端 带你入门前端工程: 国内访问（Gitee） 国外访问（Github） 图解 React 源码系列: 图解 React 源码，用大量配图的方式，致力于将 React 原理表述清楚。 50 Projects in 50 Days - HTML/CSS and JavaScript ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:21:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#前端"},{"categories":["导航"],"content":" 人工智能","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#人工智能"},{"categories":["导航"],"content":" 推荐系统 工业界的推荐系统 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:1","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#推荐系统"},{"categories":["导航"],"content":" 竞赛 The Kaggle Book ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:2","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#竞赛"},{"categories":["导航"],"content":" 博客 博客 『A Course in Machine Learning』by Hal Daumé III AI算法工程师手册 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:3","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#博客"},{"categories":["导航"],"content":" 课程 公开课 机器学习 - 吴恩达 | Coursera ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:4","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#课程"},{"categories":["导航"],"content":" 教程 Modern Deep Learning Techniques Applied to Natural Language Processing 100 numpy exercises 书籍 《利用 Python 进行数据分析（第2版）》 GitBook 《Python for Data Analysis》代码 《Pandas Cookbook》 《Pandas Cookbook》代码 教程 《简明的 TensorFlow 2》 | 在线 📅2021/07/15 🌟3484 30天吃掉那只TensorFlow2 ｜ GitBook 📅2021/05/27 🌟8855 TensorFlow 2.0 Tutorials 📅2020/09/23 🌟5993 20天吃掉那只Pytorch 20210704 深度学习500问 20210317 nlp-tutorial 20210502 Machine Learning for Beginners - A Curriculum 20210721 《Deep Learning》 《The Elements of Statistical Learning》中文版 《Interpretable machine learning》 | 在线 20210713 《动手学深度学习》李沐 | 在线 20210717 《神经网络与深度学习》邱锡鹏 | 在线 20210518 深度学习论文翻译 深度学习入门教程, 优秀文章 AiLearning: 机器学习：在线 机器学习原理：在线 Data-Science-Notes CS229 课程讲义中文翻译：在线 斯坦福大学2014（吴恩达）机器学习教程中文笔记：在线 《神经网络与深度学习》 邱锡鹏：在线 Deep Learning with PaddlePaddle：在线 Joyful-Pandas | 在线 20210331 User Guide — pandas pytorch handbook: 帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门。 【关于 NLP】那些你不知道的事 【关于 NLP】百问百答 Start Machine Learning in 2021: 2021 年开始和改进机器学习 (ML)、人工智能 (AI) 的完整指南，无需任何该领域的背景，并随时了解最新消息和最先进技术！ PyTorch 中文手册: 这是一本开源的书籍，目标是帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门。 【关于 NLP】 那些你不知道的事: 研读顶会论文，复现论文相关代码 PythonAiRoad Start Machine Learning in 2021: A complete guide to start and improve in machine learning (ML), artificial intelligence (AI) in 2021 without ANY background in the field and stay up-to-date with the latest news and state-of-the-art techniques! Best Resources to Learn Natural Language Processing in 2021 deepcourse: Deep Learning for Computer Vision, Read Online Machine Learning Crash Course: Google’s fast-paced, practical introduction to machine learning matplotlib/cheatsheets: Official Matplotlib cheat sheets ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:5","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#教程"},{"categories":["导航"],"content":" 竞赛 阿里云天池 Kaggle ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:6","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#竞赛-1"},{"categories":["导航"],"content":" 论文 Papers With Code: The latest in Machine Learning. CVF Open Access Best Paper Awards in CS 卖萌屋学术站: 每日学术论文。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:7","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#论文"},{"categories":["导航"],"content":" 社区 社区 Dataquest AI研习社 AMiner ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:22:8","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#社区"},{"categories":["导航"],"content":" 速查表 速查表 Pandas Cheat Sheet ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:23:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#速查表"},{"categories":["导航"],"content":" 算法面试 Google’s Tech Dev Guide: grow your technical skills, supplement your coursework, and prepare for interviews. awesome-cs-books: 经典编程书籍大全，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试等 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:24:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#算法面试"},{"categories":["导航"],"content":" 面试 CS-Notes： 在线 Coding Interview University： 中文 2021笔试面试题 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:24:1","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#面试"},{"categories":["导航"],"content":" 设计模式 design-patterns-for-humans-cn: Design patterns for humans中文版 《设计模式：可复用面向对象软件的基础》学习笔记 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:24:2","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#设计模式"},{"categories":["导航"],"content":" 算法 The Algorithms labuladong 的算法小抄： GitHub Pages Gitbook Gitee Pages 算法珠玑： 在线 LeetCode 101: 一个面向有C++编程基础，但缺乏刷题经验的读者的教科书和工具书（不适合编程小白喔）。 Algorithms, 4th Edition Algorithms by Jeff Erickson Competitive-Programming-Resources Algorithm Guide: 程序员必知必会的算法和数据结构 不懂动态规划？21道 LeetCode题目带你学会动态规划！ 五万字《十大排序算法》动图讲解 Learn-Algorithms: 算法学习笔记 algorithm-note: 数据结构与算法的讲解及代码实现，在线阅读 Data Structure Visualizations C++算法编程指南 Best Resources to Learn Data Structures and Algorithms DSA-Bootcamp-Java 《algorithm-note》中文版 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:24:3","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#算法"},{"categories":["导航"],"content":" 网络安全 网络安全 《CTF竞赛权威指南》 | GitBook TryHackMe Attack-Defense Online Lab XSS 挑战 CTF - Application Security Challenge Command Challenge Exploit Education Google CTF Hack The Box Defend the Web Hacksplaining Hacker101 CTF ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:25:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#网络安全"},{"categories":["导航"],"content":" 其他 项目 HelloGitHub free-project-course: 整理和搜集网络免费的项目实战课程 Github Digital Privacy MockingBird: AI拟声，5秒内克隆您的声音并生成任意语音内容 LaTeX-OCR: pix2tex, Using a ViT to convert images of equations into LaTeX code Bifrost: Search for visual datasets by task, application, class, label or format Manim Community: Python library for creating mathematical animations SG-NLP: SG-NLP is an initiative by AI Singapore’s NLP Hub A Vim Guide For Experts PearOCR Diffgram: Training data platform for machine learning delivered as a single application Forecasting: Principles and Practice (3rd ed) Greykite: A flexible, intuitive and fast forecasting library flow-forecast: Deep learning PyTorch library for time series forecasting, classification, and anomaly detection Codeimg.io: Convert code to image Macast: A menu bar application using mpv as DLNA Media Renderer. You can push videos, pictures or musics from your mobile phone to your computer Real-time-stock-market-prediction: Server architecture for Real-time Stock-market prediction with ML Open Video Downloader (youtube-dl-gui): A cross-platform GUI for youtube-dl made in Electron and node.js Awesome Scriptable: A curated list of awesome Scriptable scripts and widgets THU-Beamer-Theme: A LaTeX beamer theme template for Tsinghua students, Read Online Versus: 万物皆可对比 Appscope: Progressive Web Apps Examples 英语语法网 中国人民大学英语口语能力标准 Pl@ntNet: 植物图像识别 Table Convert Online:table to markdown, csv, json, latex table, excel, sql, xml GitHub News: Discover the Top Trending Repos Academia: How to write academic essay 图吧工具箱 WallpaperHub 柯帕斯英语网 大耳朵英语 UP-6 英语学习导航 MangaPanda: Read manga online for free in English YouZack: 英语听力精听、背单词 scrcpy: This application provides display and control of Android devices connected on USB. ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:26:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#其他"},{"categories":["导航"],"content":" 论文 Paper Style Guide ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:27:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#论文-1"},{"categories":["力扣"],"content":"628. 三个数的最大乘积 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:0:0","series":null,"tags":["力扣"],"title":"力扣 0628 三个数的最大乘积","uri":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/#"},{"categories":["力扣"],"content":" 思路 全是非负数：选择最大的三个非负数，即最大的三个数。 至少两个非负数，只有一个负数： 至少三个非负数：选择最大的三个非负数，即最大的三个数。 只有两个非负数：只有三个数可以选择，即最大的三个数。 至少一个非负数，只有两个负数： 至少三个非负数：选择最大的三个非负数，即最大的三个数；或者选择两个负数和最大的一个非负数，即最小的两个数和最大的一个数。 只有两个非负数：选择两个负数和最大的一个非负数，即最小的两个数和最大的一个数。 只有一个非负数：只有三个数可以选择，即最大的三个数。 全是负数：选择最小的三个负数，即最大的三个数。 综上，结果为最大的三个数和最小的两个数和最大的一个数中的更大值。 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:1:0","series":null,"tags":["力扣"],"title":"力扣 0628 三个数的最大乘积","uri":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/#思路"},{"categories":["力扣"],"content":" 代码 排序 class Solution { public int maximumProduct(int[] nums) { Arrays.sort(nums); int n = nums.length; return Math.max( nums[n - 1] * nums[n - 2] * nums[n - 3], // 最大的三个数 nums[n - 1] * nums[0] * nums[1] // 最小的两个数和最大的一个数 ); } } 不排序 class Solution { public int maximumProduct(int[] nums) { int max1, max2, max3, min1, min2; // 最大的三个数、最小的两个数 max1 = max2 = max3 = Integer.MIN_VALUE; min1 = min2 = Integer.MAX_VALUE; for (int x : nums) { if (x \u003e max1) { max3 = max2; max2 = max1; max1 = x; } else if (x \u003e max2) { max3 = max2; max2 = x; } else if (x \u003e max3) { max3 = x; } if (x \u003c min1) { min2 = min1; min1 = x; } else if (x \u003c min2) { min2 = x; } } return Math.max(max1 * max2 * max3, max1 * min1 * min2); } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:2:0","series":null,"tags":["力扣"],"title":"力扣 0628 三个数的最大乘积","uri":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/#代码"},{"categories":["力扣"],"content":"459. 重复的子字符串 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["力扣","字符串匹配"],"title":"力扣 0459 重复的子字符串","uri":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/#"},{"categories":["力扣"],"content":" 枚举子串长度若满足题意，则字符串 $s$ 可以写成 $s_1s_1 \\cdots s_1$，其中 $s_1$ 的数量为 $k$，则 $n = k * m \\ (2 \\le k)$，$1 \\le m \\le \\frac{n}{2}$，其中 $n$ 为字符串 $s$ 的长度，$m$ 为子串 $s_1$ 的长度。 class Solution { public boolean repeatedSubstringPattern(String s) { int n = s.length(); for (int len = 1; len * 2 \u003c= n; len++) { // 枚举子串长度 if (n % len != 0) continue; // 剪枝 int i; for (i = len; i \u003c n; i++) if (s.charAt(i - len) != s.charAt(i)) break; if (i == n) return true; } return false; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":null,"tags":["力扣","字符串匹配"],"title":"力扣 0459 重复的子字符串","uri":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/#枚举子串长度"},{"categories":["力扣"],"content":" 字符串匹配若满足要求，则字符串 $s$ 至少可以写成 $s_1s_1$，将两个 $s$ 前后拼接在一起得到 $ss = s_1s_1s_1s_1$，去掉 $ss$ 的首字符和末尾字符得到 $ss_1 = s_2s_1s_1s_2$，则字符串 $s$ 一定是 $ss_1$ 的子串。 class Solution { public boolean repeatedSubstringPattern(String s) { return (s + s).indexOf(s, 1) != s.length(); } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":null,"tags":["力扣","字符串匹配"],"title":"力扣 0459 重复的子字符串","uri":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/#字符串匹配"},{"categories":["力扣"],"content":"第 304 场周赛 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:0:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#"},{"categories":["力扣"],"content":" 复盘 全国排名：556 / 7426（8.08%） 全球排名：1309 / 26877（4.64%） 分数变化：2095 + 17 = 2112 完成时间：42m20s（+5m） 题目1 难度： 顺序：1 用时：5m46s 错误：0 题目2 难度： 顺序：2 用时：7m28s 错误：0 题目3 难度： 顺序：3 用时：16m28s 错误：1 dp 初始化错误 题目4 难度： 顺序：4 用时：17m38s 错误：0 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:1:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#复盘"},{"categories":["力扣"],"content":" 算术三元组的数目6136. 算术三元组的数目 class Solution { public int arithmeticTriplets(int[] nums, int diff) { HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int n = nums.length; for (int i = 0; i \u003c n; i++) map.put(nums[i], i); int ans = 0; for (int i = 1; i + 1 \u003c n; i++) { int prev = map.getOrDefault(nums[i] - diff, n); int next = map.getOrDefault(nums[i] + diff, -1); if (prev \u003c i \u0026\u0026 next \u003e i) ans++; } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:2:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#算术三元组的数目"},{"categories":["力扣"],"content":" 受限条件下可到达节点的数目6139. 受限条件下可到达节点的数目 class Solution { int ans = 0; public int reachableNodes(int n, int[][] edges, int[] restricted) { List\u003cInteger\u003e[] graph = new ArrayList[n]; for (int i = 0; i \u003c n; i++) graph[i] = new ArrayList\u003c\u003e(); for (int[] edge : edges) { graph[edge[0]].add(edge[1]); graph[edge[1]].add(edge[0]); } HashSet\u003cInteger\u003e res = new HashSet\u003c\u003e(); for (int x : restricted) res.add(x); boolean[] vis = new boolean[n]; dfs(graph, 0, res, vis); return ans; } void dfs(List\u003cInteger\u003e[] graph, int u, HashSet\u003cInteger\u003e res, boolean[] vis) { vis[u] = true; ans++; for (int v : graph[u]) { if (!res.contains(v) \u0026\u0026 !vis[v]) dfs(graph, v, res, vis); } } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:3:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#受限条件下可到达节点的数目"},{"categories":["力扣"],"content":" 检查数组是否存在有效划分6137. 检查数组是否存在有效划分 class Solution { public boolean validPartition(int[] nums) { int n = nums.length; // dp[i] 表示前 i 个元素是否存在有效划分 boolean[] dp = new boolean[n + 1]; dp[0] = true; dp[2] = nums[0] == nums[1]; for (int i = 2; i \u003c n; i++) { dp[i + 1] = dp[i - 1] \u0026\u0026 nums[i] == nums[i - 1] || dp[i - 2] \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 nums[i] == nums[i - 2] || dp[i - 2] \u0026\u0026 nums[i] - 1 == nums[i - 1] \u0026\u0026 nums[i] - 2 == nums[i - 2]; } return dp[n]; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:4:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#检查数组是否存在有效划分"},{"categories":["力扣"],"content":" 最长理想子序列6138. 最长理想子序列 class Solution { public int longestIdealString(String s, int k) { int[] dp = new int[26]; for (char c : s.toCharArray()) { int x = c - 'a'; int maxLen = 0; for (int i = Math.max(0, x - k); i \u003c= Math.min(25, x + k); i++) maxLen = Math.max(maxLen, dp[i]); d[x] = maxLen + 1; } int ans = 0; for (int x : dp) ans = Math.max(ans, x); return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:5:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#最长理想子序列"},{"categories":["力扣"],"content":" 总结 考察 dp ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:6:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#总结"},{"categories":["力扣"],"content":"第 84 场双周赛 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:0:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#"},{"categories":["力扣"],"content":" 复盘 全国排名：745 / 4574（16.29%） 全球排名：1631 / 23102（7.06%） 分数变化：2112 - 5 = 2107 完成时间：1h52m53s（+25m） 题目1 难度： 顺序：1 用时：2m46s 错误：0 题目2 难度： 顺序：3 用时：6m41s 错误：2 WA：int 溢出 题目3 难度： 顺序：2 用时：25m49s 错误：0 题目4 难度： 顺序：4 用时：20m6s 错误：3 WA：思路错误 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:1:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#复盘"},{"categories":["力扣"],"content":" 合并相似的物品6141. 合并相似的物品 class Solution { public List\u003cList\u003cInteger\u003e\u003e mergeSimilarItems(int[][] items1, int[][] items2) { TreeMap\u003cInteger, Integer\u003e map = new TreeMap\u003c\u003e(); for (int[] a : items1) map.put(a[0], map.getOrDefault(a[0], 0) + a[1]); for (int[] a : items2) map.put(a[0], map.getOrDefault(a[0], 0) + a[1]); List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); for (int key : map.keySet()) ans.add(List.of(key, map.get(key))); return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:2:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#合并相似的物品"},{"categories":["力扣"],"content":" 统计坏数对的数目6142. 统计坏数对的数目 class Solution { public long countBadPairs(int[] nums) { int n = nums.length; long ans = (long) n * (n - 1) / 2; Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c n; i++) { int x = i - nums[i]; ans -= map.getOrDefault(x, 0); map.put(x, map.getOrDefault(x, 0) + 1); } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:3:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#统计坏数对的数目"},{"categories":["力扣"],"content":" 任务调度器 II6174. 任务调度器 II class Solution { public long taskSchedulerII(int[] tasks, int space) { HashMap\u003cInteger, Long\u003e map = new HashMap\u003c\u003e(); // 任务起始时间 long ans = 0; for (int task : tasks) { // 当前任务开始之前必须上个任务结束并且上个同类型任务间隔 space 天 ans = Math.max(ans + 1, map.getOrDefault(task, 0L)); map.put(task, ans + space + 1); } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:4:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#任务调度器-ii"},{"categories":["力扣"],"content":" 将数组排序的最少替换次数6144. 将数组排序的最少替换次数 class Solution { public long minimumReplacement(int[] nums) { long ans = 0; int next = Integer.MAX_VALUE; for (int i = nums.length - 1; i \u003e= 0; i--) { if (nums[i] \u003e next) { int x = (nums[i] + next - 1) / next; // 向上取整 ans += x - 1; next = nums[i] / x; } else { next = nums[i]; } } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:5:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#将数组排序的最少替换次数"},{"categories":["力扣"],"content":" 总结 哈希表 遍历 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:6:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#总结"},{"categories":["力扣"],"content":"1545. 找出第 N 个二进制字符串中的第 K 位 class Solution { public char findKthBit(int n, int k) { if (k == 1) return '0'; int mid = 1 \u003c\u003c (n - 1); // 找中点 if (k == mid) return '1'; else if (k \u003c mid) return findKthBit(n - 1, k); // 顺序找左边 else return (char) ('0' + '1' - findKthBit(n - 1, mid * 2 - k)); // 逆序找右边，且翻转 } } ","date":"2022-08-06","objectID":"/posts/%E5%8A%9B%E6%89%A3-1545-%E6%89%BE%E5%87%BA%E7%AC%ACn%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%BD%8D/:0:0","series":null,"tags":["力扣","递归"],"title":"力扣 1545 找出第N个二进制字符串中的第K位","uri":"/posts/%E5%8A%9B%E6%89%A3-1545-%E6%89%BE%E5%87%BA%E7%AC%ACn%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%BD%8D/#"},{"categories":["算法"],"content":" 1.首尾指针 要求数组有序。 两数之和： 167. 两数之和 II - 输入有序数组 class Solution { public int[] twoSum(int[] numbers, int target) { int l = 0; int r = numbers.length - 1; while (l \u003c r) { int sum = numbers[l] + numbers[r]; if (sum \u003e target) r--; else if (sum \u003c target) l++; else return new int[] { l + 1, r + 1 }; } return null; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/:1:0","series":null,"tags":["算法","多指针"],"title":"算法-多指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/#1首尾指针"},{"categories":["算法"],"content":" 2.快慢指针检测链表中的环： ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/:2:0","series":null,"tags":["算法","多指针"],"title":"算法-多指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/#2快慢指针"},{"categories":["算法"],"content":" 3.二路归并 ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/:3:0","series":null,"tags":["算法","多指针"],"title":"算法-多指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/#3二路归并"},{"categories":["算法"],"content":" 3.三指针荷兰国旗问题： 75. 颜色分类 class Solution { public void sortColors(int[] nums) { int l = 0; int m = 0; int r = nums.length - 1; while (m \u003c= r) { if (nums[m] == 0) { swap(nums, l, m); l++; m++; } else if (nums[m] == 1) { m++; } else if (nums[m] == 2) { swap(nums, m, r); r--; } } } static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } 三向切分快排： static void quickSort(int[] arr, int low, int high) { // [low, high] if (low \u003e= high) return; // 1. 随机选取 pivot int pivotIndex = low + (int) (Math.random() * (high - low + 1)); // 2. partition int pivot = arr[pivotIndex]; int l = low; int m = low; int r = high; while (m \u003c= r) { if (arr[m] \u003c pivot) { swap(arr, l, m); l++; m++; } else if (arr[m] \u003e pivot) { swap(arr, m, r); r--; } else { m++; } } // 3. 递归子数组 quickSort(arr, low, l - 1); quickSort(arr, r + 1, high); } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/:4:0","series":null,"tags":["算法","多指针"],"title":"算法-多指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/#3三指针"},{"categories":["算法"],"content":" 4. k路归并","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/:5:0","series":null,"tags":["算法","多指针"],"title":"算法-多指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%8C%87%E9%92%88/#4-k路归并"},{"categories":["力扣"],"content":"15. 三数之和 ","date":"2022-08-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","series":null,"tags":["力扣","双指针"],"title":"力扣 0015 三数之和","uri":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/#"},{"categories":["力扣"],"content":" 方法一：排序+双指针+跳过重复项 class Solution { public List\u003cList\u003cInteger\u003e\u003e threeSum(int[] nums) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i \u003c n; i++) { if (nums[i] \u003e 0) break; // 保证第一个数不重复 if (i \u003e 0 \u0026\u0026 nums[i - 1] == nums[i]) continue; for (int j = i + 1, k = n - 1; j \u003c k;) { // 双指针 int sum = nums[i] + nums[j] + nums[k]; if (sum == 0) { ans.add(List.of(nums[i], nums[j], nums[k])); j++; k--; // 保证第二和第三个数不重复 while (j \u003c k \u0026\u0026 nums[j] == nums[j - 1] \u0026\u0026 nums[k] == nums[k + 1]) { j++; k--; } } else if (sum \u003e 0) k--; else j++; } } return ans; } } ","date":"2022-08-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","series":null,"tags":["力扣","双指针"],"title":"力扣 0015 三数之和","uri":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/#方法一排序双指针跳过重复项"},{"categories":["力扣"],"content":" 方法二：排序+双指针+哈希表去重 时间复杂度更高 class Solution { public List\u003cList\u003cInteger\u003e\u003e threeSum(int[] nums) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); HashSet\u003cList\u003cInteger\u003e\u003e set = new HashSet\u003c\u003e(); Arrays.sort(nums); int n = nums.length; for (int i = 0; i \u003c n; i++) { for (int j = i + 1, k = n - 1; j \u003c k;) { int sum = nums[i] + nums[j] + nums[k]; List\u003cInteger\u003e tuple = List.of(nums[i], nums[j], nums[k]); if (sum == 0 \u0026\u0026 !set.contains(tuple)) { set.add(tuple); ans.add(tuple); j++; k--; } else if (sum \u003e 0) k--; else j++; } } return ans; } } ","date":"2022-08-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:2:0","series":null,"tags":["力扣","双指针"],"title":"力扣 0015 三数之和","uri":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/#方法二排序双指针哈希表去重"},{"categories":["力扣"],"content":"第 304 场周赛 ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:0:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#"},{"categories":["力扣"],"content":" 复盘 全国排名：596 / 7372（8.08%） 全球排名：1246 / 26877（4.64%） 分数变化：2095 + 17 = 2112 完成时间：1h18s（+5m） 题目1 难度： 顺序：1 用时：5m27s 错误：0 题目2 难度： 顺序：4 用时：6m41s 错误：0 题目3 难度： 顺序：2 用时：31m22s 错误：0 题目4 难度： 顺序：3 用时：11m48s 错误：1 WA：把vis误用为onPath ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:1:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#复盘"},{"categories":["力扣"],"content":" 使数组中所有元素都等于零6132. 使数组中所有元素都等于零 class Solution { public int minimumOperations(int[] nums) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); // 去重 for (int x : nums) set.add(x); int ans = 0; int sub = 0; for (int x : set) { if (x == 0) continue; x -= sub; ans++; sub += x; } return ans; } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:2:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#使数组中所有元素都等于零"},{"categories":["力扣"],"content":" 分组的最大数量6133. 分组的最大数量 class Solution { public int maximumGroups(int[] grades) { int n = grades.length; int ans = (int) Math.sqrt(n * 2); if (ans * (ans + 1) / 2 \u003e n) ans--; return ans; } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:3:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#分组的最大数量"},{"categories":["力扣"],"content":" 找到离给定两个节点最近的节点6134. 找到离给定两个节点最近的节点 class Solution { int[] edges; int[] dis; boolean[] vis; int ans = -1; int minDis = Integer.MAX_VALUE; public int closestMeetingNode(int[] edges, int node1, int node2) { this.edges = edges; int n = edges.length; dis = new int[n]; Arrays.fill(dis, -1); vis = new boolean[n]; dfs1(node1, 0); vis = new boolean[n]; dfs2(node2, 0); return ans; } void dfs1(int node, int step) { vis[node] = true; dis[node] = step; if (edges[node] != -1 \u0026\u0026 !vis[edges[node]]) dfs1(edges[node], step + 1); } void dfs2(int node, int step) { vis[node] = true; if (dis[node] != -1) { int d = Math.max(step, dis[node]); if (d \u003c minDis) { minDis = d; ans = node; } else if (d == minDis \u0026\u0026 ans \u003e node) { ans = node; } } if (edges[node] != -1 \u0026\u0026 !vis[edges[node]]) dfs2(edges[node], step + 1); } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:4:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#找到离给定两个节点最近的节点"},{"categories":["力扣"],"content":" 图中的最长环6135. 图中的最长环 class Solution { int[] edges; int[] vis; boolean[] onPath; int ans = -1; public int longestCycle(int[] edges) { this.edges = edges; int n = edges.length; vis = new int[n]; onPath = new boolean[n]; for (int i = 0; i \u003c n; i++) if (vis[i] == 0) dfs(i, 1); return ans; } void dfs(int node, int step) { onPath[node] = true; vis[node] = step; if (edges[node] != -1) { if (onPath[edges[node]]) ans = Math.max(ans, step - vis[edges[node]] + 1); if (vis[edges[node]] == 0) dfs(edges[node], step + 1); } onPath[node] = false; } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:5:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#图中的最长环"},{"categories":["力扣"],"content":" 总结 考察图论算法：环检测。 变相考察 DFS 和 BFS。 ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:6:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#总结"},{"categories":[],"content":" C++","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#c"},{"categories":[],"content":" Java","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:0","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#java"},{"categories":[],"content":" I/O读取数据 Scanner in = new Scanner(System.in); while (in.hasNext()) { String s = in.next(); int i = in.nextInt(); long l = in.nextLong(); double d = in.nextDouble(); char c = in.nextChar(); byte b = in.nextByte(); } 打印数据 System.out.println(); System.out.print(); System.out.printf(\"%.2f\", Math.PI); // 3.14 重定向 // 从 input.txt 读取输入并输出到 output.txt 中 java Main \u003c input.txt \u003e output.txt # 将 Main1 的输出作为 Main2 的输入 java Main1 | java Main2 命令行参数 class Main { public static void main(String[] args) { // java Main 1 two String a = args[0]; // \"1\" String b = args[1]; // \"two\" } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:1","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#io"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#字符串"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#构造方法"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#常用方法"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#比较"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查找"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#替换"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#分割合并"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#处理"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#子串"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#类型转换"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#字符判断"},{"categories":[],"content":" 数组 // 一维数组 int[] arr1 = new int[3]; int[] arr2 = { 1, 2, 3 }; // 二维数组 int[][] arr3 = new int[2][2]; int[][] arr4 = { { 1, 2 }, { 3, 4 } }; // 对象数组 User[] arr5 = new User[3]; for (int i = 0; i \u003c 3; i++) arr5[i] = new User(); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:3","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#数组"},{"categories":[],"content":" 变长数组 List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:4","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#变长数组"},{"categories":[],"content":" 链表 // 双向链表 List\u003cInteger\u003e list = new LinkedList\u003c\u003e(); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:5","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#链表"},{"categories":[],"content":" 栈 // 数组实现 Deque\u003cInteger\u003e stack1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque\u003cInteger\u003e stack2 = new LinkedList\u003c\u003e(); API 1: boolean offerLast(E e)：向栈顶添加元素。 E pollLast()：从栈顶删除元素并返回该元素，若栈为空返回 null。 E peekLast()：返回栈顶元素，若栈为空返回 null。 API 2: void push(E e)：向栈顶添加元素。 E pop()：从栈顶删除元素并返回该元素，若栈为空抛出java.util.NoSuchElementException。 E peek()：返回栈顶元素，若栈为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:6","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#栈"},{"categories":[],"content":" 队列 普通队列 // 数组实现 Queue\u003cInteger\u003e queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Queue\u003cInteger\u003e queue2 = new LinkedList\u003c\u003e(); boolean offer(E e)：添加元素到队尾。 E poll()：从队头删除元素并返回该元素，若队列为空返回 null。 E peek()：返回队头元素，若队列为空返回 null。 int size()：返回队列中元素数量。 boolean isEmpty()：返回队列是否为空。 // 遍历，不支持增强 for 循环和迭代器。 while (!queue.isEmpty()) { int e = queue.poll(); } 双端队列 // 数组实现 Deque\u003cInteger\u003e queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque\u003cInteger\u003e queue2 = new LinkedList\u003c\u003e(); boolean offerFirst(E e)：队首添加元素。 boolean offerLast(E e)：队尾添加元素。 E pollFirst()：删除队首元素并返回，若队列为空返回 null。 E pollLast()：删除队尾元素并返回，若队列为空返回 null。 E peekFirst()：返回队首元素，若队列为空返回 null。 E peekLast()：返回队尾元素，若队列为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:7","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#队列"},{"categories":[],"content":" 队列 普通队列 // 数组实现 Queue queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Queue queue2 = new LinkedList\u003c\u003e(); boolean offer(E e)：添加元素到队尾。 E poll()：从队头删除元素并返回该元素，若队列为空返回 null。 E peek()：返回队头元素，若队列为空返回 null。 int size()：返回队列中元素数量。 boolean isEmpty()：返回队列是否为空。 // 遍历，不支持增强 for 循环和迭代器。 while (!queue.isEmpty()) { int e = queue.poll(); } 双端队列 // 数组实现 Deque queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque queue2 = new LinkedList\u003c\u003e(); boolean offerFirst(E e)：队首添加元素。 boolean offerLast(E e)：队尾添加元素。 E pollFirst()：删除队首元素并返回，若队列为空返回 null。 E pollLast()：删除队尾元素并返回，若队列为空返回 null。 E peekFirst()：返回队首元素，若队列为空返回 null。 E peekLast()：返回队尾元素，若队列为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:7","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#普通队列"},{"categories":[],"content":" 队列 普通队列 // 数组实现 Queue queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Queue queue2 = new LinkedList\u003c\u003e(); boolean offer(E e)：添加元素到队尾。 E poll()：从队头删除元素并返回该元素，若队列为空返回 null。 E peek()：返回队头元素，若队列为空返回 null。 int size()：返回队列中元素数量。 boolean isEmpty()：返回队列是否为空。 // 遍历，不支持增强 for 循环和迭代器。 while (!queue.isEmpty()) { int e = queue.poll(); } 双端队列 // 数组实现 Deque queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque queue2 = new LinkedList\u003c\u003e(); boolean offerFirst(E e)：队首添加元素。 boolean offerLast(E e)：队尾添加元素。 E pollFirst()：删除队首元素并返回，若队列为空返回 null。 E pollLast()：删除队尾元素并返回，若队列为空返回 null。 E peekFirst()：返回队首元素，若队列为空返回 null。 E peekLast()：返回队尾元素，若队列为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:7","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#双端队列"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map\u003cString, Integer\u003e map1 = new HashMap\u003c\u003e(); Map\u003cString,Integer\u003e map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#哈希表"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#无序哈希表"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#添加"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#删除"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#排序"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#有序哈希表"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化-1"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询-1"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet\u003cInteger\u003e set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet\u003cInteger\u003e set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator\u003cE\u003e descendingIterator() NavigableSet\u003cE\u003e descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#集合"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#无序集合"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化-2"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#添加-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#删除-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询-2"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历-2"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#排序-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#有序集合"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化-3"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询-3"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历-3"},{"categories":[],"content":" 优先队列","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:10","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#优先队列"},{"categories":[],"content":" 常量 Integer.MAX_VALUE == 2147483647; Integer.MIN_VALUE == -2147483648; Double.POSITIVE_INFINITY; Double.NEGATIVE_INFINITY; ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:11","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#常量"},{"categories":[],"content":" 类型转换 // String 转 int，不能转换抛出 java.lang.NumberFormatException int i = Integer.parseInt(\"123\"); // int 转 二进制字符串 String s = Integer.toBinaryString(123); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:12","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#类型转换-1"},{"categories":[],"content":" 算法模板","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:0","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#算法模板"},{"categories":[],"content":" 数据规模","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:1","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#数据规模"},{"categories":[],"content":" getMin 功能的栈 两个栈：一个存元素，一个存最小值。最小值可以同步存，也可以不同步。 一个栈：捆绑元素和最小值。 class MinStack { Deque\u003cInteger\u003e stackData = new ArrayDeque\u003c\u003e(); Deque\u003cInteger\u003e stackMin = new ArrayDeque\u003c\u003e(); public void push(int e) { stackData.push(e); if (stackMin.isEmpty()) stackMin.push(e); else stackMin.push(Math.min(e, getMin())); } public int pop() { if (stackData.isEmpty()) throw new Exception(\"栈中没有元素\"); stackMin.pop(); return stackData.pop(); } public int peek() { if (stackData.isEmpty()) throw new Exception(\"栈中没有元素\"); return stackData.peek(); } public int getMin() { if (stackData.isEmpty()) throw new Exception(\"栈中没有元素\"); return stackMin.peek(); } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#getmin-功能的栈"},{"categories":[],"content":" 两个栈组成队列 class TwoStackQueue { Deque\u003cInteger\u003e stackIn = new ArrayDeque\u003c\u003e(); Deque\u003cInteger\u003e stackOut = new ArrayDeque\u003c\u003e(); public void offer(int e) { stackIn.push(e); } public int poll() { check(); return stackOut.pop(); } public int peek() { check(); return stackOut.peek(); } private void check() { if (stackOut.isEmpty() \u0026\u0026 stackIn.isEmpty()) throw new Exception(\"队列中没有元素\"); if (stackOut.isEmpty()) while (!stackIn.isEmpty()) stackOut.push(stackIn.pop()); } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:3","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#两个栈组成队列"},{"categories":[],"content":" 用递归函数和栈逆序一个栈 static void reverseStack(Deque\u003cInteger\u003e stack) { if (stack.isEmpty()) return; int bottom = getAndRemoveBottom(stack); reverseStack(stack); stack.push(bottom); } static int getAndRemoveBottom(Deque\u003cInteger\u003e stack) { int top = stack.poll(); if (stack.isEmpty()) return top; else { int bottom = getAndRemoveBottom(stack); stack.push(top); return bottom; } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:4","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#用递归函数和栈逆序一个栈"},{"categories":[],"content":" 猫狗队列 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:5","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#猫狗队列"},{"categories":["操作系统"],"content":"操作系统（Operating System, OS）是硬件和其它软件沟通的桥梁。 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:0:0","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#"},{"categories":["操作系统"],"content":" 第1章 计算机系统概述","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:0","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#第1章-计算机系统概述"},{"categories":["操作系统"],"content":" 1.1 操作系统的基本概念 1.1.1 操作系统的概念 控制和管理整个计算机系统的硬件与软件资源。 合理地组织、调度计算机的工作与资源的分配。 为用户和其他软件提供方便的接口与环境。 计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 并发（Concurrence）：两个或多个事件在同一时间间隔内发生。 并发是同一时间间隔，并行（Parallel）是同一时间。 单处理机通过分时实现并发，微观上交替执行。 共享（Sharing）：系统中的资源可供内存中多个并发执行的进程共同使用。 互斥共享：一段时间内只允许一个进程访问该资源。如：打印机、磁带机。 同时访问：一段时间内允许多个进程“同时”访问该资源，宏观同时访问，微观交替访问。如：磁盘设备。 虚拟（Virtual）：把一个物理上的实体变为若干逻辑上的对应物。 按物理实体分类： 虚拟处理器：利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CPU。 虚拟存储器：将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。 虚拟设备：将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的共享设备。 按时空分类： 时分复用：虚拟处理器。 空分复用：虚拟存储器。 异步（Asynchronism）：多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。 1.1.3 操作系统两个最基本的特征 并发和共享，两者之间互为存在的条件。 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。 1.1.4 操作系统的功能 处理机管理： 处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。 进程管理主要包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。 存储器管理： 给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。 主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。 文件管理： 计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。 主要包括文件存储空间的管理、目录管理及文件读写管理和保护等。 设备管理： 完成用户的 I/O 请求，方便用户使用及提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。 1.1.5 操作系统提供的用户接口 命令接口：用户利用命令接口来组织和控制作业的执行。 联机命令接口/交互式命令接口：适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能之后，控制权转回控制台或终端，此时用户又可输入下一条命令。 脱机命令接口/批处理命令接口：适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。 程序接口：编程人员可以使用程序接口来请求操作系统服务。 程序接口由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。 当前最为流行的是图形用户界面（GUI），即图形接口。图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#11-操作系统的基本概念"},{"categories":["操作系统"],"content":" 1.1 操作系统的基本概念 1.1.1 操作系统的概念 控制和管理整个计算机系统的硬件与软件资源。 合理地组织、调度计算机的工作与资源的分配。 为用户和其他软件提供方便的接口与环境。 计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 并发（Concurrence）：两个或多个事件在同一时间间隔内发生。 并发是同一时间间隔，并行（Parallel）是同一时间。 单处理机通过分时实现并发，微观上交替执行。 共享（Sharing）：系统中的资源可供内存中多个并发执行的进程共同使用。 互斥共享：一段时间内只允许一个进程访问该资源。如：打印机、磁带机。 同时访问：一段时间内允许多个进程“同时”访问该资源，宏观同时访问，微观交替访问。如：磁盘设备。 虚拟（Virtual）：把一个物理上的实体变为若干逻辑上的对应物。 按物理实体分类： 虚拟处理器：利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CPU。 虚拟存储器：将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。 虚拟设备：将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的共享设备。 按时空分类： 时分复用：虚拟处理器。 空分复用：虚拟存储器。 异步（Asynchronism）：多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。 1.1.3 操作系统两个最基本的特征 并发和共享，两者之间互为存在的条件。 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。 1.1.4 操作系统的功能 处理机管理： 处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。 进程管理主要包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。 存储器管理： 给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。 主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。 文件管理： 计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。 主要包括文件存储空间的管理、目录管理及文件读写管理和保护等。 设备管理： 完成用户的 I/O 请求，方便用户使用及提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。 1.1.5 操作系统提供的用户接口 命令接口：用户利用命令接口来组织和控制作业的执行。 联机命令接口/交互式命令接口：适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能之后，控制权转回控制台或终端，此时用户又可输入下一条命令。 脱机命令接口/批处理命令接口：适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。 程序接口：编程人员可以使用程序接口来请求操作系统服务。 程序接口由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。 当前最为流行的是图形用户界面（GUI），即图形接口。图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#111-操作系统的概念"},{"categories":["操作系统"],"content":" 1.1 操作系统的基本概念 1.1.1 操作系统的概念 控制和管理整个计算机系统的硬件与软件资源。 合理地组织、调度计算机的工作与资源的分配。 为用户和其他软件提供方便的接口与环境。 计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 并发（Concurrence）：两个或多个事件在同一时间间隔内发生。 并发是同一时间间隔，并行（Parallel）是同一时间。 单处理机通过分时实现并发，微观上交替执行。 共享（Sharing）：系统中的资源可供内存中多个并发执行的进程共同使用。 互斥共享：一段时间内只允许一个进程访问该资源。如：打印机、磁带机。 同时访问：一段时间内允许多个进程“同时”访问该资源，宏观同时访问，微观交替访问。如：磁盘设备。 虚拟（Virtual）：把一个物理上的实体变为若干逻辑上的对应物。 按物理实体分类： 虚拟处理器：利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CPU。 虚拟存储器：将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。 虚拟设备：将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的共享设备。 按时空分类： 时分复用：虚拟处理器。 空分复用：虚拟存储器。 异步（Asynchronism）：多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。 1.1.3 操作系统两个最基本的特征 并发和共享，两者之间互为存在的条件。 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。 1.1.4 操作系统的功能 处理机管理： 处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。 进程管理主要包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。 存储器管理： 给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。 主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。 文件管理： 计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。 主要包括文件存储空间的管理、目录管理及文件读写管理和保护等。 设备管理： 完成用户的 I/O 请求，方便用户使用及提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。 1.1.5 操作系统提供的用户接口 命令接口：用户利用命令接口来组织和控制作业的执行。 联机命令接口/交互式命令接口：适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能之后，控制权转回控制台或终端，此时用户又可输入下一条命令。 脱机命令接口/批处理命令接口：适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。 程序接口：编程人员可以使用程序接口来请求操作系统服务。 程序接口由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。 当前最为流行的是图形用户界面（GUI），即图形接口。图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#112-操作系统的特征"},{"categories":["操作系统"],"content":" 1.1 操作系统的基本概念 1.1.1 操作系统的概念 控制和管理整个计算机系统的硬件与软件资源。 合理地组织、调度计算机的工作与资源的分配。 为用户和其他软件提供方便的接口与环境。 计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 并发（Concurrence）：两个或多个事件在同一时间间隔内发生。 并发是同一时间间隔，并行（Parallel）是同一时间。 单处理机通过分时实现并发，微观上交替执行。 共享（Sharing）：系统中的资源可供内存中多个并发执行的进程共同使用。 互斥共享：一段时间内只允许一个进程访问该资源。如：打印机、磁带机。 同时访问：一段时间内允许多个进程“同时”访问该资源，宏观同时访问，微观交替访问。如：磁盘设备。 虚拟（Virtual）：把一个物理上的实体变为若干逻辑上的对应物。 按物理实体分类： 虚拟处理器：利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CPU。 虚拟存储器：将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。 虚拟设备：将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的共享设备。 按时空分类： 时分复用：虚拟处理器。 空分复用：虚拟存储器。 异步（Asynchronism）：多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。 1.1.3 操作系统两个最基本的特征 并发和共享，两者之间互为存在的条件。 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。 1.1.4 操作系统的功能 处理机管理： 处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。 进程管理主要包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。 存储器管理： 给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。 主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。 文件管理： 计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。 主要包括文件存储空间的管理、目录管理及文件读写管理和保护等。 设备管理： 完成用户的 I/O 请求，方便用户使用及提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。 1.1.5 操作系统提供的用户接口 命令接口：用户利用命令接口来组织和控制作业的执行。 联机命令接口/交互式命令接口：适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能之后，控制权转回控制台或终端，此时用户又可输入下一条命令。 脱机命令接口/批处理命令接口：适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。 程序接口：编程人员可以使用程序接口来请求操作系统服务。 程序接口由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。 当前最为流行的是图形用户界面（GUI），即图形接口。图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#113-操作系统两个最基本的特征"},{"categories":["操作系统"],"content":" 1.1 操作系统的基本概念 1.1.1 操作系统的概念 控制和管理整个计算机系统的硬件与软件资源。 合理地组织、调度计算机的工作与资源的分配。 为用户和其他软件提供方便的接口与环境。 计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 并发（Concurrence）：两个或多个事件在同一时间间隔内发生。 并发是同一时间间隔，并行（Parallel）是同一时间。 单处理机通过分时实现并发，微观上交替执行。 共享（Sharing）：系统中的资源可供内存中多个并发执行的进程共同使用。 互斥共享：一段时间内只允许一个进程访问该资源。如：打印机、磁带机。 同时访问：一段时间内允许多个进程“同时”访问该资源，宏观同时访问，微观交替访问。如：磁盘设备。 虚拟（Virtual）：把一个物理上的实体变为若干逻辑上的对应物。 按物理实体分类： 虚拟处理器：利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CPU。 虚拟存储器：将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。 虚拟设备：将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的共享设备。 按时空分类： 时分复用：虚拟处理器。 空分复用：虚拟存储器。 异步（Asynchronism）：多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。 1.1.3 操作系统两个最基本的特征 并发和共享，两者之间互为存在的条件。 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。 1.1.4 操作系统的功能 处理机管理： 处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。 进程管理主要包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。 存储器管理： 给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。 主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。 文件管理： 计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。 主要包括文件存储空间的管理、目录管理及文件读写管理和保护等。 设备管理： 完成用户的 I/O 请求，方便用户使用及提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。 1.1.5 操作系统提供的用户接口 命令接口：用户利用命令接口来组织和控制作业的执行。 联机命令接口/交互式命令接口：适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能之后，控制权转回控制台或终端，此时用户又可输入下一条命令。 脱机命令接口/批处理命令接口：适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。 程序接口：编程人员可以使用程序接口来请求操作系统服务。 程序接口由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。 当前最为流行的是图形用户界面（GUI），即图形接口。图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#114-操作系统的功能"},{"categories":["操作系统"],"content":" 1.1 操作系统的基本概念 1.1.1 操作系统的概念 控制和管理整个计算机系统的硬件与软件资源。 合理地组织、调度计算机的工作与资源的分配。 为用户和其他软件提供方便的接口与环境。 计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 并发（Concurrence）：两个或多个事件在同一时间间隔内发生。 并发是同一时间间隔，并行（Parallel）是同一时间。 单处理机通过分时实现并发，微观上交替执行。 共享（Sharing）：系统中的资源可供内存中多个并发执行的进程共同使用。 互斥共享：一段时间内只允许一个进程访问该资源。如：打印机、磁带机。 同时访问：一段时间内允许多个进程“同时”访问该资源，宏观同时访问，微观交替访问。如：磁盘设备。 虚拟（Virtual）：把一个物理上的实体变为若干逻辑上的对应物。 按物理实体分类： 虚拟处理器：利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CPU。 虚拟存储器：将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。 虚拟设备：将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的共享设备。 按时空分类： 时分复用：虚拟处理器。 空分复用：虚拟存储器。 异步（Asynchronism）：多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。 1.1.3 操作系统两个最基本的特征 并发和共享，两者之间互为存在的条件。 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。 1.1.4 操作系统的功能 处理机管理： 处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。 进程管理主要包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。 存储器管理： 给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。 主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。 文件管理： 计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。 主要包括文件存储空间的管理、目录管理及文件读写管理和保护等。 设备管理： 完成用户的 I/O 请求，方便用户使用及提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。 1.1.5 操作系统提供的用户接口 命令接口：用户利用命令接口来组织和控制作业的执行。 联机命令接口/交互式命令接口：适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能之后，控制权转回控制台或终端，此时用户又可输入下一条命令。 脱机命令接口/批处理命令接口：适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。 程序接口：编程人员可以使用程序接口来请求操作系统服务。 程序接口由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。 当前最为流行的是图形用户界面（GUI），即图形接口。图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#115-操作系统提供的用户接口"},{"categories":["操作系统"],"content":" 1.2 操作系统发展历程 1.2.1 手工操作阶段（无操作系统）缺点： 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 CPU 等待手工操作，CPU 的利用不充分。 1.2.2 批处理阶段（操作系统开始出现）单道批处理系统 自动性：作业自动执行。 顺序性：作业按顺序执行。 单道性：内存中仅有一个作业在执行。 优点：减少了人工参与。 缺点：当程序进行 I/O 请求时，CPU 便处于等待状态，CPU 的利用率低。 多道批处理系统： 多道性：内存中同时存放多个作业。 宏观并行：总体上看内存中每个作业都在运行。 微观串行：每个作业轮流占用 CPU，交替执行，同一时刻只有一个作业在运行。 需解决 CPU 、存储器和外部设备的分配问题。 优点：资源利用率高，系统吞吐量大。 缺点：用户响应不及时，无交互性。 1.2.3 分时操作系统分时技术 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。 若某个作业在分配给它的时间片内不能完成，则该作业暂时停止运行，把处理器让给其他作业使用，等待下次获取到 CPU 时间片时再继续运行。 由于计算机速度很快，时间片很小，作业运行轮转得也很快，因此用户感觉就像是自己独占一台计算机。 分时系统 同时性：多个用户通过终端同时共享一台计算机。 交互性：用户通过终端与计算机进行交互。 独立性：用户之间互不影响。 及时性：系统响应及时，用户等待时间短。 1.2.4 实时操作系统任务具有优先级，可以抢占 CPU 时间片优先执行。 硬实时系统：在规定时间内必须执行。如：飞行器控制系统。 软实时系统：尽量在规定时间内执行。如：订票系统。 1.2.5 网络操作系统和分布式计算机系统 网络操作系统：网络中多个计算机结合，实现资源的共享和计算机之间的通信。 分布式计算机系统：多台计算机组成的系统。每台计算机地位平等、资源共享、并行工作、协同完成。 分布性 并行性 1.2.6 个人计算机操作系统目前最广泛使用。 Windows Linux macOS Android iOS ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#12-操作系统发展历程"},{"categories":["操作系统"],"content":" 1.2 操作系统发展历程 1.2.1 手工操作阶段（无操作系统）缺点： 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 CPU 等待手工操作，CPU 的利用不充分。 1.2.2 批处理阶段（操作系统开始出现）单道批处理系统 自动性：作业自动执行。 顺序性：作业按顺序执行。 单道性：内存中仅有一个作业在执行。 优点：减少了人工参与。 缺点：当程序进行 I/O 请求时，CPU 便处于等待状态，CPU 的利用率低。 多道批处理系统： 多道性：内存中同时存放多个作业。 宏观并行：总体上看内存中每个作业都在运行。 微观串行：每个作业轮流占用 CPU，交替执行，同一时刻只有一个作业在运行。 需解决 CPU 、存储器和外部设备的分配问题。 优点：资源利用率高，系统吞吐量大。 缺点：用户响应不及时，无交互性。 1.2.3 分时操作系统分时技术 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。 若某个作业在分配给它的时间片内不能完成，则该作业暂时停止运行，把处理器让给其他作业使用，等待下次获取到 CPU 时间片时再继续运行。 由于计算机速度很快，时间片很小，作业运行轮转得也很快，因此用户感觉就像是自己独占一台计算机。 分时系统 同时性：多个用户通过终端同时共享一台计算机。 交互性：用户通过终端与计算机进行交互。 独立性：用户之间互不影响。 及时性：系统响应及时，用户等待时间短。 1.2.4 实时操作系统任务具有优先级，可以抢占 CPU 时间片优先执行。 硬实时系统：在规定时间内必须执行。如：飞行器控制系统。 软实时系统：尽量在规定时间内执行。如：订票系统。 1.2.5 网络操作系统和分布式计算机系统 网络操作系统：网络中多个计算机结合，实现资源的共享和计算机之间的通信。 分布式计算机系统：多台计算机组成的系统。每台计算机地位平等、资源共享、并行工作、协同完成。 分布性 并行性 1.2.6 个人计算机操作系统目前最广泛使用。 Windows Linux macOS Android iOS ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#121-手工操作阶段无操作系统"},{"categories":["操作系统"],"content":" 1.2 操作系统发展历程 1.2.1 手工操作阶段（无操作系统）缺点： 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 CPU 等待手工操作，CPU 的利用不充分。 1.2.2 批处理阶段（操作系统开始出现）单道批处理系统 自动性：作业自动执行。 顺序性：作业按顺序执行。 单道性：内存中仅有一个作业在执行。 优点：减少了人工参与。 缺点：当程序进行 I/O 请求时，CPU 便处于等待状态，CPU 的利用率低。 多道批处理系统： 多道性：内存中同时存放多个作业。 宏观并行：总体上看内存中每个作业都在运行。 微观串行：每个作业轮流占用 CPU，交替执行，同一时刻只有一个作业在运行。 需解决 CPU 、存储器和外部设备的分配问题。 优点：资源利用率高，系统吞吐量大。 缺点：用户响应不及时，无交互性。 1.2.3 分时操作系统分时技术 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。 若某个作业在分配给它的时间片内不能完成，则该作业暂时停止运行，把处理器让给其他作业使用，等待下次获取到 CPU 时间片时再继续运行。 由于计算机速度很快，时间片很小，作业运行轮转得也很快，因此用户感觉就像是自己独占一台计算机。 分时系统 同时性：多个用户通过终端同时共享一台计算机。 交互性：用户通过终端与计算机进行交互。 独立性：用户之间互不影响。 及时性：系统响应及时，用户等待时间短。 1.2.4 实时操作系统任务具有优先级，可以抢占 CPU 时间片优先执行。 硬实时系统：在规定时间内必须执行。如：飞行器控制系统。 软实时系统：尽量在规定时间内执行。如：订票系统。 1.2.5 网络操作系统和分布式计算机系统 网络操作系统：网络中多个计算机结合，实现资源的共享和计算机之间的通信。 分布式计算机系统：多台计算机组成的系统。每台计算机地位平等、资源共享、并行工作、协同完成。 分布性 并行性 1.2.6 个人计算机操作系统目前最广泛使用。 Windows Linux macOS Android iOS ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#122-批处理阶段操作系统开始出现"},{"categories":["操作系统"],"content":" 1.2 操作系统发展历程 1.2.1 手工操作阶段（无操作系统）缺点： 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 CPU 等待手工操作，CPU 的利用不充分。 1.2.2 批处理阶段（操作系统开始出现）单道批处理系统 自动性：作业自动执行。 顺序性：作业按顺序执行。 单道性：内存中仅有一个作业在执行。 优点：减少了人工参与。 缺点：当程序进行 I/O 请求时，CPU 便处于等待状态，CPU 的利用率低。 多道批处理系统： 多道性：内存中同时存放多个作业。 宏观并行：总体上看内存中每个作业都在运行。 微观串行：每个作业轮流占用 CPU，交替执行，同一时刻只有一个作业在运行。 需解决 CPU 、存储器和外部设备的分配问题。 优点：资源利用率高，系统吞吐量大。 缺点：用户响应不及时，无交互性。 1.2.3 分时操作系统分时技术 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。 若某个作业在分配给它的时间片内不能完成，则该作业暂时停止运行，把处理器让给其他作业使用，等待下次获取到 CPU 时间片时再继续运行。 由于计算机速度很快，时间片很小，作业运行轮转得也很快，因此用户感觉就像是自己独占一台计算机。 分时系统 同时性：多个用户通过终端同时共享一台计算机。 交互性：用户通过终端与计算机进行交互。 独立性：用户之间互不影响。 及时性：系统响应及时，用户等待时间短。 1.2.4 实时操作系统任务具有优先级，可以抢占 CPU 时间片优先执行。 硬实时系统：在规定时间内必须执行。如：飞行器控制系统。 软实时系统：尽量在规定时间内执行。如：订票系统。 1.2.5 网络操作系统和分布式计算机系统 网络操作系统：网络中多个计算机结合，实现资源的共享和计算机之间的通信。 分布式计算机系统：多台计算机组成的系统。每台计算机地位平等、资源共享、并行工作、协同完成。 分布性 并行性 1.2.6 个人计算机操作系统目前最广泛使用。 Windows Linux macOS Android iOS ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#123-分时操作系统"},{"categories":["操作系统"],"content":" 1.2 操作系统发展历程 1.2.1 手工操作阶段（无操作系统）缺点： 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 CPU 等待手工操作，CPU 的利用不充分。 1.2.2 批处理阶段（操作系统开始出现）单道批处理系统 自动性：作业自动执行。 顺序性：作业按顺序执行。 单道性：内存中仅有一个作业在执行。 优点：减少了人工参与。 缺点：当程序进行 I/O 请求时，CPU 便处于等待状态，CPU 的利用率低。 多道批处理系统： 多道性：内存中同时存放多个作业。 宏观并行：总体上看内存中每个作业都在运行。 微观串行：每个作业轮流占用 CPU，交替执行，同一时刻只有一个作业在运行。 需解决 CPU 、存储器和外部设备的分配问题。 优点：资源利用率高，系统吞吐量大。 缺点：用户响应不及时，无交互性。 1.2.3 分时操作系统分时技术 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。 若某个作业在分配给它的时间片内不能完成，则该作业暂时停止运行，把处理器让给其他作业使用，等待下次获取到 CPU 时间片时再继续运行。 由于计算机速度很快，时间片很小，作业运行轮转得也很快，因此用户感觉就像是自己独占一台计算机。 分时系统 同时性：多个用户通过终端同时共享一台计算机。 交互性：用户通过终端与计算机进行交互。 独立性：用户之间互不影响。 及时性：系统响应及时，用户等待时间短。 1.2.4 实时操作系统任务具有优先级，可以抢占 CPU 时间片优先执行。 硬实时系统：在规定时间内必须执行。如：飞行器控制系统。 软实时系统：尽量在规定时间内执行。如：订票系统。 1.2.5 网络操作系统和分布式计算机系统 网络操作系统：网络中多个计算机结合，实现资源的共享和计算机之间的通信。 分布式计算机系统：多台计算机组成的系统。每台计算机地位平等、资源共享、并行工作、协同完成。 分布性 并行性 1.2.6 个人计算机操作系统目前最广泛使用。 Windows Linux macOS Android iOS ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#124-实时操作系统"},{"categories":["操作系统"],"content":" 1.2 操作系统发展历程 1.2.1 手工操作阶段（无操作系统）缺点： 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 CPU 等待手工操作，CPU 的利用不充分。 1.2.2 批处理阶段（操作系统开始出现）单道批处理系统 自动性：作业自动执行。 顺序性：作业按顺序执行。 单道性：内存中仅有一个作业在执行。 优点：减少了人工参与。 缺点：当程序进行 I/O 请求时，CPU 便处于等待状态，CPU 的利用率低。 多道批处理系统： 多道性：内存中同时存放多个作业。 宏观并行：总体上看内存中每个作业都在运行。 微观串行：每个作业轮流占用 CPU，交替执行，同一时刻只有一个作业在运行。 需解决 CPU 、存储器和外部设备的分配问题。 优点：资源利用率高，系统吞吐量大。 缺点：用户响应不及时，无交互性。 1.2.3 分时操作系统分时技术 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。 若某个作业在分配给它的时间片内不能完成，则该作业暂时停止运行，把处理器让给其他作业使用，等待下次获取到 CPU 时间片时再继续运行。 由于计算机速度很快，时间片很小，作业运行轮转得也很快，因此用户感觉就像是自己独占一台计算机。 分时系统 同时性：多个用户通过终端同时共享一台计算机。 交互性：用户通过终端与计算机进行交互。 独立性：用户之间互不影响。 及时性：系统响应及时，用户等待时间短。 1.2.4 实时操作系统任务具有优先级，可以抢占 CPU 时间片优先执行。 硬实时系统：在规定时间内必须执行。如：飞行器控制系统。 软实时系统：尽量在规定时间内执行。如：订票系统。 1.2.5 网络操作系统和分布式计算机系统 网络操作系统：网络中多个计算机结合，实现资源的共享和计算机之间的通信。 分布式计算机系统：多台计算机组成的系统。每台计算机地位平等、资源共享、并行工作、协同完成。 分布性 并行性 1.2.6 个人计算机操作系统目前最广泛使用。 Windows Linux macOS Android iOS ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#125-网络操作系统和分布式计算机系统"},{"categories":["操作系统"],"content":" 1.2 操作系统发展历程 1.2.1 手工操作阶段（无操作系统）缺点： 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 CPU 等待手工操作，CPU 的利用不充分。 1.2.2 批处理阶段（操作系统开始出现）单道批处理系统 自动性：作业自动执行。 顺序性：作业按顺序执行。 单道性：内存中仅有一个作业在执行。 优点：减少了人工参与。 缺点：当程序进行 I/O 请求时，CPU 便处于等待状态，CPU 的利用率低。 多道批处理系统： 多道性：内存中同时存放多个作业。 宏观并行：总体上看内存中每个作业都在运行。 微观串行：每个作业轮流占用 CPU，交替执行，同一时刻只有一个作业在运行。 需解决 CPU 、存储器和外部设备的分配问题。 优点：资源利用率高，系统吞吐量大。 缺点：用户响应不及时，无交互性。 1.2.3 分时操作系统分时技术 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。 若某个作业在分配给它的时间片内不能完成，则该作业暂时停止运行，把处理器让给其他作业使用，等待下次获取到 CPU 时间片时再继续运行。 由于计算机速度很快，时间片很小，作业运行轮转得也很快，因此用户感觉就像是自己独占一台计算机。 分时系统 同时性：多个用户通过终端同时共享一台计算机。 交互性：用户通过终端与计算机进行交互。 独立性：用户之间互不影响。 及时性：系统响应及时，用户等待时间短。 1.2.4 实时操作系统任务具有优先级，可以抢占 CPU 时间片优先执行。 硬实时系统：在规定时间内必须执行。如：飞行器控制系统。 软实时系统：尽量在规定时间内执行。如：订票系统。 1.2.5 网络操作系统和分布式计算机系统 网络操作系统：网络中多个计算机结合，实现资源的共享和计算机之间的通信。 分布式计算机系统：多台计算机组成的系统。每台计算机地位平等、资源共享、并行工作、协同完成。 分布性 并行性 1.2.6 个人计算机操作系统目前最广泛使用。 Windows Linux macOS Android iOS ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#126-个人计算机操作系统"},{"categories":["操作系统"],"content":" 1.3 操作系统运行环境 1.3.1 处理器运行模式计算机程序分类 内核程序：执行特权指令的程序。特权指令如：I/O 指令、置中断指令、存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。 用户程序：不能执行特权指令，防止破坏系统。 CPU 运行模式 核心态/内核态/管态：可以执行特权指令。 如时钟管理、中断处理、设备驱动等。 如进程管理、存储器管理、设备管理等。 用户态/目态：不能执行特权指令。 内核功能 时钟管理 计时。提供用户时间。 进程切换。时间片轮转。 中断机制 键盘鼠标的输入、进程管理和调度、系统功能调用、设备驱动、文件访问等都需要中断。 在内核态中进行中断现场的保存与恢复，转移控制权到相关处理程序，减少中断等待时间，提高 CPU 利用率。 原语：关闭中断，运行程序，打开中断。 处于操作系统的最底层。 原子性。作为一个整体，要么全都完成，要么全都不完成。 运行快速，调用频繁。 系统控制的数据结构及处理 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#13-操作系统运行环境"},{"categories":["操作系统"],"content":" 1.3 操作系统运行环境 1.3.1 处理器运行模式计算机程序分类 内核程序：执行特权指令的程序。特权指令如：I/O 指令、置中断指令、存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。 用户程序：不能执行特权指令，防止破坏系统。 CPU 运行模式 核心态/内核态/管态：可以执行特权指令。 如时钟管理、中断处理、设备驱动等。 如进程管理、存储器管理、设备管理等。 用户态/目态：不能执行特权指令。 内核功能 时钟管理 计时。提供用户时间。 进程切换。时间片轮转。 中断机制 键盘鼠标的输入、进程管理和调度、系统功能调用、设备驱动、文件访问等都需要中断。 在内核态中进行中断现场的保存与恢复，转移控制权到相关处理程序，减少中断等待时间，提高 CPU 利用率。 原语：关闭中断，运行程序，打开中断。 处于操作系统的最底层。 原子性。作为一个整体，要么全都完成，要么全都不完成。 运行快速，调用频繁。 系统控制的数据结构及处理 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#131-处理器运行模式"},{"categories":["操作系统"],"content":" 第2章 进程管理","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:0","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#第2章-进程管理"},{"categories":["操作系统"],"content":" 2.1 进程与线程 2.1.1 操作系统之进程的定义、特征、组成、组织 2.1.2 操作系统之进程的状态及转换 2.1.3 操作系统之原语实现对进程的控制 2.1.4 进程之间的通信 2.1.5 操作系统之线程概念与多线程模型 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#21-进程与线程"},{"categories":["操作系统"],"content":" 2.1 进程与线程 2.1.1 操作系统之进程的定义、特征、组成、组织 2.1.2 操作系统之进程的状态及转换 2.1.3 操作系统之原语实现对进程的控制 2.1.4 进程之间的通信 2.1.5 操作系统之线程概念与多线程模型 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#211-操作系统之进程的定义特征组成组织"},{"categories":["操作系统"],"content":" 2.1 进程与线程 2.1.1 操作系统之进程的定义、特征、组成、组织 2.1.2 操作系统之进程的状态及转换 2.1.3 操作系统之原语实现对进程的控制 2.1.4 进程之间的通信 2.1.5 操作系统之线程概念与多线程模型 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#212-操作系统之进程的状态及转换"},{"categories":["操作系统"],"content":" 2.1 进程与线程 2.1.1 操作系统之进程的定义、特征、组成、组织 2.1.2 操作系统之进程的状态及转换 2.1.3 操作系统之原语实现对进程的控制 2.1.4 进程之间的通信 2.1.5 操作系统之线程概念与多线程模型 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#213-操作系统之原语实现对进程的控制"},{"categories":["操作系统"],"content":" 2.1 进程与线程 2.1.1 操作系统之进程的定义、特征、组成、组织 2.1.2 操作系统之进程的状态及转换 2.1.3 操作系统之原语实现对进程的控制 2.1.4 进程之间的通信 2.1.5 操作系统之线程概念与多线程模型 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#214-进程之间的通信"},{"categories":["操作系统"],"content":" 2.1 进程与线程 2.1.1 操作系统之进程的定义、特征、组成、组织 2.1.2 操作系统之进程的状态及转换 2.1.3 操作系统之原语实现对进程的控制 2.1.4 进程之间的通信 2.1.5 操作系统之线程概念与多线程模型 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#215-操作系统之线程概念与多线程模型"},{"categories":["操作系统"],"content":" 2.2 处理机的调度 2.2.1 处理机调度的概念及层次 2.2.2 进程调度的时机、切换与过程、方式 2.2.3 调度算法的评价指标 2.2.4 作业/进程调度算法 2.2.5 作业/进程调度算法（高级） ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#22-处理机的调度"},{"categories":["操作系统"],"content":" 2.2 处理机的调度 2.2.1 处理机调度的概念及层次 2.2.2 进程调度的时机、切换与过程、方式 2.2.3 调度算法的评价指标 2.2.4 作业/进程调度算法 2.2.5 作业/进程调度算法（高级） ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#221-处理机调度的概念及层次"},{"categories":["操作系统"],"content":" 2.2 处理机的调度 2.2.1 处理机调度的概念及层次 2.2.2 进程调度的时机、切换与过程、方式 2.2.3 调度算法的评价指标 2.2.4 作业/进程调度算法 2.2.5 作业/进程调度算法（高级） ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#222-进程调度的时机切换与过程方式"},{"categories":["操作系统"],"content":" 2.2 处理机的调度 2.2.1 处理机调度的概念及层次 2.2.2 进程调度的时机、切换与过程、方式 2.2.3 调度算法的评价指标 2.2.4 作业/进程调度算法 2.2.5 作业/进程调度算法（高级） ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#223-调度算法的评价指标"},{"categories":["操作系统"],"content":" 2.2 处理机的调度 2.2.1 处理机调度的概念及层次 2.2.2 进程调度的时机、切换与过程、方式 2.2.3 调度算法的评价指标 2.2.4 作业/进程调度算法 2.2.5 作业/进程调度算法（高级） ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#224-作业进程调度算法"},{"categories":["操作系统"],"content":" 2.2 处理机的调度 2.2.1 处理机调度的概念及层次 2.2.2 进程调度的时机、切换与过程、方式 2.2.3 调度算法的评价指标 2.2.4 作业/进程调度算法 2.2.5 作业/进程调度算法（高级） ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#225-作业进程调度算法高级"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#23-进程的同步与互斥"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#231-进程的同步与互斥"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#232-实现临界区进程互斥的软件实现方法"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#233-实现临界区进程互斥的硬件实现方法"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#234-信号量机制"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#235-信号量机制实现进程的互斥同步与前驱关系"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#236-进程同步与互斥经典问题"},{"categories":["操作系统"],"content":" 2.3 进程的同步与互斥 2.3.1 进程的同步与互斥 2.3.2 实现临界区进程互斥的软件实现方法 2.3.3 实现临界区进程互斥的硬件实现方法 2.3.4 信号量机制 2.3.5 信号量机制实现进程的互斥、同步与前驱关系 2.3.6 进程同步与互斥经典问题 2.3.7 管程和java中实现管程的机制 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:3","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#237-管程和java中实现管程的机制"},{"categories":["操作系统"],"content":" 2.4 死锁 2.4.1 死锁详解 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:4","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#24-死锁"},{"categories":["操作系统"],"content":" 2.4 死锁 2.4.1 死锁详解 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:4","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#241-死锁详解"},{"categories":["操作系统"],"content":" 第3章 内存管理","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:0","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#第3章-内存管理"},{"categories":["操作系统"],"content":" 3.1 内存管理的概念 3.1.1 什么是内存？ 什么是内存？有何作用？ 存储单元 几个常用数量单位\u0026内存地址 进程运行的基本原理 指令的工作原理—操作码+若干参数（可能包含地址参数） 逻辑地址（相对地址）vs物理地址（绝对地址） 从写程序到程序运行—编译、链接、装入 装入模块装入内存 装入的三种方式 绝对装入 静态重定位 动态重定位 链接的三种方式 静态链接 装入时动态链接 运行时动态链接 3.1.2 内存管理管些什么？ 内存空间的分配与回收 内存空间的扩展（实现虚拟性） 地址转换 三种方式 内存保护 两种方式 3.1.3 覆盖技术与交换技术的思想 覆盖技术 交换技术 3.1.4 内存的分配与回收 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#31-内存管理的概念"},{"categories":["操作系统"],"content":" 3.1 内存管理的概念 3.1.1 什么是内存？ 什么是内存？有何作用？ 存储单元 几个常用数量单位\u0026内存地址 进程运行的基本原理 指令的工作原理—操作码+若干参数（可能包含地址参数） 逻辑地址（相对地址）vs物理地址（绝对地址） 从写程序到程序运行—编译、链接、装入 装入模块装入内存 装入的三种方式 绝对装入 静态重定位 动态重定位 链接的三种方式 静态链接 装入时动态链接 运行时动态链接 3.1.2 内存管理管些什么？ 内存空间的分配与回收 内存空间的扩展（实现虚拟性） 地址转换 三种方式 内存保护 两种方式 3.1.3 覆盖技术与交换技术的思想 覆盖技术 交换技术 3.1.4 内存的分配与回收 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#311-什么是内存"},{"categories":["操作系统"],"content":" 3.1 内存管理的概念 3.1.1 什么是内存？ 什么是内存？有何作用？ 存储单元 几个常用数量单位\u0026内存地址 进程运行的基本原理 指令的工作原理—操作码+若干参数（可能包含地址参数） 逻辑地址（相对地址）vs物理地址（绝对地址） 从写程序到程序运行—编译、链接、装入 装入模块装入内存 装入的三种方式 绝对装入 静态重定位 动态重定位 链接的三种方式 静态链接 装入时动态链接 运行时动态链接 3.1.2 内存管理管些什么？ 内存空间的分配与回收 内存空间的扩展（实现虚拟性） 地址转换 三种方式 内存保护 两种方式 3.1.3 覆盖技术与交换技术的思想 覆盖技术 交换技术 3.1.4 内存的分配与回收 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#312-内存管理管些什么"},{"categories":["操作系统"],"content":" 3.1 内存管理的概念 3.1.1 什么是内存？ 什么是内存？有何作用？ 存储单元 几个常用数量单位\u0026内存地址 进程运行的基本原理 指令的工作原理—操作码+若干参数（可能包含地址参数） 逻辑地址（相对地址）vs物理地址（绝对地址） 从写程序到程序运行—编译、链接、装入 装入模块装入内存 装入的三种方式 绝对装入 静态重定位 动态重定位 链接的三种方式 静态链接 装入时动态链接 运行时动态链接 3.1.2 内存管理管些什么？ 内存空间的分配与回收 内存空间的扩展（实现虚拟性） 地址转换 三种方式 内存保护 两种方式 3.1.3 覆盖技术与交换技术的思想 覆盖技术 交换技术 3.1.4 内存的分配与回收 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#313-覆盖技术与交换技术的思想"},{"categories":["操作系统"],"content":" 3.1 内存管理的概念 3.1.1 什么是内存？ 什么是内存？有何作用？ 存储单元 几个常用数量单位\u0026内存地址 进程运行的基本原理 指令的工作原理—操作码+若干参数（可能包含地址参数） 逻辑地址（相对地址）vs物理地址（绝对地址） 从写程序到程序运行—编译、链接、装入 装入模块装入内存 装入的三种方式 绝对装入 静态重定位 动态重定位 链接的三种方式 静态链接 装入时动态链接 运行时动态链接 3.1.2 内存管理管些什么？ 内存空间的分配与回收 内存空间的扩展（实现虚拟性） 地址转换 三种方式 内存保护 两种方式 3.1.3 覆盖技术与交换技术的思想 覆盖技术 交换技术 3.1.4 内存的分配与回收 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#314-内存的分配与回收"},{"categories":["操作系统"],"content":" 3.2 虚拟内存管理 3.2.1 虚拟内存的基本概念 传统存储管理的特征、缺点 局部性原理 虚拟内存的定义和特征 如何实现虚拟内存技术 3.2.2 请求分页管理方式 概念 页表机制—请求页表与基本页表的区别 缺页中断机构 地址变换机构 3.2.3 页面置换算法 最佳置换算法—OPT 先进先出置换算法—FIFO 最近最久未使用置换算法—LRU 时钟置换算法—CLOCK 改造型时钟置换算法 3.2.4 页面分配策略 驻留集 页面分配、置换策略 固定分配局部置换、可变分配局部置换、可变分配全局置换 何时调入页面？ 从何处调页？ 抖动（颠簸）现象 工作集 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#32-虚拟内存管理"},{"categories":["操作系统"],"content":" 3.2 虚拟内存管理 3.2.1 虚拟内存的基本概念 传统存储管理的特征、缺点 局部性原理 虚拟内存的定义和特征 如何实现虚拟内存技术 3.2.2 请求分页管理方式 概念 页表机制—请求页表与基本页表的区别 缺页中断机构 地址变换机构 3.2.3 页面置换算法 最佳置换算法—OPT 先进先出置换算法—FIFO 最近最久未使用置换算法—LRU 时钟置换算法—CLOCK 改造型时钟置换算法 3.2.4 页面分配策略 驻留集 页面分配、置换策略 固定分配局部置换、可变分配局部置换、可变分配全局置换 何时调入页面？ 从何处调页？ 抖动（颠簸）现象 工作集 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#321-虚拟内存的基本概念"},{"categories":["操作系统"],"content":" 3.2 虚拟内存管理 3.2.1 虚拟内存的基本概念 传统存储管理的特征、缺点 局部性原理 虚拟内存的定义和特征 如何实现虚拟内存技术 3.2.2 请求分页管理方式 概念 页表机制—请求页表与基本页表的区别 缺页中断机构 地址变换机构 3.2.3 页面置换算法 最佳置换算法—OPT 先进先出置换算法—FIFO 最近最久未使用置换算法—LRU 时钟置换算法—CLOCK 改造型时钟置换算法 3.2.4 页面分配策略 驻留集 页面分配、置换策略 固定分配局部置换、可变分配局部置换、可变分配全局置换 何时调入页面？ 从何处调页？ 抖动（颠簸）现象 工作集 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#322-请求分页管理方式"},{"categories":["操作系统"],"content":" 3.2 虚拟内存管理 3.2.1 虚拟内存的基本概念 传统存储管理的特征、缺点 局部性原理 虚拟内存的定义和特征 如何实现虚拟内存技术 3.2.2 请求分页管理方式 概念 页表机制—请求页表与基本页表的区别 缺页中断机构 地址变换机构 3.2.3 页面置换算法 最佳置换算法—OPT 先进先出置换算法—FIFO 最近最久未使用置换算法—LRU 时钟置换算法—CLOCK 改造型时钟置换算法 3.2.4 页面分配策略 驻留集 页面分配、置换策略 固定分配局部置换、可变分配局部置换、可变分配全局置换 何时调入页面？ 从何处调页？ 抖动（颠簸）现象 工作集 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#323-页面置换算法"},{"categories":["操作系统"],"content":" 3.2 虚拟内存管理 3.2.1 虚拟内存的基本概念 传统存储管理的特征、缺点 局部性原理 虚拟内存的定义和特征 如何实现虚拟内存技术 3.2.2 请求分页管理方式 概念 页表机制—请求页表与基本页表的区别 缺页中断机构 地址变换机构 3.2.3 页面置换算法 最佳置换算法—OPT 先进先出置换算法—FIFO 最近最久未使用置换算法—LRU 时钟置换算法—CLOCK 改造型时钟置换算法 3.2.4 页面分配策略 驻留集 页面分配、置换策略 固定分配局部置换、可变分配局部置换、可变分配全局置换 何时调入页面？ 从何处调页？ 抖动（颠簸）现象 工作集 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#324-页面分配策略"},{"categories":["操作系统"],"content":" 第4章 文件管理","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:0","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#第4章-文件管理"},{"categories":["操作系统"],"content":" 4.1 文件系统 4.1.1 文件管理概念和功能 文件的属性 文件内部的数据如何组织？ 文件之间如何组织？ 操作系统应该向上提供哪些功能？ 从上往下看，文件应该如何存放在外存？ 其他需要由操作系统实现的文件管理功能 4.1.2 文件逻辑结构 无结构文件 有结构文件 有结构文件的逻辑结构 顺序文件 索引文件 索引顺序文件 多级索引顺序文件 4.1.3 文件目录结构 文件控制块 对目录的操作 单级目录结构 两级目录结构 多级目录结构(树形目录结构) 无环图目录结构 索引节点(FCB的改进)瘦身 4.1.4 OS之文件的物理结构 文件块、磁盘块 连续分配 链接分配 隐式链接 显式链接 链接分配总结 索引分配 链接方案 多层索引 混合索引 索引分配总结 文件物理结构分配总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#41-文件系统"},{"categories":["操作系统"],"content":" 4.1 文件系统 4.1.1 文件管理概念和功能 文件的属性 文件内部的数据如何组织？ 文件之间如何组织？ 操作系统应该向上提供哪些功能？ 从上往下看，文件应该如何存放在外存？ 其他需要由操作系统实现的文件管理功能 4.1.2 文件逻辑结构 无结构文件 有结构文件 有结构文件的逻辑结构 顺序文件 索引文件 索引顺序文件 多级索引顺序文件 4.1.3 文件目录结构 文件控制块 对目录的操作 单级目录结构 两级目录结构 多级目录结构(树形目录结构) 无环图目录结构 索引节点(FCB的改进)瘦身 4.1.4 OS之文件的物理结构 文件块、磁盘块 连续分配 链接分配 隐式链接 显式链接 链接分配总结 索引分配 链接方案 多层索引 混合索引 索引分配总结 文件物理结构分配总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#411-文件管理概念和功能"},{"categories":["操作系统"],"content":" 4.1 文件系统 4.1.1 文件管理概念和功能 文件的属性 文件内部的数据如何组织？ 文件之间如何组织？ 操作系统应该向上提供哪些功能？ 从上往下看，文件应该如何存放在外存？ 其他需要由操作系统实现的文件管理功能 4.1.2 文件逻辑结构 无结构文件 有结构文件 有结构文件的逻辑结构 顺序文件 索引文件 索引顺序文件 多级索引顺序文件 4.1.3 文件目录结构 文件控制块 对目录的操作 单级目录结构 两级目录结构 多级目录结构(树形目录结构) 无环图目录结构 索引节点(FCB的改进)瘦身 4.1.4 OS之文件的物理结构 文件块、磁盘块 连续分配 链接分配 隐式链接 显式链接 链接分配总结 索引分配 链接方案 多层索引 混合索引 索引分配总结 文件物理结构分配总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#412-文件逻辑结构"},{"categories":["操作系统"],"content":" 4.1 文件系统 4.1.1 文件管理概念和功能 文件的属性 文件内部的数据如何组织？ 文件之间如何组织？ 操作系统应该向上提供哪些功能？ 从上往下看，文件应该如何存放在外存？ 其他需要由操作系统实现的文件管理功能 4.1.2 文件逻辑结构 无结构文件 有结构文件 有结构文件的逻辑结构 顺序文件 索引文件 索引顺序文件 多级索引顺序文件 4.1.3 文件目录结构 文件控制块 对目录的操作 单级目录结构 两级目录结构 多级目录结构(树形目录结构) 无环图目录结构 索引节点(FCB的改进)瘦身 4.1.4 OS之文件的物理结构 文件块、磁盘块 连续分配 链接分配 隐式链接 显式链接 链接分配总结 索引分配 链接方案 多层索引 混合索引 索引分配总结 文件物理结构分配总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#413-文件目录结构"},{"categories":["操作系统"],"content":" 4.1 文件系统 4.1.1 文件管理概念和功能 文件的属性 文件内部的数据如何组织？ 文件之间如何组织？ 操作系统应该向上提供哪些功能？ 从上往下看，文件应该如何存放在外存？ 其他需要由操作系统实现的文件管理功能 4.1.2 文件逻辑结构 无结构文件 有结构文件 有结构文件的逻辑结构 顺序文件 索引文件 索引顺序文件 多级索引顺序文件 4.1.3 文件目录结构 文件控制块 对目录的操作 单级目录结构 两级目录结构 多级目录结构(树形目录结构) 无环图目录结构 索引节点(FCB的改进)瘦身 4.1.4 OS之文件的物理结构 文件块、磁盘块 连续分配 链接分配 隐式链接 显式链接 链接分配总结 索引分配 链接方案 多层索引 混合索引 索引分配总结 文件物理结构分配总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#414-os之文件的物理结构"},{"categories":["操作系统"],"content":" 4.2 磁盘组织与管理 4.2.1 磁盘的结构 磁盘、磁道、扇区 如何在磁盘中读/写数据 盘面、柱面 磁盘的分类 磁头是否可移动 盘片是否可更换 4.2.2 磁盘调度算法 一次磁盘读/写操作需要的时间 先来先服务(FCFS) 最短寻找时间优先算法（SSTF） 扫描算法（SCAN） LOOK算法 循环扫描算法（S-SCAN） C-LOOK算法 4.2.3 减少磁盘延迟时间的方法 一次磁盘读/写操作需要的时间 交替编号 磁盘地址结构的设计 错位命名 4.2.4 磁盘管理 磁盘初始化 引导块 坏块的管理 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#42-磁盘组织与管理"},{"categories":["操作系统"],"content":" 4.2 磁盘组织与管理 4.2.1 磁盘的结构 磁盘、磁道、扇区 如何在磁盘中读/写数据 盘面、柱面 磁盘的分类 磁头是否可移动 盘片是否可更换 4.2.2 磁盘调度算法 一次磁盘读/写操作需要的时间 先来先服务(FCFS) 最短寻找时间优先算法（SSTF） 扫描算法（SCAN） LOOK算法 循环扫描算法（S-SCAN） C-LOOK算法 4.2.3 减少磁盘延迟时间的方法 一次磁盘读/写操作需要的时间 交替编号 磁盘地址结构的设计 错位命名 4.2.4 磁盘管理 磁盘初始化 引导块 坏块的管理 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#421-磁盘的结构"},{"categories":["操作系统"],"content":" 4.2 磁盘组织与管理 4.2.1 磁盘的结构 磁盘、磁道、扇区 如何在磁盘中读/写数据 盘面、柱面 磁盘的分类 磁头是否可移动 盘片是否可更换 4.2.2 磁盘调度算法 一次磁盘读/写操作需要的时间 先来先服务(FCFS) 最短寻找时间优先算法（SSTF） 扫描算法（SCAN） LOOK算法 循环扫描算法（S-SCAN） C-LOOK算法 4.2.3 减少磁盘延迟时间的方法 一次磁盘读/写操作需要的时间 交替编号 磁盘地址结构的设计 错位命名 4.2.4 磁盘管理 磁盘初始化 引导块 坏块的管理 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#422-磁盘调度算法"},{"categories":["操作系统"],"content":" 4.2 磁盘组织与管理 4.2.1 磁盘的结构 磁盘、磁道、扇区 如何在磁盘中读/写数据 盘面、柱面 磁盘的分类 磁头是否可移动 盘片是否可更换 4.2.2 磁盘调度算法 一次磁盘读/写操作需要的时间 先来先服务(FCFS) 最短寻找时间优先算法（SSTF） 扫描算法（SCAN） LOOK算法 循环扫描算法（S-SCAN） C-LOOK算法 4.2.3 减少磁盘延迟时间的方法 一次磁盘读/写操作需要的时间 交替编号 磁盘地址结构的设计 错位命名 4.2.4 磁盘管理 磁盘初始化 引导块 坏块的管理 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#423-减少磁盘延迟时间的方法"},{"categories":["操作系统"],"content":" 4.2 磁盘组织与管理 4.2.1 磁盘的结构 磁盘、磁道、扇区 如何在磁盘中读/写数据 盘面、柱面 磁盘的分类 磁头是否可移动 盘片是否可更换 4.2.2 磁盘调度算法 一次磁盘读/写操作需要的时间 先来先服务(FCFS) 最短寻找时间优先算法（SSTF） 扫描算法（SCAN） LOOK算法 循环扫描算法（S-SCAN） C-LOOK算法 4.2.3 减少磁盘延迟时间的方法 一次磁盘读/写操作需要的时间 交替编号 磁盘地址结构的设计 错位命名 4.2.4 磁盘管理 磁盘初始化 引导块 坏块的管理 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#424-磁盘管理"},{"categories":["操作系统"],"content":" 第5章 I/O 管理","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:0","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#第5章-io-管理"},{"categories":["操作系统"],"content":" 5.1 I/O 管理概述 5.1.1 I/O 设备 什么是 I/O 设备？ I/O 设备的分类 使用特性分类 传输速率分类 信息交换单位分类 5.1.2 控制 I/O 设备的 I/O 控制器 I/O 设备的组成 机械部件 电子部件：I/O 控制器的功能 I/O 控制器的组成 I/O 控制器的两种寄存器编址方式 内存映像 独立编址 5.1.3 控制 I/O 设备的方式 程序直接控制 中断驱动 DMA 通道控制 四种方式比较 5.1.4 I/O 软件的层次结构 用户层软件 设备独立性软件 逻辑设备表（LUT） 为什么不同的设备需要不同的驱动程序？ 设备驱动程序 中断处理程序 总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#51-io-管理概述"},{"categories":["操作系统"],"content":" 5.1 I/O 管理概述 5.1.1 I/O 设备 什么是 I/O 设备？ I/O 设备的分类 使用特性分类 传输速率分类 信息交换单位分类 5.1.2 控制 I/O 设备的 I/O 控制器 I/O 设备的组成 机械部件 电子部件：I/O 控制器的功能 I/O 控制器的组成 I/O 控制器的两种寄存器编址方式 内存映像 独立编址 5.1.3 控制 I/O 设备的方式 程序直接控制 中断驱动 DMA 通道控制 四种方式比较 5.1.4 I/O 软件的层次结构 用户层软件 设备独立性软件 逻辑设备表（LUT） 为什么不同的设备需要不同的驱动程序？ 设备驱动程序 中断处理程序 总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#511-io-设备"},{"categories":["操作系统"],"content":" 5.1 I/O 管理概述 5.1.1 I/O 设备 什么是 I/O 设备？ I/O 设备的分类 使用特性分类 传输速率分类 信息交换单位分类 5.1.2 控制 I/O 设备的 I/O 控制器 I/O 设备的组成 机械部件 电子部件：I/O 控制器的功能 I/O 控制器的组成 I/O 控制器的两种寄存器编址方式 内存映像 独立编址 5.1.3 控制 I/O 设备的方式 程序直接控制 中断驱动 DMA 通道控制 四种方式比较 5.1.4 I/O 软件的层次结构 用户层软件 设备独立性软件 逻辑设备表（LUT） 为什么不同的设备需要不同的驱动程序？ 设备驱动程序 中断处理程序 总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#512-控制-io-设备的-io-控制器"},{"categories":["操作系统"],"content":" 5.1 I/O 管理概述 5.1.1 I/O 设备 什么是 I/O 设备？ I/O 设备的分类 使用特性分类 传输速率分类 信息交换单位分类 5.1.2 控制 I/O 设备的 I/O 控制器 I/O 设备的组成 机械部件 电子部件：I/O 控制器的功能 I/O 控制器的组成 I/O 控制器的两种寄存器编址方式 内存映像 独立编址 5.1.3 控制 I/O 设备的方式 程序直接控制 中断驱动 DMA 通道控制 四种方式比较 5.1.4 I/O 软件的层次结构 用户层软件 设备独立性软件 逻辑设备表（LUT） 为什么不同的设备需要不同的驱动程序？ 设备驱动程序 中断处理程序 总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#513-控制-io-设备的方式"},{"categories":["操作系统"],"content":" 5.1 I/O 管理概述 5.1.1 I/O 设备 什么是 I/O 设备？ I/O 设备的分类 使用特性分类 传输速率分类 信息交换单位分类 5.1.2 控制 I/O 设备的 I/O 控制器 I/O 设备的组成 机械部件 电子部件：I/O 控制器的功能 I/O 控制器的组成 I/O 控制器的两种寄存器编址方式 内存映像 独立编址 5.1.3 控制 I/O 设备的方式 程序直接控制 中断驱动 DMA 通道控制 四种方式比较 5.1.4 I/O 软件的层次结构 用户层软件 设备独立性软件 逻辑设备表（LUT） 为什么不同的设备需要不同的驱动程序？ 设备驱动程序 中断处理程序 总结 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#514-io-软件的层次结构"},{"categories":["操作系统"],"content":" 5.2 I/O 核心子系统 5.2.1 内核的 I/O 核心子系统及功能 I/O核心子系统 假脱机技术 I/O调度 设备保护 5.2.2 I/O 设备假脱机技术（SPOOLing） 假脱机技术 脱机技术 手工操作阶段：主机直接从 I/O 设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。 批处理阶段引入了脱机输入/输出技术(用磁带完成)：引入脱机技术后，缓解了CPU与慢速I/0设备的速度矛盾。另方面，即使CPU在忙碌，也可以提前将数据输入到磁带:即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。 假脱机技术 输入井和输出井 输入进程与输出进程 输入输出缓冲区 共享打印机原理分析 5.2.3 I/O 设备的分配与回收 设备分配时应该考虑的因素 设备的固有属性 设备的分配算法 设备分配中的安全性 静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源.破坏了“请求和保持”条件，不会发生死锁 动态分配：进程运行过程中动态申请设备资源 设备、控制器、通道之间的关系 设备分配管理中的数据结构 设备控制表（DCT） 控制器控制表（COCT） 通道控制表（CHCT） 系统设备表（SDT） 设备分配的步骤 设备分配的改进步骤 5.2.4 缓冲区管理 缓冲区 单缓冲区 双缓冲区 单缓冲和双缓冲通信时的区别 循环缓冲区 缓冲池 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#52-io-核心子系统"},{"categories":["操作系统"],"content":" 5.2 I/O 核心子系统 5.2.1 内核的 I/O 核心子系统及功能 I/O核心子系统 假脱机技术 I/O调度 设备保护 5.2.2 I/O 设备假脱机技术（SPOOLing） 假脱机技术 脱机技术 手工操作阶段：主机直接从 I/O 设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。 批处理阶段引入了脱机输入/输出技术(用磁带完成)：引入脱机技术后，缓解了CPU与慢速I/0设备的速度矛盾。另方面，即使CPU在忙碌，也可以提前将数据输入到磁带:即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。 假脱机技术 输入井和输出井 输入进程与输出进程 输入输出缓冲区 共享打印机原理分析 5.2.3 I/O 设备的分配与回收 设备分配时应该考虑的因素 设备的固有属性 设备的分配算法 设备分配中的安全性 静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源.破坏了“请求和保持”条件，不会发生死锁 动态分配：进程运行过程中动态申请设备资源 设备、控制器、通道之间的关系 设备分配管理中的数据结构 设备控制表（DCT） 控制器控制表（COCT） 通道控制表（CHCT） 系统设备表（SDT） 设备分配的步骤 设备分配的改进步骤 5.2.4 缓冲区管理 缓冲区 单缓冲区 双缓冲区 单缓冲和双缓冲通信时的区别 循环缓冲区 缓冲池 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#521-内核的-io-核心子系统及功能"},{"categories":["操作系统"],"content":" 5.2 I/O 核心子系统 5.2.1 内核的 I/O 核心子系统及功能 I/O核心子系统 假脱机技术 I/O调度 设备保护 5.2.2 I/O 设备假脱机技术（SPOOLing） 假脱机技术 脱机技术 手工操作阶段：主机直接从 I/O 设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。 批处理阶段引入了脱机输入/输出技术(用磁带完成)：引入脱机技术后，缓解了CPU与慢速I/0设备的速度矛盾。另方面，即使CPU在忙碌，也可以提前将数据输入到磁带:即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。 假脱机技术 输入井和输出井 输入进程与输出进程 输入输出缓冲区 共享打印机原理分析 5.2.3 I/O 设备的分配与回收 设备分配时应该考虑的因素 设备的固有属性 设备的分配算法 设备分配中的安全性 静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源.破坏了“请求和保持”条件，不会发生死锁 动态分配：进程运行过程中动态申请设备资源 设备、控制器、通道之间的关系 设备分配管理中的数据结构 设备控制表（DCT） 控制器控制表（COCT） 通道控制表（CHCT） 系统设备表（SDT） 设备分配的步骤 设备分配的改进步骤 5.2.4 缓冲区管理 缓冲区 单缓冲区 双缓冲区 单缓冲和双缓冲通信时的区别 循环缓冲区 缓冲池 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#522-io-设备假脱机技术spooling"},{"categories":["操作系统"],"content":" 5.2 I/O 核心子系统 5.2.1 内核的 I/O 核心子系统及功能 I/O核心子系统 假脱机技术 I/O调度 设备保护 5.2.2 I/O 设备假脱机技术（SPOOLing） 假脱机技术 脱机技术 手工操作阶段：主机直接从 I/O 设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。 批处理阶段引入了脱机输入/输出技术(用磁带完成)：引入脱机技术后，缓解了CPU与慢速I/0设备的速度矛盾。另方面，即使CPU在忙碌，也可以提前将数据输入到磁带:即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。 假脱机技术 输入井和输出井 输入进程与输出进程 输入输出缓冲区 共享打印机原理分析 5.2.3 I/O 设备的分配与回收 设备分配时应该考虑的因素 设备的固有属性 设备的分配算法 设备分配中的安全性 静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源.破坏了“请求和保持”条件，不会发生死锁 动态分配：进程运行过程中动态申请设备资源 设备、控制器、通道之间的关系 设备分配管理中的数据结构 设备控制表（DCT） 控制器控制表（COCT） 通道控制表（CHCT） 系统设备表（SDT） 设备分配的步骤 设备分配的改进步骤 5.2.4 缓冲区管理 缓冲区 单缓冲区 双缓冲区 单缓冲和双缓冲通信时的区别 循环缓冲区 缓冲池 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#523-io-设备的分配与回收"},{"categories":["操作系统"],"content":" 5.2 I/O 核心子系统 5.2.1 内核的 I/O 核心子系统及功能 I/O核心子系统 假脱机技术 I/O调度 设备保护 5.2.2 I/O 设备假脱机技术（SPOOLing） 假脱机技术 脱机技术 手工操作阶段：主机直接从 I/O 设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。 批处理阶段引入了脱机输入/输出技术(用磁带完成)：引入脱机技术后，缓解了CPU与慢速I/0设备的速度矛盾。另方面，即使CPU在忙碌，也可以提前将数据输入到磁带:即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。 假脱机技术 输入井和输出井 输入进程与输出进程 输入输出缓冲区 共享打印机原理分析 5.2.3 I/O 设备的分配与回收 设备分配时应该考虑的因素 设备的固有属性 设备的分配算法 设备分配中的安全性 静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源.破坏了“请求和保持”条件，不会发生死锁 动态分配：进程运行过程中动态申请设备资源 设备、控制器、通道之间的关系 设备分配管理中的数据结构 设备控制表（DCT） 控制器控制表（COCT） 通道控制表（CHCT） 系统设备表（SDT） 设备分配的步骤 设备分配的改进步骤 5.2.4 缓冲区管理 缓冲区 单缓冲区 双缓冲区 单缓冲和双缓冲通信时的区别 循环缓冲区 缓冲池 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","series":null,"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#524-缓冲区管理"},{"categories":["力扣"],"content":"919. 完全二叉树插入器 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:0:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#"},{"categories":["力扣"],"content":" 方法一：每次insert时BFS查找待插入结点的位置","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法一每次insert时bfs查找待插入结点的位置"},{"categories":["力扣"],"content":" 解题思路插入。BFS 遍历树，找到的第一个左孩子或者右孩子不存在的结点则为待插入结点的父结点。 若左孩子不存在，则新插入结点为父结点的左孩子。 若右孩子不存在，则新插入结点为父结点的右孩子。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; public CBTInserter(TreeNode root) { this.root = root; } public int insert(int val) { Queue\u003cTreeNode\u003e que = new ArrayDeque\u003c\u003e(); que.offer(root); while (!que.isEmpty()) { TreeNode node = que.poll(); if (node.left == null) { node.left = new TreeNode(val); return node.val; } else if (node.right == null) { node.right = new TreeNode(val); return node.val; } que.offer(node.left); que.offer(node.right); } return -1; } public TreeNode get_root() { return root; } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(1)$ insert：$O(n)$，$n$ 为二叉树结点数量，每次insert时执行一遍 BFS 需要遍历大概一半的结点数。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析"},{"categories":["力扣"],"content":" 方法二：存储最后两层的结点","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法二存储最后两层的结点"},{"categories":["力扣"],"content":" 解题思路 初始化。通过 BFS 遍历树，存储最后两层的结点。 插入。 若最后一层已满，新插入结点为新的一层的第一个结点，其父结点为上一层第一个结点。然后更新最后两层。 若最后一层未满，大小为k，新插入结点插入该层的末尾，其父结点为上一层的第k/2个结点，若k为偶数，则作为左孩子插入，否则是右孩子。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路-1"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; List\u003cTreeNode\u003e row1, row2; // 最后一层，倒数第二层。 int level; // 层数 public CBTInserter(TreeNode root) { this.root = root; Queue\u003cTreeNode\u003e que = new ArrayDeque\u003c\u003e(); que.offer(root); while (!que.isEmpty()) { int size = que.size(); List\u003cTreeNode\u003e row = new ArrayList\u003c\u003e(); while (size-- \u003e 0) { TreeNode node = que.poll(); row.add(node); if (node.left != null) que.offer(node.left); if (node.right != null) que.offer(node.right); } level++; // 更新最后两层 row2 = row1; row1 = row; } ensureLastRow(); } public int insert(int val) { TreeNode node = new TreeNode(val); int k = row1.size(); TreeNode parent = row2.get(k / 2); if (k % 2 == 0) parent.left = node; else parent.right = node; row1.add(node); ensureLastRow(); return parent.val; } public TreeNode get_root() { return root; } void ensureLastRow() { if (row1.size() == 1 \u003c\u003c (level - 1)) { // 最后一层已满 row2 = row1; row1 = new ArrayList\u003c\u003e(); level++; } } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码-1"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(n)$，$n$ 为二叉树结点数量，执行了一遍 BFS。 insert：$O(1)$。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析-1"},{"categories":["力扣"],"content":" 方法三：队列存储出度小于 2 的结点（即左右孩子不全有）","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法三队列存储出度小于-2-的结点即左右孩子不全有"},{"categories":["力扣"],"content":" 解题思路 初始化。通过 BFS 遍历树，保留遍历队列，找到第一个左孩子或右孩子不存在的结点为止。 插入。队列的队头结点即为父结点，若新插入结点为右孩子则从队列中删除父结点，然后将新插入结点加入队列。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路-2"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; Queue\u003cTreeNode\u003e que = new ArrayDeque\u003c\u003e(); public CBTInserter(TreeNode root) { this.root = root; que.offer(root); while (!que.isEmpty()) { TreeNode node = que.peek(); if (node.left != null) que.offer(node.left); else break; if (node.right != null) { que.offer(node.right); que.poll(); } else break; } } public int insert(int val) { TreeNode node = new TreeNode(val); TreeNode parent = que.peek(); if (parent.left == null) parent.left = node; else { parent.right = node; que.poll(); } que.offer(node); return parent.val; } public TreeNode get_root() { return root; } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码-2"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(n)$，$n$ 为二叉树结点数量，执行了一遍 BFS。 insert：$O(1)$。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析-2"},{"categories":["力扣"],"content":" 方法四：根据结点的序号的二进制查找结点","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法四根据结点的序号的二进制查找结点"},{"categories":["力扣"],"content":" 解题思路根据完全二叉树可以通过数组存储的性质，定义根结点序号为 1，则序号为k的结点的父结点序号为k/2，左孩子序号为2*k，右孩子序号为2*k+1。 将序号进行二进制表示（忽略最高位的 1），0表示取左子树，1取右子树，则该二进制为根结点到指定序号结点的路径。 例：序号为 5 (二进制为 0b101) 的结点为根结点的左孩子(0)的右孩子(1)。 初始化。通过 DFS 遍历树计算结点数量n。 插入。待插入结点为第n+1个结点，通过其序号二进制找到父结点。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路-3"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; int n; // 结点数 public CBTInserter(TreeNode root) { this.root = root; dfs(root); } public int insert(int val) { String path = Integer.toBinaryString(++n); TreeNode node = new TreeNode(val); TreeNode parent = root; // 忽略最高位 1；倒数第二位为父结点 for (int i = 1; i + 1 \u003c path.length(); i++) { if (path.charAt(i) == '0') parent = parent.left; else parent = parent.right; } if (parent.left == null) parent.left = node; else parent.right = node; return parent.val; } public TreeNode get_root() { return root; } void dfs(TreeNode root) { if (root == null) return; n++; dfs(root.left); dfs(root.right); } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码-3"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(n)$，$n$ 为二叉树结点数量，执行了一遍 DFS。 insert：$O(\\log{n})$，$n$ 个结点的完全二叉树的最大高度为 $\\log_2{n}$。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析-3"},{"categories":["力扣"],"content":" 图论","date":"2022-07-24","objectID":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/:1:0","series":null,"tags":["力扣"],"title":"力扣题解","uri":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/#图论"},{"categories":["力扣"],"content":" 拓扑排序 207. 课程表 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u003cInteger\u003e[] graph = new ArrayList[numCourses]; boolean[] vis = new boolean[numCourses]; boolean[] onPath = new boolean[numCourses]; for (int i = 0; i \u003c numCourses; i++) graph[i] = new ArrayList\u003c\u003e(); for (int[] course : prerequisites) // 建图 graph[course[1]].add(course[0]); for (int u = 0; u \u003c numCourses; u++) // DFS 遍历 if (!vis[u] \u0026\u0026 dfs(graph, u, vis, onPath)) return false; return true; } boolean dfs(List\u003cInteger\u003e[] graph, int u, boolean[] vis, boolean[] onPath) { // 返回是否存在环 vis[u] = true; onPath[u] = true; for (int v : graph[u]) { if (onPath[v]) // 找到环 return true; if (!vis[v] \u0026\u0026 dfs(graph, v, vis, onPath)) // 已找到环，剪枝 return true; } onPath[u] = false; // 回溯 return false; } } ","date":"2022-07-24","objectID":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/:1:1","series":null,"tags":["力扣"],"title":"力扣题解","uri":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/#拓扑排序"},{"categories":["算法"],"content":" 素数","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:1:0","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#素数"},{"categories":["算法"],"content":" 判断素数 static boolean isPrime(int n) { if (n \u003c 2) return false; if (n \u003e 2 \u0026\u0026 n % 2 == 0) return false; for (int i = 3; i \u003c= (int) Math.sqrt(n); i += 2) // i * i \u003c= n 可能溢出 if (n % i == 0) return false; return true; } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:1:1","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#判断素数"},{"categories":["算法"],"content":" 平方根","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:2:0","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#平方根"},{"categories":["算法"],"content":" 二分法 static double sqrt(double x) { if (x \u003c 0) return Double.NaN; double threshold = 1e-15; double left = 0.0; double right = x; while (true) { double mid = (left + right) / 2; if (Math.abs(mid * mid - x) \u003c threshold) return mid; else if (mid * mid \u003e x) right = mid; else left = mid; } } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:2:1","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#二分法"},{"categories":["算法"],"content":" 牛顿迭代法 对于函数 $y=\\sqrt{x}$，计算 $y_0=\\sqrt{x_0}$。 $$ y = \\sqrt{x} \\newline y’ = \\frac{1}{2\\sqrt{x}} $$ static double sqrt(double x) { if (x \u003c 0) return Double.NaN; double threshold = 1e-15; double x1 = x; while (Math.abs(x1 - x / x1) \u003e threshold * x1) x1 = (x / x1 + x1) / 2; return x1; } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:2:2","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#牛顿迭代法"},{"categories":[],"content":" 面向对象设计模式","date":"2022-06-21","objectID":"/posts/java-ee-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Java EE 教程","uri":"/posts/java-ee-%E6%95%99%E7%A8%8B/#面向对象设计模式"},{"categories":[],"content":" DAO 模式DAO（Data Access Objects，数据访问对象）是指位于业务逻辑和持久化数据之间实现对持久化数据的访问。通俗来讲，就是将数据库操作都封装起来。 DAO 模式的优势： 隔离了数据访问代码和业务逻辑代码。业务逻辑代码直接调用 DAO 方法即可，完全感觉不到数据库表的存在。分工明确，数据访问层代码变化不影响业务逻辑代码，这符合单一职能原则，降低了耦合性，提高了可复用性。 隔离了不同数据库实现。采用面向接口编程，如果底层数据库变化，如由 MySQL 变成 Oracle 只要增加 DAO 接口的新实现类即可，原有 MySQL 实现不用修改。这符合“开-闭”原则。该原则降低了代码的耦合性，提高了代码扩展性和系统的可移植性。 DAO 模式组成部分： DAO 接口。把对数据库的所有操作定义成抽象方法，可以提供多种实现。 package org.example.dao; import org.example.entity.Website; import java.util.List; public interface WebsiteDAO { public void insert(Website website) throws Exception; public void update(Website website) throws Exception; public void delete(int websiteId) throws Exception; public Website queryById(int websiteId) throws Exception; public List\u003cWebsite\u003e queryAll() throws Exception; } DAO 实现类。针对不同数据库给出 DAO 接口定义方法的具体实现。 package org.example.dao.impl; import org.example.dao.WebsiteDAO; import org.example.entity.Website; import org.example.utils.DBConnectionUtil; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.ArrayList; import java.util.List; public class WebsiteDAOImpl implements WebsiteDAO { @Override public void insert(Website website) throws Exception { String sql = \"insert into websites (website_name, website_url, website_rank, website_country) values (?, ?, ?, ?)\"; PreparedStatement stmt = null; DBConnectionUtil util = null; try { util = new DBConnectionUtil(); stmt = util.getConnection().prepareStatement(sql); stmt.setString(1, website.getWebsiteName()); stmt.setString(2, website.getWebsiteUrl()); stmt.setInt(3, website.getWebsiteRank()); stmt.setString(4, website.getWebsiteCountry()); stmt.executeUpdate(); stmt.close(); } catch (Exception e) { throw new Exception(\"操作出现异常\"); } finally { if (util != null) { util.close(); } } } @Override public void update(Website website) throws Exception { String sql = \"update websites set website_name=?, website_url=?, website_rank=?, website_country=? where website_id=?\"; PreparedStatement stmt = null; DBConnectionUtil util = null; try { util = new DBConnectionUtil(); stmt = util.getC","date":"2022-06-21","objectID":"/posts/java-ee-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"Java EE 教程","uri":"/posts/java-ee-%E6%95%99%E7%A8%8B/#dao-模式"},{"categories":[],"content":" Java 连接 MySQL 下载并在项目中导入mysql-connector-java-8.0.29.jar。 若是 Maven 项目，则在pom.xml中添加依赖。 \u003c!-- pom.xml --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.29\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class MySQLConnectionDemo { // MySQL 8.0 以下版本 // private static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; private static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; private static final String DB_URL = \"jdbc:mysql://localhost:3306/demo\"; public static void main(String[] args) { try { // 注册 JDBC 驱动 Class.forName(JDBC_DRIVER); // 建立连接 Connection conn = DriverManager.getConnection(DB_URL, \"root\", \"12345678\"); // 执行 SQL Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(\"select * from websites\"); while (rs.next()) { int websiteId = rs.getInt(\"website_id\"); String websiteName = rs.getString(\"website_name\"); System.out.println(websiteId + \" \" + websiteName); } // 关闭资源 rs.close(); stmt.close(); conn.close(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2022-06-21","objectID":"/posts/java-ee-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Java EE 教程","uri":"/posts/java-ee-%E6%95%99%E7%A8%8B/#java-连接-mysql"},{"categories":["教程"],"content":" 常见问题","date":"2022-06-21","objectID":"/posts/mysql-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["MySQL"],"title":"MySQL 教程","uri":"/posts/mysql-%E6%95%99%E7%A8%8B/#常见问题"},{"categories":["教程"],"content":" 1. MySQL 驱动是什么？MySQL 驱动会在底层跟数据库建立网络连接，之后才能发送请求给数据库服务器，Java 代码才能基于这个连接去执行各种各样的增删改查 SQL 语句。 MySQL 官方会提供对应各种语言的 MySQL 驱动，让各种语言编写的系统通过 MySQL 驱动去访问 MySQL 数据库。 ","date":"2022-06-21","objectID":"/posts/mysql-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["MySQL"],"title":"MySQL 教程","uri":"/posts/mysql-%E6%95%99%E7%A8%8B/#1-mysql-驱动是什么"},{"categories":["教程"],"content":" 2. 数据库连接池是什么？Tomcat 有多个线程来并发的处理同时接收到的多个请求，若这些线程争用一个数据库连接去访问数据库的话，效率十分低下。 数据库连接池，即存放多个数据库连接的“池塘”，让多个线程可以使用里面的数据库连接去执行 SQL 语句，执行完之后把连接放回池子里，后续还可以继续使用。 常见的数据库连接池有 DBCP、C3P0、Druid 等。 ","date":"2022-06-21","objectID":"/posts/mysql-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["MySQL"],"title":"MySQL 教程","uri":"/posts/mysql-%E6%95%99%E7%A8%8B/#2-数据库连接池是什么"},{"categories":["教程"],"content":" 3. MySQL 数据库中的连接池是什么？MySQL 内维护的与系统之间的多个数据库连接的“池塘”。 当系统每次跟 MySQL 建立连接时，进行账号密码的验证、库表权限的验证。 ","date":"2022-06-21","objectID":"/posts/mysql-%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":["MySQL"],"title":"MySQL 教程","uri":"/posts/mysql-%E6%95%99%E7%A8%8B/#3-mysql-数据库中的连接池是什么"},{"categories":["教程"],"content":" 4. MySQL 如何执行 SQL 语句？现在假设我们的数据库服务器的连接池中的某个连接接收到了网络请求，假设就是一条SQL语句，那么大家先思考一个问题， 谁负责从这个连接中去监听网络请求?谁负责从网络连接里把请求数据读取出来? 我想很多人恐怕都没思考过这个问题，但是如果大家对计算机基础知识有一个简单了解的话，应该或多或少知道一点，那就是 网络连接必须得分配给一个线程去进行处理，由一个线程来监听请求以及读取请求数据，比如从网络连接中读取和解析出来一 条我们的系统发送过去的SQL语句，如下图所示: 所以MySQL内部首先提供了一个组件，就是 SQL接口(SQL Interface)，他是一套执行SQL语句的接口，专门用于执行我们 发送给MySQL的那些增删改查的SQL语句 因此MySQL的工作线程接收到SQL语句之后，就会转交给SQL接口去执行，如下图。 MySQL自己本 身也是一个系统，是一个数据库管理系统，他没法直接理解这些SQL语句! 查询解析器(Parser) 就是负责对SQL语句进行解析的，比如对上面那个SQL语句进行一下拆解，拆解成以下几个部分: 我们现在要从“users”表里查询数据 查询“id”字段的值等于1的那行数据 对查出来的那行数据要提取里面的“id,name,age”三个字段。 当我们通过解析器理解了SQL语句要干什么之后，接着会找 查询优化器(Optimizer) 来选择一个最优的查询路径。 所以查询优化器大概就是干这个的，他会针对你编写的几十行、几百行甚至上千行的复杂SQL语句生成查询路径树，然后从里 面选择一条最优的查询路径出来。 最后一步，就是把查询优化器选择的最优查询路径，也就是你到底应该按照一个什么样的顺序和步骤去执行这个SQL语句的计 划，把这个计划交给底层的存储引擎去真正的执行。 但是存储引擎的话，他是支持各种各样的存储引擎的，比如我们常见的InnoDB、MyISAM、Memory等等，我们是可以选择 使用哪种存储引擎来负责具体的SQL语句执行的。 其实我们现在还漏了一个 执行器 的概念，这个执行器会根据优化器选择的执行方案，去调用存储引擎的接口按照一定的顺序和 步骤，就把SQL语句的逻辑给执行了。 执行器就会去根据我们的优化器生成的一套执行计划，然后不停的调用存储引擎的各种接口去完成SQL 语句的执行计划，大致就是不停的更新或者提取一些数据出来 ","date":"2022-06-21","objectID":"/posts/mysql-%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":["MySQL"],"title":"MySQL 教程","uri":"/posts/mysql-%E6%95%99%E7%A8%8B/#4-mysql-如何执行-sql-语句"},{"categories":["教程"],"content":" 5. InnoDB 存储引擎如何查询数据？InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是 缓冲池(Buffer Pool)，这里面会缓存很多的数据， 以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了。 ","date":"2022-06-21","objectID":"/posts/mysql-%E6%95%99%E7%A8%8B/:1:5","series":null,"tags":["MySQL"],"title":"MySQL 教程","uri":"/posts/mysql-%E6%95%99%E7%A8%8B/#5-innodb-存储引擎如何查询数据"},{"categories":["算法"],"content":" 1.区间重叠252. 会议室 按区间左端点升序排序。 若上个区间的右端点大于下个区间的左端点，则两区间重叠。 class Solution { public boolean canAttendMeetings(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); for (int i = 1; i \u003c intervals.length; i++) if (intervals[i - 1][1] \u003e intervals[i][0]) return false; return true; } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#1区间重叠"},{"categories":["算法"],"content":" 2.区间合并56. 合并区间 ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#2区间合并"},{"categories":["算法"],"content":" 2.1 排序 按区间左端点升序排序。 若两区间重叠则合并两个区间。 class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); int[][] ans = new int[intervals.length][2]; int index = -1; for (int[] interval : intervals) { if (index == -1 || interval[0] \u003e ans[index][1]) ans[++index] = interval; else ans[index][1] = Math.max(ans[index][1], interval[1]); } return Arrays.copyOf(ans, index + 1); } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:2:1","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#21-排序"},{"categories":["算法"],"content":" 2.2 位图 位图上的 1 表示在区间内，0 表示不在区间内。 将所有区间表示在位图上，最后每个连续的全 1 区间即为合并后的区间。 class Solution { public int[][] merge(int[][] intervals) { BitSet bitSet = new BitSet(); int maxRight = 0; for (int[] interval : intervals) { // 乘 2 为了使像 [1, 2] 和 [3, 4] 这样的区间不连续 // [1, 2] -\u003e [2, 4] // [3, 4] -\u003e [6, 8] int left = interval[0] * 2; int right = interval[1] * 2 + 1; bitSet.set(left, right); // [left, right) maxRight = Math.max(maxRight, right); } int left = 0; int len = 0; while (left \u003c maxRight) { // [left, right) left = bitSet.nextSetBit(left); // 下一个为 1 的位置 int right = bitSet.nextClearBit(left); // 下一个为 0 的位置 intervals[len][0] = left / 2; intervals[len][1] = right / 2; len++; left = right; } return Arrays.copyOf(intervals, len); } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:2:2","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#22-位图"},{"categories":["算法"],"content":" 3.插入区间57. 插入区间 按区间左端点升序排序。 二分查找待插入区间的左端点和右端点位置，合并这些区间。 class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { int n = intervals.length; // 1. 在 intervals 中查找最后一个右端点小于 newInterval 左端点的区间 // 该区间（包含）及之前的区间不用合并 int left = 0; int right = n; int mid; while (left \u003c right) { mid = left + (right - left) / 2; if (intervals[mid][1] \u003c newInterval[0]) left = mid + 1; else right = mid; } // 在 newInterval 之前最后一个不用合并的区间的下标 int start = right - 1; // 2. 在 intervals 中查找第一个左端点大于 newInterval 右端点的区间 // 该区间（包含）及之后的区间不用合并 left = 0; right = n; while (left \u003c right) { mid = left + (right - left) / 2; if (intervals[mid][0] \u003e newInterval[1]) right = mid; else left = mid + 1; } // 在 newInterval 之后第一个不用合并的区间的下标 int end = left; // 3. 合并区间 // [start + 1, end - 1] 区间内的区间需要合并成 1 个区间 int[][] ans = new int[(start + 1) + 1 + (n - end)][2]; int idx = 0; for (int i = 0; i \u003c= start; i++) ans[idx++] = intervals[i]; ans[idx][0] = newInterval[0]; ans[idx][1] = newInterval[1]; if (start + 1 \u003c n) // 需要合并 ans[idx][0] = Math.min(ans[idx][0], intervals[start + 1][0]); if (end - 1 \u003e= 0) // 需要合并 ans[idx][1] = Math.max(ans[idx][1], intervals[end - 1][1]); idx++; for (int i = end; i \u003c n; i++) ans[idx++] = intervals[i]; return ans; } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:3:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#3插入区间"},{"categories":["算法"],"content":" 4.删除区间435. 无重叠区间 按区间左端点升序排序。 当两个区间重叠时，我们选择右端点更小的那个区间。（贪心） class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); int ans = 0; int pre = 0; for (int i = 1; i \u003c intervals.length; i++) { if (intervals[i][0] \u003c intervals[pre][1]) { // 重叠 if (intervals[i][1] \u003c intervals[pre][1]) pre = i; // 被包含 ans++; } else pre = i; // 不重叠 } return ans; } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:4:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#4删除区间"},{"categories":["算法"],"content":" 5. 区间合并、插入、删除综合715. Range 模块 ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:5:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#5-区间合并插入删除综合"},{"categories":["算法"],"content":" 5.1 有序集合 随时保证有序集合中的区间不重叠。 插入区间 $[left, right)$： 二分查找最后一个 $l_i \\le left$，即 $l_i \\le left \u0026\u0026 l_{i+1} \\gt left$ 的区间 $[l_i, r_i)$ 若 若 若 若 删除区间[left, right)： class RangeModule { TreeMap\u003cInteger, Integer\u003e ranges = new TreeMap\u003c\u003e(); // {l=r} public void addRange(int left, int right) { Integer ll = ranges.floorKey(left); // 左侧区间的左端点 ll \u003c= left Integer rl = ranges.floorKey(right); // 右侧区间的左端点 rl \u003c= right // [ll, lr) 和 [left, right) 区间重叠 ll \u003c= left \u003c= lr (ll \u003c lr) if (ll != null \u0026\u0026 ranges.get(ll) \u003e= left) left = ll; // [left, right) 和 [rl, rr) 区间重叠 rl \u003c= right \u003c= rr (rl \u003c rr) if (rl != null \u0026\u0026 ranges.get(rl) \u003e= right) right = ranges.get(rl); // 将 [left, right) 向两端扩充为合并后的区间 ranges.put(left, right); // 迭代器删除被 [left, right) 包含的区间 var it = ranges.keySet().iterator(); while (it.hasNext()) { int l = it.next(); int r = ranges.get(l); if (left \u003c l \u0026\u0026 r \u003c= right) it.remove(); } } public boolean queryRange(int left, int right) { Integer ll = ranges.floorKey(left); // 左侧区间的左端点 ll \u003c= left // 若 ll \u003c= left \u003c right \u003c= lr，则返回 true return ll == null ? false : right \u003c= ranges.get(ll); } public void removeRange(int left, int right) { Integer ll = ranges.lowerKey(left); // 左侧区间的左端点 ll \u003c left Integer rl = ranges.lowerKey(right); // 右侧区间的左端点 rl \u003c right if (ll != null) { int lr = ranges.get(ll); if (lr \u003e right) { // 分割区间 ll \u003c left \u003c right \u003c lr ranges.put(ll, left); ranges.put(right, lr); } else if (lr \u003e left) { // 分割区间 ll \u003c left \u003c lr \u003c= right ranges.put(ll, left); } } if (rl != null) { int rr = ranges.get(rl); // 若 rl \u003c left，则 rl == ll，之前已经分割 if (rr \u003e right) { // 分割区间 left \u003c= rl \u003c right \u003c rr ranges.put(rl, right); // 减小区间，便于删除 ranges.put(right, rr); } } // 迭代器删除被 [left, right) 包含的区间 var it = ranges.keySet().iterator(); while (it.hasNext()) { int l = it.next(); int r = ranges.get(l); if (left \u003c= l \u0026\u0026 r \u003c= right) it.remove(); } } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:5:1","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#51-有序集合"},{"categories":["算法"],"content":" 参考 秒懂力扣区间题目：重叠区间、合并区间、插入区间 【C++】【高频考题】剑指 Offer II 074. 合并区间 题解：排序、扫描线基础题 - 合并区间 - 力扣（LeetCode） ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:6:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#参考"},{"categories":["算法"],"content":" 实战 ","date":"2022-06-16","objectID":"/posts/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":["算法","贪心算法"],"title":"算法-贪心算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/#实战"},{"categories":["力扣"],"content":"730. 统计不同回文子序列 ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/:0:0","series":null,"tags":["力扣","动态规划","三维DP"],"title":"力扣 0730 统计不同回文子序列","uri":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/#"},{"categories":["力扣"],"content":" 方法一：三维DP状态定义： dp[x][i][j]表示在字符串区间s[i:j]（包含j）中以字符x开头和结尾的不同回文序列数量。 则答案为求 $\\sum_{i=0}^Cdp[x_i][0][n-1] \\bmod 1000000007$，其中 $x_i \\in S$，$S$ 为字符串中出现的字符集合，$C$ 为该字符集合的大小。 状态转移方程： s[i]==x \u0026\u0026 s[j]==x时，s[i+1:j-1]中的回文序列加上s[i]和s[j]会构成新的以x开头和结尾的回文序列。再加上xx和x两个回文序列。 $$ dp[x][i][j]=2+\\sum_{k=0}^Cdp[x_k][i+1][j-1] $$ s[i]==x \u0026\u0026 s[j]!=x时 $$ dp[x][i][j]=dp[x][i][j-1] $$ s[i]!=x \u0026\u0026 s[j]==x时 $$ dp[x][i][j]=dp[x][i+1][j] $$ s[i]!=x \u0026\u0026 s[j]!=x时 $$ dp[x][i][j]=dp[x][i+1][j-1] $$ 边界条件： 当i==j \u0026\u0026 s[i]==x时，dp[x][i][j]=1 当i==j \u0026\u0026 s[i]!=x时，dp[x][i][j]=0 当i\u003ej时，dp[x][i][j]=0 代码实现： class Solution { static final int MOD = (int) 1e9 + 7; public int countPalindromicSubsequences(String s) { int n = s.length(); int[][][] dp = new int[4][n][n]; // 初始化边界条件 for (int i = 0; i \u003c n; i++) { dp[s.charAt(i) - 'a'][i][i] = 1; } // 遍历 i 和 j for (int step = 1; step \u003c n; step++) { for (int i = 0; i + step \u003c n; i++) { int j = i + step; int x1 = s.charAt(i) - 'a'; int x2 = s.charAt(j) - 'a'; // 状态转移 for (int x = 0; x \u003c 4; x++) { if (x1 == x \u0026\u0026 x2 == x) { dp[x][i][j] = 2; for (int k = 0; k \u003c 4; k++) { dp[x][i][j] = (dp[x][i][j] + dp[k][i + 1][j - 1]) % MOD; } } else if (x1 == x \u0026\u0026 x2 != x) { dp[x][i][j] = dp[x][i][j - 1]; } else if (x1 != x \u0026\u0026 x2 == x) { dp[x][i][j] = dp[x][i + 1][j]; } else { dp[x][i][j] = dp[x][i + 1][j - 1]; } } } } int ans = 0; for (int x = 0; x \u003c 4; x++) { ans = (ans + dp[x][0][n - 1]) % MOD; } return ans; } } 复杂度分析： 时间复杂度：$ O(C^2 \\times n^2) $ 空间复杂度：$ O(C \\times n^2) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/:1:0","series":null,"tags":["力扣","动态规划","三维DP"],"title":"力扣 0730 统计不同回文子序列","uri":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/#方法一三维dp"},{"categories":["力扣"],"content":"69. x 的平方根 ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#"},{"categories":["力扣"],"content":" 方法一：数学 $\\sqrt{x}=x^{\\frac{1}{2}}=(e^{\\ln x})^{\\frac{1}{2}}=e^{\\frac{1}{2}\\ln x}$ 由于计算机无法存储浮点数的精确值，因此运算过程中会存在误差。例如当 $x = 2147395600$ 时的计算结果与正确值 $46340$ 相差 $10^{-11}$，这样在对结果取整数部分时，会得到 $46339$ 这个错误的结果。 class Solution { public int mySqrt(int x) { if (x == 0) return 0; int ans = (int) Math.exp(0.5 * Math.log(x)); return (long) (ans + 1) * (ans + 1) \u003c= x ? ans + 1 : ans; } } 时间复杂度：$ O(1) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:1:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#方法一数学"},{"categories":["力扣"],"content":" 方法二：二分查找 public class Solution { public int mySqrt(int x) { int left = 0; int right = x; while (left \u003c= right) { int mid = left + (right - left) / 2; if ((long) mid * mid \u003c= x) left = mid + 1; else right = mid - 1; } return right; } } 时间复杂度：$ O(\\log x) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:2:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#方法二二分查找"},{"categories":["力扣"],"content":" 方法三：牛顿迭代法 由 $\\sqrt{x} = z$ 得 $z^2-x=0 \\ (z\u003e0)$，则 $z$ 为 $f(z)=z^2-x$ 的零点。 我们任取一个 $z_0$ 作为初始值。 在每一步的迭代中，我们找到函数图像上的点 $(z_i, f(z_i))$，过该点作一条斜率为该点导数 $f’(z_i)=2z_i$ 的直线 $$g(z)=2z_i(z-z_i)+f(z_i)=2z_iz-z_i^2-x$$ 该直线与 x 轴的交点为 $(z_{i+1},0)$，即 $(\\frac{x+z_i^2}{2z_i},0)$。 经过多次迭代后，$z_i$ 会逐渐接近零点。 class Solution { public int mySqrt(int x) { if (x == 0) return 0; double z0 = x; while (true) { double zi = (x + z0 * z0) / (2 * z0); if (Math.abs(z0 - zi) \u003c 1e-7) break; z0 = zi; } return (int) z0; } } 时间复杂度：$ O(\\log x) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:3:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#方法三牛顿迭代法"},{"categories":["算法"],"content":" 1.基础","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#1基础"},{"categories":["算法"],"content":" 水塘抽样$$ \\begin{aligned} P \u0026= P(第i个节点的值成为最后被返回的值) \\newline \u0026= P(第i次随机选择的值=0) \\times P(第i+1次随机选择的值 \\ne 0) \\times \\cdots \\times P(第n次随机选择的值 \\ne 0) \\newline \u0026= \\frac{1}{i} \\times (1-\\frac{1}{i+1}) \\times \\cdots \\times (1-\\frac{1}{n}) \\newline \u0026= \\frac{1}{i} \\times \\frac{i}{i+1} \\times \\cdots \\times \\frac{n-1}{n} \\newline \u0026= \\frac{1}{n} \\end{aligned} $$ ","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:1:1","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#水塘抽样"},{"categories":["算法"],"content":" 2.实战","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#2实战"},{"categories":["算法"],"content":" 非重叠矩形中的随机点497. 非重叠矩形中的随机点 ","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:2:1","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#非重叠矩形中的随机点"},{"categories":["算法"],"content":" 链表随机节点382. 链表随机节点 水塘抽样 class Solution { ListNode head; public Solution(ListNode head) { this.head = head; } public int getRandom() { int len = 1; int ans = 0; for (ListNode p = head; p != null; p = p.next) { if ((int) (Math.random() * len) == 0) // 1 / i 的概率选中 ans = p.val; len++; } return ans; } } ","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:2:2","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#链表随机节点"},{"categories":["算法"],"content":" 1.介绍 前缀和数组长度为原数组长度加 1 nums[left] + nums[left + 1] + ... + nums[right] = prefixSum[right + 1] - prefixSum[left] $$ \\sum_{i=left}^{right}nums[i]=prefixSum[right + 1]-prefixSum[left] $$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:1:0","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#1介绍"},{"categories":["算法"],"content":" 2.结果 1 2 3 4 5 // nums 0 1 3 6 10 15 // prefixSum ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:2:0","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#2结果"},{"categories":["算法"],"content":" 3.代码 int[] getPrefixSum(int[] nums) { int n = nums.length; int[] prefixSum = new int[n + 1]; for (int i = 0; i \u003c n; i++) { prefixSum[i + 1] = prefixSum[i] + nums[i]; } return prefixSum; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:3:0","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#3代码"},{"categories":["算法"],"content":" int[] getDiff(int[] nums) { int n = nums.length; for (int i = n; i \u003e 0; i--) { nums[i] -= nums[i - 1]; } return nums; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%B7%AE%E5%88%86/:0:0","series":null,"tags":null,"title":"算法-差分","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%B7%AE%E5%88%86/#"},{"categories":["算法"],"content":" int[] getMonoStack(int[] nums) { int n = nums.length; int[] ans = new int[n]; Deque\u003cInteger\u003e stack = new LinkedList\u003c\u003e(); // for (int i = 0; i \u003c n; i++) { // 左侧 for (int i = n - 1; i \u003e= 0; i--) { // 右侧 // 第一个大于等于的元素 stack.peek() \u003c nums[i] // 第一个更大的元素 stack.peek() \u003c= nums[i] // 第一个小于等于的元素 stack.peek() \u003e nums[i] // 第一个更小的元素 stack.peek() \u003e= nums[i] if (!stack.isEmpty() \u0026\u0026 stack.peek() \u003c nums[i]) { stack.pop(); } ans[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(nums[i]); } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:0:0","series":null,"tags":null,"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#"},{"categories":["数据结构"],"content":" 一棵 n 个节点的树，有 n-1 条边。 一棵 n 个节点的树，有 n 棵子树。 根节点：唯一，无入度的节点 节点的深度：节点距离根节点的距离。 typedef struct treeNode { treeNode(int x): value(x) {} int value; vector\u003ctreeNode*\u003e child; } TreeNode; class TreeNode { public int val; public TreeNode[] children; TreeNode() { this.val = 0; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/#"},{"categories":["算法"],"content":" 结果集合 def backtrack(当前路径, 可选择列表): if 可选择列表为空: 结果集合添加当前路径 return for 当前选择 in 可选择列表: 当前路径添加当前选择 可选择列表删除当前选择 backtrack(当前路径, 可选择列表) 当前路径撤销当前选择 可选择列表添加当前选择 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:0","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#"},{"categories":["算法"],"content":" 排列\u0026组合\u0026子集问题 无重复元素\u0026元素不可重复选择子集 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param nums 元素唯一的数组 * @return 所有子集的集合 */ List\u003cList\u003cInteger\u003e\u003e subsets(int[] nums) { dfs(nums, 0); return ans; } /** * @param nums 元素唯一的数组 * @param start 可选择元素范围[start, nums.length) */ void dfs(int[] nums, int start) { // 前序添加 ans.add(new LinkedList\u003c\u003e(set)); for (int i = start; i \u003c nums.length; i++) { set.add(nums[index]); dfs(nums, i + 1); // 回溯 set.pollLast(); } } 组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param n 元素范围[1, n] * @param k 组合中元素个数 * @return 所有长度为 k 的组合的集合 */ List\u003cList\u003cInteger\u003e\u003e combine(int n, int k) { dfs(n, k, 0); return ans; } /** * @param n 元素范围[1, n] * @param k 组合中元素个数 * @param start 可选择元素范围[start, n] */ void dfs(int n, int k, int start) { if (set.size() == k) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = start; i \u003c= n; i++) { set.add(i); dfs(n, k, i + 1); // 回溯 set.pollLast(); } } 排列 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); boolean[] vis; /** * @param nums 元素唯一的数组 * @return 所有排列的集合 */ List\u003cList\u003cInteger\u003e\u003e permute(int[] nums) { vis = new boolean[nums.length]; dfs(nums); return ans; } /** * @param nums 元素唯一的数组 */ void dfs(int[] nums) { int n = nums.length; if (set.size() == n) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = 0; i \u003c n; i++) { // 防止重复选 if (!vis[i]) { vis[i] = true; set.add(nums[i]); dfs(nums); // 回溯 set.pollLast(); vis[i] = false; } } } 无重复元素\u0026元素可以重复选择组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); /** * @param candidates 无重复元素的数组 * @param target 目标和 * @return 所有和为 target 的组合的集合（元素可重复） */ List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, 0, 0); return ans; } /** * @param candidates 有序数组 * @param target 目标和 * @param start 可选择元素范围[start, candidates.length) * @param sum 当前元素和 */ void dfs(int[] candidates, int target, int start, i","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#排列组合子集问题"},{"categories":["算法"],"content":" 排列\u0026组合\u0026子集问题 无重复元素\u0026元素不可重复选择子集 List","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#无重复元素元素不可重复选择"},{"categories":["算法"],"content":" 排列\u0026组合\u0026子集问题 无重复元素\u0026元素不可重复选择子集 List","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#无重复元素元素可以重复选择"},{"categories":["算法"],"content":" 排列\u0026组合\u0026子集问题 无重复元素\u0026元素不可重复选择子集 List","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#有重复元素元素不可重复选择"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#jarvis-算法"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#graham-算法"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#andrew-算法"},{"categories":["算法"],"content":" 1.介绍 快速求x的n次幂。 时间复杂度：$O(\\log n)$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:1:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#1介绍"},{"categories":["算法"],"content":" 2.迭代写法 static double fastPow(double x, int n) { if (x == 0) return 0; if (x == 1) return 1; // 防止 n = -214748328 时，-n 溢出 long nn = n; if (nn \u003c 0) { x = 1 / x; nn = -nn; } double ans = 1.0; while (nn \u003e 0) { if ((nn \u0026 1) == 1) ans *= x; // nn % 2 == 1 x *= x; nn \u003e\u003e= 1; // nn /= 2; } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:2:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#2迭代写法"},{"categories":["算法"],"content":" 3.递归写法 static double fastPow(double x, int n) { if (x == 0) return 0; if (x == 1) return 1; // 防止 n = -214748328 时，-n 溢出 long nn = n; if (nn \u003c 0) { x = 1 / x; nn = -nn; } return fastPow(x, nn); } static double fastPow(double x, long n) { if (n == 0) return 1; if (n == 1) return x; double half = fastPow(x, n \u003e\u003e 1); if ((n \u0026 1) == 1) return half * half * x; else return half * half; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:3:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#3递归写法"},{"categories":["算法"],"content":" 4.矩阵快速幂 static int[][] fastPow(int[][] mat, int n) { if (n == 0) return mat; // 单位矩阵 int m = mat.length; int[][] ans = new int[m][m]; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c m; j++) if (i == j) ans[i][j] = 1; while (n \u003e 0) { if ((n \u0026 1) == 1) ans = matMul(ans, mat); mat = matMul(mat, mat); n \u003e\u003e= 1; } return ans; } static int[][] matMul(int[][] a, int[][] b) { // [m, h] * [h, n] -\u003e [m, n] int m = a.length; int h = a[0].length; int h1 = b.length; int n = b[0].length; if (h != h1) return null; int[][] ans = new int[m][n]; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c n; j++) for (int k = 0; k \u003c h; k++) ans[i][j] += a[i][k] * b[k][j]; return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:4:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#4矩阵快速幂"},{"categories":["算法"],"content":" 5.实战 372. 超级次方 50. Pow(x, n) ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:5:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#5实战"},{"categories":["算法"],"content":" 窗口大小可任意调整 // 窗口大小可任意调整 int left = 0; int right = 0; int ans = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 while (condition) { // 约束值满足调整窗口的条件 // 缩小窗口 // 左端点 left 操作 // 修改约束值 left++; } ans = Math.max(ans, right - left + 1); right++; } 窗口大小单调递增 // 窗口大小单调递增 int left = 0; int right = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 if (condition) { // 约束值满足调整窗口的条件 // 此时左端点移动最多使窗口大小不变 // 左端点 left 操作 // 修改约束值 left++; } right++; } int ans = right - left; ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","series":null,"tags":null,"title":"算法-滑动窗口","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#"},{"categories":["算法"],"content":" 窗口大小可任意调整 // 窗口大小可任意调整 int left = 0; int right = 0; int ans = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 while (condition) { // 约束值满足调整窗口的条件 // 缩小窗口 // 左端点 left 操作 // 修改约束值 left++; } ans = Math.max(ans, right - left + 1); right++; } 窗口大小单调递增 // 窗口大小单调递增 int left = 0; int right = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 if (condition) { // 约束值满足调整窗口的条件 // 此时左端点移动最多使窗口大小不变 // 左端点 left 操作 // 修改约束值 left++; } right++; } int ans = right - left; ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","series":null,"tags":null,"title":"算法-滑动窗口","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#窗口大小可任意调整"},{"categories":["算法"],"content":" 窗口大小可任意调整 // 窗口大小可任意调整 int left = 0; int right = 0; int ans = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 while (condition) { // 约束值满足调整窗口的条件 // 缩小窗口 // 左端点 left 操作 // 修改约束值 left++; } ans = Math.max(ans, right - left + 1); right++; } 窗口大小单调递增 // 窗口大小单调递增 int left = 0; int right = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 if (condition) { // 约束值满足调整窗口的条件 // 此时左端点移动最多使窗口大小不变 // 左端点 left 操作 // 修改约束值 left++; } right++; } int ans = right - left; ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","series":null,"tags":null,"title":"算法-滑动窗口","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#窗口大小单调递增"},{"categories":["算法"],"content":"找出游戏的获胜者 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:0:0","series":null,"tags":["算法"],"title":"算法-约瑟夫环","uri":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/#"},{"categories":["算法"],"content":" 原理倒推法 还剩1个人，此人获胜，下标为 $$f(1,k)=0$$ 还剩2个人，淘汰第k个人，即淘汰下标(k-1)%2，下次从k%2开始，则获胜者下标为 $$f(2,k)=(f(1,k)+k)\\mod 2=(0+k)\\mod 2$$ 还剩3个人，淘汰第k个人，即淘汰下标(k-1)%3，下次从k%3开始，则获胜者下标为 $$f(3,k)=(f(2,k)+k)\\mod 3=((0+k)\\mod 2+k)\\mod 3$$ … n个人，淘汰第k个人，即淘汰下标(k-1)%n，下次从k%n开始，则获胜者下标为 $$f(n,k)=(f(n-1,k)+k)\\bmod{n}=(\\cdots((0+k)\\bmod{2}+k)\\bmod{3}\\cdots)\\bmod{n}$$ int findTheWinner(int n, int k) { int ans = 0; for (int i = 2; i \u003c= n; i++) { ans = (ans + k) % i; } return ans + 1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:1:0","series":null,"tags":["算法"],"title":"算法-约瑟夫环","uri":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/#原理"},{"categories":["算法"],"content":" 1.基础 要求序列非递减，即nums[i - 1] \u003c= nums[i] 时间复杂度：$O(\\log n)$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:1:0","series":null,"tags":["算法","二分搜索"],"title":"算法-二分搜索","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/#1基础"},{"categories":["算法"],"content":" 2.等于指定值的下标 返回值： 返回数组中等于指定值的元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; binarySearch(nums, 3); // -1 binarySearch(nums, 4); // 0 binarySearch(nums, 5); // 1 或 2 binarySearch(nums, 6); // 3 binarySearch(nums, 7); // 4 binarySearch(nums, 8); // -1 闭区间写法： static int binarySearch(int[] nums, int target) { // 二分查找等于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid - 1; } return -1; } 左闭右开写法： static int binarySearch(int[] nums, int target) { // 二分查找等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid; } return -1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:2:0","series":null,"tags":["算法","二分搜索"],"title":"算法-二分搜索","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/#2等于指定值的下标"},{"categories":["算法"],"content":" 3.第一个大于指定值的下标 返回值： 返回数组中大于指定值的最小元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; higher(nums, 3); // 0 higher(nums, 4); // 1 higher(nums, 5); // 3 higher(nums, 6); // 4 higher(nums, 7); // 5 higher(nums, 8); // 5 闭区间写法： static int higher(int[] nums, int target) { // 二分查找第一个大于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e target) right = mid - 1; else left = mid + 1; } return left; } 左闭右开写法： static int higher(int[] nums, int target) { // 二分查找第一个大于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e target) right = mid; else left = mid + 1; } return left; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:3:0","series":null,"tags":["算法","二分搜索"],"title":"算法-二分搜索","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/#3第一个大于指定值的下标"},{"categories":["算法"],"content":" 4.第一个大于等于指定值的下标 返回值： 返回数组中大于等于指定值的最小元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; ceiling(nums, 3); // 0 ceiling(nums, 4); // 0 ceiling(nums, 5); // 1 ceiling(nums, 6); // 3 ceiling(nums, 7); // 4 ceiling(nums, 8); // 5 闭区间写法： static int ceiling(int[] nums, int target) { // 二分查找第一个大于等于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e= target) right = mid - 1; else left = mid + 1; } return left; } 左闭右开写法： static int ceiling(int[] nums, int target) { // 二分查找第一个大于等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e= target) right = mid; else left = mid + 1; } return left; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:4:0","series":null,"tags":["算法","二分搜索"],"title":"算法-二分搜索","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/#4第一个大于等于指定值的下标"},{"categories":["算法"],"content":" 5.最后一个小于指定值的下标 返回值： 返回数组中小于指定值的最大元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; lower(nums, 3); // -1 lower(nums, 4); // -1 lower(nums, 5); // 0 lower(nums, 6); // 2 lower(nums, 7); // 3 lower(nums, 8); // 4 闭区间写法： static int lower(int[] nums, int target) { // 二分查找第一个小于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) left = mid + 1; else right = mid - 1; } return right; } 左闭右开写法： static int lower(int[] nums, int target) { // 二分查找第一个小于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) left = mid + 1; else right = mid; } return right - 1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:5:0","series":null,"tags":["算法","二分搜索"],"title":"算法-二分搜索","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/#5最后一个小于指定值的下标"},{"categories":["算法"],"content":" 6.最后一个小于等于指定值的下标 返回值： 返回数组中小于等于指定值的最大元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; floor(nums, 3); // -1 floor(nums, 4); // 0 floor(nums, 5); // 2 floor(nums, 6); // 3 floor(nums, 7); // 4 floor(nums, 8); // 4 闭区间写法： static int floor(int[] nums, int target) { // 二分查找最后一个小于等于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= target) left = mid + 1; else right = mid - 1; } return right; } 左闭右开写法： static int floor(int[] nums, int target) { // 二分查找最后一个小于等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= target) left = mid + 1; else right = mid; } return right - 1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:6:0","series":null,"tags":["算法","二分搜索"],"title":"算法-二分搜索","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/#6最后一个小于等于指定值的下标"},{"categories":["算法"],"content":" 7.总结 闭区间 vs 左闭右开： // 闭区间 int right = nums.length - 1; while (left \u003c= right) right = mid - 1; // 左闭右开 int right = nums.length; while (left \u003c right) right = mid; 大于等于 vs 小于等于 vs 大于 vs 小于： // 大于等于 if (nums[mid] \u003e= target) // right return left; // 小于等于 if (nums[mid] \u003c= target) // left return right; // 闭区间 return right - 1; // 左闭右开 // 大于 if (nums[mid] \u003e target) // right return left; // 小于 if (nums[mid] \u003c target) // left return right; // 闭区间 return right - 1; // 左闭右开 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:7:0","series":null,"tags":["算法","二分搜索"],"title":"算法-二分搜索","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/#7总结"},{"categories":["数据结构"],"content":"MySQL 的索引采用这种数据结构。一棵 $m$ 阶的B+树需满足下列条件： 每个分支结点最多有 $m$ 棵子树。 非叶根结点至少有两棵子树，其他每个分支结点至少有 $\\lceil \\frac{m}{2} \\rceil$ 棵子树。 每个结点的子树个数与关键字个数相等。 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字从小到大排序，并且相邻叶结点从小到大相互链接起来。 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。 查找 B+树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。所以，在B+树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。 B+树与B树的差异 在B+树中，具有n个关键字的结点含有n棵子树；而在B树中，具有n个关键字的结点含有n+1棵子树。 在B+树中，每个结点的关键字个数n的范围是 $\\lceil \\frac{m}{2} \\rceil \\le n \\le m$（根结点：$1 \\le n \\le m$）；在B树中，每个结点的关键字个数n的范围是 $\\lceil \\frac{m}{2} \\rceil-1 \\le n \\le m-1$（根结点：$1 \\le n \\le m-1$)。 在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点（最外层内部结点）包含的关键字和其他结点包含的关键字是不重复的。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b+%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-B+树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b+%E6%A0%91/#"},{"categories":["数据结构"],"content":"又称多路平衡查找树，规定B树的阶 $m$ 为每个结点的最大孩子数量。 每个结点最多 $m$ 个孩子。 若根结点不是叶结点，则至少有两个孩子。 除根结点外，每个非叶结点至少有 $\\lceil \\frac{m}{2} \\rceil$ 个孩子。 结点中关键字从小到大排序，关键字两侧为指向孩子的指针。 关键字左侧指针指向的子树中的关键字均小于该关键字，右侧则大于。 所有叶结点在同一层，不存储信息（空结点）。 高度 对任意一棵包含 $n$ 个关键字、高度为 $h$、阶数为 $m$ 的B树（不考虑空的叶结点）： 下界：每层关键字越多，则高度越矮。B树中每个结点最多有 $m$ 棵子树，$m-1$ 个关键字，所以 $$ \\begin{align} n\u0026\\le(m-1)(1+m+m^2+\\cdots+m^{h-1})=m^h-1 \\\\ h\u0026\\ge\\log_m(n+1) \\end{align} $$ 上界：每层关键字越少，则高度越高。B树中根结点最少1个关键字，非叶结点最少 $\\lceil \\frac{m}{2} \\rceil$ 棵子树， $\\lceil \\frac{m}{2} \\rceil-1$ 个关键字，所以 $$ \\begin{align} n\u0026\\ge1+2\\times(\\lceil \\frac{m}{2} \\rceil-1)(1+\\lceil \\frac{m}{2} \\rceil+\\lceil \\frac{m}{2} \\rceil^2+\\cdots+\\lceil \\frac{m}{2} \\rceil^{h-2})=2\\times\\lceil \\frac{m}{2} \\rceil^{h-1}-1 \\\\ h\u0026\\le\\log_{\\lceil \\frac{m}{2} \\rceil}(\\frac{n+1}{2})+1 \\end{align} $$ 查找 查找结点。将结点信息读入内存。 结点中查找关键字。在结点关键字表中二分查找，未找到则查找对应子树。 若子树为空，则查找失败。 插入 定位。利用查找算法，找出插入该关键字的最底层中的某个非叶结点。 插入。除了根结点，每个结点的关键字个数都在区间 $[\\lceil \\frac{m}{2} \\rceil-1,m-1]$ 内。若插入后的结点关键字个数在范围内，则可以直接插入，否则必须对结点进行分裂。 分裂。将待分裂结点从中间位置（$\\lceil \\frac{m}{2} \\rceil$）将其中的关键宇分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（$\\lceil \\frac{m}{2} \\rceil$）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。 删除 定位。 删除。 借位。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-B树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b%E6%A0%91/#"},{"categories":["数据结构"],"content":"LFU (Least Frequently Used) class Node { int key, value; Node prev, next; public Node (int key, int value) { this.key = key; this.value = value; } } class BiLinkedList { final Node head, tail; int length; public BiLinkedList() { this.head = new Node(0, 0); this.tail = new Node(0, 0); this.length = 0; head.next = tail; tail.prev = head; } public void addLast(Node node) { node.prev = tail.prev; node.next = tail; tail.prev.next = node; tail.prev = node; length++; } public void remove(Node node) { if (node.prev == null || node.next == null) { return; } node.prev.next = node.next; node.next.prev = node.prev; length--; } public void removeFirst() { if (length == 0) { return; } head.next.next.prev = head; head.next = head.next.next; length--; } } class LFUCache { HashMap\u003cInteger, Node\u003e keyToNode; HashMap\u003cInteger, Integer\u003e keyToFreq; HashMap\u003cInteger, BiLinkedList\u003e freqToNodes; final int capacity; int length; int minFreq; public LFUCache(int capacity) { this.keyToNode = new HashMap\u003c\u003e(); this.keyToFreq = new HashMap\u003c\u003e(); this.freqToNodes = new HashMap\u003c\u003e(); this.capacity = capacity; this.length = 0; this.minFreq = -1; } public int get(int key) { if (keyToNode.containsKey(key)) { Node node = keyToNode.get(key); // 更新频率 int freq = keyToFreq.get(key); keyToFreq.put(key, freq + 1); // 删除结点 freqToNodes.get(freq).remove(node); // 添加结点 if (freqToNodes.containsKey(freq + 1)) { freqToNodes.get(freq + 1).addLast(node); } else { BiLinkedList list = new BiLinkedList(); list.addLast(node); freqToNodes.put(freq + 1, list); } // 更新 minFreq if (freq == minFreq) { while (freqToNodes.get(minFreq).length == 0) { minFreq++; } } return node.value; } else { return -1; } } public void put(int key, int value) { if (keyToNode.containsKey(key)) { // 更新值 Node node = keyToNode.get(key); node.value = value; // 更新频率 int freq = keyToFreq.get(key); keyToFreq.put(key, freq + 1); // 删除结点 freqToNodes.get(freq).remove(node); // 添加结点 if (freqToNodes.containsKey(freq + 1)) { freqToNodes.get(freq + 1).addLast(node); } else { BiLinkedList list = new BiLinkedList(","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lfu/:0:0","series":null,"tags":null,"title":"数据结构-LFU","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lfu/#"},{"categories":["数据结构"],"content":"LRU (Least Recently Used) 最近最少使用算法。当容量满时，将最久没有使用过的缓存删除。 class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class BiLinkedList { final Node head, tail; final int capacity; int length; public BiLinkedList(int capacity) { this.capacity = capacity; length = 0; head = new Node(0, 0); tail = new Node(0, 0); head.next = tail; tail.prev = head; } /** * 将结点加入双向链表的尾部 * * @param node 待加入结点 */ public void addLast(Node node) { node.prev = tail.prev; node.next = tail; node.prev.next = node; tail.prev = node; length++; } /** * 将 node 从双向链表中删除 * * @param node 待加入结点 */ public void remove(Node node) { node.prev.next = node.next; node.next.prev = node.prev; length--; } /** * 将双向链表的第一个结点删除 */ public void removeFirst() { if (length == 0) { return; } head.next = head.next.next; head.next.prev = head; length--; } } class LRUCache { private BiLinkedList list; private HashMap\u003cInteger, Node\u003e keyToNode; public LRUCache(int capacity) { list = new BiLinkedList(capacity); keyToNode = new HashMap\u003c\u003e(); } public int get(int key) { if (keyToNode.containsKey(key)) { Node node = keyToNode.get(key); list.remove(node); list.addLast(node); return node.val; } else { return -1; } } public void put(int key, int value) { if (keyToNode.containsKey(key)) { Node node = keyToNode.get(key); node.val = value; list.remove(node); list.addLast(node); } else { if (list.length == list.capacity) { keyToNode.remove(list.head.next.key); list.removeFirst(); } Node node = new Node(key, value); keyToNode.put(key, node); list.addLast(node); } } } class LRUCache { private LinkedHashMap\u003cInteger, Integer\u003e map; private int capacity; public LRUCache(int capacity) { map = new LinkedHashMap\u003c\u003e(); this.capacity = capacity; } public int get(int key) { int val = map.getOrDefault(key, -1); if (map.containsKey(key)) { map.remove(key); map.put(key, val); } return val; } public void put(int key, int value) { map.remove(key); map.put(key, value); if (map.size() \u003e this.capacity) { map.remove(map.keySet().iterator().next()); } } }","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/:0:0","series":null,"tags":null,"title":"数据结构-LRU","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/#"},{"categories":["数据结构"],"content":"Balanced Binary Search Tree，BBST 通过旋转来保持树的平衡。 class TreeNode { int val; TreeNode left, right; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-AVL树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl%E6%A0%91/#"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#性质"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#自平衡"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#插入"},{"categories":["数据结构"],"content":" 1. 介绍线段树是常用的用来维护区间信息的数据结构，在区间动态修改的同时还能够高效查询区间信息。 功能： 单点修改 第i个元素增加x 第i个元素减少x 第i个元素修改为x 区间修改 区间[i, j]中的元素都增加x 区间[i, j]中的元素都减少x 区间[i, j]中的元素都修改为x 区间查询 查询区间[i, j]中的元素和 查询区间[i, j]中的元素最大值 查询区间[i, j]中的元素最小值 查询区间[i, j]中的元素最大公因数 结构： 每个结点代表一个区间，结点的值根据问题进行定义（区间和、区间最大值等）。 结点的左右孩子平分父结点的区间。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:1:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#1-介绍"},{"categories":["数据结构"],"content":" 2. 实现","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#2-实现"},{"categories":["数据结构"],"content":" 2.1 基于链表实现 结点定义 class Node { int val; Node left, right; public Node() {} public Node(int val) { this.val = val; } } 建树 void buildTree(Node node, int start, int end) { // } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:1","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#21-基于链表实现"},{"categories":["数据结构"],"content":" 2.2 基于数组实现 class SegmentTree { private int[] tree; // 维护区间 private int[] lazy; // 惰性标记，维护修改值 public SegmentTree(int[] nums) { int n = nums.length; // 线断树有 n 个叶结点，总结点个数设为 x // 非叶结点都有 2 棵子树，则 // x - 1 = (x - n) * 2 // x = 2 * n - 1 // 根结点索引从 1 开始 tree = new int[n * 2]; lazy = new int[n * 2]; build(nums, 0, nums.length - 1, 1); } void build(int[] nums, int left, int right, int root) { // 对 [left, right] 区间建立线段树,当前根的编号为 root if (left == right) { // 叶结点 tree[root] = nums[left]; return; } // + 优先级高于 \u003e\u003e int mid = left + ((right - left) \u003e\u003e 1); build(nums, left, mid, root \u003c\u003c 1); // root * 2 // \u003c\u003c 优先级高于 | build(nums, mid + 1, right, root \u003c\u003c 1 | 1); // root * 2 + 1 // 子树信息更新父结点信息 tree[root] = tree[root \u003c\u003c 1] + tree[root \u003c\u003c 1 | 1]; } int rangeSum(int qLeft, int qRight, int left, int right, int root) { // 查询区间 [qLeft, qRight] 的元素总和 if (qLeft \u003c= left \u0026\u0026 right \u003c= qRight) { // 当前区间是查询区间的子区间 return tree[root]; } pushDown(left, right, root); int mid = left + ((right - left) \u003e\u003e 1); int sum = 0; if (qLeft \u003c= mid) { sum += rangeSum(qLeft, qRight, left, mid, root \u003c\u003c 1); } if (mid \u003c qRight) { sum += rangeSum(qLeft, qRight, mid + 1, right, root \u003c\u003c 1 | 1); } return sum; } void update(int qLeft, int qRight, int val, int left, int right, int root) { // 将区间 [qLeft, qRight] 内的元素加 val if (qLeft \u003c= left \u0026\u0026 right \u003c= qRight) { tree[root] += val * (right - left + 1); // 不必此时修改到叶结点，将修改值记录到父结点的 lazy 标记 // 下次查询到需要修改的叶结点时再修改 lazy[root] += val; return; } pushDown(left, right, root); int mid = left + ((right - left) \u003e\u003e 1); if (qLeft \u003c= mid) { update(qLeft, qRight, val, left, mid, root \u003c\u003c 1); } if (mid \u003c qRight) { update(qLeft, qRight, val, mid + 1, right, root \u003c\u003c 1 | 1); } tree[root] = tree[root \u003c\u003c 1] + tree[root \u003c\u003c 1 | 1]; } private void pushDown(int left, int right, int root) { // lazy 标记处理 int mid = left + ((right - left) \u003e\u003e 1); if (lazy[root] \u003e 0 \u0026\u0026 left \u003c right) { // 如果当前节点的 lazy 标记非空，则更新当前节点两个子节点的值和 lazy 标记 tree[root \u003c\u003c 1] += lazy[root] * (mid - left + 1); tree[root \u003c\u003c 1 | 1] += lazy[root] * (right - mid); lazy[root \u003c\u003c 1] += lazy[root]; lazy[roo","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:2","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#22-基于数组实现"},{"categories":["数据结构"],"content":" 3. 分析 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:3:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#3-分析"},{"categories":["数据结构"],"content":" 参考 线段树详解「汇总级别整理 🔥🔥🔥」 - 我的日程安排表 I - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:4:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#参考"},{"categories":["数据结构"],"content":"树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i \u003c n - 1; i++) { add(i, nums[i]); } } public void add(int index, int val) { // 下标从 1 开始 index++; // 单点修改，增加数组 index 元素的值 while (index \u003c n) { tree[index] += val; // 更新父结点 index += lowBit(index); } } public int preSum(int index) { // 查询前缀和 int sum = 0; while (index \u003e 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":null,"title":"数据结构-树状数组","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#"},{"categories":["数据结构"],"content":"树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i \u003c n - 1; i++) { add(i, nums[i]); } } public void add(int index, int val) { // 下标从 1 开始 index++; // 单点修改，增加数组 index 元素的值 while (index \u003c n) { tree[index] += val; // 更新父结点 index += lowBit(index); } } public int preSum(int index) { // 查询前缀和 int sum = 0; while (index \u003e 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":null,"title":"数据结构-树状数组","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#查询前缀和"},{"categories":["数据结构"],"content":"树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i \u003c n - 1; i++) { add(i, nums[i]); } } public void add(int index, int val) { // 下标从 1 开始 index++; // 单点修改，增加数组 index 元素的值 while (index \u003c n) { tree[index] += val; // 更新父结点 index += lowBit(index); } } public int preSum(int index) { // 查询前缀和 int sum = 0; while (index \u003e 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":null,"title":"数据结构-树状数组","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#复杂度分析"},{"categories":["数据结构"],"content":" 1.介绍前缀树，又称字典树（Trie） ，是一种特殊的 N 叉树。 前缀树用来存储字符串，每条边代表一个字符。每一个节点会有多个子节点，则通往不同子节点的路径上有着不同的字符。 从根节点通往某节点路径上所有的字符组成对应的字符串。 根节点表示空字符串。 节点所有的后代都与该节点相关的字符串有着共同的前缀。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:1:0","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#1介绍"},{"categories":["数据结构"],"content":" 2.实现数组： 优点：访问结点快速。 缺点：空间浪费。通过下标访问结点。 哈希表： 优点：通过字符访问结点。节约空间。 缺点：速度稍慢。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:2:0","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#2实现"},{"categories":["数据结构"],"content":" 3.代码","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:0","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#3代码"},{"categories":["数据结构"],"content":" 3.1 数组 class TrieNode { boolean isEnd = false; TrieNode[] next = new TrieNode[26]; } class Trie { TrieNode root; public Trie() { root = new TrieNode(); } public void insert(String s) { // 插入字符串 TrieNode p = root; for (char c : s.toCharArray()) { int i = c - 'a'; if (p.next[i] == null) p.next[i] = new TrieNode(); p = p.next[i]; } p.isEnd = true; } public boolean search(String s) { // 查找字符串 s 是否在树中 TrieNode p = root; for (char c : s.toCharArray()) { if (p.next[c - 'a'] == null) return false; p = p.next[c - 'a']; } return p.isEnd; } public boolean startsWith(String s) { // 查找是否存在前缀字符串 s TrieNode p = root; for (char c : s.toCharArray()) { if (p.next[c - 'a'] == null) return false; p = p.next[c - 'a']; } return true; } } 时间复杂度：字符串长度为 len。$ O(len) $ 空间复杂度：节点数量为 n，字符集大小为 k。$ O(n * k) $ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:1","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#31-数组"},{"categories":["数据结构"],"content":" 3.2 哈希表 class TrieNode { Map\u003cCharacter, TrieNode\u003e children = new HashMap\u003c\u003e(); isEnd = false; } class Trie { TrieNode root; Trie() { root = new TrieNode(); } void insert(String s) { TrieNode p = root; for (char c : s.toCharArray()) { p.children.putIfAbsent(c, new TrieNode()); p = p.children.get(c); } p.isEnd = true; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:2","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#32-哈希表"},{"categories":["数据结构"],"content":" 3.3 二维数组 class Trie { static final int MAX_N = 100009; int[][] trie; // 以当前字符结尾的单词的数量 int[] count; // 尚未使用的索引开始位置 int index; public Trie() { trie = new int[MAX_N][26]; count = new int[MAX_N]; index = 0; } public void insert(String s) { // 插入 s int p = 0; for (int i = 0; i \u003c s.length(); i++) { int u = s.charAt(i) - 'a'; if (trie[p][u] == 0) trie[p][u] = ++index; p = trie[p][u]; } count[p]++; } public boolean search(String s) { // 是否存在 s int p = 0; for (int i = 0; i \u003c s.length(); i++) { int u = s.charAt(i) - 'a'; if (trie[p][u] == 0) return false; p = trie[p][u]; } return count[p] != 0; } public boolean startsWith(String s) { // 是否存在前缀 s int p = 0; for (int i = 0; i \u003c s.length(); i++) { int u = s.charAt(i) - 'a'; if (trie[p][u] == 0) return false; p = trie[p][u]; } return true; } } 时间复杂度：字符串长度为 len。$ O(len) $ 空间复杂度：节点数量为 n，字符集大小为 k。$ O(n * k) $ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:3","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#33-二维数组"},{"categories":["算法"],"content":" 1.基础Dynamic Programming 定义： 存在「重叠子问题」 具备「最优子结构」 步骤： 确定「初始条件」 确定「状态」 确定「可选择列表」 确定「状态转移方程」 数组优化时间 降维优化空间 思路： 自顶向下 def fib(n): return fib(n - 1) + fib(n - 2) 自底向上 def fib(n): for i in range(n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#1基础"},{"categories":["算法"],"content":" 线性DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#线性dp"},{"categories":["算法"],"content":" 二维DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:2","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#二维dp"},{"categories":["算法"],"content":" 背包问题","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#背包问题"},{"categories":["算法"],"content":" 区间DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:4","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#区间dp"},{"categories":["算法"],"content":" 树形DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:5","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#树形dp"},{"categories":["算法"],"content":" 状压DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:6","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#状压dp"},{"categories":["算法"],"content":" 数位DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:7","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#数位dp"},{"categories":["算法"],"content":" 2.实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#2实战"},{"categories":["算法"],"content":" 2.1 买卖股票的最佳时机 2.1.1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2.1.2 买卖股票的最佳时机-无次数限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 2.1.3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] +","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#21-买卖股票的最佳时机"},{"categories":["算法"],"content":" 2.1 买卖股票的最佳时机 2.1.1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2.1.2 买卖股票的最佳时机-无次数限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 2.1.3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] +","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#211-买卖股票的最佳时机-最多1次"},{"categories":["算法"],"content":" 2.1 买卖股票的最佳时机 2.1.1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2.1.2 买卖股票的最佳时机-无次数限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 2.1.3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] +","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#212-买卖股票的最佳时机-无次数限制"},{"categories":["算法"],"content":" 2.1 买卖股票的最佳时机 2.1.1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2.1.2 买卖股票的最佳时机-无次数限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 2.1.3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] +","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#213-买卖股票的最佳时机-最多2次"},{"categories":["算法"],"content":" 2.1 买卖股票的最佳时机 2.1.1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2.1.2 买卖股票的最佳时机-无次数限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 2.1.3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] +","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#214-买卖股票的最佳时机-最多k次"},{"categories":["算法"],"content":" 2.1 买卖股票的最佳时机 2.1.1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2.1.2 买卖股票的最佳时机-无次数限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 2.1.3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] +","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#215-买卖股票的最佳时机-冷冻期"},{"categories":["算法"],"content":" 2.1 买卖股票的最佳时机 2.1.1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2.1.2 买卖股票的最佳时机-无次数限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 2.1.3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] +","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#216-买卖股票的最佳时机-手续费"},{"categories":["算法"],"content":" 最长递增子序列（LIS）Longest Increasing Subsequence 动态规划 int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; int ans = 1; for (int i = 0; i \u003c n; i++) { dp[i] = 1; for (int j = 0; j \u003c i; j++) { if (nums[i] \u003e nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); ans = Math.max(ans, dp[i]); } } } return ans; } $O(n^2)$ 贪心 + 二分查找 /** * list 中每个链表都是降序排列，只能将更小的值加入末尾 * 若均无法添加，则作为一个新链表加入 list * 二分查找找到能够添加的下标最小的链表，然后加入 * 最后保证了每个链表的尾结点单调递增 * list 的大小即为最长子序列的长度 */ int lengthOfLIS(int[] nums) { int[] top = new int[nums.length]; int size = 0; for (int num : nums) { int left = 0; int right = size; while (left \u003c right) { int mid = left + (right - left) / 2; if (top[mid] \u003c num) { left = mid + 1; } else { right = mid; } } top[size] = num; if (left == size) { size++; } } return size; } 二分查找 /** * 数组 d[i]，表示长度为 i 的最长上升子序列的末尾元素的最小值 * 用 len 记录目前最长上升子序列的长度 */ int lengthOfLIS(int[] nums) { int[] dis = new int[nums.length]; int len = 0; for (int num : nums) { int left = 0; int right = len; while (left \u003c right) { int mid = left + (right - left) / 2; if (dis[mid] \u003c num) { left = mid + 1; } else { right = mid; } } dis[left] = num; if (left == len) { len++; } } return len; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:2","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长递增子序列lis"},{"categories":["算法"],"content":" 统计不同回文子序列力扣-0730-统计不同回文子序列 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#统计不同回文子序列"},{"categories":["算法"],"content":" 火柴拼正方形473. 火柴拼正方形 状压DP class Solution { public boolean makesquare(int[] matchsticks) { int totalLen = Arrays.stream(matchsticks).sum(); if (totalLen % 4 != 0) { return false; } int len = totalLen / 4, n = matchsticks.length; int[] dp = new int[1 \u003c\u003c n]; Arrays.fill(dp, -1); dp[0] = 0; for (int s = 1; s \u003c (1 \u003c\u003c n); s++) { for (int k = 0; k \u003c n; k++) { if ((s \u0026 (1 \u003c\u003c k)) == 0) { continue; } int s1 = s \u0026 ~(1 \u003c\u003c k); if (dp[s1] \u003e= 0 \u0026\u0026 dp[s1] + matchsticks[k] \u003c= len) { dp[s] = (dp[s1] + matchsticks[k]) % len; break; } } } return dp[(1 \u003c\u003c n) - 1] == 0; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:4","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#火柴拼正方形"},{"categories":["算法","字符串匹配"],"content":" 1.KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:1","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#1kmp-算法"},{"categories":["算法","字符串匹配"],"content":" 1.KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:1","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理"},{"categories":["算法","字符串匹配"],"content":" 1.KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:1","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#代码"},{"categories":["算法","字符串匹配"],"content":" 1.KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:1","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考"},{"categories":["算法","字符串匹配"],"content":" 2.BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar\u003cchar, int\u003e和goodSuffix[]。 代码 HashMap\u003cCharacter, Integer\u003e getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap\u003cCharacter, Integer\u003e badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap\u003cCharacter, Integer\u003e badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:2","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#2bm-算法"},{"categories":["算法","字符串匹配"],"content":" 2.BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMap getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:2","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理-1"},{"categories":["算法","字符串匹配"],"content":" 2.BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMap getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:2","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#代码-1"},{"categories":["算法","字符串匹配"],"content":" 2.BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMap getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:2","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考-1"},{"categories":["算法","字符串匹配"],"content":" 3.Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap\u003cCharacter, Integer\u003e pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:3","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#3sunday-算法"},{"categories":["算法","字符串匹配"],"content":" 3.Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:3","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理-2"},{"categories":["算法","字符串匹配"],"content":" 3.Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:3","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#代码-2"},{"categories":["算法","字符串匹配"],"content":" 3.Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:3","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考-2"},{"categories":["算法","字符串匹配"],"content":" 4.Rabin Karp 算法 原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i \u003c m; i++) { pHash = (pHash * K + pattern[i]) % MOD; tHash = (tHash * K + text[i]) % MOD; } for (int i = 0; i + m \u003c= n; i++) { if (pHash == tHash) { boolean equal = true; // 二次判断，防止哈希冲突 for (int j = 0; j \u003c m; j++) { if (text[i + j] != pattern[j]) { equal = false; break; } } if (equal) { return i; } } if (i + m \u003e= n) { break; } // 滚动计算哈希 tHash = ((tHash - text[i] * POWER % MOD) * K + text[i + m]) % MOD; if (tHash \u003c 0) { tHash += MOD; } } return -1; } 参考 字符串匹配算法-Rabin Karp算法 | coolcao的小站 简单易懂的Rabin Karp算法详解！ - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:4","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#4rabin-karp-算法"},{"categories":["算法","字符串匹配"],"content":" 4.Rabin Karp 算法 原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i \u003c m; i++) { pHash = (pHash * K + pattern[i]) % MOD; tHash = (tHash * K + text[i]) % MOD; } for (int i = 0; i + m \u003c= n; i++) { if (pHash == tHash) { boolean equal = true; // 二次判断，防止哈希冲突 for (int j = 0; j \u003c m; j++) { if (text[i + j] != pattern[j]) { equal = false; break; } } if (equal) { return i; } } if (i + m \u003e= n) { break; } // 滚动计算哈希 tHash = ((tHash - text[i] * POWER % MOD) * K + text[i + m]) % MOD; if (tHash \u003c 0) { tHash += MOD; } } return -1; } 参考 字符串匹配算法-Rabin Karp算法 | coolcao的小站 简单易懂的Rabin Karp算法详解！ - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:4","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理-3"},{"categories":["算法","字符串匹配"],"content":" 4.Rabin Karp 算法 原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i \u003c m; i++) { pHash = (pHash * K + pattern[i]) % MOD; tHash = (tHash * K + text[i]) % MOD; } for (int i = 0; i + m \u003c= n; i++) { if (pHash == tHash) { boolean equal = true; // 二次判断，防止哈希冲突 for (int j = 0; j \u003c m; j++) { if (text[i + j] != pattern[j]) { equal = false; break; } } if (equal) { return i; } } if (i + m \u003e= n) { break; } // 滚动计算哈希 tHash = ((tHash - text[i] * POWER % MOD) * K + text[i + m]) % MOD; if (tHash \u003c 0) { tHash += MOD; } } return -1; } 参考 字符串匹配算法-Rabin Karp算法 | coolcao的小站 简单易懂的Rabin Karp算法详解！ - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:4","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#代码-3"},{"categories":["算法","字符串匹配"],"content":" 4.Rabin Karp 算法 原理 主串text长度为n，匹配串pattern长度为m。 使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[a,b]的哈希值为 $$hash1=text[a] \\times k^{b-a} + \\cdots + text[b] \\times k^{0}$$ 区间[a+1,b+1]的哈希值为 $$hash2=text[a+1] \\times k^{b-a} + \\cdots + text[b+1] \\times k^{0}$$ $$hash2=(hash1-text[a] \\times k^{b-a}) \\times k + text[b + 1] \\times k^{0}$$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$hash2=((hash1-text[a] \\times k^{b-a} \\mod q) \\times k + text[b + 1] \\times k^{0}) \\mod q$$ 最后，k取一个大于text[i]取值范围的质数即可。 时间复杂度：O(n + m) 代码 int rkSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; final int MOD = (int) 1e7 + 7; // 取余 final int K = 31; // 任意数字即可，一般为质数 final int POWER = (int) Math.pow(K, m - 1) % MOD; int pHash = 0; int tHash = 0; for (int i = 0; i \u003c m; i++) { pHash = (pHash * K + pattern[i]) % MOD; tHash = (tHash * K + text[i]) % MOD; } for (int i = 0; i + m \u003c= n; i++) { if (pHash == tHash) { boolean equal = true; // 二次判断，防止哈希冲突 for (int j = 0; j \u003c m; j++) { if (text[i + j] != pattern[j]) { equal = false; break; } } if (equal) { return i; } } if (i + m \u003e= n) { break; } // 滚动计算哈希 tHash = ((tHash - text[i] * POWER % MOD) * K + text[i + m]) % MOD; if (tHash \u003c 0) { tHash += MOD; } } return -1; } 参考 字符串匹配算法-Rabin Karp算法 | coolcao的小站 简单易懂的Rabin Karp算法详解！ - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:0:4","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考-3"},{"categories":["算法"],"content":" 1.基础","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:1:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#1基础"},{"categories":["算法"],"content":" 1.1 术语介绍 稳定排序：相同大小的元素在排序前后保持相对顺序不变。 不稳定排序：相同大小的元素在排序前后的相对顺序发生变化。 内部排序：在内存中进行的排序。 外部排序：数据量太大不能全部读入内存，需要通过内存和磁盘结合进行的排序。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:1:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#11-术语介绍"},{"categories":["算法"],"content":" 1.2 数组中元素交换的方法 static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } static void swap(int[] nums, int i, int j) { if (i == j) return; nums[i] = nums[i] ^ nums[j]; nums[j] = nums[i] ^ nums[j]; nums[i] = nums[i] ^ nums[j]; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:1:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#12-数组中元素交换的方法"},{"categories":["算法"],"content":" 2.冒泡排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#2冒泡排序"},{"categories":["算法"],"content":" 2.1 原理 将整个数组划分为两个区域：未排序区、已排序区。数组左侧为未排序区，右侧为已排序区。 从左往右进行排序，当进行第一轮排序时，未排序区大小为 n，已排序区大小为 0。 每次比较相邻的两个数，若左侧的数字大于右侧的数字，则交换这两个数字。 当比较到未排序区的末尾时，未排序区的最后一个数字即为未排序区的最大数字，将其放入已排序区，则未排序区大小减 1，已排序区大小加 1，此时完成一轮排序。 当进行了 n - 1 轮排序后，未排序区的大小减为 1 时，排序结束。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#21-原理"},{"categories":["算法"],"content":" 2.2 优化 限制区域（默认）：每一轮只用比较未排序区的元素。当进行了 i 轮排序后，已排序区的大小为 i，未排序区的大小为 n - i。 提前结束：当某一轮未发生交换时，说明排序已经完成，可以提前结束。可设置一个布尔值记录一轮排序是否有发生交换。 冒泡界优化：若当前轮使多个元素有序，则下一轮只需比较之前的元素。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#22-优化"},{"categories":["算法"],"content":" 2.3 代码 // 1.未优化 static void bubbleSort(int[] nums) { int n = nums.length; for (int epoch = 1; epoch \u003c n; epoch++) { for (int i = 0; i \u003c n - epoch; i++) { if (nums[i] \u003e nums[i + 1]) { swap(nums, i, i + 1); } } } } // 2.提前结束优化 static void bubbleSort(int[] nums) { int n = nums.length; for (int epoch = 1; epoch \u003c n; epoch++) { boolean swapped = false; for (int i = 0; i \u003c n - epoch; i++) { if (nums[i] \u003e nums[i + 1]) { swap(nums, i, i + 1); swapped = true; } } if (!swapped) break; } } // 3.冒泡界优化 static void bubbleSort(int[] nums) { int n = nums.length; int firstSortedIndex = n - 1; for (int epoch = 1; epoch \u003c n; epoch++) { boolean swapped = false; int lastSwappedIndex; for (int i = 0; i \u003c firstSortedIndex; i++) { if (nums[i] \u003e nums[i + 1]) { swap(nums, i, i + 1); swapped = true; lastSwappedIndex = i; } } if (!swapped) break; firstSortedIndex = lastSwappedIndex; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#23-代码"},{"categories":["算法"],"content":" 2.4 分析 时间复杂度：$ O(n^2) $ $$ \\sum_{epoch=1}^{n-1}\\sum_{i=0}^{n-epoch-1}1=\\sum_{epoch=1}^{n-1}(n-epoch-1)=(n-2)+(n-3)+\\cdots+0=\\frac{(n-1)(n-2)}{2} $$ 空间复杂度：$ O(1) $ 稳定性：稳定 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#24-分析"},{"categories":["算法"],"content":" 3.选择排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#3选择排序"},{"categories":["算法"],"content":" 3.1 原理 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#31-原理"},{"categories":["算法"],"content":" 3.2 优化 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#32-优化"},{"categories":["算法"],"content":" 3.3 代码 void selectionSort(int[] nums) { int len = nums.length; // 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子 for (int i = 0; i \u003c len - 1; i++) { // 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i int minIdx = i; for (int j = i + 1; j \u003c len; j++) { if (nums[j] \u003c nums[minIdx]) { minIdx = j; } } swap(nums, i, minIdx); } return nums; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#33-代码"},{"categories":["算法"],"content":" 3.4 分析 时间复杂度：$ O(n^2) $ $$ \\sum_{epoch=1}^{n-1}\\sum_{i=0}^{n-epoch-1}1=\\sum_{epoch=1}^{n-1}(n-epoch-1)=(n-2)+(n-3)+\\cdots+0=\\frac{(n-1)(n-2)}{2} $$ 空间复杂度：$ O(1) $ 稳定性：不稳定 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#34-分析"},{"categories":["算法"],"content":" 4.插入排序 void insertionSort(vector\u003cint\u003e\u0026 arr) { for (int i = 1; i \u003c arr.size(); i++) { int temp = arr[i], j; for (j = i - 1; j \u003e= 0 \u0026\u0026 arr[j] \u003e arr[i]; j--) { arr[j + 1] = arr[j]; } arr[j + 1] = temp; } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ 特点： 稳定 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:4:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#4插入排序"},{"categories":["算法"],"content":" 5.希尔排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:5:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#5希尔排序"},{"categories":["算法"],"content":" 6.归并排序 10.4.1 自顶向下 static int[] copy; static void mergeSort(int[] arr) { copy = new int[arr.length]; mergeSort(arr, 0, arr.length - 1); } static void mergeSort(int[] arr, int low, int high) { if (low \u003e= high) return; int mid = low + (high - low) / 2; mergeSort(arr, low, mid); mergeSort(arr, mid + 1, high); merge(arr, low, mid, high); } static void merge(int[] arr, int low, int mid, int high) { } 10.4.2 自底向上 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#6归并排序"},{"categories":["算法"],"content":" 6.归并排序 10.4.1 自顶向下 static int[] copy; static void mergeSort(int[] arr) { copy = new int[arr.length]; mergeSort(arr, 0, arr.length - 1); } static void mergeSort(int[] arr, int low, int high) { if (low \u003e= high) return; int mid = low + (high - low) / 2; mergeSort(arr, low, mid); mergeSort(arr, mid + 1, high); merge(arr, low, mid, high); } static void merge(int[] arr, int low, int mid, int high) { } 10.4.2 自底向上 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#1041-自顶向下"},{"categories":["算法"],"content":" 6.归并排序 10.4.1 自顶向下 static int[] copy; static void mergeSort(int[] arr) { copy = new int[arr.length]; mergeSort(arr, 0, arr.length - 1); } static void mergeSort(int[] arr, int low, int high) { if (low \u003e= high) return; int mid = low + (high - low) / 2; mergeSort(arr, low, mid); mergeSort(arr, mid + 1, high); merge(arr, low, mid, high); } static void merge(int[] arr, int low, int mid, int high) { } 10.4.2 自底向上 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#1042-自底向上"},{"categories":["算法"],"content":" 7.快速排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#7快速排序"},{"categories":["算法"],"content":" 7.1 介绍与归并排序一样，快速排序也是一种利用 分治思想 的排序方法，确定 主轴及分区 是快速排序的核心操作。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#71-介绍"},{"categories":["算法"],"content":" 7.2 特点 时间复杂度：平均/最优为 $O(n \\log n)$，最坏为 $O(n^2)$。 实现简单 原地排序 每一轮确定一个元素的位置 不稳定 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#72-特点"},{"categories":["算法"],"content":" 7.3 步骤 在数组中随机取出一个数，称之为基数（pivot）。 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域。 从左向右遍历找到第一个大于等于基数的元素。 从右向左遍历找到第一个小于等于基数的元素。 交换两个元素。 将左右两个区域视为两个数组，重复前两个步骤，当子数组排序完成即整个数组排序完成。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#73-步骤"},{"categories":["算法"],"content":" 7.4 标准快排实现 static void quickSort(int[] arr, int low, int high) { // [low, high] if (low \u003e= high) return; // 1. 随机选取 pivot int pivotIndex = low + (int) (Math.random() * (high - low + 1)); int temp = arr[low]; arr[low] = arr[pivotIndex]; arr[pivotIndex] = temp; // 2. partition 划分 int pivot = arr[low]; int l = low; int r = high; while (l \u003c r) { // pivot 在左侧则先右后左，pivot 在右侧则先左后右 while (l \u003c r \u0026\u0026 arr[r] \u003e= pivot) r--; arr[l] = arr[r]; while (l \u003c r \u0026\u0026 arr[l] \u003c= pivot) l++; arr[r] = arr[l]; } arr[l] = pivot; // 3. 递归子数组 quickSort(arr, low, l - 1); quickSort(arr, l + 1, high); } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#74-标准快排实现"},{"categories":["算法"],"content":" 7.5 三向切分快排实现将数组切分为三个部分：小于 pivot、等于 pivot、大于 pivot。 当数组中存在重复元素时效率更高。 每一轮确定 r - l + 1 个元素的位置。 static void quickSort(int[] arr, int low, int high) { // [low, high] if (low \u003e= high) return; // 1. 随机选取 pivot int pivotIndex = low + (int) (Math.random() * (high - low + 1)); // 2. partition int pivot = arr[pivotIndex]; int l = low; int m = low; int r = high; while (m \u003c= r) { if (arr[m] \u003c pivot) { swap(arr, l, m); l++; m++; } else if (arr[m] \u003e pivot) { swap(arr, m, r); r--; } else { m++; } } // 3. 递归子数组 quickSort(arr, low, l - 1); quickSort(arr, r + 1, high); } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:5","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#75-三向切分快排实现"},{"categories":["算法"],"content":" 8.堆排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:8:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#8堆排序"},{"categories":["算法"],"content":" 9.计数排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:9:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#9计数排序"},{"categories":["算法"],"content":" 10.基数排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:10:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#10基数排序"},{"categories":["算法"],"content":" 11.桶排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:11:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#11桶排序"},{"categories":["算法"],"content":" 12.总结 排序算法 时间复杂度 稳定性 冒泡排序 $O(n^2)$ 稳定 选择排序 $O(n^2)$ 不稳定 插入排序 $O(n^2)$ 稳定 快速排序 $O(n \\log n)$ 不稳定 归并排序 $O(n \\log n)$ 稳定 堆排序 $O(n \\log n)$ 不稳定 计数排序 $O(n)$ 稳定 基数排序 $O(n)$ 稳定 名称 数据对象 稳定性 时间复杂度 额外空间复杂度 描述 平均 最坏 冒泡排序 数组 是 $ O(n^2) $ $ O(1) $ (无序区，有序区)从无序区通过交换找出最大元素放到有序区前端。 选择排序 数组 否 $ O(n^2) $ $ O(1) $ (有序区，无序区)在无序区里找一个最小的元素放到有序区后端。对数组：比较多，交换少 链表 是 插入排序 数组、链表 是 $ O(n^2) $ $ O(1) $ (有序区，无序区)把无序区的第一个元素插入到有序区的合适位置。对数组：比较少，交换多 堆排序 数组 否 $ O(n \\log{n}) $ $ O(1) $ (最大堆，有序区)从堆顶把最大值弹出到有序区前端，然后调整堆。 归并排序 数组 是 $ O(n \\log{\\log{n}}) $ $ O(1) $ 将数据分为两段，再从两段中逐个选最小的元素移入新数据段的末尾。可自上而下，也可自下而上 $ O(n \\log{n}) $ 自上而下：$ O(n)+O(\\log{n}) $ 链表 自下而上：$ O(1) $ 快速排序 数组 否 $ O(n \\log{n}) $ $ O(n^2) $ $ O(\\log{n}) $ (小数区，基准元素，大数区)在区间中随机挑选一个元素作为基准元素，将小于该基准的元素放到基准之前，大于的放到基准之后，然后递归地对小数区和大数区进行快速排序。 希尔排序 数组 否 $ O(n \\log{\\log{n}}) $ $ O(n^2) $ $ O(1) $ 按从大到小的间距进行多次插入排序，最后一次的间距为1。 计数排序 数组、链表 是 $ O(n+m) $ $ O(n+m) $ 统计小于等于该元素值的元素的个数i，然后将该元素放在目标数组的第i个位置。 桶排序 数组、链表 是 $ O(n) $ $ O(m) $ 将值为i的元素放入第i号桶，然后依次把桶里的元素倒出来。 基数排序 数组、链表 是 $ O(k \\times n) $ $ O(n^2) $ 一种多关键字的排序算法，可用桶排序实现。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:12:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#12总结"},{"categories":["算法"],"content":" 13.实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:13:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#13实战"},{"categories":["算法"],"content":" 参考 当我谈排序时，我在谈些什么🤔 复习基础排序算法（Java） - 排序数组 - 力扣（LeetCode） 十大排序从入门到入赘 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:14:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#参考"},{"categories":["数据结构","二叉树"],"content":" 基础满二叉树：一个高度为 d 的二叉树，有 $2^d-1$ 个节点。即除叶节点外，每个节点都有两个孩子，即节点的出度只为 0 或 2。 完全二叉树：只有最后一层可能未满，且节点严格从左往右排列。即出度为 1 的节点一定只有左孩子；若某节点出度小于 2，则其右边的节点出度为 0。 二叉树第 $i$ 层最多有 $2^{i-1}$ 个节点。 高度为 $d$ 的二叉树最多有 $2^d-1$ 个节点。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:1","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#基础"},{"categories":["数据结构","二叉树"],"content":" 定义 class TreeNode(object): def __init__(self, value): self.lchild = None self.rchild = None self.value = 0 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:2","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#定义"},{"categories":["数据结构","二叉树"],"content":" 遍历 前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { if (!root) return; postorder(root-\u003eleft); postorder(root-\u003eright); // 处理节点值 root-\u003eval } 非递归法： 前序遍历的非递归方法先左后右，最后逆序即可 void postorder(TreeNode* root) { if (!root) return; vector\u003cint\u003e res; // 保存遍历结果 stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root-\u003eval); // 保存节点值 if (root-\u003eleft) st.push(st-\u003eleft); if (root-\u003eright) st.push(st-\u003eright); } reverse(res.begin(), res.end()); // 逆序 } 层序遍历 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:3","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#遍历"},{"categories":["数据结构","二叉树"],"content":" 遍历 前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { if (!root) return; postorder(root-\u003eleft); postorder(root-\u003eright); // 处理节点值 root-\u003eval } 非递归法： 前序遍历的非递归方法先左后右，最后逆序即可 void postorder(TreeNode* root) { if (!root) return; vector res; // 保存遍历结果 stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root-\u003eval); // 保存节点值 if (root-\u003eleft) st.push(st-\u003eleft); if (root-\u003eright) st.push(st-\u003eright); } reverse(res.begin(), res.end()); // 逆序 } 层序遍历 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:3","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#前序遍历"},{"categories":["数据结构","二叉树"],"content":" 遍历 前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { if (!root) return; postorder(root-\u003eleft); postorder(root-\u003eright); // 处理节点值 root-\u003eval } 非递归法： 前序遍历的非递归方法先左后右，最后逆序即可 void postorder(TreeNode* root) { if (!root) return; vector res; // 保存遍历结果 stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root-\u003eval); // 保存节点值 if (root-\u003eleft) st.push(st-\u003eleft); if (root-\u003eright) st.push(st-\u003eright); } reverse(res.begin(), res.end()); // 逆序 } 层序遍历 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:3","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#中序遍历"},{"categories":["数据结构","二叉树"],"content":" 遍历 前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { if (!root) return; postorder(root-\u003eleft); postorder(root-\u003eright); // 处理节点值 root-\u003eval } 非递归法： 前序遍历的非递归方法先左后右，最后逆序即可 void postorder(TreeNode* root) { if (!root) return; vector res; // 保存遍历结果 stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root-\u003eval); // 保存节点值 if (root-\u003eleft) st.push(st-\u003eleft); if (root-\u003eright) st.push(st-\u003eright); } reverse(res.begin(), res.end()); // 逆序 } 层序遍历 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:3","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#后序遍历"},{"categories":["数据结构","二叉树"],"content":" 遍历 前序遍历递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { if (!root) return; postorder(root-\u003eleft); postorder(root-\u003eright); // 处理节点值 root-\u003eval } 非递归法： 前序遍历的非递归方法先左后右，最后逆序即可 void postorder(TreeNode* root) { if (!root) return; vector res; // 保存遍历结果 stack st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root-\u003eval); // 保存节点值 if (root-\u003eleft) st.push(st-\u003eleft); if (root-\u003eright) st.push(st-\u003eright); } reverse(res.begin(), res.end()); // 逆序 } 层序遍历 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:3","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#层序遍历"},{"categories":["数据结构","二叉树"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 递归 迭代 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:4","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#二叉搜索树"},{"categories":["数据结构","二叉树"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 递归 迭代 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:4","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#性质"},{"categories":["数据结构","二叉树"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 递归 迭代 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:4","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#插入"},{"categories":["数据结构","二叉树"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 递归 迭代 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:0:4","series":null,"tags":null,"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#删除"},{"categories":["算法"],"content":" 1.实现","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:0","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#1实现"},{"categories":["算法"],"content":" 1.1 单向链表 class ListNode { int val; ListNode next; public ListNode() {} public ListNode(int val) { this.val = val; } public ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class SingleLinkedList { // 哨兵结点、虚拟头结点，存储结点数量 ListNode dummy = new ListNode(0); // 尾结点 ListNode tail = dummy; public void add(int val) { // 向链表尾部添加结点 tail.next = new ListNode(val); tail = tail.next; dummy.val++; } public boolean remove() { // 删除链表尾结点 if (isEmpty()) return false; ListNode node = dummy; while (node.next != tail) node = node.next; node.next = null; tail = node; dummy.val--; return true; } public boolean isEmpty() { return tail == dummy; } public int size() { return dummy.val; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:1","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#11-单向链表"},{"categories":["算法"],"content":" 1.2 双向链表 class ListNode { int val; ListNode prev, next; public ListNode() {} public ListNode(int val) { this.val = val; } public ListNode(int val, ListNode prev, ListNode next) { this.val = val; this.prev = prev; this.next = next; } } class DoubleLinkedList { // 哨兵结点、虚拟头/尾结点，存储结点数量 ListNode dummy = new ListNode(0); public DoubleLinkedList() { // 初始化 dummy.prev = dummy; dummy.next = dummy; } public void add(int val) { // 向链表尾部添加结点 dummy.prev.next = new ListNode(val, dummy.prev, dummy); dummy.prev = dummy.prev.next; dummy.val++; } public boolean remove() { // 删除链表尾结点 if (isEmpty()) return false; dummy.prev.prev.next = dummy; dummy.prev = dummy.prev.prev; dummy.val--; return true; } public boolean isEmpty() { return dummy.next == dummy; } public int size() { return dummy.val; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#12-双向链表"},{"categories":["算法"],"content":" 1.3 链表遍历 递归 void traverse(TreeNode head) { if (head == null) return; // 前序 traverse(head.next); // 后序 } 迭代 ListNode p = head; while (p != null) { p = p.next; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#13-链表遍历"},{"categories":["算法"],"content":" 2.实战","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:0","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2实战"},{"categories":["算法"],"content":" 2.1 小技巧 虚拟头结点 快慢指针 二路归并 k路归并 递归 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:1","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#21-小技巧"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#22-简单"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#221-合并两个有序链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#222-有序链表去重"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#223-判断链表中是否有环"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#224-找出两个链表的交点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#225-删除所有满足条件的节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#226-反转链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#227-判断是否回文链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#228-删除给定节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#229-找出链表的中间节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2210-二进制链表转整数"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2211-删除-m-个节点之后的-n-个节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2212-逆序打印链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2213-删除第一个满足条件的节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2214-找出倒数第-k-个节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2215-未排序链表去重"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#23-中等"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#231-两数相加"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#232-删除倒数第-n-个结点"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#233-两两交换相邻节点"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#234-旋转链表"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#235-删除有序链表中重复的元素"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#236-按指定元素划分链表"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#237-反转从-left-到-right-的链表节点"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#238"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#239"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2310"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2311"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2312"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2313"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2314"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2315"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2316"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2317"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2318"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2319"},{"categories":["算法"],"content":" 2.4 困难 2.4.1","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:4","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#24-困难"},{"categories":["算法"],"content":" 2.4 困难 2.4.1","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:4","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#241"},{"categories":["数据结构","图"],"content":" 1.术语表图（graph） 边（edge）：连接两个顶点。 自环：起点和终点是同一个顶点的边。 平行边：连接同一对顶点的两条边。 边是否存在方向： 有向图：边有方向。 无向图：边无方向。 是否有环： 无环图：不存在环的图。 顶点（vertex） 度（degree）：顶点连接的边的数量。 入度（indegree）：终点是当前顶点的有向边的数量（到达当前顶点）。 出度（outdegree）：起点是当前顶点的有向边的数量（从当前顶点出发）。 路径（path）：由边连接的一系列顶点。 简单路径：无重复顶点的路径。 环（loop）：起点和终点相同的路径。 简单环：无重复顶点的环。 是否存在平行边： 简单图：无平行边的图。 多重图：存在平行边的图。 子图：边和连接的顶点的子集。 连通图：任意一个顶点都存在路径到达另一个任意顶点。 连通子图： 极大连通子图： 二分图：能将所有顶点分为两个部分的图，每条边的两个顶点分别属于不同的部分。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:1:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#1术语表"},{"categories":["数据结构","图"],"content":" 2.图的存储","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#2图的存储"},{"categories":["数据结构","图"],"content":" 2.1 邻接矩阵 // mat[u][v] == true 表示顶点 u 到顶点 v 存在一条有向边，u 是起点，v 是终点 boolean[][] mat = new boolean[n][n]; // mat[u][v] == w 表示顶点 u 到顶点 v 的有向边的边权 w // 可将 mat[u][v] 赋值为 0 或 Integer.MAX_VALUE 表示 u 和 v 之间无边 int[][] mat = new int[n][n]; 优点：可快速判断两个顶点是否相邻 缺点：占用空间大 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#21-邻接矩阵"},{"categories":["数据结构","图"],"content":" 2.2 邻接表 // graph[u] 存储从顶点 u 开始的所有边的终点集合 // graph[u].get(i) == v 表示顶点 u 开始的第 i 条边的终点 v List\u003cInteger\u003e[] graph = new ArrayList[n]; // graph[u].get(i)[0] == v, graph[u].get(i)[1] == w 表示顶点 u 开始的第 i 条边的终点 v，边权 w List\u003cint[]\u003e[] graph = new ArrayList[n]; for (int i = 0; i \u003c n; i++) graph[i] = new ArrayList\u003c\u003e(); // 快速判断两个顶点是否相邻 Set\u003cInteger\u003e[] graph = new HashSet[n]; Set\u003cint[]\u003e[] graph = new HashSet[n]; for (int i = 0; i \u003c n; i++) graph[i] = new HashSet\u003c\u003e(); // 快速判断两个顶点是否相邻，从顶点 u 开始的所有边的终点集合有序 Set\u003cInteger\u003e[] graph = new TreeSet[n]; Set\u003cint[]\u003e[] graph = new TreeSet[n]; for (int i = 0; i \u003c n; i++) graph[i] = new TreeSet\u003c\u003e(); 优点：占用空间小 缺点：无法快速判断两个顶点是否相邻（用 Set 存储可解决） ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#22-邻接表"},{"categories":["数据结构","图"],"content":" 2.3 其他 // 1.邻接表（无边权） // adjList1[u] 表示顶点 u 的相邻顶点 List\u003cInteger\u003e[] adjList1; // 2.邻接表 有边权 // adjList2[u] = { {v1, w1}, {v2, w2} ... } 表示顶点 u 的相邻顶点 List\u003cint[]\u003e[] adjList2; // 3.邻接表（无边权，可快速查询某顶点是否相邻） // adjSet[u] 表示顶点 u 的相邻顶点 TreeSet\u003cInteger\u003e[] adjSet; // 4.邻接矩阵 // adjMat[u][v] 表示顶点 u 到 顶点 v 的边的权值。 int[][] adjMat; // 5.边集数组 // edges[i] = { u, v, w } 表示第 i 条边，从顶点 u 到 顶点 v，权值为 w。 int[][] edges; 邻接表 优点：占用的空间少 缺点：无法快速判断两个节点是否相邻 适用于稀疏图 邻接矩阵 优点：占用的空间多 缺点：可以快速判断两个节点是否相邻 适用于稠密图 链式邻接表实现 // 边的定义 class Edge { // 起点，终点，边权 int u, v, w; } // 边集数组 // edges[j] 存储第 j 条边的 { 起点 u，终点 v，边权 w } Edge[] edges; // 或者 int[][] edges; // 表头数组 // adjEdges[u] 存储 u 点的所有出边的编号 List\u003cInteger\u003e[] adjEdges; 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 4, 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ 适用于各种图。 能够处理反向边，边的编号与 1 异或得到反向边。 链式前向星实现 // 边的定义 class Edge { // 终点，边权，下一条边的编号 int v, w, ne; } // 边集数组 // edges[j] 存储第 j 条边的 { 终点 v，边权 w，下一条边的编号 ne } Edge[] edges; // 或者 int[][] edges; // 表头数组 // firstEdge[u] 存储 u 点的第一条出边的编号 int[] firstEdge; // 添加边 void addEdge(int i, int u, int v, int w) { Edge e = new Edge(); e.v = v; e.w = w; // 头插法 e.ne = firstEdge[u]; edges[i] = e; firstEdge[u] = i; } 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#23-其他"},{"categories":["数据结构","图"],"content":" 2.3 其他 // 1.邻接表（无边权） // adjList1[u] 表示顶点 u 的相邻顶点 List[] adjList1; // 2.邻接表 有边权 // adjList2[u] = { {v1, w1}, {v2, w2} ... } 表示顶点 u 的相邻顶点 List[] adjList2; // 3.邻接表（无边权，可快速查询某顶点是否相邻） // adjSet[u] 表示顶点 u 的相邻顶点 TreeSet[] adjSet; // 4.邻接矩阵 // adjMat[u][v] 表示顶点 u 到 顶点 v 的边的权值。 int[][] adjMat; // 5.边集数组 // edges[i] = { u, v, w } 表示第 i 条边，从顶点 u 到 顶点 v，权值为 w。 int[][] edges; 邻接表 优点：占用的空间少 缺点：无法快速判断两个节点是否相邻 适用于稀疏图 邻接矩阵 优点：占用的空间多 缺点：可以快速判断两个节点是否相邻 适用于稠密图 链式邻接表实现 // 边的定义 class Edge { // 起点，终点，边权 int u, v, w; } // 边集数组 // edges[j] 存储第 j 条边的 { 起点 u，终点 v，边权 w } Edge[] edges; // 或者 int[][] edges; // 表头数组 // adjEdges[u] 存储 u 点的所有出边的编号 List[] adjEdges; 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 4, 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ 适用于各种图。 能够处理反向边，边的编号与 1 异或得到反向边。 链式前向星实现 // 边的定义 class Edge { // 终点，边权，下一条边的编号 int v, w, ne; } // 边集数组 // edges[j] 存储第 j 条边的 { 终点 v，边权 w，下一条边的编号 ne } Edge[] edges; // 或者 int[][] edges; // 表头数组 // firstEdge[u] 存储 u 点的第一条出边的编号 int[] firstEdge; // 添加边 void addEdge(int i, int u, int v, int w) { Edge e = new Edge(); e.v = v; e.w = w; // 头插法 e.ne = firstEdge[u]; edges[i] = e; firstEdge[u] = i; } 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#链式邻接表"},{"categories":["数据结构","图"],"content":" 2.3 其他 // 1.邻接表（无边权） // adjList1[u] 表示顶点 u 的相邻顶点 List[] adjList1; // 2.邻接表 有边权 // adjList2[u] = { {v1, w1}, {v2, w2} ... } 表示顶点 u 的相邻顶点 List[] adjList2; // 3.邻接表（无边权，可快速查询某顶点是否相邻） // adjSet[u] 表示顶点 u 的相邻顶点 TreeSet[] adjSet; // 4.邻接矩阵 // adjMat[u][v] 表示顶点 u 到 顶点 v 的边的权值。 int[][] adjMat; // 5.边集数组 // edges[i] = { u, v, w } 表示第 i 条边，从顶点 u 到 顶点 v，权值为 w。 int[][] edges; 邻接表 优点：占用的空间少 缺点：无法快速判断两个节点是否相邻 适用于稀疏图 邻接矩阵 优点：占用的空间多 缺点：可以快速判断两个节点是否相邻 适用于稠密图 链式邻接表实现 // 边的定义 class Edge { // 起点，终点，边权 int u, v, w; } // 边集数组 // edges[j] 存储第 j 条边的 { 起点 u，终点 v，边权 w } Edge[] edges; // 或者 int[][] edges; // 表头数组 // adjEdges[u] 存储 u 点的所有出边的编号 List[] adjEdges; 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 4, 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ 适用于各种图。 能够处理反向边，边的编号与 1 异或得到反向边。 链式前向星实现 // 边的定义 class Edge { // 终点，边权，下一条边的编号 int v, w, ne; } // 边集数组 // edges[j] 存储第 j 条边的 { 终点 v，边权 w，下一条边的编号 ne } Edge[] edges; // 或者 int[][] edges; // 表头数组 // firstEdge[u] 存储 u 点的第一条出边的编号 int[] firstEdge; // 添加边 void addEdge(int i, int u, int v, int w) { Edge e = new Edge(); e.v = v; e.w = w; // 头插法 e.ne = firstEdge[u]; edges[i] = e; firstEdge[u] = i; } 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#链式前向星"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search BFS void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue\u003cInteger\u003e queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#3图的遍历"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search BFS void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#31-深度优先搜索dfs"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search BFS void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#32-广度优先搜索bfs"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search BFS void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#33-双向-bfs"},{"categories":["数据结构","图"],"content":" 4.环检测 DFS：若下个待访问的顶点在当前访问路径上，则说明存在环。 BFS：若存在顶点未被访问，则说明存在环。 207. 课程表 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:4:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#4环检测"},{"categories":["数据结构","图"],"content":" 4.1 DFS：布尔数组表示顶点是否在当前路径上 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u003cInteger\u003e[] graph = new ArrayList[numCourses]; for (int i = 0; i \u003c numCourses; i++) graph[i] = new ArrayList\u003c\u003e(); boolean[] vis = new boolean[numCourses]; boolean[] onPath = new boolean[numCourses]; for (int[] course : prerequisites) // 建图 graph[course[1]].add(course[0]); for (int u = 0; u \u003c numCourses; u++) // DFS 遍历 if (!vis[u] \u0026\u0026 dfs(graph, u, vis, onPath)) return false; return true; } boolean dfs(List\u003cInteger\u003e[] graph, int u, boolean[] vis, boolean[] onPath) { // 返回是否存在环 vis[u] = true; onPath[u] = true; for (int v : graph[u]) { if (onPath[v]) // 找到环 return true; if (!vis[v] \u0026\u0026 dfs(graph, v, vis, onPath)) // 已找到环，剪枝 return true; } onPath[u] = false; // 回溯 return false; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:4:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#41-dfs布尔数组表示顶点是否在当前路径上"},{"categories":["数据结构","图"],"content":" 4.2 DFS：vis 数组中的不同值表示顶点的不同状态（未访问、访问中、已访问）。 class Solution { List\u003cList\u003cInteger\u003e\u003e edges; int[] visited; boolean valid = true; public boolean canFinish(int numCourses, int[][] prerequisites) { edges = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c numCourses; ++i) edges.add(new ArrayList\u003c\u003e()); visited = new int[numCourses]; for (int[] info : prerequisites) edges.get(info[1]).add(info[0]); for (int i = 0; i \u003c numCourses \u0026\u0026 valid; ++i) if (visited[i] == 0) dfs(i); return valid; } public void dfs(int u) { visited[u] = 1; // 当前路径上 for (int v: edges.get(u)) { if (visited[v] == 0) { // 未访问 dfs(v); if (!valid) return; } else if (visited[v] == 1) { valid = false; return; } } visited[u] = 2; // 已访问 } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:4:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#42-dfsvis-数组中的不同值表示顶点的不同状态未访问访问中已访问"},{"categories":["数据结构","图"],"content":" 4.3 BFS：每次删除入度为 0 的顶点 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u003cList\u003cInteger\u003e\u003e graph = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c numCourses; i++) graph.add(new ArrayList\u003c\u003e()); int[] indegree = new int[numCourses]; // 入度 for (int[] edge : prerequisites) { graph.get(edge[1]).add(edge[0]); // 方向无所谓 indegree[edge[0]]++; } // bfs Queue\u003cInteger\u003e queue = new ArrayDeque\u003c\u003e(); for (int i = 0; i \u003c numCourses; i++) if (indegree[i] == 0) // 入度为 0 queue.offer(i); int visited = 0; // 已访问顶点数量 while (!queue.isEmpty()) { visited++; int u = queue.poll(); for (int v : graph.get(u)) { indegree[v]--; if (indegree[v] == 0) // 入度为 0 queue.offer(v); } } return visited == numCourses; // 若有顶点未访问则存在环 } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:4:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#43-bfs每次删除入度为-0-的顶点"},{"categories":["数据结构","图"],"content":" 5.拓扑排序拓扑排序（Topological Sort）：得到有向图 $G$ 的顶点的一个排列，满足任意一条有向边 $(u,v)$，$u$ 在排列中都在 $v$ 前面，即相对顺序不变。 DFS：后序添加顶点，然后逆序即可得到拓扑排序序列。（或者建图时颠倒每条边的起始顶点和结束顶点，则最后无需逆序） 210. 课程表 II DFS： class Solution { List\u003cList\u003cInteger\u003e\u003e graph; int[] vis; int[] ans; int index; public int[] findOrder(int numCourses, int[][] prerequisites) { graph = new ArrayList\u003c\u003e(numCourses); for (int i = 0; i \u003c numCourses; i++) graph.add(new ArrayList\u003c\u003e()); for (int[] pre : prerequisites) graph.get(pre[0]).add(pre[1]); // 逆序建图 // graph.get(pre[1]).add(pre[0]); // 顺序建图 // index = numCourses - 1; // 顺序建图 vis = new int[numCourses]; ans = new int[numCourses]; for (int i = 0; i \u003c numCourses; i++) if (vis[i] == 0 \u0026\u0026 dfs(i)) // 存在环 return new int[0]; return ans; } boolean dfs(int u) { vis[u] = 1; for (int v : graph.get(u)) { if (vis[v] == 0 \u0026\u0026 dfs(v)) return true; // 剪枝 else if (vis[v] == 1) return true; // 存在环 } vis[u] = 2; ans[index++] = u; // ans[index--] = u; // 顺序建图 return false; } } BFS： class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { List\u003cList\u003cInteger\u003e\u003e graph = new ArrayList\u003c\u003e(numCourses); for (int i = 0; i \u003c numCourses; i++) graph.add(new ArrayList\u003c\u003e()); int[] indegree = new int[numCourses]; for (int[] pre : prerequisites) { indegree[pre[0]]++; graph.get(pre[1]).add(pre[0]); } int[] ans = new int[numCourses]; int index = 0; Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); int count = 0; for (int i = 0; i \u003c numCourses; i++) if (indegree[i] == 0) { que.offer(i); ans[index++] = i; } while (!que.isEmpty()) { int u = que.poll(); count++; for (int v : graph.get(u)) { indegree[v]--; if (indegree[v] == 0) { que.offer(v); ans[index++] = v; } } } return count == numCourses ? ans : new int[0]; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:5:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#5拓扑排序"},{"categories":["数据结构","图"],"content":" 最小生成树","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:6:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#最小生成树"},{"categories":["数据结构","图"],"content":" 克鲁斯卡尔 int[][] kruskal() { } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:6:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#克鲁斯卡尔"},{"categories":["数据结构","图"],"content":" 普里姆 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:6:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#普里姆"},{"categories":["数据结构","图"],"content":" Flood Fill 岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#flood-fill"},{"categories":["数据结构","图"],"content":" Flood Fill 岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#岛屿数量"},{"categories":["数据结构","图"],"content":" Flood Fill 岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#封闭岛屿的数量"},{"categories":["数据结构","图"],"content":" Flood Fill 岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#1020-飞地的数量"},{"categories":["数据结构","图"],"content":" Flood Fill 岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#695-岛屿的最大面积"},{"categories":["数据结构","图"],"content":" Flood Fill 岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#1905-统计子岛屿"},{"categories":["数据结构","图"],"content":" Flood Fill 岛屿数量 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; int m, n; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; boolean[][] visited = new boolean[m][n]; int res = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { res++; dfs(grid, i, j, visited); } } } return res; } void dfs(char[][] grid, int x, int y, boolean[][] visited) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || visited[x][y] || grid[x][y] == '0') { return; } visited[x][y] = true; for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY, visited); } } 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#694-不同岛屿的数量"},{"categories":null,"content":" 基本位运算 \u0026：与。同1则1，其余为0。 |：或。同0则0，其余为1。 ~：非。01互换。 ^：异或。同0异1。 \u003c\u003c：左移。右补0。 \u003e\u003e：带符号右移。正数左补0，负数左补1。 \u003e\u003e\u003e：无符号右移。左补0。 ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#基本位运算"},{"categories":null,"content":" 常用操作","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#常用操作"},{"categories":null,"content":" 交换两个数 a ^= b; // a' == a ^ b b ^= a; // b' == b ^ a' == b ^ a ^ b == a a ^= b; // a' == a' ^ b' == a ^ b ^ a == b ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:1","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#交换两个数"},{"categories":null,"content":" 转为相反数 n = (~n) + 1; ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:2","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#转为相反数"},{"categories":null,"content":" 加 1 // -n == (~n) + 1 // -(~n) == (~(~n)) + 1 // -(~n) == n + 1 n = -(~n); ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:3","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#加-1"},{"categories":null,"content":" 减 1 // -n == (~n) + 1 // -(-n) == (~(-n)) + 1 // n == (~(-n)) + 1 // ~(-n) == n - 1 n = ~(-n); ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:4","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#减-1"},{"categories":null,"content":" 英文字母转小写 // 'a' == 0b01100001 // 'A' == 0b01000001 // 'z' == 0b01111010 // 'Z' == 0b01011010 // ' ' == 0b00100000 c |= ' '; ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:5","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#英文字母转小写"},{"categories":null,"content":" 英文字母转大写 // 'a' == 0b01100001 // 'A' == 0b01000001 // 'z' == 0b01111010 // 'Z' == 0b01011010 // '_' == 0b01011111 c \u0026= '_'; ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:6","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#英文字母转大写"},{"categories":null,"content":" 英文字母大小写互转 // 'a' == 0b01100001 // 'A' == 0b01000001 // 'z' == 0b01111010 // 'Z' == 0b01011010 // ' ' == 0b00100000 c ^= ' '; ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:7","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#英文字母大小写互转"},{"categories":null,"content":" 判断两个数符号是否相同 // 0b0... ^ 0b1... == 0b1... // 0b0... ^ 0b0... == 0b0... // 0b1... ^ 0b1... == 0b0... a ^ b \u003e 0; ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:8","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#判断两个数符号是否相同"},{"categories":null,"content":" 判断一个数的奇偶 (n \u0026 1) == 1; // 奇数 (n \u0026 1) == 0; // 偶数 ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:9","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#判断一个数的奇偶"},{"categories":null,"content":" 将一个数二进制表示中最低位 1 置为 0 // n == 0b...10...0 // n - 1 == 0b...01...1 // n \u0026 (n - 1) == 0b...000000 n \u0026 (n - 1); ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:10","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#将一个数二进制表示中最低位-1-置为-0"},{"categories":null,"content":" 只保留一个数二进制表示中最低位 1 // n == 0b.....10...0 // n - 1 == 0b.....01...1 // n \u0026 (n - 1) == 0b.....000000 // n -= n \u0026 (n - 1) == 0b0...010...0 n -= n \u0026 (n - 1); ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:11","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#只保留一个数二进制表示中最低位-1"},{"categories":null,"content":" 统计一个数二进制表示中 1 的数量 int count = 0; while (n) { count++; n = n \u0026 (n - 1); } ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:2:12","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#统计一个数二进制表示中-1-的数量"},{"categories":null,"content":" 进阶操作","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:3:0","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#进阶操作"},{"categories":null,"content":" 参考 位运算操作常见技巧_阿飞算法的博客-CSDN博客 ","date":"2022-05-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/:4:0","series":null,"tags":["位运算"],"title":"位运算技巧","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/#参考"},{"categories":null,"content":" 画布 plt.figure( figsize=(10, 8), # 画布大小。（宽，高） dpi=None, # 分辨率。300、600 tight_layout=None, # 紧凑布局。True ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#画布"},{"categories":null,"content":" 网格 plt.grid( visible=None, which='major', axis='both' ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#网格"},{"categories":null,"content":" 边框 获取边框 ax = plt.gca() ax.spines['top'] ax.spines['right'] ax.spines['bottom'] ax.spines['left'] 边框设置 ax.set_facecolor('white') ax.spines['top'].set_color('white') ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#边框"},{"categories":null,"content":" 轴 x轴 plt.xlabel( xlabel, loc='center', # 标签位置。'left'、'center'、'right' ) 刻度 # x轴刻度 plt.xticks( ticks=None, # 刻度。[0, 1, 2] labels=None, # 刻度值。['Jan', 'Feb', 'Mar'] rotation=None, # 旋转。'vertical'、45 ) # y轴刻度 plt.yticks( ticks=None, # 刻度。[0, 1, 2] labels=None, # 刻度值。['Jan', 'Feb', 'Mar'] rotation=None, # 旋转。'vertical'、45 ) 设置y轴刻度的最大/最小值 plt.ylim( bottom=bottom, # 最小值 top=top # 最大值 ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#轴"},{"categories":null,"content":" 其他 紧凑布局 plt.tight_layout() 保存图片 plt.savefig( fname, # 文件路径。image.png dpi='figure', # 图片分辨率。600、300 format=None, # 文件格式。'png'、'pdf'、'svg'、'eps' transparent=False, # 是否透明 ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#其他"},{"categories":[],"content":"结构化查询语言（Structured Query Language，SQL），读作S-Q-L或者sequel，是用来与数据库通信的语言。 SQL关键字不区分大小写。 ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 一、数据库 显示数据库 SHOW DATABASES; 选择数据库 USE db_name; 创建数据库 CREATE DATABASE db_name; CREATE DATABASE IF NOT EXISTS db_name; 删除数据库 DROP DATABASE db_name; 显示创建数据库的 SQL 语句 SHOW CREATE DATABASE db_name; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#一数据库"},{"categories":[],"content":" 二、表 显示表 SHOW TABLES; 描述表 DESCRIBE tb_name; SHOW COLUMNS FROM tb_name; 创建表 CREATE TABLE tb_name ( col_1 type_1 cons_1, col_2 type_2 cons_2, cons_3, cons_4 ); -- 使用旧表创建新表 CREATE TABLE tb_new LIKE tb_old; 显示创建表的 SQL 语句 SHOW CREATE TABLE tb_name; 删除表 DROP TABLE tb_name; 修改表名 ALTER TABLE tb_old RENAME TO tb_new; 添加列 ALTER TABLE tb_name ADD COLUMN col_ type_ cons_; 删除列 ALTER TABLE tb_name DROP COLUMN col_; 修改列名 ALTER TABLE tb_name RENAME col_old TO col_new; 添加约束 ALTER TABLE tb_name ADD cons; -- 添加主键 ALTER TABLE tb_name ADD PRIMARY KEY (col_); 删除约束 ALTER TABLE tb_name DROP cons; -- 删除主键 ALTER TABLE tb_name DROP PRIMARY KEY (col_); 创建索引 CREATE INDEX idx_name ON ta_name (col_1, col_2); -- 唯一索引 CREATE UNIQUE INDEX idx_name ON ta_name (col_1, col_2); 删除索引 DROP INDEX idx_name; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#二表"},{"categories":[],"content":" 三、修改数据 添加 -- 添加多条记录 INSERT INTO tb_name (col_1, col_2) VALUES (val_1_1, val_1_2), (val_2_1, val_2_2); -- 从其他表添加 INSERT INTO tb_name_1 (col_1, col_2) SELECT col_1, col_2 FROM tb_name_2; 删除 -- 删除指定记录 DELETE FROM tb_name WHERE cond_; -- 删除所有记录 DELETE FROM tb_name; TRUNCATE TABLE tb_name; 修改 UPDATE tb_name SET col_1=val_1, col_2=val_2 WHERE cond_; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#三修改数据"},{"categories":[],"content":" 四、查询数据","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#四查询数据"},{"categories":[],"content":" 4.1 单表查询 条件查询 -- 指定列 SELECT col_1, col_2 FROM tb_name WHERE cond_; -- 所有列 SELECT * FROM tb_name; 去重 SELECT DISTINCT col_ FROM tb_name; 分页：pos从 0 开始。 -- [0, len) SELECT col_ FROM tb_name LIMIT len_; -- [pos, pos + len) SELECT col_ FROM tb_name LIMIT pos_, len_; SELECT col_ FROM tb_name LIMIT len_ OFFSET pos_; 排序 -- 升序，ASC SELECT col_ FROM tb_name ORDER BY col_1; -- 降序 SELECT col_ FROM tb_name ORDER BY col_1 DESC; -- 复杂排序 SELECT col_ FROM tb_name ORDER BY col_1 DESC col_2 ASC; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#41-单表查询"},{"categories":[],"content":" 4.2 函数 数量 SELECT COUNT(*) FROM tb_name; SELECT COUNT(1) FROM tb_name; 求和 SELECT SUM(col_) FROM tb_name; 平均值 SELECT AVG(col_) FROM tb_name; 最大值 SELECT MAX(col_) FROM tb_name; 最小值 SELECT MIN(col_) FROM tb_name; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#42-函数"},{"categories":[],"content":" 4.3 多表查询 -- SELECT col_ FROM tb_1 INNER JOIN tb_2 ON cond_; SELECT col_ FROM tb_1 LEFT JOIN tb_2 ON cond_; SELECT col_ FROM tb_1 RIGHT JOIN tb_2 ON cond_; SELECT col_ FROM tb_1 INNER JOIN tb_2 ON cond_; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#43-多表查询"},{"categories":[],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between \u003ca\u003e and \u003cb\u003e [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (\u003ca\u003e, \u003cb\u003e, \u003cc\u003e) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select \u003ccolumns\u003e from \u003ctable\u003e where \u003ccolumn\u003e like \u003cpattern\u003e; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select \u003ccolumns\u003e from \u003ctable\u003e where \u003ccolumn\u003e regexp \u003cpattern\u003e; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat(\u003ccolumns\u003e) from \u003ctable\u003e; 计算： select \u003ccolumn1\u003e \u003cop\u003e \u003ccolumn2\u003e as \u003calias\u003e from \u003ctable\u003e; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#五条件"},{"categories":[],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between and [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (, , ) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select from where like ; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select from where regexp ; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat() from ; 计算： select as from ; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#551-通配符"},{"categories":[],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between and [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (, , ) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select from where like ; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select from where regexp ; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat() from ; 计算： select as from ; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#552-正则表达式"},{"categories":[],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between and [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (, , ) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select from where like ; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select from where regexp ; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat() from ; 计算： select as from ; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#553-生成新列"},{"categories":[],"content":" 六、约束","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#六约束"},{"categories":["Java"],"content":" 线程、程序和进程 程序：含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 进程：程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 线程：与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:1:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#线程程序和进程"},{"categories":["Java"],"content":" 线程的基本状态Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态： 初始（New） 运行（Runnable） 等待（Waiting） 超时等待（Timed Waiting） 阻塞（Blocked） 终止（Terminated） 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示： ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:2:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#线程的基本状态"},{"categories":["Java"],"content":" 线程池的优点 线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。 可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:3:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#线程池的优点"},{"categories":["Java"],"content":" 创建线程池 ThreadPoolExecutor​(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u003cRunnable\u003e workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：线程池核心线程数量 maximumPoolSize：线程池最大线程数量 keepAliveTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间 unit：存活时间的单位 workQueue：存放任务的队列 threadFactory：线程工厂 handler：超出线程范围和队列容量的任务的处理程序 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:4:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#创建线程池"},{"categories":["Java"],"content":" 线程池原理提交一个任务到线程池中，线程池的处理流程如下： 判断线程池里的核心线程是否都在执行任务。 如果核心线程空闲或者还有核心线程没有被创建，则创建一个新的工作线程来执行任务。 如果核心线程都在执行任务，则进入下个流程。 线程池判断工作队列是否已满。 如果工作队列未满，则将新提交的任务存储在这个工作队列里。 如果工作队列已满，则进入下个流程。 判断线程池里的线程是否都处于工作状态。 如果存在空闲线程，则创建一个新的工作线程来执行任务。 如果全部繁忙，则交给饱和策略来处理这个任务。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:5:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#线程池原理"},{"categories":["Java"],"content":" 线程池源码分析 ThreadPoolExecutor的execute()方法 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列 int c = ctl.get(); if (workerCountOf(c) \u003c corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // 线程池处于运行状态并且加入队列成功 if (isRunning(c) \u0026\u0026 workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) \u0026\u0026 remove(command)) reject(command); // 线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程） else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 创建线程失败，则采取阻塞处理的方式 else if (!addWorker(command, false)) reject(command); } ThreadPoolExecutor的addWorker()方法 private boolean addWorker(Runnable firstTask, boolean core) { retry: for (int c = ctl.get();;) { // Check if queue empty only if necessary. if (runStateAtLeast(c, SHUTDOWN) \u0026\u0026 (runStateAtLeast(c, STOP) || firstTask != null || workQueue.isEmpty())) return false; for (;;) { if (workerCountOf(c) \u003e= ((core ? corePoolSize : maximumPoolSize) \u0026 COUNT_MASK)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateAtLeast(c, SHUTDOWN)) continue retry; // else CAS failed due to workerCount change; retry inner loop } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int c = ctl.get(); if (isRunning(c) || (runStateLessThan(c, STOP) \u0026\u0026 firstTask == null)) { if (t.getState() != Thread.State.NEW) throw new IllegalThreadStateException(); workers.add(w); workerAdded = true; int s = workers.size(); if (s \u003e largestPoolSize) largestPoolSize = s; } } finally { mainLock.unlock(); } if (workerAdded) { t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; } ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:6:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#线程池源码分析"},{"categories":["Java"],"content":" 线程池饱和策略RejectedExecutionHandler 当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。Java 提供了 4 种策略： AbortPolicy：直接抛出异常 CallerRunsPolicy：只用调用所在的线程运行任务 DiscardOldestPolicy：丢弃队列里最早的一个任务，并执行当前任务 DiscardPolicy：不处理，丢弃 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:7:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#线程池饱和策略"},{"categories":["Java"],"content":" Executor框架的两级调度模型在 HotSpot VM 的模型中，Java 线程被一对一映射为本地操作系统线程。Java 线程启动时会创建一个本地操作系统线程，当 Java 线程终止时，对应的操作系统线程也被销毁回收，而操作系统会调度所有线程并将它们分配给可用的 CPU。 在上层，Java 程序会将应用分解为多个任务，然后使用应用级的调度器（Executor）将这些任务映射成固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/:8:0","series":null,"tags":["Java","多线程","面试","JUC"],"title":"Java 多线程详解","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#executor框架的两级调度模型"},{"categories":null,"content":" JVM 主要组成部分JVM 包含两个子系统和两个组件： 两个子系统 Class loader（类装载）：根据给定的全限定类名（如：java.lang.Object）来装载 class 文件到 Runtime data area 中的method area。 Execution engine（执行引擎）：执行 classes 中的指令。 两个组件 Runtime data area（运行时数据区）：这就是我们常说的 JVM 的内存。 Native Interface（本地接口）：与 Native libraries 交互，是其它编程语言交互的接口。 首先通过编译器（javac）把 Java 代码编译成字节码（.class）。类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内。而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:1:0","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#jvm-主要组成部分"},{"categories":null,"content":" JVM 运行时数据区JVM 在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， JVM 规范规定的区域分为以下 5 个部分： 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。 Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作 数栈、动态链接、方法出口等信息。 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。 Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享，几乎所有的对象实例都在这里分配内存。 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:2:0","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#jvm-运行时数据区"},{"categories":null,"content":" 对象创建的主要流程虚拟机遇到一条 new 指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载（ClassLoader）。类加载通过后，接下来分配内存。若 Java 堆中内存是绝对规整的，使用指针碰撞方式分配内存；如果不是规整的，就从空闲列表中分配，叫做空闲列表方式。 划分内存时还需要考虑一个问题——并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。然后内存空间初始化操作，接着是做一些必要的对象设置（元信息、哈希码……），然后执行方法。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:3:0","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#对象创建的主要流程"},{"categories":null,"content":" 为对象分配内存类加载完成后，接着会在 Java 堆中划分一块内存分配给对象。内存分配根据 Java 堆是否规整，有两种方式： 指针碰撞：如果 Java 堆的内存是规整，即所有用过的内存放在一边，而空闲的内存放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。 空闲列表：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。 选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理的功能决定。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:3:1","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#为对象分配内存"},{"categories":null,"content":" 处理并发安全问题对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）； 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用 TLAB。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:3:2","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#处理并发安全问题"},{"categories":null,"content":" 对象的访问定位Java 程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有句柄和直接指针两种方式。 直接指针：指向对象，代表一个对象在内存中的起始地址。 句柄：可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:4:0","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#对象的访问定位"},{"categories":null,"content":" 句柄访问Java 堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。 优点：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:4:1","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#句柄访问"},{"categories":null,"content":" 直接指针如果使用直接指针访问，引用中存储的直接就是对象地址，那么 Java 堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。 优点：速度更快，节省了一次指针定位的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 虚拟机中采用的就是这种方式。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:4:2","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#直接指针"},{"categories":null,"content":" 内存溢出内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说， Java 是有 GC 垃圾回收机制的，也就是说，不再被使用的对象，会被 GC 自动回收掉，自动从内存中清除。但是，即使这样，Java 也还是存在着内存泄漏的情况，Java 导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为 长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:5:0","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#内存溢出"},{"categories":null,"content":" Java 垃圾回收机制 GC 垃圾回收，顾名思义就是释放垃圾占用的空间，从而提升程序性能，防止内存泄露。当一个对象不再被需要时，该对象就需要被回收并释放空间。 Java 内存运行时数据区域包括程序计数器、虚拟机栈、本地方法栈、堆等区域。其中，程序计数器、虚拟机栈和本地方法栈都是线程私有的，当线程结束时，这些区域的生命周期也结束了，因此不需要过多考虑回收的问题。而堆是虚拟机管理的内存中最大的一块，堆中的内存的分配和回收是动态的，垃圾回收主要关注的是堆空间。 调用垃圾回收器的方法 调用垃圾回收器的方法是gc，该方法在System类和Runtime类中都存在。在Runtime类中，方法gc是实例方法，方法System.gc是调用该方法的一种传统而便捷的方法。在System类中，方法gc是静态方法，该方法会调用Runtime类中的gc方法。其实，java.lang.System.gc等价于java.lang.Runtime.getRuntime.gc的简写，都是调用垃圾回收器。方法gc的作用是提示Java虚拟机进行垃圾回收，该方法由系统自动调用，不需要人为调用。该方法被调用之后，由Java虚拟机决定是立即回收还是延迟回收。 finalize 方法 与垃圾回收有关的另一个方法是finalize方法。该方法在Object类中被定义，在释放对象占用的内存之前会调用该方法。该方法的默认实现不做任何事，如果必要，子类应该重写该方法，一般建议在该方法中释放对象持有的资源。 判断对象是否可回收 垃圾回收器在对堆进行回收之前，首先需要确定哪些对象是可回收的。常用的算法有两种，引用计数算法和根搜索算法。 1.引用计数算法 引用计数算法给每个对象添加引用计数器，用于记录对象被引用的计数，引用计数为 0 的对象即为可回收的对象。 虽然引用计数算法的实现简单，判定效率也很高，但是引用计数算法无法解决对象之间循环引用的情况。如果多个对象之间存在循环引用，则这些对象的引用计数永远不为 0，无法被回收。因此 Java 语言没有使用引用计数算法。 2.根搜索算法 主流的商用程序语言都是使用根搜索算法判断对象是否可回收。根搜索算法的思路是，从若干被称为 GC Roots 的对象开始进行搜索，不能到达的对象即为可回收的对象。 在 Java 中，GC Roots 一般包含下面几种对象： 虚拟机栈中引用的对象 本地方法栈中的本地方法引用的对象 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 3.引用的分类 引用计数算法和根搜索算法都需要通过判断引用的方式判断对象是否可回收。 在 JDK 1.2 之后，Java 将引用分成四种，按照引用强度从高到低的顺序依次是： 强引用：在程序代码中普遍存在的引用。垃圾回收器永远不会回收被强引用关联的对象。 软引用：还有用但并非必需的对象。只有在系统将要发生内存溢出异常时，被软引用关联的对象才会被回收。在 JDK 1.2 之后，提供了SoftReference类实现软引用。 弱引用：非必需的对象，其强度低于软引用。被弱引用关联的对象只能存活到下一次垃圾回收发生之前，当垃圾回收器工作时，被弱引用关联的对象一定会被回收。在 JDK 1.2 之后，提供了WeakReference类实现弱引用。 虚引用：最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。在 JDK 1.2 之后，提供了PhantomReference类实现虚引用。 垃圾回收算法 1.标记—清除算法 标记—清除算法是最基础的垃圾回收算法，后续的垃圾收集算法都是基于标记—清除算法进行改进而得到的。标记—清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 标记—清除算法有两个主要缺点。一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 2.复制算法 复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将还存活着的对象复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 复制算法解决了效率问题。由于每次都是对整个半区进行内存回收，因此在内存分配时不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。复制算法的优点是实现简单，运行高效，缺点是将内存缩小为了原来的一半，以及在对象存活率较高时复制操作的次数较多，导致效率降低。 3.标记—整理算法 标记—整理算法是根据老年代的特点提出的。标记过程与标记—清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向一端移动，然后清除边界以外的内存。 4.分代收集算法 分代收集算法根据对","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:0","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#java-垃圾回收机制"},{"categories":null,"content":" 垃圾回收器的基本原理对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。 可以手动执行System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:1","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#垃圾回收器的基本原理"},{"categories":null,"content":" Java 中的引用类型 强引用：发生 GC 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用PhantomReference 实现虚引用，虚引用的用途是在 GC 时返回一个通知。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:2","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#java-中的引用类型"},{"categories":null,"content":" 如何判断对象是否可以被回收垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器加 1，引用被释放时计数减 1，当计数器为 0 时就可以被回收。它有一个缺点是不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:3","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#如何判断对象是否可以被回收"},{"categories":null,"content":" 垃圾回收算法分类 **标记-清除（Mark-Sweep）**算法：标记无用对象，然后进行清除回收。 优点：实现简单，不需要对象进行移动。 缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。 复制算法：把内存空间划分为两个大小相等的区域，当一块用完的时候将活着的对象复制到另一块，然后再把已使用的内存空间一次清理掉。 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。 缺点：内存使用率不高，只有 50%。对象存活率过高时会频繁进行复制，降低了效率。 **标记-整理（Mark-Compact）**算法：标记无用对象，让所有存活的对象都向一端移动，使它们紧凑的排列在一起，然后对端边界以外的内存进行回收。 优点：解决了标记-清理算法存在的内存碎片问题。 缺点：仍需要进行局部对象移动，一定程度上降低了效率。 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代（Young Generation）、老年代（Old/Tenured Generation）和永久代（Permanent Generation）。新生代基本采用复制算法，老年代采用标记整理算法。当前商业虚拟机都采用分代收集的垃圾收集算法。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:4","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#垃圾回收算法分类"},{"categories":null,"content":" 永久代中会发生垃圾回收吗垃圾回收不会发生在永久代，但如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。 Java 8 中移除了永久代，新加了一个叫做元数据区的 native 内存区。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:5","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#永久代中会发生垃圾回收吗"},{"categories":null,"content":" 垃圾回收器分类 新生代的垃圾收集器： Serial（复制算法）：新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效； ParNew（复制算法）：新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现； Parallel Scavenge（复制算法）：新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； 老年代的垃圾收集器： Serial Old（标记-整理算法）：老年代单线程垃圾收集器，Serial 的老年代版本； Parallel Old（标记-整理算法）：老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本； CMS（Concurrent Mark-Sweep）（标记-清除算法）：老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。 整个 Java 堆空间 G1（Garbage First）（标记-整理算法）： Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。 CMS 垃圾回收器CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 垃圾回收器的工作流程新生代默认占总空间的 1/3，老生代默认占 2/3。新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 区中存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就加 1，当年龄到达 15（默认值）时，移动到老生代。占内存大的对象也会直接进入老生代。 老生代中空间占用到达某个阈值之后就会触发全局垃圾回收（Full GC），一般使用标记-整理算法。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:6","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#垃圾回收器分类"},{"categories":null,"content":" 垃圾回收器分类 新生代的垃圾收集器： Serial（复制算法）：新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效； ParNew（复制算法）：新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现； Parallel Scavenge（复制算法）：新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； 老年代的垃圾收集器： Serial Old（标记-整理算法）：老年代单线程垃圾收集器，Serial 的老年代版本； Parallel Old（标记-整理算法）：老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本； CMS（Concurrent Mark-Sweep）（标记-清除算法）：老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。 整个 Java 堆空间 G1（Garbage First）（标记-整理算法）： Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。 CMS 垃圾回收器CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 垃圾回收器的工作流程新生代默认占总空间的 1/3，老生代默认占 2/3。新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 区中存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就加 1，当年龄到达 15（默认值）时，移动到老生代。占内存大的对象也会直接进入老生代。 老生代中空间占用到达某个阈值之后就会触发全局垃圾回收（Full GC），一般使用标记-整理算法。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:6","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#cms-垃圾回收器"},{"categories":null,"content":" 垃圾回收器分类 新生代的垃圾收集器： Serial（复制算法）：新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效； ParNew（复制算法）：新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现； Parallel Scavenge（复制算法）：新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； 老年代的垃圾收集器： Serial Old（标记-整理算法）：老年代单线程垃圾收集器，Serial 的老年代版本； Parallel Old（标记-整理算法）：老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本； CMS（Concurrent Mark-Sweep）（标记-清除算法）：老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。 整个 Java 堆空间 G1（Garbage First）（标记-整理算法）： Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。 CMS 垃圾回收器CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 垃圾回收器的工作流程新生代默认占总空间的 1/3，老生代默认占 2/3。新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 区中存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就加 1，当年龄到达 15（默认值）时，移动到老生代。占内存大的对象也会直接进入老生代。 老生代中空间占用到达某个阈值之后就会触发全局垃圾回收（Full GC），一般使用标记-整理算法。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:6","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#垃圾回收器的工作流程"},{"categories":null,"content":" Java 内存分配策略对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲（TLAB），将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配（大对象）。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则： 对象优先在 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。 Minor GC：发生在新生代中的 GC，因为 Java 对象大多都是朝生夕死，所以 Minor GC 非常频繁，一般回收速度也非常快； Major GC/Full GC：发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。 大对象直接进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。新生代使用的是复制算法，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。 长期存活对象将进入老年代。虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每经过一次 Minor GC 未被回收则年龄加 1，当年龄达到一个阈值（默认 15）就会被晋升到老年代。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:6:7","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#java-内存分配策略"},{"categories":null,"content":" JVM 类加载机制虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:7:0","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#jvm-类加载机制"},{"categories":null,"content":" JVM 加载 class 文件Java 中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也 是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时 候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。类装载方式，有两种： 隐式装载。程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用 类装载器加载对应的类到 JVM 中。 显式装载。通过Class.forName()等方法，显式加载需要的类。 Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到 JVM 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:7:1","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#jvm-加载-class-文件"},{"categories":null,"content":" 类加载器实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有一下四种类加载器: 启动类加载器(Bootstrap ClassLoader)用来加载 Java 核心类库，无法被 java程序直接引用。 扩展类加载器(extensions class loader): 它用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径 （CLASSPATH ）来加载 Java 类。一般来说，Java 应用的类都是由它来 完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:7:2","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#类加载器"},{"categories":null,"content":" 类装载的执行过程类装载分为以下 5个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 验证：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为 一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:7:3","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#类装载的执行过程"},{"categories":null,"content":" 双亲委派模型在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一 个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/:7:4","series":null,"tags":["Java","虚拟机","面试","JVM"],"title":"Java 虚拟机详解","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E8%A7%A3/#双亲委派模型"},{"categories":[],"content":"import numpy as np ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 随机种子 np.random.seed(self, seed=None)：固定随机数的输出结果。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#随机种子"},{"categories":[],"content":" 创建数组","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#创建数组"},{"categories":[],"content":" 指定值填充 np.empty(shape, dtype=float, order='C', *, like=None)：返回给定形状和类型的新数组，而无需初始化条目。 np.empty_like(prototype, dtype=None, order='K', subok=True, shape=None)：返回形状和类型与给定数组相同的新数组。 np.eye(N, M=None, k=0, dtype=\u003cclass 'float'\u003e, order='C', *, like=None)：返回单位矩阵。 np.identity(n, dtype=None, *, like=None)：返回单位矩阵。 np.ones(shape, dtype=None, order='C', *, like=None)：返回给定形状和类型的新数组，并用1填充。 np.ones_like(a, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用1填充。 np.zeros(shape, dtype=float, order='C', *, like=None)：返回给定形状和类型的新数组，并用0填充。 np.zeros_like(a, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用0填充。 np.full(shape, fill_value, dtype=None, order='C', *, like=None)：返回给定形状和类型的新数组，并用fill_value填充。 np.full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用fill_value填充。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#指定值填充"},{"categories":[],"content":" 范围内填充 np.arange([start, ]stop, [step, ]dtype=None, *, like=None)：返回给定间隔内的均匀间隔的值。 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)：返回指定间隔内的等间隔数字。 np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)：返回数以对数刻度均匀分布。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#范围内填充"},{"categories":[],"content":" 随机值填充 np.random.rand(d0, d1, ..., dn)：返回服从[0,1)均匀分布的指定形状的浮点数数组。 np.random.uniform(low=0.0, high=1.0, size=None)：返回服从[low,high)均匀分布的指定形状的浮点数数组。 np.random.randint(low, high=None, size=None, dtype=int)：返回服从[low,high)均匀分布的指定形状的整数数组。 np.random.randn(d0, d1, ..., dn)：返回服从N(0,1)标准正态分布的指定形状的浮点数数组。 np.random.normal(loc=0.0, scale=1.0, size=None)：返回服从N(loc,scale)正态分布的指定形状的浮点数数组。 np.random.choice(a, size=None, replace=True, p=None)：从数组中随机有放回采样若干次。 np.random.permutation(x)：返回随机排列。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#随机值填充"},{"categories":[],"content":" 数组操作 ndarray.T：返回转置。 np.transpose(a, axes=None)：返回转置。 np.c_[tup]：左右合并。 np.column_stack(tup)：左右合并。 np.r_[tup]：行合并。 ``：行合并。 ``： ``： ``： ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#数组操作"},{"categories":["力扣","摩尔投票法"],"content":"题目链接 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:0:0","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#"},{"categories":["力扣","摩尔投票法"],"content":" 摩尔投票法","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:0","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#摩尔投票法"},{"categories":["力扣","摩尔投票法"],"content":" 背景摩尔投票法的核心思想为对拼消耗。首先我们考虑最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数 $\\frac{1}{2}$ 的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。摩尔投票算法的核心思想是基于这个事实： 每次从序列里选择两个不相同的数字删除掉（或称为「抵消」），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个元素。假设我们当前数组中存在次数大于总数一半的元素为 x，数组的总长度为 n，则我们可以把数组分为两部分，一部分为相同的 k 个元素 x，另一部分为 $\\frac{n - k}{2}$ 对个不同的元素配对，此时我们假设还存在另外一个次数大于总数一半的元素 y，则此时 y 应该满足 y $\\gt \\frac{n}{2}$，但是按照我们之前的推理 y 应当满足 y $\\le \\frac{n - k}{2}$，二者自相矛盾。 论文地址：MJRTYA Fast Majority Vote Algorithm ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:1","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#背景"},{"categories":["力扣","摩尔投票法"],"content":" 步骤","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:2","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#步骤"},{"categories":["力扣","摩尔投票法"],"content":" 代码 class Solution { public: vector\u003cint\u003e majorityElement(vector\u003cint\u003e \u0026nums) { // 记录两个元素的值 int value1, value2; // 记录对应元素出现的次数 int count1 = 0, count2 = 0; // 第一次遍历：筛选出现次数最多元素（至少0个，至多2个）或者出现位置偏后的元素，用 value1 和 value2 记录 for (int \u0026v : nums) { if (count1 == 0 \u0026\u0026 count2 == 0 || count1 == 0 \u0026\u0026 v != value2) { value1 = v; count1++; } else if (count2 == 0 \u0026\u0026 v != value1) { value2 = v; count2++; } else if (v == value1) count1++; else if (v == value2) count2++; else { // 三个元素均不相等则消除 count1--; count2--; } } int total_count1 = 0; int total_count2 = 0; // 第二次遍历：记录筛选出的元素的出现次数，用来检验是否满足题意 for (int \u0026v : nums) { if (count1 \u003e 0 \u0026\u0026 v == value1) total_count1++; if (count2 \u003e 0 \u0026\u0026 v == value2) total_count2++; } vector\u003cint\u003e ans; int len = nums.size(); if (total_count1 \u003e len / 3) ans.push_back(value1); if (total_count2 \u003e len / 3) ans.push_back(value2); return ans; } }; ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:3","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#代码"},{"categories":["力扣","摩尔投票法"],"content":" 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:4","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#复杂度分析"},{"categories":["力扣","特殊算法"],"content":"题目链接 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:0:0","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#"},{"categories":["力扣","特殊算法"],"content":" 反对角线查找","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:0","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#反对角线查找"},{"categories":["力扣","特殊算法"],"content":" 步骤沿着反对角线进行查找，可以右上到左下，也可以反过来，以右上到左下为例： 如果当前元素与 target 相等，返回 true； 如果当前元素大于 target，由于每一列的元素都是升序排列的，那么当前元素所在列往下所有元素全都大于 target，因此考虑左侧的元素； 如果当前元素小于 target，由于每一行的元素都是升序排列的，那么当前元素所在行往左所有元素全都小于 target，因此考虑下方的元素。 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:1","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#步骤"},{"categories":["力扣","特殊算法"],"content":" 代码 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); // 右上角 int x = 0, y = n - 1; while (x \u003c m \u0026\u0026 y \u003e= 0) { if (matrix[x][y] == target) return true; // 先左 else if (matrix[x][y] \u003e target) y--; // 后下 else x++; } return false; } }; ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:2","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#代码"},{"categories":["力扣","特殊算法"],"content":" 复杂度分析 时间复杂度：$O(m + n)$ 空间复杂度：$O(1)$ ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:3","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#复杂度分析"},{"categories":[],"content":"访问无公网地址的设备，如访问手机、平板、笔记本等。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" ZeroTierZeroTier官网 特点： 免费 多平台 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#zerotier"},{"categories":[],"content":" 使用 在ZeroTier官网创建一个账号。 登录后创建一个网络，得到网络ID。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#使用"},{"categories":[],"content":" 使用 从ZeroTier官网下载并安装适用于您的操作系统的 ZeroTier。 加入网络，填写网络ID。 在ZeroTier中心管理网络，对已加入网络的设备，勾选Auth?，在Managed IPs处会显示 IP，即可用此 IP 访问该设备。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#使用-1"},{"categories":[],"content":" 一般结构 // 包 package main // 导包 import ( \"fmt\" ) // 常量 const c = \"C\" // 变量 var v int = 5 // 自定义类型 type T struct { } // init() 函数，最先执行 func init() { } // main() 函数，其次执行 func main() { var a int Func1() // ... fmt.Println(a) } // 自定义可导出（公开）函数 func Func1() { //... } // 自定义不可导出（私有）函数 func func2() { } ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#一般结构"},{"categories":[],"content":" 规范 虽然不需要分号作为语句的结束，但实际上这一过程是由编译器自动完成 不存在隐式类型转换，所有类型转换必须显式说明，如a := int(b) 标识符的命名规则遵循骆驼命名法 \\作为多行连接符 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#规范"},{"categories":[],"content":" 注释 // 单行注释 /* 多行注释 */ 可通过godoc来导出注释，显示文档说明。 每一个包应该有相关注释。 在package语句之前的块注释将被默认认为是这个包的文档说明，称为包注释。 一个包可以有多个文件，只需要在其中一个文件中添加包注释。 所有全局的类型、常量、变量、函数和被导出的对象都应有注释。若出现在函数前面，称为文档注释，例如函数Abc()，则注释为// Abc ...。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#注释"},{"categories":[],"content":" 可见性 public：标识符以大写字母开头，如Name。 private：标识符以小写字母开头，如id。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#可见性"},{"categories":[],"content":" 包 import ( fm \"fmt\" // 别名 \"os\" \"./local_pkg\" // 本地包 ) 规范： 导入的包未使用报错。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#包"},{"categories":[],"content":" 函数 func funcName(p1 int, p2 int) (add int, sub int) { return p1 + p2, p1 - p2 } // 函数很短，也可以放在同一行 func Sum(a, b int) int { return a + b } 规范： main()函数： main()函数是程序第一个执行的函数（如果有init()函数则会先执行init()） main包必须包含main()函数 main()函数既没有参数，也没有返回类型 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#函数"},{"categories":[],"content":" 类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map\u003cstring, int\u003e或typedef map\u003cstring, int\u003e si; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) 每遇到一次const关键字，iota就重置为0 变量 var a, b int = 1, 2 var ( c int d bool e string ) 变量声明后，自动赋零值 int为0，float为0.0，bool为false，string为\"\"，指针为nil。 内层代码块中可使用与外部代码相同名称的变量，此时外部的同名变量将会暂时隐藏（内层不改变外部变量值） ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#类型"},{"categories":[],"content":" 类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map或typedef map si; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) 每遇到一次const关键字，iota就重置为0 变量 var a, b int = 1, 2 var ( c int d bool e string ) 变量声明后，自动赋零值 int为0，float为0.0，bool为false，string为\"\"，指针为nil。 内层代码块中可使用与外部代码相同名称的变量，此时外部的同名变量将会暂时隐藏（内层不改变外部变量值） ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#常量"},{"categories":[],"content":" 类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map或typedef map si; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) 每遇到一次const关键字，iota就重置为0 变量 var a, b int = 1, 2 var ( c int d bool e string ) 变量声明后，自动赋零值 int为0，float为0.0，bool为false，string为\"\"，指针为nil。 内层代码块中可使用与外部代码相同名称的变量，此时外部的同名变量将会暂时隐藏（内层不改变外部变量值） ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#变量"},{"categories":[],"content":" 英语 简称 中文 Accuracy 精度 Activation Function 激活函数 Adaptive Boosting AdaBoost AdaBoost Adaptive Gradient Algorithm AdaGrad AdaGrad Adaptive Moment Estimation Algorithm Adam Adam Affinity Matrix 亲和矩阵 Agent 智能体 Alpha-Beta Pruning α-β修剪法 Anomaly Detection 异常检测 Area Under ROC Curve AUC Artificial Intelligence AI 人工智能 Artificial Neural Network ANN 人工神经网络 Attention Mechanism 注意力机制 Autoencoder AE 自编码器 Automatic Differentiation AD 自动微分 Autoregressive AR 自回归 Back Propagation BP 反向传播 Bag of Words BOW 词袋 Bagging 装袋 Bandit 赌博机/老虎机 Baseline 基准 Batch Gradient Descent BGD 批量梯度下降法 Batch Normalization BN 批量规范化 Batch Size 批量大小 Bayes Classifier 贝叶斯分类器 Beam Search 束搜索 Benchmark 基准 Bi-Directional Long-Short Term Memory Bi-LSTM 双向长短期记忆 Bias 偏差/偏置 Bidirectional Recurrent Neural Network Bi-RNN 双向循环神经网络 Bigram 二元语法 Binary Sparse Coding 二值稀疏编码 Boosting Tree 提升树 Bootstrap Sampling 自助采样法 Bootstrapping 自助法/自举法 Bottom-Up 自下而上 Chebyshev Distance 切比雪夫距离 Classification And Regression Tree CART 分类与回归树 Computer Vision CV 计算机视觉 Conditional Random Field CRF 条件随机场 Confidence 置信度 Confusion Matrix 混淆矩阵 Conjugate Gradient 共轭梯度 Consistency Convergence 一致性收敛 Content-Addressable Memory CAM 基于内容寻址的存储 Context-Specific Independences 特定上下文独立 Contextual Bandit 上下文赌博机/上下文老虎机 Contextualized Representation 基于上下文的表示 Contractive Autoencoder 收缩自编码器 Contrastive Divergence 对比散度 Convergence 收敛 Convex Optimization 凸优化 Convex Quadratic Programming 凸二次规划 Convolutional Neural Network CNN 卷积神经网络 Correlation Coefficient 相关系数 Cost Function 代价函数 Covariance 协方差 Credit Assignment Problem CAP 贡献度分配问题 Cross Correlation 互相关 Cross Entropy 交叉熵 Cross Validation 交叉验证 Cross-Entropy Loss Function 交叉熵损失函数 Cumulative Distribution Function CDF 累积分布函数 Curvature 曲率 Curve-Fitting 曲线拟合 Data Mining 数据挖掘 Decision Tree 决策树 Deconvolution 反卷积 Deduction 演绎 Deep Convolutional Generative Adversarial Network DCGAN 深度卷积生成对抗网络 Denoising 去噪 Derivative 导数 Determinant 行列式 Diagonal Matrix 对角矩阵 Dimension Reduction 降维 Discriminative Model 判别式模型 Discriminator 判别器 Distance Measure 距离度量 Diverge 发散 Divergence 散度 Diversi","date":"2021-09-22","objectID":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/:0:0","series":null,"tags":[],"title":"翻译专业术语表","uri":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/#"},{"categories":[],"content":" 参考 Artificial-Intelligence-Terminology-Database ","date":"2021-09-22","objectID":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/:1:0","series":null,"tags":[],"title":"翻译专业术语表","uri":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/#参考"},{"categories":[],"content":"根据模型预测值和真实值的区别来评价模型。 ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#"},{"categories":[],"content":" 1.回归","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#1回归"},{"categories":[],"content":" 1.1 MAE平均绝对误差，MAE，Mean Absolute Error $$ MAE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i| $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:1","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#11-mae"},{"categories":[],"content":" 1.2 MAPE平均绝对百分比误差，MAPE，Mean Absolute Percentage Error $$ MAPE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n\\frac{|y_i-\\hat{y}_i|}{|y_i|} $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:2","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#12-mape"},{"categories":[],"content":" 1.3 MSE均方误差，MSE，Mean Squared Error $$ MSE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i|_2^2 $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:3","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#13-mse"},{"categories":[],"content":" 1.4 RMSE均方根误差，RMSE，Root Mean Squared Error $$ RMSE(y,\\hat{y})=\\sqrt{\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i|_2^2} $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:4","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#14-rmse"},{"categories":[],"content":" 1.5 MSLE均方误差对数，MSLE，Mean Squared Log Error $$ MSLE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n\\big(\\log{(1+y_i)}-\\log{(1+\\hat{y}_i)}\\big)^2 $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:5","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#15-msle"},{"categories":[],"content":" 1.6 MedAE中位绝对误差，MedAE，Median Absolute Error $$ MedAE(y,\\hat{y})=median(|y_1-\\hat{y}_1|,\\cdots,|y_n-\\hat{y}_n|) $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:6","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#16-medae"},{"categories":[],"content":" 1.7 $R^2$拟合优度/可决系数，$R^2$，R Squared $$ R^2(y,\\hat{y})=1-\\frac{ \\sum_{i=1}^n (y_i-\\hat{y_i})^2 }{ \\sum_{i=1}^n (y_i-\\bar{y})^2 } $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:7","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#17-r2"},{"categories":[],"content":" 参考 回归模型的评价指标比较 - 知乎 ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:2:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#参考"},{"categories":null,"content":"设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#"},{"categories":null,"content":" 1.单例模式Singleton Pattern ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#1单例模式"},{"categories":null,"content":" 1.1 定义与特点定义： 一个类只有一个实例。 特点： 单例类只有一个实例对象。 单例对象必须由单例类自行创建。 单例类对外提供一个访问该单例的全局访问点。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#11-定义与特点"},{"categories":null,"content":" 1.2 优点与缺点优点： 减少内存开销。 避免对资源的多重占用。 优化对共享资源的访问。 缺点： 单例模式一般没有接口，扩展困难。扩展必须修改代码，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#12-优点与缺点"},{"categories":null,"content":" 1.3 应用场景 需要频繁创建的类，使用单例可以降低系统的内存压力，减少 GC。 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。 某类创建实例时占用资源较多，或实例化耗时较长，且经常使用。 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。 频繁访问数据库或文件的对象。 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#13-应用场景"},{"categories":null,"content":" 1.4 代码实现 1.4.1 懒汉式 class LazySingleton { // 保证 instance 在所有线程中同步 private static volatile LazySingleton instance; // private 避免类在外部被实例化 private LazySingleton() {} public LazySingleton getInstance() { if (instance == null) { synchronized (LazySingleton.class) { if (instance == null) { instance = new LazySingleton(); } } } return instance; } } 1.4.2 饿汉式 class HungrySingleton { private static final HungrySingleton instance = new HungrySingleton(); private HungrySingleton() {} public HungrySingleton getInstance() { return instance; } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#14-代码实现"},{"categories":null,"content":" 1.4 代码实现 1.4.1 懒汉式 class LazySingleton { // 保证 instance 在所有线程中同步 private static volatile LazySingleton instance; // private 避免类在外部被实例化 private LazySingleton() {} public LazySingleton getInstance() { if (instance == null) { synchronized (LazySingleton.class) { if (instance == null) { instance = new LazySingleton(); } } } return instance; } } 1.4.2 饿汉式 class HungrySingleton { private static final HungrySingleton instance = new HungrySingleton(); private HungrySingleton() {} public HungrySingleton getInstance() { return instance; } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#141-懒汉式"},{"categories":null,"content":" 1.4 代码实现 1.4.1 懒汉式 class LazySingleton { // 保证 instance 在所有线程中同步 private static volatile LazySingleton instance; // private 避免类在外部被实例化 private LazySingleton() {} public LazySingleton getInstance() { if (instance == null) { synchronized (LazySingleton.class) { if (instance == null) { instance = new LazySingleton(); } } } return instance; } } 1.4.2 饿汉式 class HungrySingleton { private static final HungrySingleton instance = new HungrySingleton(); private HungrySingleton() {} public HungrySingleton getInstance() { return instance; } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#142-饿汉式"},{"categories":null,"content":" 2.代理模式Proxy Pattern ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#2代理模式"},{"categories":null,"content":" 2.1 定义与特点定义： 特点： ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#21-定义与特点"},{"categories":null,"content":" 2.2 优点与缺点","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#22-优点与缺点"},{"categories":null,"content":" 2.3 应用场景","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#23-应用场景"},{"categories":null,"content":" 2.4 代码实现","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#24-代码实现"},{"categories":null,"content":" 参考 图说设计模式 — Graphic Design Patterns 设计模式 - 菜鸟教程 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["设计模式"],"title":"设计模式教程","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%99%E7%A8%8B/#参考"},{"categories":[],"content":"类图是 UML 中面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 1.类图表示 一个类的 UML 图表示为一个矩形框，分为三层： 类名 粗体居中 若为抽象类，类名和抽象方法用斜体表示 若为接口，类名上加\u003c\u003cinterface\u003e\u003e，一般无属性 属性 可见性 + 属性名 + 类型 方法 可见性 + 方法名 + ( + 参数名 + 参数类型 + ) + 返回类型 可见性： -表示private #表示protected 空表示package/default +表示public ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#1类图表示"},{"categories":[],"content":" 2.关系表示","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#2关系表示"},{"categories":[],"content":" 2.1 泛化（Generalization） 关系：继承非抽象类 表示：子类指向父类的实线空心三角箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#21-泛化generalization"},{"categories":[],"content":" 2.2 实现（Realize） 关系：继承抽象类 表示：子类指向父类的虚线空心三角箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#22-实现realize"},{"categories":[],"content":" 2.3 聚合（Aggregation） 关系：成员对象是整体对象的属性，部分可独立存在，且可属于多个整体 表示：部分指向整体的实线空心菱形箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#23-聚合aggregation"},{"categories":[],"content":" 2.4 组合（Composition） 关系：成员对象是整体对象的属性，整体与部分密不可分 表示：部分指向整体的实线实心菱形箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#24-组合composition"},{"categories":[],"content":" 2.5 关联（Association） 关系：成员对象是整体对象的属性，一般表示一种平等关系 表示：部分指向整体的实线箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#25-关联association"},{"categories":[],"content":" 2.6 依赖（Dependency） 关系：依赖对象一般作为参数传入另一个对象 表示：对象指向依赖对象的虚线箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#26-依赖dependency"},{"categories":[],"content":" 参考 看懂UML类图和时序图 — Graphic Design Patterns 30分钟学会UML类图 - 知乎 Class diagrams - Mermaid ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#参考"},{"categories":null,"content":" 1.数组","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#1数组"},{"categories":null,"content":" 打印数组 import java.utils.Arrays; int[] arr1; System.out.println(Arrays.toString()); int[][] arr2; System.out.println(Arrays.deepToString()); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#打印数组"},{"categories":null,"content":" 类型转换 // int[] 转 List\u003cInteger\u003e // 不可添加、删除、修改 int[] arr; List\u003cInteger\u003e list = List.of(arr); // int[] 转 Integer[] int[] arr; Integer[] arr2 = IntStream.of(arr).boxed() // Integer[] 转 List\u003cInteger\u003e // 不可添加、删除、修改 Integer[] arr; List\u003cInteger\u003e list = List.of(arr); // List\u003cInteger\u003e 转 Integer[] List\u003cInteger\u003e list; int[] arr2 = list.stream().mapToInt().toArray(Integer::new); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#类型转换"},{"categories":null,"content":" 2.Collection","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#2collection"},{"categories":null,"content":" 2.1 方法 int size()：返回容器大小 boolean isEmpty()：容器是否为空 boolean contains(Object element)：是否包含指定元素 boolean add(E element)：添加元素；未添加成功返回 false boolean remove(Object element)：删除指定元素；未删除成功返回 false Iterator\u003cE\u003e iterator()：返回迭代器 boolean containsAll(Collection\u003c?\u003e c)：$A \\supset B$；当前容器是否包含了容器 c 中的所有元素 boolean addAll(Collection\u003c? extends E\u003e c)：$A \\cup B$；添加容器 c 中的所有元素到当前容器 boolean removeAll(Collection\u003c?\u003e c)：$A-B$；从当前容器中删除同时包含于容器 c 中的所有元素 boolean retainAll(Collection\u003c?\u003e c)：$A \\cap B$；从当前容器中删除不包含于容器 c 中的所有元素 void clear()：清空容器 Object[] toArray()：容器转 Object 数组 \u003cT\u003e T[] toArray(T[] a)：容器转数组 `` ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#21-方法"},{"categories":null,"content":" 2.2 遍历（1）聚合操作（Stream + Lambda）：只能访问，不能修改。 myColl.stream() .filter(e -\u003e e.getAttribute() == \"Attribute\") .forEach(e -\u003e System.out.println(e.toString())); myColl.forEach(System.out::println); （2）for-each：只能访问，不能修改。 for (Object o : myColl) { System.out.println(o); } （3）Iterator：可修改。 // 定义 public interface Iterator\u003cE\u003e { boolean hasNext(); // 是否存在下个元素 E next(); // 迭代器后移，同时返回下个元素 void remove(); // 删除当前元素 } for (Iterator\u003cE\u003e it = myColl.iterator(); it.hasNext();) { System.out.println(it.next()); } for (Iterator\u003cE\u003e it = myColl.iterator(); it.hasNext();) { E e = it.next(); if (judge(e)) { it.remove(); } } （4）for：可修改。 for (int i = 0; i \u003c myColl.size(); i++) { System.out.println(myColl.get(i)); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#22-遍历"},{"categories":null,"content":" List import java.util.List; ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator\u003cInteger\u003e it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List\u003cInteger\u003e list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List\u003cInteger\u003e list4 = List.of(1, 2, 3); // 初始化5，推荐 List\u003cInteger\u003e list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List\u003cInteger\u003e list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet\u003cInteger\u003e deDuplicator = new LinkedHashSet\u003c\u003e(list1); List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List\u003cInteger\u003e list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List\u003cInteger\u003e list4 = new ArrayList\u003c\u003e(); HashSet\u003cInteger\u003e hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { // AbstractList\u003cE\u003e protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#arraylist"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#api"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#初始化"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#去重"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#源码"},{"categories":null,"content":" LinkedList import java.util.LinkedList; API构造方法 增 // 尾部添加 boolean add​(E e) // 一般 List 使用 boolean offer​(E e) // 一般 Queue 使用 void addLast​(E e) // 一般 LinkedList 使用 boolean offerLast​(E e) // 一般 Deque 使用 // 首部添加 void addFirst​(E e) // 一般 LinkedList 使用 boolean offerFirst​(E e) // 一般 Deque 使用 void push​(E e) // 一般 栈 使用 // 指定位置添加 void add​(int index, E element) // 添加集合 boolean addAll​(Collection\u003c? extends E\u003e c) boolean addAll​(int index, Collection\u003c? extends E\u003e c) 删 // 尾部删除 E removeLast() // 一般 LinkedList 使用 E pollLast() // 一般 Deque 使用 // 首部删除 E remove() // 一般 List 使用 E poll() // 一般 Queue 使用 E removeFirst() // 一般 LinkedList 使用 E pollFirst() // 一般 Deque 使用 E pop() // 一般 栈 使用 // 指定位置删除 E remove​(int index) // 指定元素删除 boolean remove​(Object o) boolean removeFirstOccurrence​(Object o) boolean removeLastOccurrence​(Object o) // 清空 void clear() 改 E set​(int index, E element) 查 // 尾部 E getLast() // 一般 List 使用 E peekLast() // 一般 List 使用 // 指定位置 E get​(int index) // 首部 E getFirst() // 一般 List 使用 E peekFirst() // 一般 List 使用 E peek() // 一般 Queue 使用 boolean contains​(Object o) int indexOf​(Object o) int lastIndexOf​(Object o) 其他 ListIterator\u003cE\u003e listIterator​(int index) Iterator\u003cE\u003e descendingIterator() ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#linkedlist"},{"categories":null,"content":" LinkedList import java.util.LinkedList; API构造方法 增 // 尾部添加 boolean add​(E e) // 一般 List 使用 boolean offer​(E e) // 一般 Queue 使用 void addLast​(E e) // 一般 LinkedList 使用 boolean offerLast​(E e) // 一般 Deque 使用 // 首部添加 void addFirst​(E e) // 一般 LinkedList 使用 boolean offerFirst​(E e) // 一般 Deque 使用 void push​(E e) // 一般 栈 使用 // 指定位置添加 void add​(int index, E element) // 添加集合 boolean addAll​(Collection\u003c? extends E\u003e c) boolean addAll​(int index, Collection\u003c? extends E\u003e c) 删 // 尾部删除 E removeLast() // 一般 LinkedList 使用 E pollLast() // 一般 Deque 使用 // 首部删除 E remove() // 一般 List 使用 E poll() // 一般 Queue 使用 E removeFirst() // 一般 LinkedList 使用 E pollFirst() // 一般 Deque 使用 E pop() // 一般 栈 使用 // 指定位置删除 E remove​(int index) // 指定元素删除 boolean remove​(Object o) boolean removeFirstOccurrence​(Object o) boolean removeLastOccurrence​(Object o) // 清空 void clear() 改 E set​(int index, E element) 查 // 尾部 E getLast() // 一般 List 使用 E peekLast() // 一般 List 使用 // 指定位置 E get​(int index) // 首部 E getFirst() // 一般 List 使用 E peekFirst() // 一般 List 使用 E peek() // 一般 Queue 使用 boolean contains​(Object o) int indexOf​(Object o) int lastIndexOf​(Object o) 其他 ListIterator listIterator​(int index) Iterator descendingIterator() ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#api-1"},{"categories":null,"content":" 4.4 遍历ListIterator：可修改，双向迭代。 // 列表迭代器定义 public interface ListIterator\u003cE\u003e extends Iterator\u003cE\u003e { boolean hasNext(); E next(); int nextIndex(); // 返回下个元素下标 boolean hasPrevious(); E previous(); int previousIndex(); void remove(); void set(E e); // 修改当前迭代器指向元素 void add(E e); // 添加到当前迭代器指向元素之前（next 之前，previous 之后），能被 } 迭代器总是位于元素之间，它并不指向某个元素，而是指向元素之间的间隔。 所以，listIterator(int index)可以接受的参数范围为[0, myList.size()] listIterator()返回的迭代器初始位于第一个元素之前。 listIterator()返回的迭代器初始位于第一个元素之前。 // 正向 for (ListIterator\u003cE\u003e it = myList.listIterator(); it.hasNext();) { E e = it.next(); } // 逆向 for (ListIterator\u003cE\u003e it = myList.listIterator(myList.size()); it.hasPrevious();) { E e = it.previous(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#44-遍历"},{"categories":null,"content":" List 和数组转换 List 转数组 List\u003cInteger\u003e list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List\u003cInteger\u003e list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list-和数组转换"},{"categories":null,"content":" List 和数组转换 List 转数组 List list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list-转数组"},{"categories":null,"content":" List 和数组转换 List 转数组 List list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#数组转-list"},{"categories":null,"content":" Queue // 定义 Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); // 向队尾添加元素 queue.offer(1); // 删除队首元素并返回 int first1 = queue.poll(); // 取队首元素 int first2 = queue.peek(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#queue"},{"categories":null,"content":" Deque // 定义 Deque\u003cInteger\u003e deque = new LinkedList\u003c\u003e(); // 队尾添加 deque.offerLast(1); // 队首添加 deque.offerFirst(1); // 队尾删除并返回 int last1 = deque.pollLast(); // 队首删除并返回 int first1 = deque.pollFirst(); // 取队尾元素 int last2 = deque.peekLast(); // 取队首元素 int first2 = deque.peekFirst(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#deque"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue\u003cInteger\u003e q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue\u003cInteger\u003e q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable\u003cA\u003e { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator\u003cA\u003e { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue\u003cStu\u003e q1 = new PriorityQueue\u003c\u003e(new StuComp\u003cStu\u003e()); // 显式定义排序类 class StuComp implements Comparator\u003cStu\u003e { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue\u003cStu\u003e q1 = new PriorityQueue\u003c\u003e(new Comparator\u003cStu\u003e() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator\u003cStu\u003e { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#priorityqueue"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#基本用法"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#自定义类"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#模板"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#具体实现"},{"categories":null,"content":" Set","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#set"},{"categories":null,"content":" HashSet 元素唯一，不可重复 元素乱序 数组+哈希函数实现，性能最优 import java.util.HashSet; HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(1); set.contains(1); set.remove(1); set.clear(); set.size(); set.isEmpty(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#hashset"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); TreeSet\u003cInteger\u003e set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set\u003cInteger\u003e set1 = set.subSet(1, 2); // [1] Set\u003cInteger\u003e set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set\u003cInteger\u003e set3 = set.tailSet(2); // [1] Set\u003cInteger\u003e set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set\u003cInteger\u003e set3 = set.tailSet(2); // [2, 3] Set\u003cInteger\u003e set4 = set.tailSet(2, false); // [3] // 逆序 Set\u003cInteger\u003e set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator\u003cInteger\u003e it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator\u003cInteger\u003e it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#treeset"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#增"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#查"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#删"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#子集"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#遍历"},{"categories":null,"content":" Map ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#map"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); Map\u003cString, Integer\u003e otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry\u003cString, Integer\u003e ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#hashmap"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#增改"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#查-1"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#删-1"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#遍历-1"},{"categories":null,"content":" TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable\u003cStu\u003e { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) \u003c 0 等价于 x \u003c y if (score != s.score) { return s.score - score; } else { return name.compareTo(s.name); } } } Map\u003cStu, Integer\u003e map = new TreeMap\u003c\u003e(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Map\u003cStu, Integer\u003e map1 = new TreeMap\u003c\u003e(new Comparator\u003cStu\u003e() { @Override public int compare(Stu a, Stu b) { // compare(x, y) \u003c 0 等价于 x \u003c y if (a.score != b.score) { return b.score - a.score; } else { return a.name.compareTo(b.name); } } }); // 实现2 lambda 表达式 Comparator\u003cStu\u003e cmp = (Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Map\u003cStu, Integer\u003e map2 = new TreeMap\u003c\u003e(cmp); // 实现3 lambda 表达式 Map\u003cStu, Integer\u003e map3 = new TreeMap\u003c\u003e((Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name)); // 实现4 Comparator 类方法 Map\u003cStu, Integer\u003e map4 = new TreeMap\u003c\u003e(Comparator.comparing(Stu::getScore).reversed().thenComparing(Stu::getName)); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#treemap"},{"categories":null,"content":" TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) \u003c 0 等价于 x \u003c y if (score != s.score) { return s.score - score; } else { return name.compareTo(s.name); } } } Map map = new TreeMap\u003c\u003e(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Map map1 = new TreeMap\u003c\u003e(new Comparator() { @Override public int compare(Stu a, Stu b) { // compare(x, y) \u003c 0 等价于 x \u003c y if (a.score != b.score) { return b.score - a.score; } else { return a.name.compareTo(b.name); } } }); // 实现2 lambda 表达式 Comparator cmp = (Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Map map2 = new TreeMap\u003c\u003e(cmp); // 实现3 lambda 表达式 Map map3 = new TreeMap\u003c\u003e((Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name)); // 实现4 Comparator 类方法 Map map4 = new TreeMap\u003c\u003e(Comparator.comparing(Stu::getScore).reversed().thenComparing(Stu::getName)); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#类实现-comparable-接口"},{"categories":null,"content":" TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) \u003c 0 等价于 x \u003c y if (score != s.score) { return s.score - score; } else { return name.compareTo(s.name); } } } Map map = new TreeMap\u003c\u003e(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Map map1 = new TreeMap\u003c\u003e(new Comparator() { @Override public int compare(Stu a, Stu b) { // compare(x, y) \u003c 0 等价于 x \u003c y if (a.score != b.score) { return b.score - a.score; } else { return a.name.compareTo(b.name); } } }); // 实现2 lambda 表达式 Comparator cmp = (Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Map map2 = new TreeMap\u003c\u003e(cmp); // 实现3 lambda 表达式 Map map3 = new TreeMap\u003c\u003e((Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name)); // 实现4 Comparator 类方法 Map map4 = new TreeMap\u003c\u003e(Comparator.comparing(Stu::getScore).reversed().thenComparing(Stu::getName)); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#自定义-comparator-比较器"},{"categories":null,"content":" Arrays import java.util.Arrays; ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#arrays"},{"categories":null,"content":" 二分查找查找指定值，返回下标，若未找到则返回应该插入的下标的相反数减一。需要数组升序且元素无重复。 static \u003cT\u003e int binarySearch(T[] a, T key) static \u003cT\u003e int binarySearch(T[] a, int fromIndex, int toIndex, T key) static \u003cT\u003e int binarySearch​(T[] a, T key, Comparator\u003c? super T\u003e c) static \u003cT\u003e int binarySearch​(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c) int[] arr = {1, 3, 5}; Arrays.binarySearch(arr, -1); // -1 Arrays.binarySearch(arr, 0); // -1 Arrays.binarySearch(arr, 1); // 0 Arrays.binarySearch(arr, 2); // -2 Arrays.binarySearch(arr, -4); // -1 Arrays.binarySearch(arr, 8); // -4 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#二分查找"},{"categories":null,"content":" 比较a 小于 b 返回 -1，等于返回 0，大于返回 1。 static \u003cT\u003e int compare(T[] a, T[] b) static \u003cT\u003e int compare​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e int compare​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e int compare​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) 相等 true，不相等 false。 static \u003cT\u003e boolean equals​(T[] a, T[] b) static \u003cT\u003e boolean equals​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e boolean equals​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e boolean equals​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) 比较多维数组 static boolean deepEquals​(Object[] a1, Object[] a2) int[][] a = { { 1, 2 }, { 3, 4 } }; int[][] b = { { 1, 2 }, { 3, 4 } }; System.out.println(a == b); // false System.out.println(a.equals(b)); // false System.out.println(Arrays.deepEquals(a, b)); // true 返回第一个不相等的下标，若全相等，返回 -1。 static \u003cT\u003e int mismatch​(T[] a, T[] b) static \u003cT\u003e int mismatch​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e int mismatch​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e int mismatch​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#比较"},{"categories":null,"content":" 复制新数组长度小于原数组则截断，大于则多余元素为 null/0。 static \u003cT\u003e T[] copyOf​(T[] original, int newLength) static \u003cT,​U\u003e T[] copyOf​(U[] original, int newLength, Class\u003c? extends T[]\u003e newType) static \u003cT\u003e T[] copyOfRange​(T[] original, int from, int to) static \u003cT,​U\u003e T[] copyOfRange​(U[] original, int from, int to, Class\u003c? extends T[]\u003e newType) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:3","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#复制"},{"categories":null,"content":" 赋值 static \u003cT\u003e void fill(T[] a, T val) static \u003cT\u003e void fill(T[] a, int fromIndex, int toIndex, T val) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#赋值"},{"categories":null,"content":" 前缀操作 static \u003cT\u003e void parallelPrefix​(T[] array, BinaryOperator\u003cT\u003e op) static \u003cT\u003e void parallelPrefix​(T[] array, int fromIndex, int toIndex, BinaryOperator\u003cT\u003e op) int[] a = { 1, 2, 3 }; // 前缀和 Arrays.parallelPrefix(a, (x, y) -\u003e x + y); // [1, 3, 6] ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:5","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#前缀操作"},{"categories":null,"content":" 排序 static \u003cT\u003e void sort​(T[] a) static \u003cT\u003e void sort​(T[] a, Comparator\u003c? super T\u003e c) static \u003cT\u003e void sort​(T[] a, int fromIndex, int toIndex) static \u003cT\u003e void sort​(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:6","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#排序"},{"categories":null,"content":" 流 static \u003cT\u003e Stream\u003cT\u003e stream​(T[] array) static \u003cT\u003e Stream\u003cT\u003e stream​(T[] array, int startInclusive, int endExclusive) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:7","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#流"},{"categories":null,"content":" 转为字符串 static \u003cT\u003e String toString(T[] a) static String deepToString​(Object[] a)：可用于打印多维数组。 int[][] a = { { 1, 2 }, { 3, 4 } }; int[][] b = { { 1, 2 }, { 3, 4 } }; System.out.println(a); // [[I@36aa7bc2 System.out.println(Arrays.toString(a)); // [[I@76ccd017, [I@182decdb] System.out.println(Arrays.toString(a[0])); // [1, 2] System.out.println(Arrays.deepToString(a)); // [[1, 2], [3, 4]] ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:8","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#转为字符串"},{"categories":null,"content":" Collections import java.util.Collections; // 创建空集合 // 返回的集合是不可变集合，无法向其中添加或删除元素。 List\u003cString\u003e list1 = Collections.emptyList(); List\u003cString\u003e list2 = List.of(); Map\u003cString, Integer\u003e map1 = Collections.emptyMap(); Map\u003cString, Integer\u003e map2 = Map.of(); Set\u003cString\u003e set1 = Collections.emptySet(); Set\u003cString\u003e set2 = Set.of(); // 创建单元素集合 // 返回的集合是不可变集合，无法向其中添加或删除元素。 List\u003cString\u003e list1 = Collections.singletonList(\"one\"); List\u003cString\u003e list2 = List.of(\"one\"); Map\u003cString, Integer\u003e map1 = Collections.singletonMap(\"one\", 1); Map\u003cString, Integer\u003e map2 = Map.of(\"one\", 1); Set\u003cString\u003e set1 = Collections.singleton(\"one\"); Set\u003cString\u003e set2 = Set.of(\"one\"); // 排序 // 必须传入可变 List Collections.sort(list); // 洗牌 // 必须传入可变 List Collections.shuffle(list); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#collections"},{"categories":null,"content":" 10.代码片段 // 数组转 List // 1.重新分配空间 List\u003cInteger\u003e myList = new ArrayList\u003c\u003e(Arrays.asList(1, 2, 3)); // 2.使用同一片空间 List\u003cInteger\u003e myList = Arrays.asList(1, 2, 3); // 禁止调整大小，若 add 或 remove // 则抛出 UnsupportedOperationException 异常 // 转换为字符串 String str = myColl.stream() .map(Object::toString) .collect(Collectors.joining(\", \")); // 求和 int sum = myColl.stream() .collect(Collectors.summingInt(E::getValue)); // 删除容器中所有指定元素 myColl.removeAll(Collections.singleton(e)); myColl.removeAll(Collections.singleton(mull)); // 容器转数组，要求容器中元素类型统一 String[] arrStr = myColl.toArray(new String[0]); Integer[] arrInt = myColl.toArray(new Integer[0]); // 1.容器去重 Collection\u003cE\u003e noDups = new HashSet\u003c\u003e(myColl); Collection\u003cE\u003e noDups = myColl.stream().collect(Collectors.toSet()); // 2.容器去重，且保持原来顺序 Collection\u003cE\u003e noDups = new LinkedHashSet\u003c\u003e(myColl); public static \u003cE\u003e Set\u003cE\u003e removeDups(Collection\u003cE\u003e myColl) { return new LinkedHashSet\u003cE\u003e(myColl); } // 取出属性值，创建集合 Set\u003cString\u003e set = people.stream() .map(Person::getName) .collect(Collectors.toCollection(TreeSet::new)); // 交换元素 public static \u003cE\u003e void swap(List\u003cE\u003e a, int i, int j) { E tmp = a.get(i); a.set(i, a.get(j)); a.set(j, tmp); } // 洗牌算法，打乱顺序 public static void shuffle(List\u003cE\u003e list, Random rnd) { for (int i = list.size(); i \u003e 1; i--) { swap(list, i - 1, rnd.nextInt(i)); } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#10代码片段"},{"categories":null,"content":" char[] 转 Character[] char[] charArray = { 'a', 'b', 'c' }; Character[] charObjectArray = ArrayUtils.toObject(charArray); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:9:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#char-转-character"},{"categories":null,"content":" 11.聚合操作","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#11聚合操作"},{"categories":null,"content":" 重写 equals 方法 对引用类型用Objects.equals()比较（避免判断null），对基本类型直接用==比较。 import java.util.Objects; public boolean equals(Object o) { if (o instanceof E) { E e = (E) o; // } return false; } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#重写-equals-方法"},{"categories":null,"content":" 重写 hashCode 方法 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 import java.util.Objects; class Stu { String name; int score, age; public int hashCode() { return Objects.hash(name, score, age); } } 参考： Aggregate Operations - Java Tutorials ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#重写-hashcode-方法"},{"categories":null,"content":" StreamsJava 8 中引入。 import java.util.stream.Collectors; import java.util.stream.Stream; // 获取流方法1 int[] array = { 1, 2, 3 }; Stream\u003cInteger\u003e s1 = Stream.of(array); // 获取流方法2 List\u003cInteger\u003e list = List.of(1, 2, 3); Stream\u003cInteger\u003e s2 = list.stream(); // 获取流方法3 Stream\u003cInteger\u003e s3 = Stream.of(1, 2, 3); // forEach 终端操作 List\u003cInteger\u003e list = List.of(1, 2, 3); list.stream().forEach(e -\u003e System.out.println(e)); list.stream().forEach(System.out::println); // map 中间操作 List\u003cString\u003e list = list.stream().map(e -\u003e e.toString()).collect(Collectors.toList()); // collect 终端操作 List\u003cInteger\u003e list = Stream.of(1, 2, 3).collect(Collectors.toList()); String str = list.stream().map(e -\u003e e.toString()).collect(Collectors.joining(\", \")); Set\u003cInteger\u003e set = list.stream().collect(Collectors.toSet()); // filter 中间操作 List\u003cInteger\u003e list = Stream.of(1, 2, 3).filter(e -\u003e e \u003c 2).collect(Collectors.toList()); // findFirst Integer x = Stream.of(1, 2, 3).filter(e -\u003e e % 2 == 1).findFirst().orElse(null); // toArray Integer[] array = list.stream().toArray(Integer[]::new); // flatMap 中间操作 List\u003cList\u003cString\u003e\u003e namesNested = Arrays.asList( Arrays.asList(\"Jeff\", \"Bezos\"), Arrays.asList(\"Bill\", \"Gates\"), Arrays.asList(\"Mark\", \"Zuckerberg\")); List\u003cString\u003e namesFlatStream = namesNested.stream() .flatMap(Collection::stream) .collect(Collectors.toList()); // count 终端操作 long a = list.stream().count(); // Stream\u003cInteger\u003e infiniteStream = Stream.iterate(2, i -\u003e i * 2); List\u003cInteger\u003e collect = infiniteStream .skip(3) // 跳过前 3 个元素 .limit(5) // 长度为 5 .collect(Collectors.toList()); // sorted list.stream().sorted((a, b) -\u003e b - a); // min max Integer x = list.stream().min((a, b) -\u003e a - b).orElse(null); Integer x = list.stream().max((a, b) -\u003e a - b).orElse(null); // distinct List\u003cInteger\u003e newList = list.stream().distinct().collect(Collectors.toList()); // allMatch anyMatch noneMatch boolean allEven = list.stream().allMatch(i -\u003e i % 2 == 0); boolean oneEven = list.stream().anyMatch(i -\u003e i % 2 == 0); boolean noneMultipleOfThree = list.stream().noneMatch(i -\u003e i % 3 == 0); // I","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:13:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#streams"},{"categories":["Python"],"content":"常用 Python 第三方库。 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:0:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#"},{"categories":["Python"],"content":" 机器学习 scikit-learn: machine learning in Python. 🌟48.1k XGBoost: Scalable, Portable and Distributed Gradient Boosting (GBDT, GBRT or GBM) Library, for Python, R, Java, Scala, C++ and more. Runs on single machine, Hadoop, Spark, Dask, Flink and DataFlow. 🌟21.9k LightGBM: A fast, distributed, high performance gradient boosting (GBT, GBDT, GBRT, GBM or MART) framework based on decision tree algorithms, used for ranking, classification and many other machine learning tasks. 🌟13.2k CatBoost: A fast, scalable, high performance Gradient Boosting on Decision Trees library, used for ranking, classification, regression and other machine learning tasks for Python, R, Java, C++. Supports computation on CPU and GPU. 🌟6.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:1:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#机器学习"},{"categories":["Python"],"content":" 深度学习 TensorFlow: TensorFlow is an end-to-end open source platform for machine learning. 🌟161k Pytorch: Tensors and Dynamic neural networks in Python with strong GPU acceleration. 🌟52.4k MXNet: Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Scala, Go, Javascript and more. 🌟19.8k PaddlePaddle: PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice. 🌟17.1k JAX: Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more. 🌟15.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:2:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#深度学习"},{"categories":["Python"],"content":" 超参数优化 Optuna: A hyperparameter optimization framework. 🌟5,642 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:3:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#超参数优化"},{"categories":["Python"],"content":" 自动化机器学习 auto-sklearn: Automated Machine Learning with scikit-learn. 🌟5,907 PyCaret: An open-source, low-code machine learning library in Python. 🌟4,541 Auto-PyTorch: Automatic architecture search and hyperparameter optimization for PyTorch. 🌟1,464 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:4:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#自动化机器学习"},{"categories":["Python"],"content":" 时间序列分析 Prophet: Tool for producing high quality forecasts for time series data that has multiple seasonality with linear or non-linear growth. 🌟13,809 tsfresh: The package provides systematic time-series feature extraction by combining established algorithms from statistics, time-series analysis, signal processing, and nonlinear dynamics with a robust feature selection algorithm. 🌟6,074 sktime: A unified framework for machine learning with time series. 🌟4,721 Kats: Kats, a kit to analyze time series data, a lightweight, easy-to-use, generalizable, and extendable framework to perform time series analysis, from understanding the key statistics and characteristics, detecting change points and anomalies, to forecasting future trends. 🌟3,308 Darts: A python library for easy manipulation and forecasting of time series. 🌟3,208 GluonTS: Probabilistic time series modeling in Python. 🌟2,351 Merlion: A Machine Learning Framework for Time Series Intelligence. 🌟2,275 tslearn: A machine learning toolkit dedicated to time-series data. 🌟1,904 tsai: tsai is an open-source deep learning package built on top of Pytorch \u0026 fastai focused on state-of-the-art techniques for time series tasks like classification, regression, forecasting, imputation… 🌟1,443 Greykite: The Greykite library provides flexible, intuitive and fast forecasts through its flagship algorithm, Silverkite. 🌟1,358 mcfly: A deep learning tool for time series classification. 🌟337 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:5:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#时间序列分析"},{"categories":["Python"],"content":" 计算机视觉 Face Recognition: The world’s simplest facial recognition api for Python and the command line. 🌟42.3k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:6:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#计算机视觉"},{"categories":["Python"],"content":" 自然语言处理 Transformers: State-of-the-art Natural Language Processing for Pytorch, TensorFlow, and JAX. 🌟54.9k jieba: “结巴”中文分词：做最好的 Python 中文分词组件。 🌟27.4k HanLP: 中文分词 词性标注 命名实体识别 依存句法分析 成分句法分析 语义依存分析 语义角色标注 指代消解 风格转换 语义相似度 新词发现 关键词短语提取 自动摘要 文本分类聚类 拼音简繁转换 自然语言处理。 🌟24.5k spaCy: Industrial-strength Natural Language Processing (NLP) in Python. 🌟21.9k AllenNLP: An open-source NLP research library, built on PyTorch. 🌟10.7k NLTK: NLTK – the Natural Language Toolkit – is a suite of open source Python modules, data sets, and tutorials supporting research and development in Natural Language Processing. 🌟10.3k TextBlob: Simple, Pythonic, text processing–Sentiment analysis, part-of-speech tagging, noun phrase extraction, translation, and more. 🌟8k fastNLP: fastNLP 是一款面向自然语言处理（NLP）的轻量级框架，目标是快速实现NLP任务以及构建复杂模型。 🌟2.4k textacy: NLP, before and after spaCy. 🌟1.8k xmnlp: 提供中文分词, 词性标注, 命名体识别，情感分析，文本纠错，文本转拼音，文本摘要，偏旁部首等功能。 🌟736 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:7:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#自然语言处理"},{"categories":["Python"],"content":" 科学计算 NumPy: The fundamental package for scientific computing with Python. 🌟18.9k SciPy: SciPy is an open-source software for mathematics, science, and engineering. It includes modules for statistics, optimization, integration, linear algebra, Fourier transforms, signal and image processing, ODE solvers, and more. 🌟8.9k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:8:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#科学计算"},{"categories":["Python"],"content":" 处理数据 pandas: Flexible and powerful data analysis / manipulation library for Python, providing labeled data structures similar to R data.frame objects, statistical functions, and much more. 🌟31.8k pdfminer.six: It is a tool for extracting information from PDF documents. 🌟3.2k openpyxl: openpyxl is a Python library to read/write Excel 2010 xlsx/xlsm/xltx/xltm files. ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:9:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#处理数据"},{"categories":["Python"],"content":" 可视化 Matplotlib: Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. 🌟14.6k seaborn: Seaborn is a Python visualization library based on matplotlib. It provides a high-level interface for drawing attractive statistical graphics. 🌟9k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:10:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#可视化"},{"categories":["Python"],"content":" 爬虫 Requests: A simple, yet elegant, HTTP library. 🌟46.5k Scrapy: Scrapy, a fast high-level web crawling \u0026 scraping framework for Python. 🌟42.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:11:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#爬虫"},{"categories":[],"content":"Pandas 是一个优秀的数据处理库。 import pandas as pd ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 数据结构","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#数据结构"},{"categories":[],"content":" DataFrame df = pd.DataFrame({\"c1\": [11, 21, 31], \"c2\": [12, 22, 32], \"c3\": [13, 23, 33]}, index=[\"r1\", \"r2\", \"r3\"]) df = pd.DataFrame([[11, 12, 13], [21, 22, 23], [31, 32, 33]], index=['r1', 'r2', 'r3'], columns=['c1', 'c2', 'c3']) ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#dataframe"},{"categories":[],"content":" Series","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#series"},{"categories":[],"content":" 读取数据 pd.read_csv() ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#读取数据"},{"categories":[],"content":" 处理缺失数据 df.dropna() df.fillna(value) ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#处理缺失数据"},{"categories":[],"content":" 参考 User Guide — pandas documentation ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#参考"},{"categories":[],"content":"阿里云盘相关小技巧。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:0:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#"},{"categories":[],"content":" 1）阿里云盘转存115资源 下载 Chrome 或 Edge 或 Firefox 浏览器，并安装 Tampermonkey 插件。 安装脚本。 打开阿里云盘网页版。 点击右上角多文件提取，导入 sha1 链接文件。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:1:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#1阿里云盘转存115资源"},{"categories":[],"content":" 参考 如何使用第三方脚本实现阿里云盘分享文件 - 太空堡垒麦克罗斯 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:1:1","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#参考"},{"categories":[],"content":" 2）绕过阿里云分享限制目前阿里云盘只能分享 txt、mp4、jpg 等特定类型的文件, 而不能分享 zip、rar、7z 等压缩文件。 下载十六进制编辑器，修改前四个数值就可以改变文件种类。 macOS：brew install hex-fiend 示例：将zip文件伪装成png文件。 打开文件，将前四个数值改为89504E47。 修改文件后缀为png。 上传阿里云盘，此时可以分享。 下载文件后打开，将前四个数值改回504B0304。 文件后缀改回zip，然后解压。 文件类型 前四个值 png 89504E47 jpg/jpeg FFD8FFE0 gif 47494638 webp 52494646 svg 3C737667 mp4 00000020 zip 504B0304 7z 377ABCAF ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:2:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#2绕过阿里云分享限制"},{"categories":[],"content":" 参考 如何绕过阿里云盘文件分享种类限制 - 哔哩哔哩 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:2:1","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#参考-1"},{"categories":["位运算","力扣"],"content":"题目链接 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#"},{"categories":["位运算","力扣"],"content":" 方法一：模拟","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#方法一模拟"},{"categories":["位运算","力扣"],"content":" 代码 class Solution { public: int xorOperation(int n, int start) { int ans = start; for (int i = 1; i \u003c n; ++i) { ans ^= (start + i * 2); } return ans; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:1","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#代码"},{"categories":["位运算","力扣"],"content":" 复杂度分析 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:2","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#复杂度分析"},{"categories":["位运算","力扣"],"content":" 方法二：数学","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#方法二数学"},{"categories":["位运算","力扣"],"content":" 思路首先介绍异或运算： 对于单个比特的异或，相同为0，相异为1，即： $ 0 \\oplus 0 = 0 $ $ 0 \\oplus 1 = 1 $ $ 1 \\oplus 0 = 1 $ $ 1 \\oplus 1 = 0 $ 对于整数的异或，按最低位对齐，相同位置的比特进行异或运算，如： $ \\ \\ \\ \\ 0001 \\ (1) $ $ \\underline{\\oplus \\ 0011 \\ (3)} $ $ \\ \\ \\ \\ 0010 \\ (2) $ 异或运算满足以下基本性质： $ a \\oplus a = 0 $ $ a \\oplus 0 = a $ $ a \\oplus b = b \\oplus a $ $ (a \\oplus b) \\oplus c = a \\oplus (b \\oplus c) $ 可以推导出如下性质： $ a \\oplus b \\oplus b = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i+1个a} = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i个a} = 0 $ $ \\forall i \\in \\mathbb{Z}, 有 4i \\oplus (4i+1) \\oplus (4i+2) \\oplus (4i+3) = 0 $ 回到本题，我们需要计算 $ start \\oplus (start+2) \\oplus (start+4) \\oplus \\cdots \\oplus (start+2(n-1)) $，观察公式可以知道每一项奇偶性相同，因此它们的二进制表示中的最低位或者均为1或均为0。 于是我们可以把参与运算的数的二进制位的最低位提取出来单独处理。当且仅当start为奇数且n也为奇数时，结果才为奇数，即最低位为1。令 $ e = n \\oplus start \\oplus 1 $。 此时不考虑start的最后一位，我们将start右移一位，令 $ s = \\lfloor \\frac{start}{2} \\rfloor $，公式转化为 $ s \\oplus (s+1) \\oplus (s+2) \\oplus \\cdots \\oplus (s+n-1) + e $。 这样我们可以自定义函数sumXor(x)来计算 $ 0 \\oplus 1 \\oplus 2 \\oplus \\cdots \\oplus x $，根据上面异或运算的推导性质第4条，可以得出如下结论： $ 当x=4i + 0,i \\in \\mathbb{Z}时，sumXor(x) = x $ $ 当x=4i + 1,i \\in \\mathbb{Z}时，sumXor(x) = (x-1) \\oplus x = 1 $ $ 当x=4i + 2,i \\in \\mathbb{Z}时，sumXor(x) = (x-2) \\oplus (x-1) \\oplus x = x + 1 $ $ 当x=4i + 3,i \\in \\mathbb{Z}时，sumXor(x) = 0 $ 所以，最终结果为 $ [(sumXor(s+n-1) \\oplus sumXor(s-1)) \\times 2] \\oplus e $。 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:1","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#思路"},{"categories":["位运算","力扣"],"content":" 代码 class Solution { public: int xorOperation(int n, int start) { int s = start \u003e\u003e 1; int e = n \u0026 start \u0026 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return (ret \u003c\u003c 1) | e; } int sumXor(int x) { if (x % 4 == 0) return x; else if (x % 4 == 1) return 1; else if (x % 4 == 2) return x + 1; return 0; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:2","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#代码-1"},{"categories":["位运算","力扣"],"content":" 复杂度分析 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:3","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#复杂度分析-1"},{"categories":["软件"],"content":"适用于各种平台的一些好用软件。 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:0:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#"},{"categories":["软件"],"content":" 跨平台 Mark Text：简洁美观的 Markdown 编辑器。开源 免费 Visual Studio Code：代码编辑器。开源 免费 JetBrains Toolbox App：JetBrains IDE 管理器。 学生免费 PDF Reader Pro：阅读、编辑、注释、转换和签署 PDF 的最佳 PDF 软件。 付费 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:1:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#跨平台"},{"categories":["软件"],"content":" macOS Homebrew：适用于 macOS（或 Linux）缺失的软件包的管理器。 开源 免费 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Hex Fiend：适用于 macOS 的快速且智能的开源十六进制编辑器。 开源 免费 brew install --cask hex-fiend Mounty for NTFS：在 macOS 下以读写模式重新挂载写保护的 NTFS 卷的小工具。 免费 brew install --cask mounty Android File Transfer：在 Mac 计算机和 Android 设备之间浏览和传输文件。 免费 brew install --cask android-file-transfer IINA：适用于 macOS 的现代媒体播放器。 开源 免费 brew install --cask iina OpenInTerminal-Lite：适用于 macOS 的 Finder 工具栏应用程序，用于在终端、iTerm、Hyper 或 Alacritty 中打开当前目录。 开源 免费 brew install --cask openinterminal-lite brew install --cask openineditor-lite MacZip：专为 macOS 而设计的压缩软件. 免费 brew install --cask maczip CheatSheet：适用于 macOS 的列出当前应用程序所有快捷键的工具。 免费 brew install --cask cheatsheet 腾讯柠檬清理：适用于 macOS 的磁盘清理工具。 免费 QSpace：一款简洁高效的多视图文件管理器。 付费 Alfred：通过自定义操作控制你的 Mac 电脑，提高工作效率。 付费 Downie：适用于 macOS 的视频下载工具。 付费 Dash：API 文档浏览器和代码片段管理器。 付费 shottr：截图、滚动截图、抠图、测距、OCR、取色。 免费 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:2:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#macos"},{"categories":["软件"],"content":" macOS 破解软件下载 MacWk ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:2:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#macos-破解软件下载"},{"categories":["软件"],"content":" Windows Bandizip：压缩文件管理工具。 Everything：基于名称快速定位文件和文件夹。 Potplayer：多媒体播放器。 Revo Uninstaller：软件卸载和清除管理器。 MobaXterm：远程连接管理器。 Visual Studio：C++、C# 开发IDE。 Microsoft Store Windows Terminal QuickLook Files ModernFlyouts (Preview) IrfanView64 TranslucentTB ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:3:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#windows"},{"categories":["软件"],"content":" 浏览器插件","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#浏览器插件"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#chrome-网上应用店需要科学上网"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#沙拉查词"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#mac-沙拉查词--alfred"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#test"},{"categories":["软件"],"content":" Edge 外接程序 BETA uBlock Origin 沙拉查词-聚合词典划词翻译 Tampermonkey Bitwarden - 免费密码管理器 Augmented Steam Edge 浏览器也可到 Chrome 网上应用店安装扩展。 https://github.com/beekeeper-studio/beekeeper-studio ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:2","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#edge-外接程序-betahttpsmicrosoftedgemicrosoftcomaddonsmicrosoft-edge-extensions-homehlzh-cn"},{"categories":[],"content":"从 YouTube 和其他视频网站下载视频的命令行程序。 ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 一、介绍 官网 Github ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#一介绍"},{"categories":[],"content":" 二、安装Windows: 下载exe，然后添加环境变量。 pip install --upgrade youtube-dl # 列出帮助菜单 youtube-dl -h/--help # 查看版本 youtube-dl --version # 升级 youtube-dl -U/--update ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#二安装"},{"categories":[],"content":" 三、使用 # 列出所有清晰度和格式 youtube-dl -F/--list-formats \u003cURL\u003e # 下载对应格式或清晰度 youtube-dl -f/--format \u003cFORMAT\u003e \u003cURL\u003e # 下载后视频和音频合并 youtube-dl -f XXX+YYY \u003cURL\u003e # 下载最佳质量 youtube-dl -f bestvideo+bestaudio \u003cURL\u003e # 列出所有字幕 youtube-dl --list-subs \u003cURL\u003e # 下载英文（en）字幕，格式为 srt youtube-dl --sub-lang en --write-auto-sub --sub-format srt --skip-download \u003cURL\u003e # 代理 youtube-dl --proxy \u003cURL\u003e # cookies youtube-dl --cookies \u003cFILE\u003e # 登录 youtube-dl -u/--username \u003cUSERNAME\u003e youtube-dl -p/--password \u003cPASSWORD\u003e youtube-dl -2/--twofactor \u003cTWOFACTOR\u003e youtube-dl --video-password \u003cPASSWORD\u003e ","date":"2021-04-16","objectID":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"youtube-dl 使用教程","uri":"/posts/youtube-dl-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#三使用"},{"categories":["Hugo"],"content":" 1.网站配置","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#1网站配置"},{"categories":["Hugo"],"content":" 1.1 基础配置 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#11-基础配置"},{"categories":["Hugo"],"content":" 1.2 完整配置 [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#12-完整配置"},{"categories":["Hugo"],"content":" 2.网站图标，浏览器配置，网站清单强烈建议你把： apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在/static目录，利用 RealFaviconGenerator 可以很容易地生成这些文件。 可以自定义browserconfig.xml和site.webmanifest文件来设置 theme-color 和 background-color。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#2网站图标浏览器配置网站清单"},{"categories":["Hugo"],"content":" 3.自定义样式 需使用 Hugo extended 版本 通过自定义.scss样式文件，LoveIt 主题支持自定义的样式。 包含自定义.scss样式文件的路径为assets/css。 在assets/css/_override.scss中，你可以覆盖themes/LoveIt/assets/css/_variables.scss中的变量以自定义样式。 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在assets/css/_custom.scss中，你可以添加一些 CSS 样式代码以自定义样式。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#3自定义样式"},{"categories":["Hugo"],"content":" 4.多语言和 i18nHugo 配置多语言支持 一个支持英语和中文的网站配置： # [en, zh-cn, fr, pl, ...] 默认语言 defaultContentLanguage = \"zh-cn\" [languages] # 英语 [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 # 中文 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 然后，对于每个新页面，将语言代码附加到文件名中。 单个文件my-page.md需要分为三个文件： 英语：my-page.en.md 中文：my-page.zh-cn.md 也可使用 文章前置参数 来翻译文章。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#4多语言和-i18n"},{"categories":["Hugo"],"content":" 修改默认的翻译字符串翻译字符串用于在主题中使用的常见默认值。 目前提供一些语言的翻译，但你可能自定义其他语言或覆盖默认值。 要覆盖默认值，请在你项目的 i18n 目录i18n/\u003clanguageCode\u003e.toml中创建一个新文件，并从themes/LoveIt/i18n/en.toml中获得提示。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#修改默认的翻译字符串"},{"categories":["Hugo"],"content":" 5.搜索基于 Lunr.js 或 algolia，LoveIt 主题支持搜索功能。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#5搜索"},{"categories":["Hugo"],"content":" 5.1 输出配置为了生成搜索功能所需要的index.json，请在你的网站配置中添加JSON输出文件类型到outputs部分的home字段中。 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#51-输出配置"},{"categories":["Hugo"],"content":" 5.2 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#52-搜索配置"},{"categories":["Hugo"],"content":" 5.3 比较 lunr：简单，无需同步index.json，没有contentLength的限制，但占用带宽大且性能低（特别是中文需要一个较大的分词依赖库） algolia：高性能并且占用带宽低，但需要同步index.json且有contentLength的限制 文章内容被h2和h3HTML 标签切分来提高查询效果并且基本实现全文搜索。contentLength用来限制h2和h3HTML 标签开头的内容部分的最大长度。 algolia：你需要上传index.json到 algolia 来激活搜索功能，你可以使用浏览器来上传index.json文件。但是一个自动化的脚本可能效果更好，Algolia Atomic 是一个不错的选择。为了兼容 Hugo 的多语言模式，你需要上传不同语言的index.json文件到对应的 algolia index，例如zh-cn/index.json或en/index.json…… ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:3","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#53-比较"},{"categories":["Hugo"],"content":" 6.内容文本内容组织 保持博客文章存放在content/posts目录，例如：content/posts/我的第一篇文章.md 保持简单的静态页面存放在content目录，例如：content/about.md 本地媒体资源引用 使用页面包中的页面资源。你可以使用适用于Resources.GetMatch的值或者直接使用相对于当前页面目录的文件路径来引用页面资源。 将本地资源放在assets目录中，默认路径是/assets。引用资源的文件路径是相对于assets目录的。 将本地资源放在static目录中，默认路径是/static。引用资源的文件路径是相对于static目录的。 引用的优先级符合以上的顺序。 在这个主题中的很多地方可以使用上面的本地资源引用，例如：链接、图片、image shortcode、music shortcode、和前置参数中的部分参数. 页面资源或者assets目录中的图片处理会在未来的版本中得到支持。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#6内容"},{"categories":["Hugo"],"content":" 7.前置参数 只有在文章的参数和你的网站设置中的page部分不一致时才有必要显式设置。 --- title: \"My first blog\" # 标题 subtitle: \"\" # 副标题 date: 2020-03-04T15:58:26+08:00 # 创建日期 lastmod: 2020-03-04T15:58:26+08:00 # 修改日期 draft: true # 是否草稿 author: \"\" # 作者 authorLink: \"\" # 作者链接 description: \"\" # 内容描述 license: \"\" # 文章许可 images: [] # 页面图片,用于 Open Graph 和 Twitter Cards tags: [] # 标签 categories: [] # 分类 featuredImage: \"\" # 特色图片 featuredImagePreview: \"\" # 主页预览的图片 hiddenFromHomePage: false # 是否从主页上隐藏 hiddenFromSearch: false # 是否从搜索中隐藏 twemoji: false # 是否使用 twemoji lightgallery: true # 图片是否按照画廊形式呈现 ruby: true # 是否使用上标注释扩展语法 fraction: true # 是否使用分数扩展语法 fontawesome: true # 是否使用 Font Awesome 扩展语法 linkToMarkdown: true # 页脚是否显示指向原始 Markdown 文件的链接 rssFullText: false # RSS 中是否显示全文内容 toc: # 和 params.page.toc 部分相同 enable: true auto: true code: # 和 params.page.code 部分相同 copy: true # ... math: # 和 params.page.math 部分相同 enable: true # ... mapbox: # 和 params.page.mapbox 部分相同 accessToken: \"\" # ... share: # 和 params.page.share 部分相同 enable: true # ... comment: # 和 params.page.comment 部分相同 enable: true # ... library: # 和 params.page.library 部分相同 css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: # 和 params.page.seo 部分相同 images: [] # ... --- ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:7:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#7前置参数"},{"categories":["Hugo"],"content":" 8.内容摘要","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:8:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#8内容摘要"},{"categories":[],"content":"You-Get 是一个轻量级命令行工具，可以方便的从一些网站上下载媒体内容（视频、音频、图像）。 ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 一、介绍 官网 Github ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#一介绍"},{"categories":[],"content":" 二、安装pip install --upgrade you-get ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#二安装"},{"categories":[],"content":" 三、使用 # 查看所有可选质量与格式 you-get -i/--info \u003cURL\u003e # 自定义下载文件路径和名称 you-get -o/--output-dir \u003cPATH\u003e \u003cURL\u003e you-get -O/--output-filename \u003cFILENAME\u003e \u003cURL\u003e # 代理 you-get -x/--http-proxy \u003cPROXY_IP:PORT\u003e \u003cURL\u003e # cookies you-get --cookies/-c \u003ccookies.txt/cookies.sqlite\u003e \u003cURL\u003e ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#三使用"},{"categories":[],"content":" 3.1 cookie 获取Chrome 扩展程序：Get cookies.txt ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#31-cookie-获取"},{"categories":[],"content":" 四、支持网站 YouTube bilibili ","date":"2021-04-10","objectID":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":[],"title":"You-Get 使用教程","uri":"/posts/you-get-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#四支持网站"},{"categories":null,"content":"FFmpeg 是视频/音频处理最常用的开源软件。 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#"},{"categories":null,"content":" 常用参数 -c：指定编码器。-c copy：直接复制，不重新编码，加快生成速度 -c:v或-vcodec：指定视频编码器。-c:v copy或-vcodec copy：不改变视频编码，直接拷贝 -c:a或-acodec：指定音频编码器。-c:a copy或-acodec copy：不改变音频编码，直接拷贝 -i：指定输入文件 -an：去除音频流 -vn：去除视频流 -preset：指定输出的视频质量，会影响生成速度。可用值：ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow -y：不经过确认，输出时直接覆盖同名文件 -hwaccel cuvid：指定使用 cuvid 硬件加速 举例： ffmpeg -y -c:a libfdk_aac -c:v libx264 -i input.mp4 -c:a libvorbis -c:v libvpx-vp9 output.webm ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#常用参数"},{"categories":null,"content":" 格式转换 ffmpeg -i input.webm output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#格式转换"},{"categories":null,"content":" 提取视频中的音频 ffmpeg -i input.mp4 -vn -acodec copy output.aac ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#提取视频中的音频"},{"categories":null,"content":" 去除视频中的音频 ffmpeg -i input.mp4 -an -vcodec copy output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#去除视频中的音频"},{"categories":null,"content":" 合并音频和视频视频不包含音频： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental output.mp4 视频包含音频，需要被替换： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental -map 0:v:0 -map 1:a:0 output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#合并音频和视频"},{"categories":null,"content":" 视频截图在第 4.5s 截取一帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 1 output.png 在第 4.5s 截取 10 帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 10 output%d.png ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#视频截图"},{"categories":null,"content":" C++ #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; void solve() { int n; cin \u003e\u003e n; cout \u003c\u003c n \u003c\u003c endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); int t; cin \u003e\u003e t; while (t--) solve(); return 0; } #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef long double ld; typedef complex\u003cld\u003e cd; typedef pair\u003cint, int\u003e pi; typedef pair\u003cll,ll\u003e pl; typedef pair\u003cld,ld\u003e pd; typedef vector\u003cint\u003e vi; typedef vector\u003cld\u003e vd; typedef vector\u003cll\u003e vl; typedef vector\u003cpi\u003e vpi; typedef vector\u003cpl\u003e vpl; typedef vector\u003ccd\u003e vcd; template\u003cclass T\u003e using pq = priority_queue\u003cT\u003e; template\u003cclass T\u003e using pqg = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e; #define FOR(i, a, b) for (int i=a; i\u003c(b); i++) #define F0R(i, a) for (int i=0; i\u003c(a); i++) #define FORd(i,a,b) for (int i = (b)-1; i \u003e= a; i--) #define F0Rd(i,a) for (int i = (a)-1; i \u003e= 0; i--) #define trav(a,x) for (auto\u0026 a : x) #define uid(a, b) uniform_int_distribution\u003cint\u003e(a, b)(rng) #define sz(x) (int)(x).size() #define mp make_pair #define pb push_back #define f first #define s second #define lb lower_bound #define ub upper_bound #define all(x) x.begin(), x.end() #define ins insert template\u003cclass T\u003e bool ckmin(T\u0026 a, const T\u0026 b) { return b \u003c a ? a = b, 1 : 0; } template\u003cclass T\u003e bool ckmax(T\u0026 a, const T\u0026 b) { return a \u003c b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); void __print(int x) {cerr \u003c\u003c x;} void __print(long x) {cerr \u003c\u003c x;} void __print(long long x) {cerr \u003c\u003c x;} void __print(unsigned x) {cerr \u003c\u003c x;} void __print(unsigned long x) {cerr \u003c\u003c x;} void __print(unsigned long long x) {cerr \u003c\u003c x;} void __print(float x) {cerr \u003c\u003c x;} void __print(double x) {cerr \u003c\u003c x;} void __print(long double x) {cerr \u003c\u003c x;} void __print(char x) {cerr \u003c\u003c '\\'' \u003c\u003c x \u003c\u003c '\\'';} void __print(const char *x) {cerr \u003c\u003c '\\\"' \u003c\u003c x \u003c\u003c '\\\"';} void __print(const string \u0026x) {cerr \u003c\u003c '\\\"' \u003c\u003c x \u003c\u003c '\\\"';} void __print(bool x) {cerr \u003c\u003c (x ? \"true\" : \"false\");} template\u003ctypename T, typename V\u003e void __print(const pair\u003cT, V\u003e \u0026x) {cerr \u003c\u003c '{","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:1:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#c"},{"categories":null,"content":" 输入","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:2:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#输入"},{"categories":null,"content":" 输出","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#输出"},{"categories":null,"content":" 格式化 ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#格式化"},{"categories":null,"content":" 排序排序模板 public class SortTemplate { public static void sort(Comparable[] array) {} private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } private static void show(Comparable[] array) { for (Comparable elem : array) { System.out.print(elem + \" \"); } System.out.println(); } private static boolean isSorted(Comparable[] array) { for (int i = 1; i \u003c array.length; i++) { if (less(array[i], array[i - 1])) { return false; } } return true; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#排序"},{"categories":null,"content":" 1 选择排序 public class SelectionSort { public static void sort(Comparable[] array) { int len = array.length; for (int i = 0; i \u003c len; i++) { int minIdx = i; for (int j = i + 1; j \u003c len; j++) { if (less(array[j], array[minIdx])) { minIdx = j; } } exchange(array, i, minIdx); } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#1-选择排序"},{"categories":null,"content":" 2 插入排序 public class InsertionSort { public static void sort(Comparable[] array) { int len = array.length; for (int i = 1; i \u003c len; i++) { for (int j = i; j \u003e 0 \u0026\u0026 less(array[j], array[j - 1]); j--) { exchange(array, j, j - 1); } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:2","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#2-插入排序"},{"categories":null,"content":" 3 希尔排序 public class ShellSort { public static void sort(Comparable[] array) { int len = array.length; int step = 1; while (step \u003c len / 3) { // 1, 4, 13, 40, 121, 364, 1093, ... step = step * 3 + 1; } while (step \u003e= 1) { for (int i = step; i \u003c len; i++) { for (int j = i; j \u003e= step \u0026\u0026 less(array[j], array[j - step]); j -= step) { exchange(array, j, j - step); } } step /= 3; } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:3","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#3-希尔排序"},{"categories":null,"content":" 4 归并排序自顶向下 public class MergeSort { private static Comparable[] copy; public static void sort(Comparable[] array) { int len = array.length; copy = new Comparable[len]; sort(array, 0, len - 1); } private static void sort(Comparable[] array, int low, int high) { // [low, high] if (low \u003e= high) return; int mid = low + (high - low) / 2; sort(array, low, mid); sort(array, mid + 1, high); merge(array, low, mid, high); } private static void merge(Comparable[] array, int low, int mid, int high) { // [low, high] int i = low; int j = mid + 1; if (high + 1 - low \u003e= 0) System.arraycopy(array, low, copy, low, high + 1 - low); for (int k = low; k \u003c= high; k++) { if (i \u003e mid) { array[k] = copy[j++]; } else if (j \u003e high) { array[k] = copy[i++]; } else if (less(copy[j], copy[i])) { array[k] = copy[j++]; } else { array[k] = copy[i++]; } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } } 自底向上 public class MergeSort { private static Comparable[] copy; public static void sort(Comparable[] array) { int len = array.length; copy = new Comparable[len]; for (int step = 1; step \u003c len; step *= 2) { for (int low = 0; low \u003c len - step; low += 2 * step) { merge(array, low, low + step - 1, Math.min(low + 2 * step - 1, len - 1)); } } } private static void merge(Comparable[] array, int low, int mid, int high) { // [low, high] int i = low; int j = mid + 1; if (high + 1 - low \u003e= 0) System.arraycopy(array, low, copy, low, high + 1 - low); for (int k = low; k \u003c= high; k++) { if (i \u003e mid) { array[k] = copy[j++]; } else if (j \u003e high) { array[k] = copy[i++]; } else if (less(copy[j], copy[i])) { array[k] = copy[j++]; } else { array[k] = copy[i++]; } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:4","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#4-归并排序"},{"categories":null,"content":" 5 快速排序 public class QuickSort { public static void sort(Comparable[] array) { sort(array, 0, array.length - 1); } public static void sort(Comparable[] array, int low, int high) { // [low, high] if (low \u003e= high) return; int i = partition(array, low, high); sort(array, low, i - 1); sort(array, i + 1, high); } private static int partition(Comparable[] array, int low, int high) { // [low, high] int i = low; int j = high + 1; Comparable copy = array[low]; while (true) { while (less(array[++i], copy)) { if (i == high) break; } while (less(copy, array[--j])) { if (j == low) break; } if (i \u003e= j) break; exchange(array, i, j); } exchange(array, low, j); return j; } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:5","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#5-快速排序"},{"categories":null,"content":" 算法","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:5:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#算法"},{"categories":null,"content":" 滑动窗口","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:5:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#滑动窗口"},{"categories":null,"content":" 二分查找 int binarySearch(vector\u003cint\u003e arr, const int target) { // 升序数组 // [low, high] int low = 0, high = arr.size() - 1, mid; while (low \u003c= high) { mid = low + (high - low) / 2; if (target == arr[mid]) { return mid; } else if (target \u003e arr[mid]) { low = mid + 1; } else { high = mid - 1; } } return -1; } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:5:2","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#二分查找"},{"categories":null,"content":" 小技巧头文件 #include\u003cbits/stdc++.h\u003e 判断奇偶 if (x \u0026 1) // 奇数，等价于 x % 2 else // 偶数 快速乘除2 x \u003c\u003c= 1; // 乘2，等价于 x *= 2; x \u003e\u003e= 1; // 除2，等价于 x /= 2; 快速交换 a ^= b; // a1 = a ^ b b ^= a; // b1 = b ^ a1 = b ^ a ^ b = a a ^= b; // a2 = a1 ^ b1 = a ^ b ^ a = b 遍历字符串 for (int i = 0; s[i]; i++) 使用 emplace_back() 代替 push_back() 内置求最大公约数函数：__gcd(x, y); 使用 inline 函数 全局数组最大 $ 10^7 $，函数内数组最大 $ 10^6 $ 得到最高有效位数字 double k = log(n, 10); k -= floor(k); x = pow(10, k); 得到数字的有效位数 n = floor(log(n, 10)) + 1; 判断是否是 2 的幂（Brian Kernighan’s Algorithm） // log(n) n \u0026\u0026 (!(n \u0026 (n - 1))) C++11 内置 STL 函数 // 是否全是正数？ all_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否存在正数 any_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否全不是正数？ none_of(first, first + n, [](int x) { return x \u003e 0; }); // 复制 int source[5] = {0, 12, 34, 50, 80}; int target[5]; copy_n(source, 5, target); // 迭代 int a[5] = {0}; char c[3] = {0}; iota(a, a + 5, 10); // {10, 11, 12, 13, 14} iota(c, c + 3, 'a'); // {'a', 'b', 'c'} 二进制表示 auto number = 0b011; cout \u003c\u003c number; // 3 Using Range based for loop ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:6:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#小技巧"},{"categories":null,"content":" C++ 实用技巧","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:7:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#c-实用技巧"},{"categories":null,"content":" STL 常用库 /*** 函数 ***/ #include\u003calgorithm\u003e #include\u003cfunctional\u003e // hash #include\u003cclimits\u003e // 常量 #include\u003ccmath\u003e #include\u003ccstdio\u003e #include\u003ccstdlib\u003e // random #include\u003cctime\u003e #include\u003ciostream\u003e #include\u003csstream\u003e #include\u003ciomanip\u003e // 右对齐 std::right 设置宽度 std::setw(width) /*** 数据结构 ***/ #include\u003cdeque\u003e #include\u003clist\u003e #include\u003cqueue\u003e // 包括 priority_queue #include\u003cstack\u003e #include\u003cstring\u003e #include\u003cvector\u003e ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:7:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#stl-常用库"},{"categories":null,"content":" I/O #include\u003ciostream\u003e // cin cout #include\u003ccstdio\u003e // scanf printf // cin does not concern with ’\\n’ at end of each line // however scanf or getline does concern with ’\\n’ at end of each line // ’\\n’ will be ignored when you use cin to read char. // 读取数值数据后在读取字符串 cin \u003e\u003e n; getline(cin, str) // wasted getline getline(cin, str) // real input string ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:7:2","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#io"},{"categories":["二分查找","力扣"],"content":"题目链接 ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:0:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#"},{"categories":["二分查找","力扣"],"content":" 方法一：两次二分查找易知： 每行升序 每列升序 所以，我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e matrix, int target) { auto row = upper_bound(matrix.begin(), matrix.end(), target, [](const int b, const vector\u003cint\u003e \u0026a) { return b \u003c a[0]; }); if (row == matrix.begin()) { return false; } --row; return binary_search(row-\u003ebegin(), row-\u003eend(), target); } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int rowIndex = binarySearchFirstColumn(matrix, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], target); } public int binarySearchFirstColumn(int[][] matrix, int target) { int low = -1, high = matrix.length - 1; while (low \u003c high) { int mid = (high - low + 1) / 2 + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } public boolean binarySearchRow(int[] row, int target) { int low = 0, high = row.length - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; if (row[mid] == target) { return true; } else if (row[mid] \u003e target) { high = mid - 1; } else { low = mid + 1; } } return false; } } int binarySearchFirstColumn(int** matrix, int matrixSize, int target) { int low = -1, high = matrixSize - 1; while (low \u003c high) { int mid = (high - low + 1) / 2 + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } bool binarySearchRow(int* row, int rowSize, int target) { int low = 0, high = rowSize - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; if (row[mid] == target) { return true; } else if (row[mid] \u003e target) { high = mid - 1; } else { low = mid + 1; } } return false; } bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) { int rowIndex = binarySearchFirstColumn(matrix, matrixSize, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target); } var searchMatrix = function(matrix, target) { const rowIndex = binarySearchFirstColumn(matrix, ta","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:1:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#方法一两次二分查找"},{"categories":["二分查找","力扣"],"content":" 方法二：一次二分查找根据特性可将二维数组看作一维的升序数组，再使用二分搜索查找。（要求二维数组每行元素个数相等） class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; // 中位数映射到行和列 if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } } bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) { int m = matrixSize, n = matrixColSize[0]; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } var searchMatrix = function(matrix, target) { const m = matrix.length, n = matrix[0].length; let low = 0, high = m * n - 1; while (low \u003c= high) { const mid = Math.floor((high - low) / 2) + low; const x = matrix[Math.floor(mid / n)][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; }; func searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) i := sort.Search(m*n, func(i int) bool { return matrix[i/n][i%n] \u003e= target }) return i \u003c m*n \u0026\u0026 matrix[i/n][i%n] == target } 时间复杂度：$ O(\\log mn) $ ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:2:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#方法二一次二分查找"},{"categories":["Java","面试"],"content":" 路线图 MCA JAVA后端架构师 八股文： CS-Notes JavaGuide Java 全栈知识体系 进击的java菜鸟 算法： labuladong 的算法小抄 代码随想录 数据库： DB-TUTORIAL ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:1:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#路线图"},{"categories":["Java","面试"],"content":" Java 基础","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:2:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#java-基础"},{"categories":["Java","面试"],"content":" Math.abs(Integer.MIN_VALUE) Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE; ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:2:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#mathabsintegermin_value"},{"categories":["Java","面试"],"content":" 使用未初始化的变量使用未初始化的变量抛出编译异常。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:2:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#使用未初始化的变量"},{"categories":["Java","面试"],"content":" 1 / 0 和 1 / 0.0 的区别？ 1 / 0 抛出 java.lang.ArithmeticException: / by zero 异常。 1 / 0.0 返回 Infinity。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:2:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#1--0-和-1--00-的区别"},{"categories":["Java","面试"],"content":" 为什么数组起始索引是 0 ？计算数组元素地址为数组起始地址加索引，将其实索引设为 1 会浪费第一个元素空间或者计算地址时需要减 1，不便于使用。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:2:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么数组起始索引是-0-"},{"categories":["Java","面试"],"content":" Java 方法参数传递为按值传递Java 将参数值的一个副本从调用端传递到方法。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:2:5","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#java-方法参数传递为按值传递"},{"categories":["Java","面试"],"content":" 数组也是对象","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:2:6","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#数组也是对象"},{"categories":["Java","面试"],"content":" 数据库","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:3:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#数据库"},{"categories":["Java","面试"],"content":" 数据库范式 1NF(第一范式)：属性不可再分。 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。即新增了主键列。 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖。即删除依赖于其他属性的列。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:3:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#数据库范式"},{"categories":["Java","面试"],"content":" drop、delete 与 truncate 区别 drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。 truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。 delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。 truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:3:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#dropdelete-与-truncate-区别"},{"categories":["Java","面试"],"content":" 大数据量高并发的数据库优化","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:3:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#大数据量高并发的数据库优化"},{"categories":["Java","面试"],"content":" MySQL 折叠 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#mysql"},{"categories":["Java","面试"],"content":" 一、索引为什么使用索引 提升查询速度，减少IO。 索引是什么 记录数据所在磁盘位置的目录。 索引的存储位置 InnoDB存储引擎：数据和索引都存放于*.ibd MyISAM存储引擎：数据*.MYD，索引*.MYI 索引分类及创建 主键索引：主键自带索引。 普通索引：为普通列创建索引。create index \u003cidx_name\u003e on \u003ctable\u003e(\u003ccolumn\u003e); 唯一索引：为唯一列创建索引。create unique index \u003cidx_unique_name\u003e on \u003ctable\u003e(\u003ccolumn\u003e); 联合索引：为多个列创建索引。create index \u003cidx_name\u003e on \u003ctable\u003e(\u003ccolumn1\u003e,\u003ccolumn2\u003e) 全文索引：在不同列或不同表中查询，MyISAM存储引擎支持，但实际生产中使用ElasticSearch、Solr代替。 联合索引建议不超过5个列。 索引的数据结构 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#一索引"},{"categories":["Java","面试"],"content":" MyISAM 和 InnoDB 的区别是否支持行级锁 MyISAM 只有表级锁(table-level locking)。 InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁。 是否支持事务 MyISAM 不提供事务支持。 InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。 是否支持外键 MyISAM 不支持。 InnoDB 支持。 是否支持数据库异常崩溃后的安全恢复 MyISAM 不支持。 InnoDB 支持。 是否支持 MVCC MyISAM 不支持。 InnoDB 支持。 MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。 索引和数据是否分开存储 MyISAM 分开存储，.MYI存索引，.MYD存数据。 InnoDB 一起存储，.ibd文件。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#myisam-和-innodb-的区别"},{"categories":["Java","面试"],"content":" 表级锁和行级锁 表级锁： MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。 行级锁： MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#表级锁和行级锁"},{"categories":["Java","面试"],"content":" InnoDB 的锁算法 Record lock：行锁，单个行记录上的锁。 Gap lock：间隙锁，锁定一个范围，不包括记录本身。 Next-key lock：行锁+间隙锁，锁定一个范围，包含记录本身。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#innodb-的锁算法"},{"categories":["Java","面试"],"content":" 事务事务是逻辑上的一组操作，要么都执行，要么都不执行。 InnoDB 使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 InnoDB 通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:5","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#事务"},{"categories":["Java","面试"],"content":" 事务的 ACID 特性 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:6","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#事务的-acid-特性"},{"categories":["Java","面试"],"content":" 并发事务带来的问题 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:7","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#并发事务带来的问题"},{"categories":["Java","面试"],"content":" 事务隔离级别 READ-UNCOMMITTED（读未提交）： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED（读已提交）： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ（可重复读）： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE（串行化）： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重复读）。 避免幻读 将事务隔离级别调整为 SERIALIZABLE 在可重复读的事务级别下，给事务操作的这张表添加表锁 在可重复读的事务级别下，给事务操作的这张表添加 Next-Key Locks 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是 InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读） 并不会有任何性能损失。 InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE(串行化) 隔离级别。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:8","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#事务隔离级别"},{"categories":["Java","面试"],"content":" 索引索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。 优点 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:9","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#索引"},{"categories":["Java","面试"],"content":" 索引数据结构 Hash表为什么 MySQL 没有使用其作为索引的数据结构呢？ Hash 冲突问题 Hash 索引不支持顺序和范围查询 B 树\u0026 B+树B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。 MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为非聚簇索引。 InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为聚簇索引（或聚集索引），而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#索引数据结构"},{"categories":["Java","面试"],"content":" 索引数据结构 Hash表为什么 MySQL 没有使用其作为索引的数据结构呢？ Hash 冲突问题 Hash 索引不支持顺序和范围查询 B 树\u0026 B+树B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。 MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为非聚簇索引。 InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为聚簇索引（或聚集索引），而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#hash表"},{"categories":["Java","面试"],"content":" 索引数据结构 Hash表为什么 MySQL 没有使用其作为索引的数据结构呢？ Hash 冲突问题 Hash 索引不支持顺序和范围查询 B 树\u0026 B+树B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。 MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为非聚簇索引。 InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为聚簇索引（或聚集索引），而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#b-树-b树"},{"categories":["Java","面试"],"content":" 索引类型 主键索引(Primary Key)数据表的主键列使用的就是主键索引。 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。 在 MySQL 的 InnoDB 的表中，当没有显式地指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。 二级索引(辅助索引)二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:11","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#索引类型"},{"categories":["Java","面试"],"content":" 索引类型 主键索引(Primary Key)数据表的主键列使用的就是主键索引。 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。 在 MySQL 的 InnoDB 的表中，当没有显式地指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。 二级索引(辅助索引)二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:11","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#主键索引primary-key"},{"categories":["Java","面试"],"content":" 索引类型 主键索引(Primary Key)数据表的主键列使用的就是主键索引。 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。 在 MySQL 的 InnoDB 的表中，当没有显式地指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。 二级索引(辅助索引)二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:11","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#二级索引辅助索引"},{"categories":["Java","面试"],"content":" 聚簇索引和非聚簇索引 聚簇索引聚簇索引即索引结构和数据一起存放的索引。主键索引属于聚簇索引。 在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。 优点 聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 缺点 依赖于有序的数据 ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。 非聚簇索引非聚簇索引即索引结构和数据分开存放的索引。 二级索引属于非聚簇索引。 非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 优点 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。 缺点 跟聚簇索引一样，非聚簇索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。当查询列为索引列时（覆盖索引），无需回表查询。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:12","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#聚簇索引和非聚簇索引"},{"categories":["Java","面试"],"content":" 聚簇索引和非聚簇索引 聚簇索引聚簇索引即索引结构和数据一起存放的索引。主键索引属于聚簇索引。 在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。 优点 聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 缺点 依赖于有序的数据 ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。 非聚簇索引非聚簇索引即索引结构和数据分开存放的索引。 二级索引属于非聚簇索引。 非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 优点 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。 缺点 跟聚簇索引一样，非聚簇索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。当查询列为索引列时（覆盖索引），无需回表查询。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:12","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#聚簇索引"},{"categories":["Java","面试"],"content":" 聚簇索引和非聚簇索引 聚簇索引聚簇索引即索引结构和数据一起存放的索引。主键索引属于聚簇索引。 在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。 优点 聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 缺点 依赖于有序的数据 ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。 非聚簇索引非聚簇索引即索引结构和数据分开存放的索引。 二级索引属于非聚簇索引。 非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 优点 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。 缺点 跟聚簇索引一样，非聚簇索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。当查询列为索引列时（覆盖索引），无需回表查询。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:12","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#非聚簇索引"},{"categories":["Java","面试"],"content":" 覆盖索引如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！ 覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:13","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#覆盖索引"},{"categories":["Java","面试"],"content":" 联合索引使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。 最左前缀匹配原则在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 \u003e、\u003c、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。 索引下推索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引（MyISAM）遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:14","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#联合索引"},{"categories":["Java","面试"],"content":" 联合索引使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。 最左前缀匹配原则在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 \u003e、\u003c、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。 索引下推索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引（MyISAM）遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:14","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#最左前缀匹配原则"},{"categories":["Java","面试"],"content":" 联合索引使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。 最左前缀匹配原则在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 \u003e、\u003c、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。 索引下推索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引（MyISAM）遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:14","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#索引下推"},{"categories":["Java","面试"],"content":" 索引注意事项 选择合适的字段创建索引： 不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。 被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。 被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。 频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。 被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。 被频繁更新的字段应该慎重建立索引。 虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。 尽可能的考虑建立联合索引而不是单列索引。 因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。 注意避免冗余索引。 冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a)，那么索引(a)就是冗余索引。如（name,city）和（name）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的，在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。 考虑在字符串类型的字段上使用前缀索引代替普通索引。 前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:15","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#索引注意事项"},{"categories":["Java","面试"],"content":" MySQL 三大日志(binlog、redo log和undo log) binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:16","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#mysql-三大日志binlogredo-log和undo-log"},{"categories":["Java","面试"],"content":" MySQL 三大日志(binlog、redo log和undo log) binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:16","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#binlog"},{"categories":["Java","面试"],"content":" MySQL 三大日志(binlog、redo log和undo log) binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:16","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#redo-log"},{"categories":["Java","面试"],"content":" MySQL 三大日志(binlog、redo log和undo log) binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:16","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#两阶段提交"},{"categories":["Java","面试"],"content":" MySQL 三大日志(binlog、redo log和undo log) binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:4:16","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#undo-log"},{"categories":["Java","面试"],"content":" Java 集合框架 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#java-集合框架"},{"categories":["Java","面试"],"content":" Arraylist 和 Vector 的区别 ArrayList 是 List 的主要实现类，底层使⽤ Object[] 存储，适⽤于频繁的查找⼯作，线程不安全。 Vector 是 List 的古⽼实现类，底层使⽤ Object[] 存储，线程安全的。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#arraylist-和-vector-的区别"},{"categories":["Java","面试"],"content":" RandomAccess 接⼝ public interface RandomAccess { } RandomAccess 接⼝用于标识实现这个接⼝的类具有随机访问功能。ArrayList 实现了 RandomAccess 接⼝， ⽽ LinkedList 没有实现。 在 binarySearch() ⽅法中，它要判断传⼊的 list 是否 RandomAccess 的实例，如果是，调⽤ indexedBinarySearch() ⽅法，如果不是，那么调⽤ iteratorBinarySearch() ⽅法。 public static \u003cT\u003e int binarySearch(List\u003c? extends Comparable\u003c? super T\u003e\u003e list, T key) { if (list instanceof RandomAccess || list.size() \u003c BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#randomaccess-接"},{"categories":["Java","面试"],"content":" Comparable 和 Comparator 的区别 Comparable 接口出自 java.lang 包，它有⼀个 compareTo(Object obj) 方法⽤来排序。 interface Comparable { int compareTo(Object obj); } Comparator 接口出自 java.util 包（需要导包），它有⼀个 compare(Object obj1, Object obj2) 方法⽤来排序。 package java.util; interface Comparator { int compare(Object obj1, Object obj2); } compareTo(Object obj) 方法和 compare(Object obj1, Object obj2) 方法的返回值 小于 0 代表升序， 大于 0 代表降序。 Collections.sort()、TreeSet、TreeMap、PriorityQueue使用自定义类时必须实现 Comparable 接口或传入 Comparator 接口的实现类。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#comparable-和-comparator-的区别"},{"categories":["Java","面试"],"content":" HashMap 和 HashTable 的区别 HashTable 已被 ConcurrentHashMap 淘汰 是否线程安全 HashMap 线程不安全 HashTable 线程安全 效率 HashMap 比 HashTable 效率高，因为 HashTable 线程安全 对 null 的⽀持 HashMap 可以存储 null 的 key 和 value，但 null 作为 key 只能有⼀个，null 作为 value 可以有多个 HashTable 不允许 null，否则抛出 NullPointerException 初始⼤⼩和扩充机制 HashMap 默认初始⼤⼩为 16，当指定大小时扩充为 2 的幂次方，已使用 75% 空间时进行扩容，每次扩容变为 2 * n HashTable 默认初始⼤⼩为 11，每次扩容变为 2 * n + 1 底层数据结构 JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间。 Hashtable 没有这样的机制。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#hashmap-和-hashtable-的区别"},{"categories":["Java","面试"],"content":" HashMap 的底层实现 变量 package java.util; public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable { static class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { // 数组存放的元素，即链表结点 final int hash; final K key; V value; Node\u003cK,V\u003e next; } static final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e { // 红黑树结点 TreeNode\u003cK,V\u003e parent; TreeNode\u003cK,V\u003e left; TreeNode\u003cK,V\u003e right; TreeNode\u003cK,V\u003e prev; boolean red; } static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // 默认初始大小 16 static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30; // 最大容量 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认扩容阈值 static final int TREEIFY_THRESHOLD = 8; // 链表变为红黑树时的链表结点数量阈值 static final int MIN_TREEIFY_CAPACITY = 64; // 链表变为红黑树时的数组大小阈值 static final int UNTREEIFY_THRESHOLD = 6; // 红黑树变为链表时的结点数量阈值 transient Node\u003cK,V\u003e[] table; // 底层数组 transient Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet; // entry 集合 transient int size; // 集合大小 transient int modCount; // 集合修改次数，实现 fail-fast int threshold; // 数组大小 final float loadFactor; // 数组扩容阈值 } 构造方法 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003c 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity \u003e MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } hash() // \u003e= jdk 1.8 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } // \u003c jdk 1.8 static final int hash(Object key) { int h = key.hashCode(); h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12); return h ^ (h \u003e\u003e\u003e 7) ^ (h) \u003e\u003e\u003e 4; } tableSizeFor() static final int tableSizeFor(int cap) { // 扩充为 2 的幂次方 int n = -1 \u003e\u003e\u003e Integer.numberOfLeadingZeros(cap - 1); return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACI","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:5","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#hashmap-的底层实现"},{"categories":["Java","面试"],"content":" 为什么 HashMap 的大小是 2 的幂次方每个 key 的 hash 值很大，需要通过取模，即 hash(key) % n 得到数组索引，当 n 是 2 的幂次方时通过 (n - 1) \u0026 hash(key) 可以更快速的进行取模。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:6","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么-hashmap-的大小是-2-的幂次方"},{"categories":["Java","面试"],"content":" 为什么 HashMap 多线程会导致死循环JDK 1.8 之前存在这个问题，因为并发下扩容时的 rehash 会造成元素之间会形成⼀个循环链表。 当 HashMap 扩容时，HashMap 中的所有元素都需要被重新 hash 一遍，称为 rehash。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:7","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么-hashmap-多线程会导致死循环"},{"categories":["Java","面试"],"content":" ConcurrentHashMap 和 HashTable 的区别 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:8","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#concurrenthashmap-和-hashtable-的区别"},{"categories":["Java","面试"],"content":" ConcurrentHashMap 的底层实现 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:9","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#concurrenthashmap-的底层实现"},{"categories":["Java","面试"],"content":" 快速失败（Fail-fast）和 安全失败（Fail-safe）快速失败（fail-fast）是 Java 集合的⼀种错误检测机制。在使用迭代器对集合进⾏遍历的时候， 多线程下，在操作非安全失败（fail-safe）的集合类时，可能触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 单线程下，在遍历过程中对集合对象的内容进行修改，会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 采⽤安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，⽽是先复制原有集合内容，在拷⻉的集合上进⾏遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛出 ConcurrentModificationException 异常。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#快速失败fail-fast和-安全失败fail-safe"},{"categories":["Java","面试"],"content":" Arrays.asList() 和 List.of() Arrays.asList() 返回的对象是 java.util.Arrays 类中的内部类 java.util.Arrays$ArrayList，而不是 java.util.ArrayList。java.util.Arrays$ArrayList 没有实现 add()、remove() 和 clear() 方法，但实现了 set() 方法，因此不能添加和删除元素，只能修改和读取元素。 传入的数组必须是对象数组，不能是基本类型数组。 public class Arrays { public static \u003cT\u003e List\u003cT\u003e asList(T... a) { return new ArrayList\u003c\u003e(a); } private static class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements RandomAccess { private final E[] a; ArrayList(E[] array) { a = Objects.requireNonNull(array); } public int size() {} public E get(int index) {} public E set(int index, E element) {} public int indexOf(Object o) {} public boolean contains(Object o) {} public void sort(Comparator\u003c? super E\u003e c) {} } } public abstract class AbstractList\u003cE\u003e extends AbstractCollection\u003cE\u003e implements List\u003cE\u003e { public void add(int index, E element) { throw new UnsupportedOperationException(); } public E remove(int index) { throw new UnsupportedOperationException(); } } List.of() 返回的是 AbstractImmutableList 接口的实现类，该接口中所有修改操作（add()、remove()、set()等）全都会抛出异常。 public interface List\u003cE\u003e extends Collection\u003cE\u003e { static \u003cE\u003e List\u003cE\u003e of(E... elements) { switch (elements.length) { case 0: return ImmutableCollections.emptyList(); case 1: return new ImmutableCollections.List12\u003c\u003e(elements[0]); case 2: return new ImmutableCollections.List12\u003c\u003e(elements[0], elements[1]); default: return new ImmutableCollections.ListN\u003c\u003e(elements); } } } class ImmutableCollections { static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); } static abstract class AbstractImmutableList\u003cE\u003e extends AbstractImmutableCollection\u003cE\u003e implements List\u003cE\u003e, RandomAccess { @Override public void add(int index, E element) { throw uoe(); } @Override public boolean addAll(int index, Collection\u003c? extends E\u003e c) { throw uoe(); } @Override public E remove(int index) { throw uoe(); } @Override public void replaceAll(UnaryOperator\u003cE\u003e operator) { throw uoe(); } @Override public E set(int index, E element) { throw uoe(); } @Override public void sort(Comparator\u003c? super ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:5:11","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#arraysaslist-和-listof"},{"categories":["Java","面试"],"content":" Spring","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:6:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#spring"},{"categories":["Java","面试"],"content":" Spring 特征 轻量 从大小与开销两方面而言 Spring 都是轻量的。完整的 Spring 框架可以在一个大小只有 1 MB 多的 jar 文件里发布，并且 Spring 所需的处理开销也是微不足道的。 Spring 是非侵入式的。Spring 应用中的对象不依赖于 Spring 的特定类。 控制反转（IoC，Inversion of Control） Spring 通过一种称作控制反转的技术促进了低耦合。 当应用了 IoC，一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:6:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#spring-特征"},{"categories":["Java","面试"],"content":" Mybatis","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:7:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#mybatis"},{"categories":["Java","面试"],"content":" 计算机网络","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#计算机网络"},{"categories":["Java","面试"],"content":" 什么是网络协议？在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#什么是网络协议"},{"categories":["Java","面试"],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 物理层在物理层上所传送的数","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#tcpip-和-osi"},{"categories":["Java","面试"],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 物理层在物理层上所传送的数","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么要对网络协议分层"},{"categories":["Java","面试"],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 物理层在物理层上所传送的数","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#应用层"},{"categories":["Java","面试"],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 物理层在物理层上所传送的数","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#传输层"},{"categories":["Java","面试"],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 物理层在物理层上所传送的数","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#网际层"},{"categories":["Java","面试"],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 物理层在物理层上所传送的数","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#数据链路层"},{"categories":["Java","面试"],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 物理层在物理层上所传送的数","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#物理层"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#tcp-三次握手和四次挥手"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#tcp-报文的头部结构"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#建立连接的三次握手"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#关闭连接的四次挥手"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么-tcp-建立连接是-3-次握手"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么-tcp-建立连接是-3-次握手关闭连接却是-4-次挥手"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么客户端第四次挥手后要等-2-msl-才能释放连接"},{"categories":["Java","面试"],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#如果已经建立连接但是客户端出现故障"},{"categories":["Java","面试"],"content":" HTTP 和 HTTPS 常用 HTTP 状态码HTTP 状态码表示客户端 HTTP 请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。 1XX：Informational（信息性），接受的请求正在处理。 100：Continue（继续）。 101：Switching Protocol（切换协议）。 2XX：Success（成功），请求正常处理完毕。 200：OK（成功），表示从客户端发来的请求在服务器端被正确处理。 201：Created（已创建）。 202：Accepted（已创建）。 203：Non-Authoritative Information（未授权信息）。 204：No Content（无内容），表示请求成功，但响应报文不含实体的主体部分。 205：Reset Content（重置内容）。 206：Partial Content（部分内容），进行范围请求成功。 3XX：Redirection（重定向），需要进行附加操作以完成请求。（对于 301/302/303 状态码，几乎所有浏览器都会删除报文主体并自动用 GET 方法重新请求） 300：Multiple Choice（多种选择）。 301：Moved Permanently（永久移动），永久性重定向，表示资源已被分配了新的 URL。 302：Found（临时移动），临时性重定向，表示资源临时被分配了新的 URL。 303：See Other（查看其他位置），表示资源存在着另一个 URL，应使用 GET 方法获取资源。 304：Not Modified（未修改），表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）。 305：Use Proxy（使用代理）。 306：Unused（未使用）。 307：Temporary Redirect（临时重定向），临时性重定向，和 302 类似，但是期望客户端保持请求方法不变向新的地址发出请求。 308：Permanent Redirect（永久重定向）。 4XX：Client Error（客户端错误），服务器无法处理请求。 400：Bad Request（错误请求），请求报文存在语法错误。 401：Unauthorized（未授权），表示发送的请求需要有通过 HTTP 认证的认证信息。 402：Payment Required（需要付款）。 403：Forbidden（禁止访问），表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述。 404：Not found（未找到），表示在服务器上没有找到请求的资源。 405：Method Not Allowed（不允许使用该方法）。 406：Not Acceptable（无法接受）。 407：Proxy Authentication Required（要求代理身份验证）。 408：Request Timeout（请求超时）。 409：Conflict（冲突）。 410：Gone（已失效）。 411：Length Required（需要内容长度头）。 412：Precondition Failed（预处理失败）。 413：Request Entity Too Large（请求实体过长）。 414：Request-URI Too Long（请求网址过长）。 415：Unsupported Media Type（媒体类型不支持）。 416：Requested Range Not Satisfiable（请求范围不合要求）。 417：Expectation Failed（预期结果失败）。 5XX：Server Error（服务器错误），服务器处理请求出错。 500：Internal Sever Error（内部服务器错误），表示服务器端在执行请求时发生了错误。 501：Not Implemented（未实现），表示服务器不支持当前请求所需要的某个功能。 502：Bad Gateway（网关错误）。 503：Service Unavailable（服务不可用），表明服务器暂时处于超负载或正在停机维护，无法处理请求。 504：Gateway Timeout（网关超时）。 505：HTTP Version Not Supported（HTTP 版本不受支持）。 GET 和 POST说到GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。 HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。 HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#http-和-https"},{"categories":["Java","面试"],"content":" HTTP 和 HTTPS 常用 HTTP 状态码HTTP 状态码表示客户端 HTTP 请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。 1XX：Informational（信息性），接受的请求正在处理。 100：Continue（继续）。 101：Switching Protocol（切换协议）。 2XX：Success（成功），请求正常处理完毕。 200：OK（成功），表示从客户端发来的请求在服务器端被正确处理。 201：Created（已创建）。 202：Accepted（已创建）。 203：Non-Authoritative Information（未授权信息）。 204：No Content（无内容），表示请求成功，但响应报文不含实体的主体部分。 205：Reset Content（重置内容）。 206：Partial Content（部分内容），进行范围请求成功。 3XX：Redirection（重定向），需要进行附加操作以完成请求。（对于 301/302/303 状态码，几乎所有浏览器都会删除报文主体并自动用 GET 方法重新请求） 300：Multiple Choice（多种选择）。 301：Moved Permanently（永久移动），永久性重定向，表示资源已被分配了新的 URL。 302：Found（临时移动），临时性重定向，表示资源临时被分配了新的 URL。 303：See Other（查看其他位置），表示资源存在着另一个 URL，应使用 GET 方法获取资源。 304：Not Modified（未修改），表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）。 305：Use Proxy（使用代理）。 306：Unused（未使用）。 307：Temporary Redirect（临时重定向），临时性重定向，和 302 类似，但是期望客户端保持请求方法不变向新的地址发出请求。 308：Permanent Redirect（永久重定向）。 4XX：Client Error（客户端错误），服务器无法处理请求。 400：Bad Request（错误请求），请求报文存在语法错误。 401：Unauthorized（未授权），表示发送的请求需要有通过 HTTP 认证的认证信息。 402：Payment Required（需要付款）。 403：Forbidden（禁止访问），表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述。 404：Not found（未找到），表示在服务器上没有找到请求的资源。 405：Method Not Allowed（不允许使用该方法）。 406：Not Acceptable（无法接受）。 407：Proxy Authentication Required（要求代理身份验证）。 408：Request Timeout（请求超时）。 409：Conflict（冲突）。 410：Gone（已失效）。 411：Length Required（需要内容长度头）。 412：Precondition Failed（预处理失败）。 413：Request Entity Too Large（请求实体过长）。 414：Request-URI Too Long（请求网址过长）。 415：Unsupported Media Type（媒体类型不支持）。 416：Requested Range Not Satisfiable（请求范围不合要求）。 417：Expectation Failed（预期结果失败）。 5XX：Server Error（服务器错误），服务器处理请求出错。 500：Internal Sever Error（内部服务器错误），表示服务器端在执行请求时发生了错误。 501：Not Implemented（未实现），表示服务器不支持当前请求所需要的某个功能。 502：Bad Gateway（网关错误）。 503：Service Unavailable（服务不可用），表明服务器暂时处于超负载或正在停机维护，无法处理请求。 504：Gateway Timeout（网关超时）。 505：HTTP Version Not Supported（HTTP 版本不受支持）。 GET 和 POST说到GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。 HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。 HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#常用-http-状态码"},{"categories":["Java","面试"],"content":" HTTP 和 HTTPS 常用 HTTP 状态码HTTP 状态码表示客户端 HTTP 请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。 1XX：Informational（信息性），接受的请求正在处理。 100：Continue（继续）。 101：Switching Protocol（切换协议）。 2XX：Success（成功），请求正常处理完毕。 200：OK（成功），表示从客户端发来的请求在服务器端被正确处理。 201：Created（已创建）。 202：Accepted（已创建）。 203：Non-Authoritative Information（未授权信息）。 204：No Content（无内容），表示请求成功，但响应报文不含实体的主体部分。 205：Reset Content（重置内容）。 206：Partial Content（部分内容），进行范围请求成功。 3XX：Redirection（重定向），需要进行附加操作以完成请求。（对于 301/302/303 状态码，几乎所有浏览器都会删除报文主体并自动用 GET 方法重新请求） 300：Multiple Choice（多种选择）。 301：Moved Permanently（永久移动），永久性重定向，表示资源已被分配了新的 URL。 302：Found（临时移动），临时性重定向，表示资源临时被分配了新的 URL。 303：See Other（查看其他位置），表示资源存在着另一个 URL，应使用 GET 方法获取资源。 304：Not Modified（未修改），表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）。 305：Use Proxy（使用代理）。 306：Unused（未使用）。 307：Temporary Redirect（临时重定向），临时性重定向，和 302 类似，但是期望客户端保持请求方法不变向新的地址发出请求。 308：Permanent Redirect（永久重定向）。 4XX：Client Error（客户端错误），服务器无法处理请求。 400：Bad Request（错误请求），请求报文存在语法错误。 401：Unauthorized（未授权），表示发送的请求需要有通过 HTTP 认证的认证信息。 402：Payment Required（需要付款）。 403：Forbidden（禁止访问），表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述。 404：Not found（未找到），表示在服务器上没有找到请求的资源。 405：Method Not Allowed（不允许使用该方法）。 406：Not Acceptable（无法接受）。 407：Proxy Authentication Required（要求代理身份验证）。 408：Request Timeout（请求超时）。 409：Conflict（冲突）。 410：Gone（已失效）。 411：Length Required（需要内容长度头）。 412：Precondition Failed（预处理失败）。 413：Request Entity Too Large（请求实体过长）。 414：Request-URI Too Long（请求网址过长）。 415：Unsupported Media Type（媒体类型不支持）。 416：Requested Range Not Satisfiable（请求范围不合要求）。 417：Expectation Failed（预期结果失败）。 5XX：Server Error（服务器错误），服务器处理请求出错。 500：Internal Sever Error（内部服务器错误），表示服务器端在执行请求时发生了错误。 501：Not Implemented（未实现），表示服务器不支持当前请求所需要的某个功能。 502：Bad Gateway（网关错误）。 503：Service Unavailable（服务不可用），表明服务器暂时处于超负载或正在停机维护，无法处理请求。 504：Gateway Timeout（网关超时）。 505：HTTP Version Not Supported（HTTP 版本不受支持）。 GET 和 POST说到GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。 HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。 HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#get-和-post"},{"categories":["Java","面试"],"content":" 浏览器访问网站的详细过程首先是查找浏览器缓存，浏览器会保存一段时间你之前访问过的一些网址的DNS信息，不同浏览器保存的时常不等。 如果没有找到对应的记录，这个时候浏览器会尝试调用系统缓存来继续查找这个网址的对应DNS信息。 如果还是没找到对应的IP，那么接着会发送一个请求到路由器上，然后路由器在自己的路由器缓存上查找记录，路由器一般也存有DNS信息。 如果还是没有，这个请求就会被发送到ISP（注：Internet Service Provider，互联网服务提供商，就是那些拉网线到你家里的运营商，中国电信中国移动什么的），ISP也会有相 应的ISP DNS服务器，一听中国电信就知道这个DNS服务器的规模肯定不会小，所以基本上都能在这里找得到。题外话：会跑到这里进行查询是因为你没有改动过\"网络中 心\"的\"ipv4\"的DNS地址，万恶的电信联通可以改动了这个DNS服务器，换句话说他们可以让你的浏览器跳转到他们设定的页面上，这也就是人尽皆知的DNS和HTTP劫持，ISP们 还美名曰“免费推送服务”。强烈鄙视这种霸王行为。我们也可以自行修改DNS服务器来防止DNS被ISP污染。 如果还是没有的话， 你的ISP的DNS服务器会将请求发向根域名服务器进行搜索。根域名服务器就是面向全球的顶级DNS服务器，共有13台逻辑上的服务器，从A到M命名，真正 的实体服务器则有几百台，分布于全球各大洲。所以这些服务器有真正完整的DNS数据库。如果到了这里还是找不到域名的对应信息，那只能说明一个问题：这个域名本来就不 存在，它没有在网上正式注册过。或者卖域名的把它回收掉了（通常是因为欠费）。 这也就是为什么打开一个新页面会有点慢，因为本地没什么缓存，要这样递归地查询下去。 多说一句，例如\"mp3.baidu.com\"，域名先是解析出这是个.com的域名，然后跑到管理.com域名的服务器上进行进一步查询，然后是.baidu，最后是mp3， 所以域名结构为：三级域名.二级域名.一级域名。 浏览器终于得到了IP以后，浏览器接着给这个IP的服务器发送了一个http请求，方式为get，例如访问nbut.cn 这个get请求包含了主机（host）、用户代理(User-Agent)，用户代理就是自己的浏览器，它是你的\"代理人\"，Connection（连接属性）中的keep-alive表示浏览器告诉对方服务 器在传输完现在请求的内容后不要断开连接，不断开的话下次继续连接速度就很快了。其他的顾名思义就行了。还有一个重点是Cookies，Cookies保存了用户的登陆信息，在每 次向服务器发送请求的时候会重复发送给服务器。Corome上的F12与Firefox上的firebug(快捷键shift+F5)均可查看这些信息。 发送完请求接下来就是等待回应了 当然了，服务器收到浏览器的请求以后（其实是WEB服务器接收到了这个请求，WEB服务器有iis、apache等），它会解析这个请求（读请求头），然后生成一个响应头和具体响 应内容。接着服务器会传回来一个响应头和一个响应，响应头告诉了浏览器一些必要的信息，例如重要的Status Code，2开头如200表示一切正常，3开头表示重定向，4开头， 如404，呵呵。响应就是具体的页面编码，就是那个……，浏览器先读了关于这个响应的说明书（响应头），然后开始解析这个响应并在页面上显示出来。在下一次CF的时候（不 是穿越火线，是http://codeforces.com/），由于经常难以承受几千人的同时访问，所以CF页面经常会出现崩溃页面，到时候可以点开火狐的firebug或是Chrome的F12看看状 态，不过这时候一般都急着看题和提交代码，似乎根本就没心情理会这个状态吧-.-。 如果是个静态页面，那么基本上到这一步就没了，但是如今的网站几乎没有静态的了吧，基本全是动态的。所以这时候事情还没完，根据我们的经验，浏览器打开一个网址的时 候会慢慢加载这个页面，一部分一部分的显示，直到完全显示，最后标签栏上的圈圈就不转了。 这是因为，主页（index）页面框架传送过来以后，浏览器还要继续向服务器发送请求，请求的内容是主页里面包含的一些资源，如图片，视频，css样式等等。这些\"非静态\"的 东西要一点点地请求过来，所以标签栏转啊转，内容刷啊刷，最后全部请求并加载好了就终于好了。 需要说明的是，对于静态的页面内容，浏览器通常会进行缓存，而对于动态的内容，浏览器通常不会进行缓存。缓存的内容通常也不会保存很久，因为难保网站不会被改动。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:5","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#浏览器访问网站的详细过程"},{"categories":["Java","面试"],"content":" ping 网站的详细过程","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:6","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#ping-网站的详细过程"},{"categories":["Java","面试"],"content":" ARP 协议和 RARP 协议","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:7","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#arp-协议和-rarp-协议"},{"categories":["Java","面试"],"content":" DNS 域名解析的过程","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:8","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#dns-域名解析的过程"},{"categories":["Java","面试"],"content":" CDN 原理","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:9","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#cdn-原理"},{"categories":["Java","面试"],"content":" RPC 为什么要有 RPC？ 什么是 RPC？ RPC 架构组件","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#rpc"},{"categories":["Java","面试"],"content":" RPC 为什么要有 RPC？ 什么是 RPC？ RPC 架构组件","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#为什么要有-rpc"},{"categories":["Java","面试"],"content":" RPC 为什么要有 RPC？ 什么是 RPC？ RPC 架构组件","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#什么是-rpc"},{"categories":["Java","面试"],"content":" RPC 为什么要有 RPC？ 什么是 RPC？ RPC 架构组件","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:8:10","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#rpc-架构组件"},{"categories":["Java","面试"],"content":" Linux","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#linux"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#常用命令"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#cdcpmvpwdclearecho"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#touchmkdirrmrmdirln"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#chmodchown"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#dfduls"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#catmorelessheadtail"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#findwhichlocate"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#sed"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#grep"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#ifconfig"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#netstat"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#vmstat"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#ssh"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#free"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#kill"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#ps"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#top"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#tarunzipgzipbzip2"},{"categories":["Java","面试"],"content":" 常用命令 cd/cp/mv/pwd/clear/echo touch/mkdir/rm/rmdir/ln chmod/chown df/du/ls cat/more/less/head/tail find/which/locate/ sed grep ifconfig netstat vmstat ssh free kill ps top tar/unzip/gzip/bzip2 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:9:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#heading"},{"categories":["Java","面试"],"content":" 设计模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#设计模式"},{"categories":["Java","面试"],"content":" 设计原则","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#设计原则"},{"categories":["Java","面试"],"content":" 工厂方法模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#工厂方法模式"},{"categories":["Java","面试"],"content":" 抽象工厂模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#抽象工厂模式"},{"categories":["Java","面试"],"content":" 单例模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#单例模式"},{"categories":["Java","面试"],"content":" 建造者模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:5","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#建造者模式"},{"categories":["Java","面试"],"content":" 原型模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:6","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#原型模式"},{"categories":["Java","面试"],"content":" 适配器模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:7","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#适配器模式"},{"categories":["Java","面试"],"content":" 装饰器模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:8","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#装饰器模式"},{"categories":["Java","面试"],"content":" 代理模式","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:10:9","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#代理模式"},{"categories":["Java","面试"],"content":" 算法","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:11:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#算法"},{"categories":["Java","面试"],"content":" 如何给 100 亿个数字排序？ 把这个37GB的大文件，平均分成1000个小文件。 拆分完了之后，得到一些几十MB的小文件，那么就可以放进内存里排序了，可以用快速排序，归并排序，堆排序等等。 1000个小文件内部排好序之后，就要把这些内部有序的小文件，合并成一个大的文件，可以用二叉堆来做1000路合并的操作，每个小文件是一路，合并后的大文件仍然有序。 首先遍历1000个文件，每个文件里面取第一个数字，组成 (数字, 文件号) 这样的组合加入到堆里（假设是从小到大排序，用小顶堆），遍历完后堆里有1000个 (数字，文件号) 这样的元素。 然后不断从堆顶拿元素出来，每拿出一个元素，把它的文件号读取出来，然后去对应的文件里，加一个元素进入堆，直到那个文件被读取完。拿出来的元素当然追加到最终结果的文件里。 按照上面的操作，直到堆被取空了，此时最终结果文件里的全部数字就是有序的了。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:11:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#如何给-100-亿个数字排序"},{"categories":["Java","面试"],"content":" 统计 100 亿个 ip 中出现次数最多的前 10 个","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:11:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#统计-100-亿个-ip-中出现次数最多的前-10-个"},{"categories":["Java","面试"],"content":" 场景题","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:12:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#场景题"},{"categories":["Java","面试"],"content":" 一千万用户实时排名如何实现？","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:12:1","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#一千万用户实时排名如何实现"},{"categories":["Java","面试"],"content":" 五万人并发抢票如何实现？","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:12:2","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#五万人并发抢票如何实现"},{"categories":["Java","面试"],"content":" 如何提高服务器并发处理能力？","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:12:3","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#如何提高服务器并发处理能力"},{"categories":["Java","面试"],"content":" 你的项目中使用过缓存机制吗？有没用用户非本地缓存？","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:12:4","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#你的项目中使用过缓存机制吗有没用用户非本地缓存"},{"categories":["Java","面试"],"content":" 网站访问慢如何处理？找原因： 服务器出口带宽不够用。 本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。 跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。 服务器负载过大，导致响应不过来。 分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。 如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。 数据库瓶颈。 如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。 如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。 网站开发代码没有优化好。 例如 SQL 语句没有优化，导致数据库读写相当耗时。 排查： 首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。 如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。 针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。 如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。怎么去解决？ 解决： 如果是出口带宽问题，那么久申请加大出口带宽。 如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。 如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。 申请购买 CDN 服务，加载用户的访问。 如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。 ","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:12:5","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#网站访问慢如何处理"},{"categories":["Java","面试"],"content":" 机试题","date":"2021-03-30","objectID":"/posts/java-%E9%9D%A2%E8%AF%95/:13:0","series":null,"tags":["Java","面试"],"title":"Java 面试","uri":"/posts/java-%E9%9D%A2%E8%AF%95/#机试题"},{"categories":["正则表达式"],"content":"用来描述字符串模式匹配规则的表达式。 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#"},{"categories":["正则表达式"],"content":" 1.规则","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#1规则"},{"categories":["正则表达式"],"content":" 1.1 单个字符匹配 正则表达式 意义 等价 a 单个指定字母 0 单个指定数字 \\\\ \\ \\* * \\. . \\n 换行符 \\f 换页符 \\t 制表符 . 单个除了换行符之外的任何字符 \\d 单个数字 [0-9] \\D 单个非数字字符 [^0-9] 、 [^\\d] \\w 单个字母或数字或下划线 [a-zA-Z0-9_] \\W 单个非字母非数字非下划线字符 [^a-zA-Z0-9_]、[^\\w] \\s 单个空白字符（空格、换行符、换页符、制表符） [ \\n\\f\\t] \\S 单个非空白字符 [^ \\n\\f\\t]、[^\\s] ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#11-单个字符匹配"},{"categories":["正则表达式"],"content":" 1.2 匹配次数 正则表达式 意义 ? 匹配0或1次 * 匹配任意次（大于等于0） + 至少匹配一次（大于等于1） {a} 匹配a次 {a,b} 至少匹配a次，至多匹配b次（[a,b]） {a,} 至少匹配a次（大于等于a） {0,b} 至多匹配b次（[0,b]） ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#12-匹配次数"},{"categories":["正则表达式"],"content":" 1.3 边界匹配 正则表达式 意义 \\b 单词边界 \\B 非单词边界 ^ 字符串开头 $ 字符串结尾 /规则/m 多行模式 /规则/i 忽略大小写 /规则/g 全局模式 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#13-边界匹配"},{"categories":["正则表达式"],"content":" 1.4 逻辑关系 正则表达式 意义 ` ` [^] 逻辑非 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#14-逻辑关系"},{"categories":["正则表达式"],"content":" 2.高级用法 回溯引用 前向查找 后向查找 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#2高级用法"},{"categories":["正则表达式"],"content":" 3.代码中使用","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#3代码中使用"},{"categories":["正则表达式"],"content":" 3.1 C++ #include \u003cregex\u003e // 转义字符 regex reg1(\"^[\\\\w-]+(\\\\.[\\\\w-]+)*@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); regex_match(\"google@gmail.com\", reg1); // 1 // 原生字符串 R\"(...)\" regex reg2(R\"(^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$)\"); regex_match(\"google@gmail.com\", reg2); // 1 // ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#31-c"},{"categories":["正则表达式"],"content":" 3.2 Java","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#32-java"},{"categories":["正则表达式"],"content":" 3.3 Python","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#33-python"},{"categories":["正则表达式"],"content":" 4.常用正则表达式 整数：^-?\\d+$ 自然数（非负整数）：^\\d+$ 正整数：^[0-9]*[1-9][0-9]*$ 非正整数：^((-\\d+) ?(0+))$ 负整数：^-[0-9]*[1-9][0-9]*$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 非负浮点数：^\\d+(\\.\\d+)?$ 正浮点数：^(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*))$ 非正浮点数：^((-\\d+(\\.\\d+)?) ?(0+(\\.0+)?))$ 负浮点数：^(-(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*)))$ 下划线、数字和大小写字母：^\\w+$ 数字和大小写字母：^[A-Za-z0-9]+$ 大小写字母：^[A-Za-z]+$ 大写字母：^[A-Z]+$ 小写字母：^[a-z]+$ 中文字符：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff]，可以用来计算字符串的长度 空行：\\n[\\s ? ]*\\r，可以用来删除空白行 HTML标记：/ \u003c(.*)\u003e.* \u003c\\/\\1\u003e ? \u003c(.*) \\/\u003e/，仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 首尾空格：(^\\s*) ?(\\s*$) ^\\s* ?\\s*$，可以用来删除行首行尾的空白字符 电子邮件：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 网址（URL）：(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$ [a-zA-z]+://[^\\s]* 命名规则（字母开头，长度5-16，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 中国座机号码：\\d{3}-\\d{8} ?\\d{4}-\\d{7} QQ号：[1-9][0-9]{4,} 中国邮政编码：[1-9]\\d{5}(?!\\d) 中国身份证：\\d{15} ?\\d{18} IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#4常用正则表达式"},{"categories":["正则表达式"],"content":" 5.辅助网站 Regexper：正则表达式规则可视化。 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#5辅助网站"},{"categories":["正则表达式"],"content":" 参考资料 正则表达式不要背 - 掘金 C++正则表达式 - cpluspluser - 博客园 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#参考资料"},{"categories":["位运算","分治法","力扣"],"content":"题目链接 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:0:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#"},{"categories":["位运算","分治法","力扣"],"content":" 方法一：逐位颠倒","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#方法一逐位颠倒"},{"categories":["位运算","分治法","力扣"],"content":" 思路将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。 代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:1","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#思路"},{"categories":["位运算","分治法","力扣"],"content":" 代码 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } }; public class Solution { public int reverseBits(int n) { int rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n != 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev; } } uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } var reverseBits = function(n) { let rev = 0; for (let i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev \u003e\u003e\u003e 0; }; func reverseBits(n uint32) (rev uint32) { for i := 0; i \u003c 32 \u0026\u0026 n \u003e 0; i++ { rev |= n \u0026 1 \u003c\u003c (31 - i) n \u003e\u003e= 1 } return } ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:2","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#代码"},{"categories":["位运算","分治法","力扣"],"content":" 复杂度 时间复杂度：$ O(\\log n) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:3","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#复杂度"},{"categories":["位运算","分治法","力扣"],"content":" 方法二：位运算分治","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#方法二位运算分治"},{"categories":["位运算","分治法","力扣"],"content":" 思路若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。 由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。 对于递归的最底层，我们需要交换所有奇偶位： 取出所有奇数位和偶数位； 将奇数位移到偶数位上，偶数位移到奇数位上。 类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:1","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#思路-1"},{"categories":["位运算","分治法","力扣"],"content":" 代码 class Solution { private: const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 public: uint32_t reverseBits(uint32_t n) { n = n \u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e 16 | n \u003c\u003c 16; } }; public class Solution { private static final int M1 = 0x55555555; // 01010101010101010101010101010101 private static final int M2 = 0x33333333; // 00110011001100110011001100110011 private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111 public int reverseBits(int n) { n = n \u003e\u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e\u003e 16 | n \u003c\u003c 16; } } const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 uint32_t reverseBits(uint32_t n) { n = n \u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e 16 | n \u003c\u003c 16; } var reverseBits = function(n) { const M1 = 0x55555555; // 01010101010101010101010101010101 const M2 = 0x33333333; // 00110011001100110011001100110011 const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const M8 = 0x00ff00ff; // 00000000111111110000000011111111 n = n \u003e\u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return (n \u003e\u003e\u003e 16 | n \u003c\u003c 16) \u003e\u003e\u003e 0; }; const ( m1 = 0x55555555 // 01010101010101010101010101010101 m2 = 0x33333333 // 00110011001100110","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:2","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#代码-1"},{"categories":["位运算","分治法","力扣"],"content":" 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:3","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#复杂度-1"},{"categories":["黑苹果","MacOS"],"content":" 一、工具 U盘（≥16G） Mac OS镜像（.dmg） 适合你的电脑的EFI文件 balenaEtcher（刻录工具） DiskGenius（分区工具） ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#一工具"},{"categories":["黑苹果","MacOS"],"content":" 二、制作U盘启动盘 插入U盘，然后打开balenaEtcher软件。 点击Select image选择Mac OS镜像。 软件会自动识别出你的U盘，最后点击Flash!。 等待刻录完成（20min左右），之后会有一个完整性检测（15min左右）。 当软件显示Flash Complete!时表示刻录成功。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#二制作u盘启动盘"},{"categories":["黑苹果","MacOS"],"content":" 三、配置Clover引导驱动 打开DiskGenius，找到U盘上的ESP分区，删除EFI文件夹。 把适合自己电脑EFI文件夹复制进去。（这里只能用快捷键复制粘贴） 保存更改。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#三配置clover引导驱动"},{"categories":["黑苹果","MacOS"],"content":" 四、制作黑苹果系统盘","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#四制作黑苹果系统盘"},{"categories":["黑苹果","MacOS"],"content":" 硬盘分区安装压缩卷（≥25G）。 选中压缩出的空闲分区，右键新建简单卷，一直点击下一步但选择不要格式化这个卷。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#硬盘分区安装"},{"categories":["黑苹果","MacOS"],"content":" 整块硬盘安装删除磁盘所有分区即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#整块硬盘安装"},{"categories":["黑苹果","MacOS"],"content":" 五、BIOS设置以技嘉（Gigabyte）主板为例： BIOS-\u003eFastBoot-\u003eDisable BIOS-\u003eWindows 8/10 Features-\u003eWindows 8/10 将操作系统类型设置为其他操作系统。从不支持Microsoft签名安全启动的第三方操作系统启动时，将“操作系统类型”设置为“其他操作系统”以获取优化的功能。 BIOS-\u003eCSM Support-\u003eDisabled 禁用CSM。兼容性支持模块（CSM）是UEFI固件的组件，该组件通过模拟BIOS环境来提供旧版BIOS兼容性，从而允许仍使用旧版操作系统和某些不支持UEFI的选件ROM。Clover和OpenCore引导都支持UEFI引导。禁用CSM使BIOS可以轻松发现Bootloader。 BIOS-\u003eLAN PXE Boot Option ROM-\u003eDisabled BIOS-\u003eStorage Boot Option Control-\u003eUEFI BIOS-\u003eOther PCI devices-\u003eUEFI Peripherals-\u003eInitial Display Output-\u003ePCIe Slot(独显)/IGFX(核显) Peripherals-\u003eAbove 4G Decoding-\u003eDisabled Peripherals-\u003eTrusted Computing-\u003eSecurity Device Support-\u003eDisable Peripherals-\u003eUSB Configuration-\u003eLegacy USB Support-\u003eDisabled 禁用旧版USB支持。 Peripherals-\u003eUSB Configuration-\u003eXHCI Hand-off-\u003eEnabled 启用XHCI切换。 Peripherals-\u003eNetwork Stack Configuration-\u003eDisabled Peripherals-\u003eSATA and RST Configuration-\u003eSATA Mode Selection-\u003eAHCI 将SATA设置为AHCI。通过高级主机控制器接口（AHCI）模式，可以在SATA驱动器上使用高级功能，例如热插拔和本机命令队列（NCQ）。AHCI还允许硬盘以比传统IDE模式更高的速度运行。 Chipset-\u003eVT-d-\u003eDisabled 禁用VT-D。VT-d特别是IOMMU规范。扩展允许您访问虚拟机下的物理硬件（例如，运行Linux的系统可以在虚拟机上运行Windows。如果没有VT-d，则视频卡会被仿真，并且游戏速度会很慢。视频卡可以进入直通模式，并且可以在Windows下作为真实硬件（可以安装nvidia驱动程序）进行访问，并且视频卡的性能类似于运行本机Windows实时预览的情况。但是对于许多黑苹果用户，VT-D不会造成任何问题，但是如果您是新手，则尝试安装和配置Hackintosh禁用VT-D并安装。您可以在安装后根据需要启用VT-D。 Chipset-\u003eIOAPIC 24-119 Entries-\u003eEnabled ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#五bios设置"},{"categories":["黑苹果","MacOS"],"content":" 六、黑苹果安装","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#六黑苹果安装"},{"categories":["黑苹果","MacOS"],"content":" 七、更改硬盘启动","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#七更改硬盘启动"},{"categories":["黑苹果","MacOS"],"content":" 八、其他问题","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#八其他问题"},{"categories":["黑苹果","MacOS"],"content":" EFI分区扩容 分出合适空间大小，可使用Windows自带的磁盘管理或者DiskGenius。 打开DiskGenius。 找到ESP分区，右键选择备份分区到镜像文件，选择合适的文件路径并保存（选择热备份）。 删除ESP分区。 在任意分区上右键选择建立ESP/MSR分区，调整合适的分区大小并确认。 保存更改。 找到ESP分区，右键选择从镜像文件还原分区，选择刚才备份的镜像文件即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#efi分区扩容"},{"categories":["黑苹果","MacOS"],"content":" 九、参考 黑果小兵的部落阁 黑苹果MacOS Big Sur 11.0 安装教程及驱动工具 主流电脑配置的通用引导文件，包含CLOVER与OpenCorer双引导 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#九参考"},{"categories":["饥荒"],"content":" 等级25级后开启制造减半后制造 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:1:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#等级"},{"categories":["饥荒"],"content":" 食谱 名称 代码 时间 保质期 饥饿、san、生命 制作 效果 百奇 sorapocky 0s ∞ 37.5、20、20 浆果×6+鸡蛋×0/1/2+蜂蜜×0/1/4 速食拉面 sora_tongmian 1.6s 20d 100/70/40、10、-5 （肉度+菜度）≥2.5 喷香蛋包饭 sora_danbaofan 16s 15d 80/56/32、10、40 蛋≥1+菜度≥0.5+肉度≥0.5 可2怪物肉 默认不放树枝。 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:2:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#食谱"},{"categories":["饥荒"],"content":" 药剂 名称 代码 制作 效果 公正 sora2gz 暖石×2+灰烬×40 恒定温度（15min） 诚实 sora2cs 荧光果×40+草×40+树枝×40 持续发光（15min） 谦卑 sora2qb 蜘蛛腺体×40 生命+40、生命+5/s（5min） 灵魂 sora2lh 灰烬×40+金块×20+莎草纸×10 san+40、san+5/s（5min） 荣誉 sora2ry 蜘蛛网×10+黑色羽毛×3+红色羽毛×3 移动速度+100%（5min） 英勇 sora2yy 蜂刺×40+燧石×40 攻击+50%（5min） 牺牲 sora2xs 狗牙×40+木炭×20+格罗姆的粘液×5 攻击+200%、防御-50%、生命-5/s（1min） 怜悯 sora2lm 治疗药膏×10+蜂蜜药膏×10+强心针×5 怪物生命+500/s（3min） 默认一次制作10个药剂 药剂同时只能生效一个，叠加使用会只有最后使用的产生效果 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:3:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#药剂"},{"categories":["饥荒"],"content":" 装备","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#装备"},{"categories":["饥荒"],"content":" 奇妙法杖 属性 属性值 代码 sora2sword 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+10% 功能 斧头、鹤嘴锄、铲子（右键开关）、锤子（右键开关）、捕虫网、鱼竿 队友能否使用 能 要求 穹10级 制作 黄金铲子×2/4/6+锤子×2/4/6+紫宝石×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#奇妙法杖"},{"categories":["饥荒"],"content":" 神奇法杖 属性 属性值 代码 sora2prop 位置 手 效果 无耐久、攻击+0、攻击距离+0、移动速度+50% 功能 只能攻击队友，将其击飞，掉落其手部装备和身上的金子 队友能否使用 能 要求 穹10级 制作 活木×10/20/30+锤子×0/4/6 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#神奇法杖"},{"categories":["饥荒"],"content":" 银白の锋 属性 属性值 代码 sora3sword 位置 手 效果 无耐久、攻击+59.5、攻击距离+1.25、移动速度+10% 功能 每次攻击回复0.5血量 队友能否使用 能 要求 穹10级 制作 影刀×1/3/5+触手尖刺×2/4/6+蝙蝠棒×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の锋"},{"categories":["饥荒"],"content":" 银白の甲 属性 属性值 代码 sora2armor 位置 身 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 木甲×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の甲"},{"categories":["饥荒"],"content":" 银白の盔 属性 属性值 代码 sora2hat 位置 头 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 猪皮帽×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の盔"},{"categories":["饥荒"],"content":" 银白の翼 属性 属性值 代码 sora2bag 位置 包 效果 14格背包、移动速度+10% 功能 保鲜+50%、回san+3/min 队友能否使用 能 要求 穹10级 制作 冰块×80/200/400+电子元件×10/20/80 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の翼"},{"categories":["饥荒"],"content":" 荣誉勋章 属性 属性值 代码 sora2amulet 位置 符 效果 移动速度+20%、攻击+20%（穹无效）、防御+20%（穹无效） 功能 防水+30%、回san+3/min、发光（多档调节，不同消耗速度，自动关闭）、 修复 关闭时自动修复0.1/s，也可用荧光果、蜗牛粘液、小发光浆果、发光浆果修复 队友能否使用 能 队友增幅 使用穹的便携烹饪锅、制作穹专属料理、快速采集、快速制作 要求 穹10级 制作 重生护符×1/2/3+寒冰护符×1/2/3+噩梦护符×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#荣誉勋章"},{"categories":["饥荒"],"content":" 穹の采 属性 属性值 代码 sorapick 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+25% 功能 灭火、批量采集，CD60s→0s 队友能否使用 不能 要求 穹20级 制作 懒人护符×1/2/4+活木×10/20/40+橙宝石×3/6/10+燧石×40/80/400 升级（冷却时间） 每1/2/3紫宝石，CD-12s，最高提升到0s 升级（采集范围） 每1/2/3橙宝石，范围+1，最高提升到7格 升级（灭火范围） 每10/20/30e，范围+0.5，最高提升到7格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の采"},{"categories":["饥荒"],"content":" 穹の愈 属性 属性值 代码 sorahealing 位置 手 效果 无耐久、攻击+15→35、攻击距离+8、移动速度+25% 功能 右键切换群体治疗或冰冻（消耗饱食度），CD60s，治疗效果30 队友能否使用 不能 要求 穹20级 制作 分解法杖×1/2/4+蜂蜜药膏×10/20/40+绿宝石×3/6/10+花瓣×40/80/400 升级（攻击） 每1/2/3紫宝石，攻击+4，最高提升到35 升级（冷却时间） 每1/2/3黄宝石，CD-10s，最高提升到10s 升级（治疗、冰冻） 每1/2/3绿宝石，治疗+10，最高提升到80（到55后可复活自己或队友） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の愈"},{"categories":["饥荒"],"content":" 穹の瞬 属性 属性值 代码 soratele 位置 手 效果 无耐久、攻击+17、攻击距离+12、移动速度+50% 功能 右键瞬移（CD20s，消耗40san），斧、锄、铲、锤、捕虫网、鱼竿（立刻上钩） 队友能否使用 不能 要求 穹20级 制作 瞬移法杖×1/2/4+月石×5/10/40+紫宝石×4/4/10+红色羽毛×4/10/40 升级（冷却时间） 每1/2/3紫宝石，CD-4s，最高提升到0s 升级（施法消耗） 每10/20/30噩梦燃料，消耗san-3，最高提升到10san ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:10","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の瞬"},{"categories":["饥荒"],"content":" 穹の空 属性 属性值 代码 soramagic 位置 手 效果 无耐久、攻击+20→45、攻击距离+5→10、移动速度+25% 功能 右键流星群伤技能，伤害20→120，CD30s，攻击有概率触发技能 队友能否使用 不能 要求 穹20级 制作 火焰法杖×1/2+金块×10/20+红宝石×2/6+噩梦燃料×10/20 制作（困难） 火焰法杖4+电子元件×20+红宝石×10+龙鳞×4 升级（攻击） 每5/10/15金块，攻击+0.5，最高提升到45 升级（攻击距离） 每1/2/3金丝雀羽毛，攻击距离+0.2，最高提升到10 升级（技能伤害） 每1/2/3红宝石，伤害+4，最高提升到120 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:11","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の空"},{"categories":["饥荒"],"content":" 穹の护 属性 属性值 代码 soraclothes 位置 身 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 保暖+0→240、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（保暖） 每1/2/3熊皮，保暖+48，最高提升到240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:12","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の护"},{"categories":["饥荒"],"content":" 穹の冠 属性 属性值 代码 sorahat 位置 头 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 防雨+0→100%（满级防水）、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（防雨） 每1/2/3巨鹿眼球，防雨+40%，最高提升到100% ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:13","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の冠"},{"categories":["饥荒"],"content":" 穹の包 属性 属性值 代码 sorabag 位置 包 效果 14格背包、出生自带、移动速度+10% 功能 保鲜（默认50%）、回san、隔热 队友能否使用 不能 要求 穹20级 制作 鸭毛×5/10+牛毛×6/20+蜘蛛网×8/20 制作（困难） 鸭毛×40+黑色羽毛×20+红色羽毛×20+紫宝石×4 升级（保鲜） 每5/10/15金块，保鲜度+10%，最高提升500% 升级（回san） 每5/10/15蜂蜜，回san+1/min，最高提升到20/min 升级（隔热） 每5/10/15冰块，隔热+4，最高提升240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:14","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の包"},{"categories":["饥荒"],"content":" 穹の二次元蝴蝶结 属性 属性值 代码 sorabowkno 位置 符 效果 攻击+20%、防御+20%、移动速度+20% 功能 防水+30%、回san+4.5/min、发光、消耗经验打包物品作礼物 队友能否使用 不能 要求 穹20级 制作 蝴蝶×10/20/20+格罗姆翅膀×3/5/10+彩虹宝石×1/2/4 升级（发光） 每5/10/15荧光果/萤火虫/发光浆果，发光范围+0.5格，最高提升5格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:15","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の二次元蝴蝶结"},{"categories":["饥荒"],"content":" 物品","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#物品"},{"categories":["饥荒"],"content":" 穹の缝纫包 属性 属性值 代码 sorarepairer 功能 重置食物新鲜度、修复装备（除了分解法杖） 制作 蜘蛛网×4/6/10+金块×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の缝纫包"},{"categories":["饥荒"],"content":" 穹の打包纸 属性 属性值 代码 sora2pack 功能 一次制作6个（一般难度），打包建筑、植物、物品等。 要求 穹10级 制作 莎草纸×4/6/10+紫宝石×1+花瓣×10/20/60 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の打包纸"},{"categories":["饥荒"],"content":" 魔法","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#魔法"},{"categories":["饥荒"],"content":" 全部魔法 名称 代码 消耗san 效果 鸽子还没到 sora_birds 20/30/40 召唤一群鸟（20-30只） 未闻花名 sora_gardening 20/30/40 催生附近作物（包括大理石树） 提醒睡觉小助手 sora_sleep 40/50/60 催眠附近生物 都是时辰的错 sora_raining 70/90/110 下雨或天晴 空白永不败北 sora_magics 120/140/160 附近物品变化，按物品12或123循环变化 超电磁炮永世长存 sora_lighting 30/40/50 附近召唤闪电 伪典-弑君者 sora_tentacles 50/70/90 附近召唤三只触手 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#全部魔法"},{"categories":["饥荒"],"content":" 空白永不败北 物品1 物品2 物品3 浆果 蜜汁浆果 蝴蝶翅膀 黄油 青蛙腿 鸟腿 花瓣 恶魔花瓣 肥料 鸟粪 石头 燧石 硝石 冰 木炭 金子 金元宝 骨片 化石碎片 月石 月亮碎片 红宝石 蓝宝石 紫宝石 绿宝石 黄宝石 橙宝石 蓝色羽毛 黑色羽毛 红色羽毛 兔毛 猪皮 触手皮 蜘蛛腺体 蚊子血袋 蜂刺 狗牙 牛毛 蜘蛛网 牛角 海象牙 羊角 龙鳞 蛤蟆皮 蝴蝶 月娥 常青树 粗壮常青树 石化树 胡萝卜（地里） 胡萝卜鼠（地里） 曼德拉草（地里） 浆果丛 浆果灌木丛 蜜汁浆果丛 树苗根 月岛树苗根 红蘑菇（树） 蓝蘑菇（树） 绿蘑菇（树） 洋葱 辣椒 大蒜 蒜粉 辣椒面 月相盘 月台 棋盘地板 卵石路 地毯地板 贝壳地板 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#空白永不败北"},{"categories":["饥荒"],"content":" 建筑","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#建筑"},{"categories":["饥荒"],"content":" 穹の圣诞树 属性 属性值 代码 sora2tree 要求 穹5级 功能 每天可随机领取物品 制作 木板×1/5/20+松果×1/10/40+桦木果×1/10/40 升级机制：往圣诞树里放东西，点击献祭（手柄关闭后就会自动献祭），献祭会增加经验值，达到一定经验值后树就会升级，不同的物品经验值也不同，但是不需要太在意升级因为献祭获得的经验和获得礼物而扣除的经验不成正比（一根草每天白嫖不香吗），所以应该把他当做垃圾桶更合适（小声bb） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の圣诞树"},{"categories":["饥荒"],"content":" 薇诺娜的投石机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的投石机"},{"categories":["饥荒"],"content":" 薇诺娜的聚光灯 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的聚光灯"},{"categories":["饥荒"],"content":" 薇诺娜的发电机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+木头×2+硝石×2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的发电机"},{"categories":["饥荒"],"content":" 秘法祭坛 属性 属性值 代码 sora2base 要求 制作（简单） 红月之眼+蓝月之眼+月石×6 制作（一般） 紫月之眼×2+黄月之眼×2+月石×20 制作（困难） 绿月之眼×3+橙月之眼×3+月石×40 火魔杖 自动攻击 冰魔杖 灭火器 传送魔杖 作为传送石的目的地 瞬移魔杖 消耗饥饿回san 解构魔杖 消耗饥饿回血 唤星者 大范围升温 访月者 大范围降温 魔杖放置在祭坛的第一格 若第二格不是噩梦燃料，则会提供大范围光源 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#秘法祭坛"},{"categories":["饥荒"],"content":" 传送石 属性 属性值 代码 sora2stone 要求 制作 金块×2+沙漠石头×0/1/1+月石×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#传送石"},{"categories":["饥荒"],"content":" 强迫の箱子 属性 属性值 代码 sora2chest 功能 25格容器，关闭时自动收集附近与第一格相同的物品，其他物品掉落（打包除外） 要求 穹10级 制作 木板×3/3/5+石砖×0/3/5+噩梦燃料×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#强迫の箱子"},{"categories":["饥荒"],"content":" 寒冰の箱子 属性 属性值 代码 sora2ice 功能 25格容器，永久保鲜 要求 穹10级 制作（简单） 冰块×80+木板×10+石砖×10 制作 蓝宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#寒冰の箱子"},{"categories":["饥荒"],"content":" 烈焰の箱子 属性 属性值 代码 sora2fire 功能 25格容器，烤熟食物，木头变木炭，可燃物变灰烬 要求 穹10级 制作（简单） 木炭×80+木板×10+石砖×10 制作 红宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#烈焰の箱子"},{"categories":["环境配置"],"content":" Windows 添加环境变量","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#windows-添加环境变量"},{"categories":["环境配置"],"content":" 窗口化操作 按Win + R，并输入sysdm.cpl。 选择高级，然后点击环境变量。 在系统变量区中选择Path，点击编辑。 点击新建，输入程序的执行路径（绝对路径）。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#窗口化操作"},{"categories":["环境配置"],"content":" 误删系统环境变量的补救措施 若未关闭当前CMD。输入echo %PATH%会显示原来的 PATH 值。 若已关闭当前CMD。每个正在运行的 Windows 程序都会有自己已加载的 PATH，可以使用Process Explorer来查看当前正在运行的程序的环境变量。例如：如果你之前打开了 Chrome，且一直未关闭，按Ctrl+O打开C:\\Windows\\System32\\cmd.exe，然后输入echo %PATH%会显示原来的 PATH 值。恢复之后删除C:\\Program Files\\Google\\Chrome\\Application和用户变量中的PATH值即可。 若已重启电脑。手动恢复 PATH 到默认值%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0，其他值已丢失。 参考：如何恢复我删除的Path环境变量？ ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#误删系统环境变量的补救措施"},{"categories":["环境配置"],"content":" VS CodeVisual Studio Code 官网 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#vs-code"},{"categories":["环境配置"],"content":" 1. C++ 安装编译器 Windows（二选一） 安装 Visual Studio 安装 MinGW-w64，推荐从 SourceForge 下载安装。 Linux: sudo apt install gcc g++ gdb build-essential Mac OS: xcode-select --install 安装 VS Code C/C++ 扩展ms-vscode.cpptools。 asd 解决头文件找不到 修改c_cpp_properties.json Linux：gcc -v -E -x c++ - Windows 10 + Visual Studio 2019 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/include/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"windows-msvc-x64\" } ], \"version\": 4 } Windows 10 + Mingw-w64 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Portable/mingw64/bin/g++.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\" } ], \"version\": 4 } 打开设置。 C_Cpp: Clang_format_fallback Style设为{BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4} C_Cpp › Default: Cpp Standard设为`` C_Cpp › Default: C Standard设为`` 参考 关闭 Windows Defender “首次看到时阻止”： 问题描述： 编译运行程序的时候总是弹出一个 Microsoft Defender 防病毒程序窗口，提示“需要扫描当前程序”。 解决方法： 按Win+R，输入gpedit.msc，打开本地组策略编辑器。 左侧选择计算机配置-\u003e管理模板-\u003eWindows 组件-Microsoft Defender 防病毒-\u003eMAPS。 右侧双击配置“首次看到时阻止”功能，选择已禁用，然后点击确定，保存退出。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#1-c"},{"categories":["环境配置"],"content":" Python 建议安装3.8版本 Python 官网 Miniconda 官网 Anaconda 官网 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#python"},{"categories":["环境配置"],"content":" pip 设置代理 Windows：%APPDATA%\\pip\\pip.ini [global] proxy = http://user:password@proxy_name:port ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#pip-设置代理"},{"categories":["环境配置"],"content":" Conda 常用命令更新：conda update 查看环境：conda env list或conda info -e 创建环境：conda create -n \u003cENVNAME\u003e python=3.X -y 删除环境：conda remove -n \u003cENVNAME\u003e --all -y 设置代理：conda config --set proxy_servers.http http://127.0.0.1:10809 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#conda-常用命令"},{"categories":["环境配置"],"content":" PyTorchPyTorch 官网 CPU： Anaconda: conda install pytorch torchvision torchaudio cpuonly -c pytorch Pip: pip install torch==1.8.1+cpu torchvision==0.9.1+cpu torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html GPU (CUDA 11.0)： Anaconda: conda install pytorch torchvision torchaudio cudatoolkit=11.0 -c pytorch Pip: pip install torch==1.7.1+cu110 torchvision==0.8.2+cu110 torchaudio===0.7.2 -f https://download.pytorch.org/whl/torch_stable.html 检查是否安装成功： import torch # 检查 pytorch 是否安装成功 print(torch.__version__) # 检查 CUDA 是否可用 print(torch.cuda.is_available()) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#pytorch"},{"categories":["环境配置"],"content":" TensorFlowTensorFlow 官网 Pip: CPU and GPU: pip install tensorflow Wheel: # https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow_cpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_cpu-2.4.1-cp38-cp38-win_amd64.whl # CPU # https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl # GPU 检查是否安装成功： import tensorflow as tf # 检查 tensorflow 是否安装成功 print(tf.__version__) # 检查 CUDA 是否可用 # 输出最后一行显示 [PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')] print(tf.config.experimental.list_physical_devices('GPU')) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#tensorflow"},{"categories":["环境配置"],"content":" Q\u0026A问题描述： 安装 CUDA 11.1 + cuDNN 8.1，tensorflow 2.4.1 检查 GPU 时报错： Could not load dynamic library 'cusolver64_10.dll'; dlerror: cusolver64_10.dll not found 解决方案： 卸载重新安装 CUDA 11.0 + cuDNN 8.0，参考 Windows 经过测试的构建配置。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#qa"},{"categories":["环境配置"],"content":" CUDA \u0026 cuDNN CUDA 和 cuDNN 版本：Windows 经过测试的构建配置 以笔记本 RTX2060 显卡为例 NVIDIA 驱动程序下载，选择对应版本，下载安装。 CUDA 工具包下载，下载对应版本安装。 在CMD输入nvcc -V，出现如下输出表示安装成功。 nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Tue_Sep_15_19:12:04_Pacific_Daylight_Time_2020 Cuda compilation tools, release 11.1, V11.1.74 Build cuda_11.1.relgpu_drvr455TC455_06.29069683_0 cuDNN 下载，需要登陆账号，登陆后下载对应版本，解压将bin、include和lib三个文件夹的内容复制到 CUDA 安装目录下。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#cuda--cudnn"},{"categories":["Git","教程"],"content":"Git 是一个开源的分布式版本控制系统。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#"},{"categories":["Git","教程"],"content":" 1 Git 基本工作流程","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#1-git-基本工作流程"},{"categories":["Git","教程"],"content":" 1.1 本地仓库 本地历史仓库（Repository）：存放不同版本的代码。 暂存区（Index）：代码提交前的临时存储区。 工作目录（Working Tree）：修改代码的区域。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#11-本地仓库"},{"categories":["Git","教程"],"content":" 1.2 远程仓库 克隆（Clone）：将远程仓库中的内容复制到本地仓库。 推送（Push）：将本地仓库中的内容推送到远程仓库。 拉取（Pull）：更新远程仓库中的改动到本地仓库。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#12-远程仓库"},{"categories":["Git","教程"],"content":" 2 Git 常用命令 # 查看 git 状态 git status # 查看日志 git log # 查看简短日志 git reflog ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#2-git-常用命令"},{"categories":["Git","教程"],"content":" 2.1 本地仓库 # 初始化，创建 git 仓库 git init # 添加文件到暂存区 git add \u003cfile\u003e # 将暂存区文件提交到本地历史仓库 git commit -m \u003cmessage\u003e # 将所有修改或删除的文件提交到本地历史仓库（不包括新建文件） git commit -a -m \u003cmessage\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#21-本地仓库"},{"categories":["Git","教程"],"content":" 2.2 版本切换 # git reset --hard a3a9cf1 git reset --hard \u003ccommit\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#22-版本切换"},{"categories":["Git","教程"],"content":" 2.3 分支管理 切换：将HEAD指向别的分支。 合并：将main指向该分支，然后将HEAD指向main分支。 # 查看所有分支 git branch # 创建新分支 git branch \u003cbranch-name\u003e # 删除指定分支 git branch -d \u003cbranch-name\u003e # 切换到其他分支 git checkout \u003cbranch\u003e # 创建新分支，并立即切换过去 git checkout -b \u003cbranch\u003e # 将指定分支合并到当前分支 git merge \u003cbranch-name\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#23-分支管理"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add \u003cname\u003e \u003curl\u003e # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u \u003crepository\u003e \u003crefspec\u003e 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone \u003crepo\u003e # 拉取远端仓库，更新本地仓库 # git pull origin master git pull \u003crepository\u003e \u003crefspec\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#24-远程仓库"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#241-远程仓库创建"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#242-ssh-配置"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#243-本地仓库同步到远程仓库"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#244-远程仓库同步到本地仓库"},{"categories":["Git","教程"],"content":" 2.5 代码冲突同一文件存在多个新版本，如下所示。需要先拉取远程仓库，手动修改冲突文件后，再次推送即可。 ! [rejected] master -\u003e master (fetch first) error: failed to push some refs to 'https://github.com/backtraxe/repo_for_test.git' 2.5.1 替换本地改动 # 丢弃当前文件修改内容 git checkout -- \u003cfile\u003e # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#25-代码冲突"},{"categories":["Git","教程"],"content":" 2.5 代码冲突同一文件存在多个新版本，如下所示。需要先拉取远程仓库，手动修改冲突文件后，再次推送即可。 ! [rejected] master -\u003e master (fetch first) error: failed to push some refs to 'https://github.com/backtraxe/repo_for_test.git' 2.5.1 替换本地改动 # 丢弃当前文件修改内容 git checkout -- # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#251-替换本地改动"},{"categories":["Git","教程"],"content":" 2.6 子模块 # 将一个 Git 仓库添加为当前仓库的子模块 git submodule add https://github.com/USERNAME/REPONAME.git # git clone 含有子模块的项目 # 1.项目已经克隆到了本地 git submodule init git sunmodule update # 或者 git submodule update --init # 2.项目还未克隆到本地 git clone --recurse-submodules https://github.com/USERNAME/REPONAME.git # 或者 git clone --recursive https://github.com/USERNAME/REPONAME.git ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#26-子模块"},{"categories":["Git","教程"],"content":" 2.7 .gitignore工作目录中需要 git 忽略的文件目录。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#27-gitignore"},{"categories":["Git","教程"],"content":" Q\u0026A","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#qa"},{"categories":["Git","教程"],"content":" 1. 无法连接服务器，报错443问： git clone或git push等操作时无法连接至服务器，报错内容如下： SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 答： 该问题由开启代理软件导致。设置-\u003e网络和Internet-\u003e代理，查看地址和端口，通过如下命令进行配置。 # git config --global http.proxy 127.0.0.1:10809 git config --global http.proxy IP_ADDRESS:PORT ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#1-无法连接服务器报错443"},{"categories":["Git","教程"],"content":" 参考 Git Cheat Sheets ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#参考"},{"categories":["饥荒"],"content":"饥荒 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#"},{"categories":["饥荒"],"content":" 科普 食物可通过觅食，陷阱，种植或者猎捕动物和怪兽获得。 不同的食物可以恢复不同的饥饿和一些生命以及理智。 但是如果吃下一些像是怪物肉或是榴梿之类的食物，可能反而会对玩家的生命值造成伤害，甚至是降低玩家的理智。 不同颜色的蘑菇针对生命值和理智值也都会对玩家产生不同的效果。 另外有些比较特殊的食物，比如发光莓，在吃下去后会给予玩家特别的效果。 大部分食物都可以通过在营火上烹饪来增加恢复的饥饿与生命或是减少（抵消）生吃对玩家造成的负面影响。 有些生的食物（通常为肉类）可以挂在干肉架上晒干来取得可以长久保存并能回复玩家饥饿/生命/理智的食物。 烹饪锅可以用来取得一些特殊料理，让玩家可以从食物中得到额外的好处（大部分的料理都有回复理智的效果，但直接食用大部分的食物都无法得到）。 肉类可以作为诱饵，可以招募猪人，可以进贡给猪王换取金块。 一个可以不断取得蛋的方法就是通过将肉喂给鸟笼中的鸟，肉类还可以制作复活肖像。 当玩家在物品栏中持有肉时会被兔人视为攻击目标。 蔬菜和水果可以当作草食动物的诱饵（像是兔子）或是喂给猪人来换取粪便。种子可以当作捕鸟陷阱的诱饵。 被视为游戏中最重要的物品之一，根据地图生成的不同，食物可以从很丰富到十分短缺都有可能。 食物受到季节的影响非常大，这鼓励玩家去根据季节挑选适合的食物（译注：像是冬天农田几乎不会生长、春天兔子不会跑出洞、只有夏天才有仙人掌花…等等例子）。 大多数的食物都会慢慢的腐烂，最后变成腐烂食物。 当食物的腐坏度为50%时，食物将会变为**不新鲜（黄色）**状态。可恢复2/3的饥饿，1/3的生命，不能恢复理智。 当食物的腐坏度为20%时，食物将会变为**变质（红色）**状态。可恢复1/2的饥饿，不能恢复生命，降低10点理智。 地面上的食物腐坏率为150%，冰箱中的腐坏率为50%，冬天食物的腐坏率为75%。 不新鲜和变质的食物对**WX-78（机器人）**没有影响。 堆叠的食物具有相同的腐烂程度，将腐烂程度不同的食物堆叠起来腐烂值取平均值。在游戏中可以利用这个设定来\"拯救\"快要腐烂的食物：将快腐烂的食物与新鲜的食物堆叠起来，然后ctrl+点击分开食物。 烹饪中的食物和在烹饪锅中的食物降低一般的腐坏度。 高脚鸟蛋，曼德拉草和巨鹿眼球是不会腐坏的。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#科普"},{"categories":["饥荒"],"content":" 食谱 类别 详细 肉类 怪物肉 鱼类 蔬菜 胡萝卜、各种蘑菇、 水果 浆果、多汁浆果、香蕉、西瓜、火龙果、石榴、榴莲 烹饪 其他 桦树果、蝴蝶翅膀、黄油、牛奶、冰、蜂蜜、腐烂食物、各种种子、齿轮、树枝、噩梦燃料、骨头碎片、花瓣 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#食谱"},{"categories":["饥荒"],"content":" 肉丸 肉度×0.5，1肉3填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 62.5 5 3 15秒 10天 食材1 食材2 食材3 食材4 怪物肉、大肉、小肉、鸡腿 浆果、冰 浆果、冰 浆果、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#肉丸"},{"categories":["饥荒"],"content":" 炖肉 肉度×3，3肉1填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 150 5 12 15秒 10天 食材1 食材2 食材3 食材4 怪物肉 大肉 大肉 浆果、冰 怪物肉 大肉 小肉 小肉 大肉 大肉 鸡腿 蛙腿 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#炖肉"},{"categories":["饥荒"],"content":" 火鸡大餐 鸡腿×2+肉度×0.5，2鸡腿1肉1填充物，两个鸡腿必须是生的。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 60秒 6天 食材1 食材2 食材3 食材4 鸡腿 鸡腿 怪物肉、大肉、小肉 浆果、蘑菇、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#火鸡大餐"},{"categories":["饥荒"],"content":" 培根煎蛋 蛋度×2+肉度×1.5，禁蔬菜、水果。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 40秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉、大肉 大肉、小肉 高脚鸟蛋 怪物肉、大肉、小肉 怪物肉、大肉、小肉 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#培根煎蛋"},{"categories":["饥荒"],"content":" 蜜汁火腿 蜂蜜×1+肉度×2，禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 30 40秒 20天 食材1 食材2 食材3 食材4 蜂蜜 怪物肉 大肉、小肉 大肉、小肉 蜂蜜 怪物肉 大肉 浆果 蜂蜜 蜂蜜 怪物肉 大肉 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#蜜汁火腿"},{"categories":["饥荒"],"content":" 果仁杂烩 烤桦树果+水果×1.5，禁冰、蔬菜。 饥饿 精神 生命 烹饪时间 腐烂时间 12.5 5 30 40秒 15天 食材1 食材2 食材3 食材4 烤桦树果 浆果 浆果 浆果 烤桦树果 烤桦树果 浆果 浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#果仁杂烩"},{"categories":["饥荒"],"content":" 波兰水饺 禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 20秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉 蘑菇 高脚鸟蛋 浆果 怪物肉 蘑菇 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#波兰水饺"},{"categories":["饥荒"],"content":" 火龙果派 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 40 40秒 15天 食材1 食材2 食材3 食材4 火龙果 树枝、浆果 树枝、浆果 树枝、浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:8","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#火龙果派"},{"categories":["饥荒"],"content":" 华夫饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 60 10秒 6天 食材1 食材2 食材3 食材4 黄油 鸡蛋、高脚鸟蛋 浆果 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:9","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#华夫饼"},{"categories":["饥荒"],"content":" 炸鱼条 鱼+树枝 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 40秒 10天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:10","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#炸鱼条"},{"categories":["饥荒"],"content":" 太妃糖 蜂蜜×3 饥饿 精神 生命 烹饪时间 腐烂时间 25 15 -3 40秒 15天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:11","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#太妃糖"},{"categories":["饥荒"],"content":" 蝴蝶松饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 20 40秒 15天 食材1 食材2 食材3 食材4 蝴蝶翅膀 蘑菇 树枝 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:12","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#蝴蝶松饼"},{"categories":["饥荒"],"content":" 粉末蛋糕 玉米+蜂蜜，腐烂时间很久。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:13","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#粉末蛋糕"},{"categories":["饥荒"],"content":" 人物 mod","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#人物-mod"},{"categories":["饥荒"],"content":" 宝石萝莉宝石萝莉完整攻略 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#宝石萝莉"},{"categories":["饥荒"],"content":" 参考资料 Don’t Starve 中文维基 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#参考资料"},{"categories":null,"content":" 1.准备工作 VPS：推荐CN2 GIA线路，其次CN2 BandwagonHost, 备用 Vultr DigitalOcean 三优云 域名 免费：Freenom 付费：NameSilo, GoDaddy DNS \u0026 CDN： Cloudflare ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#1准备工作"},{"categories":null,"content":" 2.服务端","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#2服务端"},{"categories":null,"content":" 2.1 v2ray-agentGithub 支持协议： VLESS + TCP + TLS VLESS + TCP + xtls-rprx-direct【推荐】 VLESS + gRPC + TLS VLESS + WS + TLS Trojan + TCP + TLS【推荐】 Trojan + TCP + xtls-rprx-direct【推荐】 Trojan + gRPC + TLS VMess + WS + TLS 安装： wget -P /root -N --no-check-certificate \"https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh\" \u0026\u0026 chmod 700 /root/install.sh \u0026\u0026 /root/install.sh 查看配置：vasma ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#21-v2ray-agent"},{"categories":null,"content":" 2.2 Xray_onekeyGithub 支持协议： VLESS + TCP + XTLS/TLS VLESS + TCP + XTLS/TLS 及 VLESS + WS + TLS 回落并存模式 安装： wget -N --no-check-certificate -q -O install.sh \"https://raw.githubusercontent.com/wulabing/Xray_onekey/main/install.sh\" \u0026\u0026 chmod +x install.sh \u0026\u0026 bash install.sh 查看配置：同安装 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#22-xray_onekey"},{"categories":null,"content":" 2.3 x-uiGithub 支持协议： vmess vless trojan shadowsocks dokodemo-door socks http 安装： bash \u003c(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) 查看配置：x-ui ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#23-x-ui"},{"categories":null,"content":" 3.客户端","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#3客户端"},{"categories":null,"content":" 3.1 Windows 3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#31-windows"},{"categories":null,"content":" 3.1 Windows 3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#311-v2rayn"},{"categories":null,"content":" 3.1 Windows 3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#312-clash-for-windows"},{"categories":null,"content":" 3.1 Windows 3.1.1 v2rayNGithub 3.1.2 Clash for Windows下载 Qv2ray下载 内核： v2ray xray trojan-go 插件： Trojan Trojan-Go 支持协议： Vmess (V2ray) Vless (Xray) SS (Shadowsocks) SSR (ShadowsocksR) Trojan Trojan-Go NaiveProxy QvTrojanGoPlugin.v1.0.1.Windows-x64.dll、QvTrojanPlugin.v2.0.0.Windows-x64.dll ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#qv2ray"},{"categories":null,"content":" 安卓 V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#安卓"},{"categories":null,"content":" 安卓 V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#v2rayng"},{"categories":null,"content":" 安卓 V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#igniter"},{"categories":null,"content":" 安卓 V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#clash-for-android"},{"categories":null,"content":" 安卓 V2rayNG下载 igniter只支持 Trojan 下载 Clash for Android下载 SagerNet下载 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#sagernet"},{"categories":["C++","数据结构","算法"],"content":"竞赛算法集合。 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:0:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#"},{"categories":["C++","数据结构","算法"],"content":" 1 STL 小技巧","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#1-stl-小技巧"},{"categories":["C++","数据结构","算法"],"content":" 1.1 头文件 /*** 函数 ***/ #include\u003calgorithm\u003e #include\u003cfunctional\u003e // hash #include\u003cclimits\u003e // 常量 #include\u003ccmath\u003e #include\u003ccstdio\u003e #include\u003ccstdlib\u003e // 随机数生成 random #include\u003cctime\u003e #include\u003ciostream\u003e #include\u003csstream\u003e #include\u003ciomanip\u003e // 格式化 right 和 setw(width) /*** 数据结构 ***/ #include\u003cdeque\u003e // 双端队列 #include\u003clist\u003e #include\u003cqueue\u003e // 包含 priority_queue #include\u003cstack\u003e #include\u003cstring\u003e #include\u003cvector\u003e ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#11-头文件"},{"categories":["C++","数据结构","算法"],"content":" 1.2 I/O cin \u003e\u003e n; getline(cin, str); // 接收换行符 getline(cin, str); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#12-io"},{"categories":["C++","数据结构","算法"],"content":" 1.3 常量 #include\u003cclimits\u003e INT_MIN INT_MAX LONG_MIN LONG_MAX LLONG_MIN LLONG_MAX (~0u) // 无穷大 (for long and long long) (~0u)\u003e\u003e2 // 无穷大 (for int) ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#13-常量"},{"categories":["C++","数据结构","算法"],"content":" 1.4 数学 // 当数字很大时，用 powl 代替 pow powl(a, b); // p 的 n 方根 (int)round(p, (1.0/n)); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#14-数学"},{"categories":["C++","数据结构","算法"],"content":" 1.5 初始化数组 // 一维数组 fill(arr, arr + sizeof(arr), value); fill_n(arr, sizeof(arr), value); // 二维数组，只能填充 0 或 -1 memset(arr, 0, sizeof(arr)); for (int i = 0; i \u003c row; i++) fill(a[i], a[i] + sizeof(a[i]), value); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:5","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#15-初始化数组"},{"categories":["C++","数据结构","算法"],"content":" 1.6 修改序列 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:6","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#16-修改序列"},{"categories":["C++","数据结构","算法"],"content":" 动态规划","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#动态规划"},{"categories":["C++","数据结构","算法"],"content":" 凸包技巧https://codeforces.com/contest/319/problem/C #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; typedef long long ll; const int MAXN = 105000; int n; ll height[MAXN], tax[MAXN]; ll dp[MAXN]; vector\u003cll\u003e mvals, bvals; int cur = 0; // Suppose the last 3 lines added are : (l1, l2, l3) // Line l2 becomes irrelevant, if l1/l3 x-intersection is to the left of l1/l2 x-intersection bool bad(ll m1, ll b1, ll m2, ll b2, ll m3, ll b3) { // 转为 double 避免溢出 return 1.0 * (b1 - b3) * (m2 - m1) \u003c 1.0 * (b1 - b2) * (m3 - m1); } void add(ll m, ll b) { while ( (int) mvals.size() \u003e= 2 \u0026\u0026 bad(mvals[mvals.size() - 2], bvals[bvals.size() - 2], mvals[mvals.size() - 1], bvals[bvals.size() - 1], m, b)) { mvals.pop_back(); bvals.pop_back(); } mvals.push_back(m); bvals.push_back(b); } void setCur(ll x) { if (cur \u003e (int) mvals.size() - 1) cur = (int) mvals.size() - 1; // Best-line pointer goes to the right only when queries are non-decreasing (x argument grows) while (cur \u003c (int) mvals.size() - 1 \u0026\u0026 1.0 * mvals[cur + 1] * x + bvals[cur + 1] \u003c= 1.0 * mvals[cur] * x + bvals[cur]) cur++; } int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026height[i]); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026tax[i]); // Formula is dp[i] = min(tax[j] * height[i] + dp[j] | j = 1 .. i - 1) // Here tax[j] is considered as m value, and dp[j] as b value in line equation y = m * x + b for (int i = 1; i \u003c= n; i++) { if (i == 1) { dp[i] = 0; } else { setCur(height[i]); dp[i] = mvals[cur] * height[i] + bvals[cur]; } add(tax[i], dp[i]); } cout \u003c\u003c dp[n]; return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#凸包技巧"},{"categories":["C++","数据结构","算法"],"content":" 最长递增序列https://informatics.msk.ru/mod/statements/view3.php?id=766\u0026chapterid=1794 $O(N \\log N)$ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = 1000 * 1000 * 1000; int n; int k, b, m; int a[MAXN]; int d[MAXN]; int ind[MAXN], pr[MAXN]; vector \u003cint\u003e ansv; int ans = 1; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); scanf(\"%d %d %d %d\", \u0026a[1], \u0026k, \u0026b, \u0026m); for (int i = 2; i \u003c= n; i++) a[i] = (k * a[i - 1] + b) % m; d[0] = -INF; for (int i = 1; i \u003c= n; i++) d[i] = INF; for (int i = 1; i \u003c= n; i++) { int pos = upper_bound(d + 1, d + n + 1, a[i]) - d; if (d[pos - 1] \u003c a[i] \u0026\u0026 a[i] \u003c d[pos]) { d[pos] = a[i]; ind[pos] = i; pr[i] = ind[pos - 1]; if (pos \u003e ans) { ans = pos; } } } if (ans == 1) { printf(\"%d\", a[1]); } else { int cur = ind[ans]; while (cur != 0) { ansv.push_back(a[cur]); cur = pr[cur]; } for (int i = (int) ansv.size() - 1; i \u003e= 0; i--) printf(\"%d \", ansv[i]); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最长递增序列"},{"categories":["C++","数据结构","算法"],"content":" 数据结构","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#数据结构"},{"categories":["C++","数据结构","算法"],"content":" 笛卡尔树Balanced Binary Search Tree https://informatics.msk.ru/mod/statements/view3.php?chapterid=2782 $O(\\log N)$ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int mod = 1000 * 1000 * 1000; struct node { int x, y; node *l, *r; node(int new_x, int new_y) { x = new_x; y = new_y; l = NULL; r = NULL; } }; typedef node * pnode; void merge(pnode \u0026t, pnode l, pnode r) { if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } } void split(pnode t, int x, pnode \u0026l, pnode \u0026r) { if (t == NULL) l = r = NULL; else if (t-\u003ex \u003e x) { split(t-\u003el, x, l, t-\u003el); r = t; } else { split(t-\u003er, x, t-\u003er, r); l = t; } } void add(pnode \u0026t, pnode a) { if (t == NULL) t = a; else if (a-\u003ey \u003e t-\u003ey) { split(t, a-\u003ex, a-\u003el, a-\u003er); t = a; } else { if (t-\u003ex \u003c a-\u003ex) add(t-\u003er, a); else add(t-\u003el, a); } } int next(pnode t, int x) { int ans = -1; while (t != NULL) { if (t-\u003ex \u003c x) t = t-\u003er; else { if (ans == -1 || ans \u003e t-\u003ex) ans = t-\u003ex; t = t-\u003el; } } return ans; } int n, ans, x; char qt, prev_qt; pnode root = NULL, num; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\\n\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%c %d\\n\", \u0026qt, \u0026x); if (qt == '+') { if (prev_qt == '?') x = (x + ans) % mod; num = new node(x, rand()); add(root, num); } else { ans = next(root, x); printf(\"%d\\n\", ans); } prev_qt = qt; } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#笛卡尔树"},{"categories":["C++","数据结构","算法"],"content":" 带有隐式键的笛卡尔树https://informatics.msk.ru/mod/statements/view3.php?chapterid=111240 $O(\\log N)$ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003cutility\u003e #include \u003ccstring\u003e #include \u003ciomanip\u003e using namespace std; const int INF = 2 * 1000 * 1000 * 1000; struct node { int y, val; int sz, mn; bool rev; node *l, *r; node (int new_val, int new_y) { y = new_y; val = new_val; sz = 1; mn = val; rev = false; l = NULL; r = NULL; } }; typedef node * pnode; int getsize(pnode t) { if (t == NULL) return 0; return t-\u003esz; } int getmin(pnode t) { if (t == NULL) return INF; return t-\u003emn; } void update(pnode t) { if (t == NULL) return; t-\u003esz = getsize(t-\u003el) + 1 + getsize(t-\u003er); t-\u003emn = min(t-\u003eval, min(getmin(t-\u003er), getmin(t-\u003el))); } void push(pnode t) { if (t \u0026\u0026 t-\u003erev) { swap(t-\u003el, t-\u003er); if (t-\u003el) t-\u003el-\u003erev ^= true; if (t-\u003er) t-\u003er-\u003erev ^= true; t-\u003erev = false; } } void merge(pnode \u0026t, pnode l, pnode r) { push(l); push(r); if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } update(t); } void split(pnode t, pnode \u0026l, pnode \u0026r, int x, int add = 0) { push(t); if (t == NULL) { l = r = NULL; return; } int key = getsize(t-\u003el) + 1 + add; if (x \u003c= key) { split(t-\u003el, l, t-\u003el, x, add); r = t; } else { split(t-\u003er, t-\u003er, r, x, add + getsize(t-\u003el) + 1); l = t; } update(t); } void reverse(pnode t, int l, int r) { pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); a-\u003erev ^= true; merge(t, t, a); merge(t, t, b); } int getmin(pnode t, int l, int r) { int ans; pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); ans = getmin(a); merge(t, t, a); merge(t, t, b); return ans; } int n, m; int qt, l, r; pnode root = NULL, add; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int x; sca","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#带有隐式键的笛卡尔树"},{"categories":["C++","数据结构","算法"],"content":" 树状数组$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3317 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; int a[MAXN]; long long f[MAXN]; char q; int l, r; void update(int pos, int delta) { for (; pos \u003c= n; pos = (pos | (pos + 1))) f[pos] += delta; } long long sum(int pos) { long long res = 0; for (; pos \u003e 0; pos = (pos \u0026 (pos + 1)) - 1) res += f[pos]; return res; } long long sum(int l, int r) { return sum(r) - sum(l - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026a[i]); update(i, a[i]); } scanf(\"%d\\n\", \u0026m); for (int i = 1; i \u003c= m; i++) { scanf(\"%c %d %d\\n\", \u0026q, \u0026l, \u0026r); if (q == 's') { cout \u003c\u003c sum(l, r) \u003c\u003c \" \"; } else { int delta = r - a[l]; a[l] = r; update(l, delta); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#树状数组"},{"categories":["C++","数据结构","算法"],"content":" 二维树状数组$O((\\log N)^2)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3013 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 1050; int n, m; int qn; char q[10]; int f[MAXN][MAXN]; void update(int x, int y, int delta) { for (int i = x; i \u003c= n; i = i | (i + 1)) for (int j = y; j \u003c= m; j = j | (j + 1)) f[i][j] += delta; } int getSum(int x, int y) { int res = 0; for (int i = x; i \u003e 0; i = (i \u0026 (i + 1)) - 1) for (int j = y; j \u003e 0; j = (j \u0026 (j + 1)) - 1) res += f[i][j]; return res; } int getSum(int xFrom, int xTo, int yFrom, int yTo) { return getSum(xTo, yTo) - getSum(xTo, yFrom - 1) - getSum(xFrom - 1, yTo) + getSum(xFrom - 1, yFrom - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026qn); m = n; for (int i = 1; i \u003c= qn; i++) { scanf(\"%s\", \u0026q); if (q[0] == 'A') { int x, y; scanf(\"%d %d\\n\", \u0026x, \u0026y); update(x, y, 1); } else { int xFrom, xTo, yFrom, yTo; scanf(\"%d %d %d %d\\n\", \u0026xFrom, \u0026yFrom, \u0026xTo, \u0026yTo); if (xFrom \u003e xTo) swap(xFrom, xTo); if (yFrom \u003e yTo) swap(yFrom, yTo); printf(\"%d\\n\", getSum(xFrom, xTo, yFrom, yTo)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#二维树状数组"},{"categories":["C++","数据结构","算法"],"content":" 隐式的线段树 时间复杂度：$O(\\log N)$ 空间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3327 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstdlib\u003e using namespace std; typedef long long ll; struct Node { ll sum; Node *l, *r; Node() : sum(0), l(NULL), r(NULL) { } }; void add(Node *v, int l, int r, int q_l, int q_r, ll val) { if (l \u003e r || q_r \u003c l || q_l \u003e r) return; if (q_l \u003c= l \u0026\u0026 r \u003c= q_r) { v -\u003e sum += val; return; } int mid = (l + r) \u003e\u003e 1; if (v -\u003e l == NULL) v -\u003e l = new Node(); if (v -\u003e r == NULL) v -\u003e r = new Node(); add(v -\u003e l, l, mid, q_l, q_r, val); add(v -\u003e r, mid + 1, r, q_l, q_r, val); } ll get(Node *v, int l, int r, int pos) { if (!v || l \u003e r || pos \u003c l || pos \u003e r) return 0; if (l == r) return v -\u003e sum; int mid = (l + r) \u003e\u003e 1; return v -\u003e sum + get(v -\u003e l, l, mid, pos) + get(v -\u003e r, mid + 1, r, pos); } int n, m, t, x, y, val; char c; int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); Node *root = new Node(); scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026x); add(root, 0, n - 1, i, i, x); } scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"\\n%c\", \u0026c); if (c == 'a') { scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026val); add(root, 0, n - 1, --x, --y, val); } else { scanf(\"%d\", \u0026x); printf(\"%I64d \", get(root, 0, n - 1, --x)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:5","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#隐式的线段树"},{"categories":["C++","数据结构","算法"],"content":" 最小队列 时间复杂度：$O(1)$ https://informatics.msk.ru//mod/statements/view.php?chapterid=756 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 205000; int n, m; deque \u003c pair \u003cint, int\u003e \u003e d; int a[MAXN]; void enqueue(int x) { int num = 1; while (!d.empty() \u0026\u0026 d.back().first \u003e x) { num += d.back().second; d.pop_back(); } d.push_back(make_pair(x, num)); } void dequeue() { if (d.front().second == 1) { d.pop_front(); } else { d.front().second--; } } int getMin() { return d.front().first; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); for (int i = 1; i \u003c= m; i++) { enqueue(a[i]); } printf(\"%d\\n\", getMin()); for (int i = m + 1; i \u003c= n; i++) { dequeue(); enqueue(a[i]); printf(\"%d\\n\", getMin()); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:6","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最小队列"},{"categories":["C++","数据结构","算法"],"content":" 线段树（加法-最小间隔-最大间隔）https://codeforces.com/contest/1263/problem/E #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 1000 * 1000 + 100; const int INF = (int) 1e9; struct node { int mx, mn; int add; }; int n; int val[MAXN]; string s; int pos; node tree[4 * MAXN]; void add(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; if (L == l \u0026\u0026 R == r) { tree[v].add += val; } else { int mid = L + (R - L) / 2; add(2 * v + 1, L, mid, l, min(mid, r), val); add(2 * v + 2, mid + 1, R, max(mid + 1, l), r, val); tree[v].mx = max(tree[2 * v + 1].mx + tree[2 * v + 1].add, tree[2 * v + 2].mx + tree[2 * v + 2].add); tree[v].mn = min(tree[2 * v + 1].mn + tree[2 * v + 1].add, tree[2 * v + 2].mn + tree[2 * v + 2].add); } } int getMin(int v, int L, int R, int l, int r) { if (l \u003e r) { return INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mn + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + min(getMin(2 * v + 1, L, mid, l, min(mid, r)), getMin(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int getMax(int v, int L, int R, int l, int r) { if (l \u003e r) { return -INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mx + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + max(getMax(2 * v + 1, L, mid, l, min(mid, r)), getMax(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\\n\", \u0026n); getline(cin, s); pos = 0; for (int i = 0; i \u003c (int) s.length(); i++) { if (s[i] == 'L') { if (pos \u003e 0) pos--; } else if (s[i] == 'R') { pos++; } else { int newVal = 0; if (s[i] == '(') { newVal = 1; } else if (s[i] == ')') { newVal = -1; } int delta = newVal - val[pos]; val[pos] = newVal; add(0, 0, n - 1, pos, n - 1, delta); } int mn = getMin(0, 0, n - 1, 0, n - ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:7","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树加法-最小间隔-最大间隔"},{"categories":["C++","数据结构","算法"],"content":" 线段树（分配-求和）https://codeforces.com/gym/100093 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int zero = -1; struct node { long long sum; int val; int size; }; int n, m; char qt; int x, l, r; int a[MAXN]; vector \u003cnode\u003e tree; void build (int v, int L, int R, int a[]) { if (L == R) { tree[v].sum = tree[v].val = a[L]; tree[v].size = 1; } else { int mid = L + (R - L) / 2; build(2 * v, L, mid, a); build(2 * v + 1, mid + 1, R, a); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; tree[v].val = zero; tree[v].size = tree[2 * v + 1].size + tree[2 * v].size; } } void push(int v) { if (tree[v].val == zero) return; if (tree[v].size != 1) { tree[2 * v].val = tree[v].val; tree[2 * v + 1].val = tree[v].val; } tree[v].sum = 1ll * tree[v].size * tree[v].val; tree[v].val = zero; } void assign(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; push(v); if (L == l \u0026\u0026 R == r) { tree[v].val = val; tree[v].sum = 1ll * val * tree[v].size; } else { int mid = L + (R - L) / 2; assign(2 * v, L, mid, l, min(mid, r), val); assign(2 * v + 1, mid + 1, R, max(mid + 1, l), r, val); push(2 * v); push(2 * v + 1); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; } push(v); } long long getsum(int v, int L, int R, int l, int r) { if (l \u003e r) return 0; push(v); if (l == L \u0026\u0026 r == R) return tree[v].sum; int mid = L + (R - L) / 2; long long res = getsum(2 * v, L, mid, l, min(mid, r)) + getsum(2 * v + 1, mid + 1, R, max(l, mid + 1), r); return res; } int main() { assert(freopen(\"sum.in\",\"r\",stdin)); assert(freopen(\"sum.out\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026m); tree.resize(4 * n); build(1, 1, n, a); for (int i = 1; i \u003c= m; i++) { scanf(\"%c\", \u0026qt); if (qt == 'A') { scanf(\"%d %d %d\\n\", \u0026l, \u0026r, \u0026x); assign(1, 1, n, l, r, x); } else { scanf(\"%d %d\\n\"","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:8","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树分配-求和"},{"categories":["C++","数据结构","算法"],"content":" 线段树（最小值-值更新） 预先计算：$O(N \\log N)$ 查询：$O(1)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = (int) 1e9; int n, num, qn; int a[MAXN]; int tree[4 * MAXN]; int l, r; int getMax(int l, int r) { l = num + l - 1; r = num + r - 1; int res = -INF; while (l \u003c= r) { if (l \u0026 1) { res = max(res, tree[l]); l++; } if (r % 2 == 0) { res = max(res, tree[r]); r--; } l /= 2; r /= 2; } return res; } void update(int pos, int val) { pos = num + pos - 1; tree[pos] = val; pos /= 2; while (pos \u003e= 1) { tree[pos] = max(tree[pos * 2], tree[pos * 2 + 1]); pos /= 2; } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); num = 1; while (num \u003c n) num *= 2; for (int i = num; i \u003c 2 * num; i++) { if (i - num + 1 \u003c= n) tree[i] = a[i - num + 1]; else tree[i] = -INF; } for (int i = num - 1; i \u003e= 1; i--) { tree[i] = max(tree[i * 2], tree[i * 2 + 1]); } scanf(\"%d\", \u0026qn); for (int i = 1; i \u003c= qn; i++) { scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:9","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树最小值-值更新"},{"categories":["C++","数据结构","算法"],"content":" 稀疏表 预先计算：$O(N)$ 查询：$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 2 * 105000; const int MAXLOG = 20; int n, m; int a[MAXN]; int table[MAXLOG][MAXN]; int numlog[MAXN]; void buildTable() { numlog[1] = 0; for (int i = 2; i \u003c= n; i++) numlog[i] = numlog[i / 2] + 1; for (int i = 0; i \u003c= numlog[n]; i++) { int curlen = 1 \u003c\u003c i; for (int j = 1; j \u003c= n; j++) { if (i == 0) { table[i][j] = a[j]; continue; } table[i][j] = max(table[i - 1][j], table[i - 1][j + curlen / 2]); } } } int getMax(int l, int r) { int curlog = numlog[r - l + 1]; return max(table[curlog][l], table[curlog][r - (1 \u003c\u003c curlog) + 1]); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); buildTable(); scanf(\"%d\", \u0026m); for (int i = 1; i \u003c= m; i++) { int l, r; scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:10","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#稀疏表"},{"categories":["C++","数据结构","算法"],"content":" 几何","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#几何"},{"categories":["C++","数据结构","算法"],"content":" 最近点对 时间复杂度：$O(N \\log N)$ https://www.spoj.com/problems/CLOPPAIR/ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; #define sqr(x) ((x) * (x)) const double inf = 1e100; const int MAXN = 105000; struct point { double x, y; int ind; }; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } int n; int a[MAXN]; point p[MAXN], tmp[MAXN]; double ans = inf; int p1, p2; void updateAnswer(point a, point b) { double d = dist(a, b); if (d \u003c ans) { ans = d; p1 = a.ind; p2 = b.ind; } } void closestPair(int l, int r) { if (l \u003e= r) return; if (r - l == 1) { if (p[l].y \u003e p[r].y) swap(p[l], p[r]); updateAnswer(p[l], p[r]); return; } int m = (l + r) / 2; double mx = p[m].x; closestPair(l, m); closestPair(m + 1, r); int lp = l, rp = m + 1, sz = 1; while (lp \u003c= m || rp \u003c= r) { if (lp \u003e m || ((rp \u003c= r \u0026\u0026 p[rp].y \u003c p[lp].y))) { tmp[sz] = p[rp]; rp++; } else { tmp[sz] = p[lp]; lp++; } sz++; } for (int i = l; i \u003c= r; i++) p[i] = tmp[i - l + 1]; sz = 0; for (int i = l; i \u003c= r; i++) if (abs(p[i].x - mx) \u003c ans) { sz++; tmp[sz] = p[i]; } for (int i = 1; i \u003c= sz; i++) { for (int j = i - 1; j \u003e= 1; j--) { if (tmp[i].y - tmp[j].y \u003e= ans) break; updateAnswer(tmp[i], tmp[j]); } } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%lf %lf\", \u0026p[i].x, \u0026p[i].y); p[i].ind = i - 1; } sort(p + 1, p + n + 1, cmp); closestPair(1, n); printf(\"%d %d %.6lf\\n\", min(p1, p2), max(p1, p2), ans); return 0; } #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ccmath\u003e using namespace std; #define sqr(a) ((a)*(a)) const double inf = 1e100; const int MAXN = 55000; stru","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最近点对"},{"categories":["C++","数据结构","算法"],"content":" 凸包Graham-Andrew 方法 时间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view3.php?chapterid=638 https://informatics.msk.ru/mod/statements/view3.php?id=\u0026chapterid=290 #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003ccmath\u003e using namespace std; #define sqr(x) ((x) * (x)) const double pi = acos(-1.0); struct point { double x, y; }; int n; vector \u003cpoint\u003e p, hull; double ans; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } bool eq(point a, point b) { return (a.x == b.x \u0026\u0026 a.y == b.y); } bool isCCW(point a, point b, point c) { return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) \u003e 0; } void setConvexHull(vector \u003cpoint\u003e p, vector \u003cpoint\u003e \u0026h) { sort(p.begin(), p.end(), cmp); p.erase(unique(p.begin(), p.end(), eq), p.end()); vector \u003cpoint\u003e up, down; point head = p[0], tail = p.back(); up.push_back(head); down.push_back(head); for (int i = 1; i \u003c (int) p.size(); i++) { if (i == (int) p.size() - 1 || !isCCW(tail, head, p[i])) { while ( (int) up.size() \u003e= 2 \u0026\u0026 isCCW(up[up.size() - 2], up.back(), p[i]) ) up.pop_back(); up.push_back(p[i]); } if (i == (int) p.size() - 1 || isCCW(tail, head, p[i])) { while ( (int) down.size() \u003e= 2 \u0026\u0026 !isCCW(down[down.size() - 2], down.back(), p[i]) ) down.pop_back(); down.push_back(p[i]); } } h.clear(); for (int i = 0; i \u003c (int) up.size(); i++) h.push_back(up[i]); for (int i = (int) down.size() - 2; i \u003e 0; i--) h.push_back(down[i]); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } double getPerimeter(vector \u003cpoint\u003e p) { double per = 0; for (int i = 1; i \u003c (int) p.size(); i++) per += dist(p[i - 1], p[i]); per += dist(p.back(), p[0]); return per; } int main() { freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { point tmp; scanf(\"%lf %lf\", \u0026tmp.x, \u0026tmp.y); p.push_back(tmp); } setConvexHull(p, hull); ans = getPerimeter(hull); printf(\"%.1lf\", ans); return 0; } 时间复杂度：$O(sort) + O(N)$ #include \u003ccstd","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#凸包"},{"categories":["C++","数据结构","算法"],"content":" 图","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#图"},{"categories":["C++","数据结构","算法"],"content":" Bellman-Ford 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view3.php?id=260\u0026chapterid=178 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105; const int INF = 30000; struct edge { int from, to; int w; }; int n, m; int dist[MAXN]; vector \u003cedge\u003e e; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { edge curEdge; scanf(\"%d %d %d\", \u0026curEdge.from, \u0026curEdge.to, \u0026curEdge.w); e.push_back(curEdge); } for (int i = 1; i \u003c= n; i++) dist[i] = INF; dist[1] = 0; for (int i = 1; i \u003c= n; i++) { bool changed = false; for (int j = 0; j \u003c m; j++) { int from = e[j].from, to = e[j].to, w = e[j].w; if (dist[from] != INF \u0026\u0026 dist[from] + w \u003c dist[to]) { dist[to] = dist[from] + w; changed = true; } } if (!changed) break; } for (int i = 1; i \u003c= n; i++) printf(\"%d \", dist[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#bellman-ford-算法"},{"categories":["C++","数据结构","算法"],"content":" 二部图匹配Kuhn 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=1683 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105; int n, m; vector \u003cint\u003e g[MAXN]; bool used[MAXN]; int mt[MAXN]; int ans; bool kuhn(int v) { if (used[v]) return false; used[v] = true; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (mt[to] == 0 || kuhn(mt[to])) { mt[to] = v; return true; } } return false; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int can; scanf(\"%d\", \u0026can); if (can) g[i].push_back(j); } } for (int i = 1; i \u003c= n; i++) { memset(used, 0, sizeof(used)); if (kuhn(i)) ans++; } printf(\"%d\\n\", ans); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#二部图匹配"},{"categories":["C++","数据结构","算法"],"content":" 桥搜索 时间复杂度：$O(M)$ https://codeforces.com/gym/100083 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; vector \u003cint\u003e g[MAXN]; vector \u003cint\u003e ind[MAXN]; int tin[MAXN], mn[MAXN]; bool used[MAXN]; vector \u003cint\u003e bridges; int timer; void dfs(int v, int par = -1) { used[v] = true; timer++; tin[v] = timer; mn[v] = tin[v]; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { dfs(to, v); if (mn[to] == tin[to]) { bridges.push_back(ind[v][i]); } mn[v] = min(mn[v], mn[to]); } else if (to != par) { mn[v] = min(mn[v], mn[to]); } } } int main() { assert(freopen(\"bridges.in\",\"r\",stdin)); assert(freopen(\"bridges.out\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { int from, to; scanf(\"%d %d\", \u0026from, \u0026to); g[from].push_back(to); ind[from].push_back(i); g[to].push_back(from); ind[to].push_back(i); } for (int i = 1; i \u003c= n; i++) if (!used[i]) dfs(i); sort(bridges.begin(), bridges.end()); printf(\"%d\\n\", (int) bridges.size()); for (int i = 0; i \u003c (int) bridges.size(); i++) printf(\"%d\\n\", bridges[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#桥搜索"},{"categories":["C++","数据结构","算法"],"content":" 拓扑排序 #include\u003ciostream\u003e using namespace std; int n = 100; int f[100]={0}, ans[100]={0}; bool g[100][100]={0} ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#拓扑排序"},{"categories":["C++","数据结构","算法"],"content":" 参考资料 ADJA/algos: Competitive programming algorithms in C++ - GitHub ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:6:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#参考资料"},{"categories":[],"content":" 快捷键 Tab 补全命令 Ctrl + C 停止当前运行中的程序 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#快捷键"},{"categories":[],"content":" cp","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#cp"},{"categories":[],"content":" ls显示目录内容。 # 指定目录，默认当前目录 ls \u003cpath\u003e # 列出详细信息 # 权限、用户、用户组、大小、修改时间、名称 ls -l # 文件大小显示更直观 ls -lh # 列出所有文件（包括隐藏） ls -a ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ls"},{"categories":[],"content":" 排序 # 按修改时间从近到远排序 ls -t # 按文件大小从大到小排序 ls -S # 逆序排序 ls -r ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:1","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#排序"},{"categories":[],"content":" 打印方式 # 纵向显示（一行一个） ls -1 # 横向显示（逗号分隔） ls -m ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:2","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#打印方式"},{"categories":[],"content":" 文件权限drwxrwxrwx 第1位，d，文件类型。 d：目录。 -：一般文件。 第2-4位，rwx，文件创建者的权限。 第5-7位，rwx，文件创建者同用户组成员的权限。 第8-10位，rwx，其他成员的权限。 rwx r，读取权限。二进制为100，十进制即4。 w，写入权限。二进制为010，十进制即2。 x，执行权限。二进制为001，十进制即1。 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:3","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#文件权限"},{"categories":[],"content":" mv","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#mv"},{"categories":[],"content":" scp在本地主机和远程主机之间传输文件。 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#scp"},{"categories":[],"content":" 本地主机的文件上传到远程主机 # 单个文件 scp \u003cfile\u003e \u003cuser\u003e@\u003cip\u003e:\u003cpath\u003e -P \u003cssh_port\u003e # 目录 scp -r \u003cfolder\u003e \u003cuser\u003e@\u003cip\u003e:\u003cpath\u003e -P \u003cssh_port\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:1","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#本地主机的文件上传到远程主机"},{"categories":[],"content":" 远程主机的文件下载到本地主机 # 单个文件 scp \u003cuser\u003e@\u003cip\u003e:\u003cfile\u003e \u003cpath\u003e -P \u003cssh_port\u003e # 目录 scp -r \u003cuser\u003e@\u003cip\u003e:\u003cfolder\u003e \u003cpath\u003e -P \u003cssh_port\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:2","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#远程主机的文件下载到本地主机"},{"categories":[],"content":" ssh远程登录。 # 默认端口 22 ssh \u003cuser\u003e@\u003cip\u003e # 指定端口 ssh \u003cuser\u003e@\u003cip\u003e -p \u003cport\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ssh"},{"categories":[],"content":" ssh 免密登录 # 为当前用户生成 ssh 公钥 + 私钥。 # 默认保存在 $home/.ssh/ 文件夹中。 # id_rsa 是私钥，id_rsa.pub 是公钥。 ssh-keygen # 将当前用户的公钥复制到服务器的 ~/.ssh/authorized_keys 文件 ssh-copy-id \u003cuser\u003e@\u003cip\u003e:\u003cport\u003e # 或者手动将公钥添加到服务器的 ~/.ssh/authorized_keys 文件 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:1","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ssh-免密登录"},{"categories":[],"content":" 常用 whoami man \u003ccommand\u003e clear clear -x Ctrl + L pwd ls ls -l ls -a ls -al cd cd .. cd ~ mkdir mkdir -p `` ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:7:0","series":null,"tags":[],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#常用"},{"categories":["LaTeX","Cheatsheet"],"content":"标量 - 斜体小写 - $a$ 向量 - 粗体小写 - $a$ 矩阵 - 粗体大写 - $A$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:0:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#"},{"categories":["LaTeX","Cheatsheet"],"content":" 希腊字母 大写字母 代码 小写字母 代码 变量形式 代码 $\\alpha$ \\alpha $\\beta$ \\beta $\\Gamma$ \\Gamma $\\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $\\epsilon$ \\epsilon $\\Theta$ \\Theta $\\theta$ \\theta $\\Lambda$ \\Lambda $\\lambda$ \\lambda $\\mu$ \\mu $\\Pi$ \\Pi $\\pi$ \\pi $\\rho$ \\rho $\\Sigma$ \\Sigma $\\sigma$ \\sigma $\\Phi$ \\Phi $\\phi$ \\phi $\\varphi$ \\varphi $\\Psi$ \\Psi $\\psi$ \\psi $\\Omega$ \\Omega $\\omega$ \\omega ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:1:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#希腊字母"},{"categories":["LaTeX","Cheatsheet"],"content":" 字体$\\mathcal{L}、\\mathbf{L}、\\mathbb{L}、\\ell、\\mathrm{L}、\\mathsf{L}、\\mathtt{L}、\\mathit{L}、\\mathfrak{L}、\\mathscr{L}$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:2:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#字体"},{"categories":["LaTeX","Cheatsheet"],"content":" 特殊符号 符号 代码 解释 $\\partial$ \\partial 偏导数 $\\nabla$ \\nabla 梯度 $\\ell$ \\ell $\\Complex$ \\Complex \\cnums 复数集 $\\R$ \\Reals \\reals \\R 实数集 $\\Z$ \\Z 整数集 $\\natnums$ \\natnums \\N 自然数集 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:3:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#特殊符号"},{"categories":["LaTeX","Cheatsheet"],"content":" 垂直布局 符号 代码 解释 $x_n$ x_n 下标 $e^x$ e^x 上标 $_u^o$ _u^o 上下标 $\\overset{N}{\\sum}$ \\overset{N}{\\sum} 正上标 $\\underset{i=1}{\\sum}$ \\underset{i=1}{\\sum} 正下标 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:4:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#垂直布局"},{"categories":["LaTeX","Cheatsheet"],"content":" 逻辑符与集合论 符号 代码 解释 $\\forall$ \\forall 所有 $\\exist$ \\exists \\exist 存在 $\\in$ \\in \\isin 属于 $\\notin$ \\notin 不属于 $\\subset$ \\subset 包含于 $\\supset$ \\supset 包含 $\\emptyset$ \\emptyset \\empty 空集 $\\varnothing$ \\varnothing 空集 $\\implies$ \\implies 充分 $\\impliedby$ \\impliedby 必要 $\\iff$ \\iff 充分必要 $\\neg$ \\neg \\lnot 非 $\\lor$ \\lor 或 $\\land$ \\land 与 $\\because$ \\because 因为 $\\therefore$ \\therefore 所以 $\\ne$ \\ne \\neq 不等于 $\\approx$ \\approx 约等于 $\\coloneqq$ \\coloneqq 赋值 $\\gt$ \\gt 大于 $\\ge$ \\ge \\geq 大于等于 $\\lt$ \\lt 小于 $\\le$ \\le \\leq 小于等于 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:5:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#逻辑符与集合论"},{"categories":["LaTeX","Cheatsheet"],"content":" 多元运算符 符号 代码 解释 $\\sum$ \\sum 累加 $\\prod$ \\prod 累乘 $\\bigcap$ \\bigcap 累交 $\\bigcup$ \\bigcup 类并 $\\int$ \\int 一重积分 $\\iint$ \\iint 二重积分 $\\iiint$ \\iiint 三重积分 $\\oint$ \\oint 一重环路积分 $\\oiint$ \\oiint 二重环路积分 $\\oiiint$ \\oiiint 三重环路积分 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:6:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#多元运算符"},{"categories":["LaTeX","Cheatsheet"],"content":" 二元运算符 符号 代码 解释 $\\bmod$ \\bmod $x \\pmod a$ x \\pmod a $\\div$ \\div $\\pm$ \\pm \\plusmn $\\oplus$ \\oplus $\\otimes$ \\otimes $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:7:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#二元运算符"},{"categories":["LaTeX","Cheatsheet"],"content":" 常用数学符号 符号 代码 解释 $\\lim$ \\lim $\\ln$ \\ln $\\log$ \\log $\\exp$ \\exp $\\max$ \\max $\\min$ \\min $\\argmax$ \\argmax $\\argmin$ \\argmin $\\sin$ \\sin $\\cos$ \\cos $\\tan$ \\tan $\\sqrt{x}$ \\sqrt{x} 平方根 $\\sqrt[3]{x}$ \\sqrt[3]{x} 三次方根 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:8:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#常用数学符号"},{"categories":["LaTeX","Cheatsheet"],"content":" 矩阵","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:9:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#矩阵"},{"categories":["LaTeX","Cheatsheet"],"content":" 一行多个公式$$ \\begin{align} x\u0026=t \u0026 x\u0026=\\cos t \u0026 x\u0026=t \\notag y\u0026=2t \u0026 y\u0026=\\sin(t+1) \u0026 y\u0026=\\sin t \\end{align} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#一行多个公式"},{"categories":["LaTeX","Cheatsheet"],"content":" 大括号多行公式$$ f(x)=\\begin{cases} 2x+1, \u0026 \\text{if} \u0026 x \\lt 0; \\ 0, \u0026 \\text{if} \u0026 x = 0; \\ x^2-1, \u0026 \\text{if} \u0026 x \\gt 0. \\end{cases} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:11:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#大括号多行公式"},{"categories":["LaTeX","Cheatsheet"],"content":" 参考 Supported Functions - KaTeX ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:12:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#参考"},{"categories":null,"content":" 1.基础","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1基础"},{"categories":null,"content":" 1.1 存储结构 数组： 数据连续存储 支持随机访问，通过索引快速找到对应元素，时间复杂度 $O(1)$ 数组满时需要扩容，重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 $O(n)$ 在数组中间进行插入和删除时需要对后面的所有数据进行移位，平均时间复杂度 $O(n)$ 链表： 数据不连续存储，而是靠指针指向其他元素的位置 不支持随机访问，平均时间复杂度 $O(n)$ 无需扩容 插入和删除时无需移位，时间复杂度 $O(1)$（前驱结点已知），$O(n)$（前驱结点未知） 指针域会占用储存空间，降低空间利用率 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:1","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#11-存储结构"},{"categories":null,"content":" 1.2 逻辑结构 栈（stack）：后进先出（LIFO）。 队列（queue）：先进先出（FIFO）。 树（tree）：子结点也是一棵树，子结点之间相互独立。 图（graph）：任意两个结点间可以连接。 每种逻辑结构均可使用不同存储结构实现，一般具体情况进行选择。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:2","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#12-逻辑结构"},{"categories":null,"content":" 1.3 复杂度 常见时间复杂度：$O(1)$、$O(\\log n)$、$O(n)$、$O(n\\log n)$、$O(n^2)$、$O(n^3)$ 常见空间复杂度：$O(1)$、$O(n)$、$O(n^2)$、$O(n^3)$ 复杂度一般去掉常数项，并将系数置为1，$O$ 表示上界。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:3","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#13-复杂度"},{"categories":null,"content":" 1.4 可视化 数据结构和算法动态可视化 Data Structure Visualizations ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:4","series":null,"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#14-可视化"},{"categories":null,"content":"谷歌三件套包括 Google Play 商店（Google Play Store）、Google Play 服务（Google Play Services）和Google 服务框架（Google Services Framework），只有正确安装了这三件套才能访问 Google Play 商店和使用需要 Google Play 服务的 APP。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#"},{"categories":null,"content":" 安装","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#安装"},{"categories":null,"content":" 一键安装","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#一键安装"},{"categories":null,"content":" 手动安装 访问 APKMirror。 搜索Google Services Framework，根据安卓版本选择对应的版本下载并安装。（示例：Google Services Framework 10） 搜索Google Play Services，选择最新版并进入，选择arm64-v8a + armeabi-v7a、对应的安卓版本、nodpi，下载并安装。 搜索Google Play Store，选择最新版下载并安装。 若三件套都安装完，并且正确科学上网后还是打不开Google Play 商店，尝试下载旧版本Google Play Services安装。 不推荐使用beta版本。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#手动安装"},{"categories":null,"content":" Google Play Services 版本号版本号示例：20.50.66 (100400-351698872)，其中100400说明： 第 1、2 位表示安卓版本 00 - Android 4.1 02 - Android 5.0 04 - Android 6.0 05 - Wear OS 08 - Android TV 10 - Android 9.0 12 - Android 10 15 - Android 11 第 3、4 位表示CPU架构 03 - armeabi-v7a 04 - armeabi-v7a + arm64-v8a 07 - x86 08 - x86 + x86_64 第 5、6 位表示屏幕 DPI 00 - nodpi 02 - 160dpi 04 - 240dpi 06 - 320dpi 08 - 480dpi 则100400指Android 9.0、arm64-v8a和nodpi。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#google-play-services-版本号"},{"categories":["Java"],"content":" 0 名词解释 JVM：Java Virtual Machine，Java 虚拟机。 JRE：Java Runtime Environment，Java 运行环境，包含 JVM 和 Java 核心类库。 JDK：Java Development Kit，Java 开发工具包，包含 JRE，编译工具和运行工具。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#0-名词解释"},{"categories":["Java"],"content":" 1 准备","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#1-准备"},{"categories":["Java"],"content":" 1.1 JDK 下载 Oracle JDK Oracle OpenJDK Windows 可通过 Chocolatey 安装。 MacOS 可通过 Homebrew 安装。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#11-jdk-下载"},{"categories":["Java"],"content":" 1.2 环境变量配置Windows： 设置→系统→关于→高级系统设置→环境变量。 在下方的系统变量中找到Path，点击编辑。 点击新建，将JDK的路径下的bin目录粘贴进去。（示例：C:\\Users\\backs\\Downloads\\jdk-11.0.10\\bin\\） 连续点击确定，保存退出。 打开cmd，输入java -version，若有如下所示输出即为配置成功。 java version \"11.0.10\" 2021-01-19 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.10+8-LTS-162) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.10+8-LTS-162, mixed mode) 在任意位置创建 test.java，写入以下内容。 public class test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 在该文件夹下打开命令行，输入以下内容，输出应该为 Hello World!。 javac test.java java test ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#12-环境变量配置"},{"categories":["Java"],"content":" 1.3 IDE Download IntelliJ IDEA: 最好用，Community版免费，Ultimate版收费，学生可白嫖，推荐。 psvm public static void main(String[] args) {} sout System.out.println(); arr.fori for (int i = 0; i \u003c arr.length; i++) {} arr.forr for (int i = arr.length - 1; i \u003e= 0; i--) {} alt + 1 开/关左侧目录结构 alt + 4 开/关底部控制台 ctrl + alt + L 格式化代码 ctrl + / 单行注释 ctrl + shift + / 多行注释 shift + alt + ↑ 上移 shift + alt + ↓ 下移 ctrl + x 剪切当前行 ctrl + d 下方复制当前行 shift + enter 下方新建空行 ctrl + alt + enter 上方新建空行 ctrl + alt + v 自动定义变量来接收当前值 ctrl + alt + m 将选中代码生成独立方法 Eclipse: 开源，免费。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#13-ide-download"},{"categories":["Java"],"content":" 2 基础语法","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2-基础语法"},{"categories":["Java"],"content":" 2.1 注释 // 单行注释 /* 多行注释 */ /** 文档注释 */ ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#21-注释"},{"categories":["Java"],"content":" 2.2 常量 字符串常量：\"helloworld\"，\"程序员\" 整数常量：12，-3 浮点数常量：1.2，-3.4 字符常量：'a'，'\\n'，'我' 布尔常量：true，false 空常量：null ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#22-常量"},{"categories":["Java"],"content":" 2.3 数据类型 数据类型 关键字 内存占用（字节） 取值范围 整数 byte 1 -128~127 short 2 -32,768~32,767 int 4 -2,147,483,648~2,147,483,647 long 8 $$-2^{63} \\sim 2^{63} - 1$$ 浮点数 float 4 小数点后6位 double 8 小数点后15位 字符 char 2 0~65,535 布尔 boolean 1 true,false ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#23-数据类型"},{"categories":["Java"],"content":" 2.4 变量定义和使用 float a = 3.14F; // float b = 3.14f; long c = 100L; // long d = 100l; ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#24-变量定义和使用"},{"categories":["Java"],"content":" 2.5 读取输入 import java.util.Scanner; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); String s1 = sc.nextLine(); // 遇到换行结束，接收换行符，并丢弃。 String s2 = sc.next(); // 遇到空格或换行结束，不接收。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#25-读取输入"},{"categories":["Java"],"content":" 2.6 标识符定义必须： 由数字、字母、下划线、美元符号组成 不能以数字开头 不能是关键字 区分大小写 建议： 小驼峰命名法：backTraxe，常用于定义方法、变量。 大驼峰命名法：BackTraxe，常用于定义类。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#26-标识符定义"},{"categories":["Java"],"content":" 2.7 类型转换 隐式转换 占用空间小的数据类型会先转换为占用空间大的数据类型，然后进行运算。 byte、short和char三种数据类型在运算时会转换为int，然后进行运算。 byte a = 1, b = 2; // 错误 byte c = a + b; // 正确 int d = a + b; 显式（强制）转换 有可能产生精度损失。 byte a = 1, b = 2; byte e = (byte) (a + b); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#27-类型转换"},{"categories":["Java"],"content":" 2.8 运算符 单目算术运算符：自增++、自减-- 只能作用于变量。 int a = 1; int b = a++; // a = 2, b = 1 int c = ++a; // a = 3, c = 3 int d = a--; // a = 2, d = 3 int e = --a; // a = 1, e = 1 双目算术运算符：加+、减-、乘*、除/、取余% 加+：出现字符串则为连接运算符，否则为算术运算。从左到右执行。 System.out.println(1 + 2); // 3 System.out.println(2 + 1); // 3 System.out.println(1 + 'a'); // 98 System.out.println('a' + 2); // 99 System.out.println(1 + \"abc\"); // 1abc System.out.println(\"abc\" + 2); // abc2 System.out.println(true + \"abc\"); // trueabc System.out.println(\"abc\" + true); // abctrue System.out.println(\"abc\" + 1 + 2); // abc12 System.out.println(1 + 2 + \"abc\"); // 3abc System.out.println(1 + \"\" + 2 + \"abc\"); // 12abc 除/：整数除整数得整数。 System.out.println(10 / 3); // 3 System.out.println(10 / 3.0); // 3.3333333333333335 System.out.println(10.0 / 3); // 3.3333333333333335 赋值运算符：赋值=、加后赋值+=、减后赋值-=、乘后赋值*=、除后赋值/=、取余后赋值%= a 操作符= b等价于a = (a的类型) (a 操作符 (b))，隐含了强制类型转换，从右往左运算。 int a = 10; a /= 2 + 3; // 2 等价于 a = a / (2 + 3) short b = 1; b = b + 1; // 报错 b += 1; // 2 等价于 b = (short) (b + 1) 比较运算符：相等==、不等!=、大于\u003e、大于等于\u003e=、小于\u003c、小于等于\u003c= // 基本数据类型比较值 int a = 1, b = 1; System.out.println(a == b); // true // 引用数据类型比较地址 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); System.out.println(s1 == s2); // false System.out.println(s1.equals(s2)); // true 逻辑运算符：与\u0026,\u0026\u0026、或|,||、非!、异或^ int a = 1, b = 1; // 非短路与 \u0026，每个条件都进行判断 a \u003e 2 \u0026 b++ \u003e 0; // false, a = 1, b = 2 // 短路与 \u0026\u0026，当某个条件为 false 时，后面不再进行判断 a \u003e 2 \u0026\u0026 b++ \u003e 0; // false, a = 1, b = 1 // 非短路或 |，每个条件都进行判断 a \u003e 0 | b++ \u003e 0; // true, a = 1, b = 2 // 短路或 ||，当某个条件为 true 时，后面不再进行判断 a \u003e 0 || b++ \u003e 0; // true, a = 1, b = 1 位运算符：与\u0026、或|、非~、异或^、左移\u003c\u003c、右移\u003e\u003e、无符号右移\u003e\u003e\u003e a ^ a == 0 a ^ 0 == a a \u003c\u003c 1 == a * 2 三目运算符：a ? b : c // 等价于 if (a) { b; } else { c; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#28-运算符"},{"categories":["Java"],"content":" 2.9 分支语句 if (A) { B; } if (A) { B; } else { C; } if (A) { B; } else if (C) { D; } else { E; } // case 表达式不能重复，且不能为变量。 String rank = \"First\"; switch (rank) { case \"First\": System.out.println(\"第一\"); break; case \"Second\": case \"Third\": System.out.println(\"前三\"); break; default: System.out.println(\"再接再厉\"); break; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:9","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#29-分支语句"},{"categories":["Java"],"content":" 2.10 循环语句 for (初始化语句; 继续循环条件判断语句; 每轮循环后执行语句) { 循环体; } while (继续循环条件判断语句) { 循环体; } // 至少执行一次 do { 循环体; } while (继续循环条件判断语句); 跳转控制语句 continue：中断本次循环，直接开始下一次循环。 break：退出循环。 // 中断多重循环 outer: for (int i = 0; i \u003c 10; i++) { for (int j = 0; j \u003c 10; j++) { if (i == 5 \u0026\u0026 j == 7) { System.out.println(i + \"\\n\" + j); break outer; } } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:10","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#210-循环语句"},{"categories":["Java"],"content":" 2.11 格式化输出 System.out.print(); System.out.printf(); System.out.println(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:11","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#211-格式化输出"},{"categories":["Java"],"content":" 2.12 随机数生成 import java.util.Random; Random r = new Random(); int a = r.nextInt(10); // [0, 10) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:12","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#212-随机数生成"},{"categories":["Java"],"content":" 2.13 数组 // 动态初始化。不指定元素，指定长度。默认初始化为 0 int[] arr1 = new int[3]; int[][] arr2 = new int[2][3]; // 静态初始化。指定元素，不指定长度。 int[] arr3 = new int[]{1, 2, 3}; int[][] arr4 = new int[][]{{1, 2}, {3, 4}}; int[] arr5 = {1, 2, 3}; int[][] arr6 = {{1, 2}, {3, 4}}; // 长度 arr1.length; // 3 arr2[0].length; // 3 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:13","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#213-数组"},{"categories":["Java"],"content":" 2.14 方法 方法不能嵌套定义 方法重载（overload）：方法名相同，参数数量或者类型不同。与返回值类型无关。 // 返回匿名数组 return new int[]{1, 2}; ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:14","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#214-方法"},{"categories":["Java"],"content":" 2.15 进制 二进制：以0b, 0B开头 八进制：以0开头 十六进制：以0x, 0X开头 System.out.println(10); // 10 System.out.println(0b10); // 2 System.out.println(010); // 8 System.out.println(0x10); // 16 // 10 进制转 x 进制 public static String ten2x(int num, int x) { StringBuilder str = new StringBuilder(); while (0 != num) { str.append((char) (num % x + '0')); num /= x; } str.reverse(); return str.toString(); } // x 进制转 10 进制 public static int x2ten(String str, int x) { int res = 0; for (int i = 0; i \u003c str.length(); i++) { res = res * x + str.charAt(i) - '0'; } return res; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:15","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#215-进制"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#216-字符串"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2161-字符串构造"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2162-字符串比较"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2163-字符串遍历"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2164-子串"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2165-其他操作"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2166-字符串常量池"},{"categories":["Java"],"content":" 2.17 可变字符串 2.17.1 StringBuilder插入 StringBuilder append(X x) StringBuilder insert(int offset, X x) 修改 void setCharAt(int index, char ch) StringBuilder replace(int start, int end, String str) StringBuilder delete(int start, int end) StringBuilder deleteCharAt(int index) StringBuilder reverse() 索引查找 char charAt(int index) 值查找 int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 比较 int compareTo(StringBuilder another) 子串 CharSequence subSequence(int start, int end) String substring(int start) String substring(int start, int end) 转换 StringBuilder(String str) String toString() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:17","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#217-可变字符串"},{"categories":["Java"],"content":" 2.17 可变字符串 2.17.1 StringBuilder插入 StringBuilder append(X x) StringBuilder insert(int offset, X x) 修改 void setCharAt(int index, char ch) StringBuilder replace(int start, int end, String str) StringBuilder delete(int start, int end) StringBuilder deleteCharAt(int index) StringBuilder reverse() 索引查找 char charAt(int index) 值查找 int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 比较 int compareTo(StringBuilder another) 子串 CharSequence subSequence(int start, int end) String substring(int start) String substring(int start, int end) 转换 StringBuilder(String str) String toString() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:17","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2171-stringbuilder"},{"categories":["Java"],"content":" 2.18 复杂度分析程序耗时 long start = System.currentTimeMillis(); // 执行代码 long end = System.currentTimeMillis(); System.out.println(end - start); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:18","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#218-复杂度分析"},{"categories":["Java"],"content":" 2.19 static静态修饰符，可修饰变量和方法。 - 静态变量 1. 被所有实例化的对象共享。 2. 随类的加载而加载。 3. 不需要创建对象即可调用（使用类名）。 - 静态方法 1. 只能访问静态变量或静态方法。 2. 不能使用this。 3. 不需要创建对象即可调用（使用类名）。 public class Student { public static int age = 18; public static int getAge() { return age; } } Student.age; // 18 Student.getAge(); // 18 Student stu1 = new Student(); stu1.age; // 18 stu1.age = 20; Student stu2 = new Student(); stu2.age; // 20 Student.age; // 20 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:19","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#219-static"},{"categories":["Java"],"content":" 3 面向对象编程面向对象编程（Object Oriented Programming，OOP），是一种程序设计思想，把类作为程序的基本单元，一个类包含了变量和方法。 可以提高代码的维护性、可读性、复用性。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#3-面向对象编程"},{"categories":["Java"],"content":" 3.1 为什么要面向对象 3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#31-为什么要面向对象"},{"categories":["Java"],"content":" 3.1 为什么要面向对象 3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#311-分类思想"},{"categories":["Java"],"content":" 3.1 为什么要面向对象 3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#312-分包思想"},{"categories":["Java"],"content":" 怎样面向对象","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#怎样面向对象"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#31-类"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#311-构造方法"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#312-构造代码块"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#313-静态代码块"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#314-内部类"},{"categories":["Java"],"content":" 3.2 封装隐藏实现细节，仅对外暴露公共的访问方式。可以提高代码的安全性和复用性。 针对private修饰的成员变量，如果需要被其他类使用，需要提供getXxx()和setXxx()方法。Idea 可自动生成。 public class Student { private String name; // 类外无法访问 public String getName() { return name; } public void setName(String name) { this.name = name; } public static void main(String[] args) { Student stu = new Student(); stu.setName(\"张三\"); System.out.println(stu.getName()); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#32-封装"},{"categories":["Java"],"content":" 3.3 继承","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#33-继承"},{"categories":["Java"],"content":" 3.4 多态 子类继承父类，或者子类实现接口。 子类进行方法重写。 父类引用指向子类对象，调用父类中定义的方法，子类完成动作。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#34-多态"},{"categories":["Java"],"content":" 3.5 接口 无构造方法。 所有变量都是常量public static final。 所有方法都是抽象方法public abstract(JDK 7)。 public default方法，可以有方法体（JDK 8）。若子类实现的多个接口存在相同的default方法，则子类必须重写该方法。 public static方法，可以有方法体（JDK 8）。该方法只能通过接口名调用，不能通过子类调用。 private方法，可以有方法体（JDK 9）。仅允许接口内使用。 子类implements接口，实现接口中所有抽象方法。 子类可实现多接口。 public interface Shape { double area(); double perimeter(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#35-接口"},{"categories":["Java"],"content":" 字符串 String 转 byte 数组 // 使用平台的默认字符集 byte[] getBytes() // 指定字符集。UTF-8（中文3字节）、GBK（中文2字节）等 byte[] getBytes​(String charsetName) byte[] getBytes​(Charset charset) byte 数组转 String String​(byte[] bytes) String​(byte[] bytes, String charsetName) String​(byte[] bytes, Charset charset) String​(byte[] bytes, int offset, int length) String​(byte[] bytes, int offset, int length, String charsetName) String​(byte[] bytes, int offset, int length, Charset charset) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#字符串"},{"categories":["Java"],"content":" 常用库","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#常用库"},{"categories":["Java"],"content":" Math static double E static double PI static T abs​(T a) static T max​(T a, T b) static T min​(T a, T b) static double ceil​(double a) // 向上取整 static double floor​(double a) // 向下取整 static double exp​(double a) static double pow​(double a, double b) static double log​(double a) static double log10​(double a) static double sin​(double a) static double cos​(double a) static double tan​(double a) static double random() // [0.0, 1.0) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#math"},{"categories":["Java"],"content":" System static PrintStream err static InputStream in static PrintStream out // System.setIn​(new InputStream(\"input\")); static void setIn​(InputStream in) // System.setOut(new PrintStream(\"output\")); static void setOut​(PrintStream out) // System.exit(0); static void exit​(int status) static void gc() static long currentTimeMillis() // 毫秒 static void arraycopy​(Object src, int srcPos, Object dest, int destPos, int length) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#system"},{"categories":["Java"],"content":" Object protected Object clone() boolean equals​(Object obj) { return (this == obj); } // Deprecated protected void finalize() Class\u003c?\u003e getClass() int hashCode() void notify() void notifyAll() String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } void wait() void wait​(long timeoutMillis) void wait​(long timeoutMillis, int nanos) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#object"},{"categories":["Java"],"content":" Class String getName() boolean isArray() boolean isInstance​(Object obj) boolean isInterface() Constructor\u003cT\u003e getDeclaredConstructor​(Class\u003c?\u003e... parameterTypes) Constructor\u003c?\u003e[] getDeclaredConstructors() Field getDeclaredField​(String name) Field[] getDeclaredFields() Method getDeclaredMethod​(String name, Class\u003c?\u003e... parameterTypes) Method[] getDeclaredMethods() T newInstance() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#classt"},{"categories":["Java"],"content":" BigDecimal import java.math.BigDecimal; BigDecimal​(char[] in) BigDecimal​(char[] in, int offset, int len) BigDecimal​(double val) BigDecimal​(int val) BigDecimal​(long val) BigDecimal​(String val) // 推荐 BigDecimal​(BigInteger val) BigDecimal abs() BigDecimal max​(BigDecimal val) BigDecimal min​(BigDecimal val) BigDecimal pow​(int n) int compareTo​(BigDecimal val) boolean equals​(Object x) BigDecimal add​(BigDecimal augend) BigDecimal subtract​(BigDecimal subtrahend) BigDecimal multiply​(BigDecimal multiplicand) BigDecimal divide​(BigDecimal divisor) // RoundingMode.UP 进一法 // RoundingMode.DOWN 去尾法 // RoundingMode.HALF_UP 四舍五入 BigDecimal divide​(BigDecimal divisor, int scale, RoundingMode roundingMode) BigDecimal remainder​(BigDecimal divisor) BigDecimal[] divideAndRemainder​(BigDecimal divisor) int intValue() long longValue() double doubleValue() BigInteger toBigInteger() String toString() static BigDecimal valueOf​(double val) static BigDecimal valueOf​(long val) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bigdecimal"},{"categories":["Java"],"content":" Integer static int BYTES // 4 static int MAX_VALUE // 0x7fffffff 2147483647 static int MIN_VALUE // 0x80000000 -2147483648 static int SIZE // 32 static Class\u003cInteger\u003e TYPE // int static int compare​(int x, int y) static int compareUnsigned​(int x, int y) int compareTo​(Integer anotherInteger) static int bitCount​(int i) // 返回1的数量 static int highestOneBit​(int i) // 保留最高位1 static int lowestOneBit​(int i) // 保留最低位1 static int numberOfLeadingZeros​(int i) // 前缀0数量 static int numberOfTrailingZeros​(int i) // 后缀0数量 static int reverse​(int i) static int reverseBytes​(int i) static int parseInt​(CharSequence s, int beginIndex, int endIndex, int radix) static int parseInt​(String s) static int parseInt​(String s, int radix) static String toString​(int i) static String toString​(int i, int radix) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#integer"},{"categories":["Java"],"content":" Date \u0026 SimpleDateFormat import java.util.Date; import java.text.SimpleDateFormat; // Date 类中的方法 Date() Date​(long date) Date​(String s) long getTime() void setTime​(long time) int compareTo​(Date anotherDate) // Date 转 String Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 E HH:mm:ss\"); sdf.format(date1); // 2022年05月27日 周五 13:57:41 // String 转 Date String str = \"2022年05月27日 周五 13:57:41\"; Date date2 = sdf.parse(str); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#date--simpledateformat"},{"categories":["Java"],"content":" Calendar import java.util.Calendar; Date getTime() void setTime​(Date date) long getTimeInMillis() void setTimeInMillis​(long millis) void add​(int field, int amount) int get​(int field) void set​(int field, int value) void set​(int year, int month, int date) void set​(int year, int month, int date, int hourOfDay, int minute) void set​(int year, int month, int date, int hourOfDay, int minute, int second) void setFirstDayOfWeek​(int value) Calendar calendar = Calendar.getInstance(); calendar.get(Calendar.YEAR); // 年 calendar.get(Calendar.MONTH) + 1; // 月 calendar.get(Calendar.DAY_OF_MONTH); // 日 (calendar.get(Calendar.DAY_OF_WEEK) - 1) % 7; // 周 calendar.get(Calendar.HOUR_OF_DAY); // 时 calendar.get(Calendar.MINUTE); // 分 calendar.get(Calendar.SECOND); // 秒 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#calendar"},{"categories":["Java"],"content":" DateTimeFormatter \u0026 LocalDateTime import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 E HH:mm:ss\"); LocalDateTime time = LocalDateTime.parse(str, formatter); // LocalDateTime 类中的方法 String format​(DateTimeFormatter formatter) int getYear() int getMonthValue() // [1, 12] Month getMonth() // May int getDayOfMonth() // [1, 31] int getDayOfYear() // [1, 366] DayOfWeek getDayOfWeek() // FRIDAY int getHour() // [0, 23] int getMinute() int getSecond() int getNano() static LocalDateTime of​(int year, int month, int dayOfMonth, int hour, int minute) static LocalDateTime of​(int year, int month, int dayOfMonth, int hour, int minute, int second) static LocalDateTime parse​(CharSequence text) static LocalDateTime parse​(CharSequence text, DateTimeFormatter formatter) LocalDateTime plusYears​(long years) LocalDateTime plusMonths​(long months) LocalDateTime plusDays​(long days) LocalDateTime plusHours​(long hours) LocalDateTime plusMinutes​(long minutes) LocalDateTime plusSeconds​(long seconds) LocalDateTime plusWeeks​(long weeks) LocalDateTime minusYears​(long years) LocalDateTime minusMonths​(long months) LocalDateTime minusDays​(long days) LocalDateTime minusHours​(long hours) LocalDateTime minusMinutes​(long minutes) LocalDateTime minusSeconds​(long seconds) LocalDateTime minusWeeks​(long weeks) LocalDateTime withYear​(int year) LocalDateTime withMonth​(int month) LocalDateTime withDayOfMonth​(int dayOfMonth) LocalDateTime withHour​(int hour) LocalDateTime withMinute​(int minute) LocalDateTime withSecond​(int second) LocalDateTime withDayOfYear​(int dayOfYear) LocalDate toLocalDate() LocalTime toLocalTime() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:9","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#datetimeformatter--localdatetime"},{"categories":["Java"],"content":" Period \u0026 LocalDate startDate = LocalDate.of(2022, 2, 1); LocalDate endDate = LocalDate.of(2025, 11, 18); Period period = Period.between(startDate, endDate); period.getYears(); period.getMonths(); period.getDays(); LocalDateTime startTime = LocalDateTime.of(2022, 2, 4, 5, 18, 23); LocalDateTime endTime = LocalDateTime.of(2030, 1, 30, 17, 24, 12); Duration duration = Duration.between(startTime, endTime); duration.toSeconds(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:10","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#period-"},{"categories":["Java"],"content":" 文件","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#文件"},{"categories":["Java"],"content":" 构造方法 File​(File parent, String child) File​(String pathname) File​(String parent, String child) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#构造方法"},{"categories":["Java"],"content":" 判断路径 // 是否目录 boolean isDirectory() // 是否文件 boolean isFile() // 是否存在 boolean exists() // 是否绝对路径 boolean isAbsolute() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#判断路径"},{"categories":["Java"],"content":" 获取路径 // 文件名加后缀 String getName() // 父目录 String getParent() new File(\"demo\").getParent(); // null new File(\"folder/demo\").getParent(); // folder // 返回传入的路径 String getPath() // 绝对路径 String getAbsolutePath() // 获取路径下所有路径（包括隐藏） String[] list() // 只返回文件名 File[] listFiles() // 文件名加路径（非绝对路径） ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#获取路径"},{"categories":["Java"],"content":" 创建文件或文件夹 // 创建单个文件 boolean createNewFile() throws IOException // 创建单个文件夹 boolean mkdir() // 递归创建文件夹 boolean mkdirs() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#创建文件或文件夹"},{"categories":["Java"],"content":" 删除文件或文件夹 // 删除空目录或文件 boolean delete() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#删除文件或文件夹"},{"categories":["Java"],"content":" I/O","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#io"},{"categories":["Java"],"content":" 分类流向 输入流 输出流 类型 字节流：所有文件。 字符流：文本文件。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#分类"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#文件字节流"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#fileinputstream"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#fileoutputstream"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#实战"},{"categories":["Java"],"content":" 缓冲字节流 BufferedInputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedInputStream​(InputStream in) BufferedInputStream​(InputStream in, int size) 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } void reset() throws IOException long skip​(long n) throws IOException 关闭 void close() throws IOException BufferedOutputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out, int size) 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows void flush() throws IOException 关闭 void close() throws IOException ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#缓冲字节流"},{"categories":["Java"],"content":" 缓冲字节流 BufferedInputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedInputStream​(InputStream in) BufferedInputStream​(InputStream in, int size) 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } void reset() throws IOException long skip​(long n) throws IOException 关闭 void close() throws IOException BufferedOutputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out, int size) 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows void flush() throws IOException 关闭 void close() throws IOException ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedinputstream"},{"categories":["Java"],"content":" 缓冲字节流 BufferedInputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedInputStream​(InputStream in) BufferedInputStream​(InputStream in, int size) 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } void reset() throws IOException long skip​(long n) throws IOException 关闭 void close() throws IOException BufferedOutputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out, int size) 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows void flush() throws IOException 关闭 void close() throws IOException ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedoutputstream"},{"categories":["Java"],"content":" 对象操作流 ObjectInputStream ObjectInputStream​(InputStream in) Object readObject() ObjectOutputStream 需要对象实现java.io.Serializable接口 private static final long serialVersionUID = 1L; ObjectOutputStream​(OutputStream out) void writeObject​(Object obj) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#对象操作流"},{"categories":["Java"],"content":" 对象操作流 ObjectInputStream ObjectInputStream​(InputStream in) Object readObject() ObjectOutputStream 需要对象实现java.io.Serializable接口 private static final long serialVersionUID = 1L; ObjectOutputStream​(OutputStream out) void writeObject​(Object obj) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#objectinputstream"},{"categories":["Java"],"content":" 对象操作流 ObjectInputStream ObjectInputStream​(InputStream in) Object readObject() ObjectOutputStream 需要对象实现java.io.Serializable接口 private static final long serialVersionUID = 1L; ObjectOutputStream​(OutputStream out) void writeObject​(Object obj) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#objectoutputstream"},{"categories":["Java"],"content":" 字符流 Reader int read() int read​(char[] cbuf) int read​(char[] cbuf, int off, int len) int read​(CharBuffer target) void mark​(int readAheadLimit) boolean markSupported() long transferTo​(Writer out) long skip​(long n) void reset() void close() Writer Writer append​(char c) Writer append​(CharSequence csq) Writer append​(CharSequence csq, int start, int end) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#字符流"},{"categories":["Java"],"content":" 字符流 Reader int read() int read​(char[] cbuf) int read​(char[] cbuf, int off, int len) int read​(CharBuffer target) void mark​(int readAheadLimit) boolean markSupported() long transferTo​(Writer out) long skip​(long n) void reset() void close() Writer Writer append​(char c) Writer append​(CharSequence csq) Writer append​(CharSequence csq, int start, int end) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#reader"},{"categories":["Java"],"content":" 字符流 Reader int read() int read​(char[] cbuf) int read​(char[] cbuf, int off, int len) int read​(CharBuffer target) void mark​(int readAheadLimit) boolean markSupported() long transferTo​(Writer out) long skip​(long n) void reset() void close() Writer Writer append​(char c) Writer append​(CharSequence csq) Writer append​(CharSequence csq, int start, int end) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#writer"},{"categories":["Java"],"content":" 文件字符流 FileReader 构造方法 FileReader​(String fileName) FileReader​(String fileName, Charset charset) FileReader​(File file) FileReader​(File file, Charset charset) FileWriter 构造方法 FileWriter​(String fileName) FileWriter​(String fileName, boolean append) FileWriter​(String fileName, Charset charset) FileWriter​(String fileName, Charset charset, boolean append) FileWriter​(File file) FileWriter​(File file, boolean append) FileWriter​(File file, Charset charset) FileWriter​(File file, Charset charset, boolean append) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#文件字符流"},{"categories":["Java"],"content":" 文件字符流 FileReader 构造方法 FileReader​(String fileName) FileReader​(String fileName, Charset charset) FileReader​(File file) FileReader​(File file, Charset charset) FileWriter 构造方法 FileWriter​(String fileName) FileWriter​(String fileName, boolean append) FileWriter​(String fileName, Charset charset) FileWriter​(String fileName, Charset charset, boolean append) FileWriter​(File file) FileWriter​(File file, boolean append) FileWriter​(File file, Charset charset) FileWriter​(File file, Charset charset, boolean append) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#filereader"},{"categories":["Java"],"content":" 文件字符流 FileReader 构造方法 FileReader​(String fileName) FileReader​(String fileName, Charset charset) FileReader​(File file) FileReader​(File file, Charset charset) FileWriter 构造方法 FileWriter​(String fileName) FileWriter​(String fileName, boolean append) FileWriter​(String fileName, Charset charset) FileWriter​(String fileName, Charset charset, boolean append) FileWriter​(File file) FileWriter​(File file, boolean append) FileWriter​(File file, Charset charset) FileWriter​(File file, Charset charset, boolean append) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#filewriter"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream\u003cString\u003e lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#缓冲字符流"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedreader"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedwriter"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#实战-1"},{"categories":["Java"],"content":" 转换流 InputStreamReader字节流 -\u003e 字符流 InputStreamReader​(InputStream in) InputStreamReader​(InputStream in, String charsetName) InputStreamReader​(InputStream in, Charset cs) InputStreamReader​(InputStream in, CharsetDecoder dec) String getEncoding() int read() int read​(char[] cbuf, int offset, int length) OutputStreamWriter字符流 -\u003e 字节流 OutputStreamWriter​(OutputStream out) OutputStreamWriter​(OutputStream out, String charsetName) OutputStreamWriter​(OutputStream out, Charset cs) OutputStreamWriter​(OutputStream out, CharsetEncoder enc) String getEncoding() void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#转换流"},{"categories":["Java"],"content":" 转换流 InputStreamReader字节流 -\u003e 字符流 InputStreamReader​(InputStream in) InputStreamReader​(InputStream in, String charsetName) InputStreamReader​(InputStream in, Charset cs) InputStreamReader​(InputStream in, CharsetDecoder dec) String getEncoding() int read() int read​(char[] cbuf, int offset, int length) OutputStreamWriter字符流 -\u003e 字节流 OutputStreamWriter​(OutputStream out) OutputStreamWriter​(OutputStream out, String charsetName) OutputStreamWriter​(OutputStream out, Charset cs) OutputStreamWriter​(OutputStream out, CharsetEncoder enc) String getEncoding() void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#inputstreamreader"},{"categories":["Java"],"content":" 转换流 InputStreamReader字节流 -\u003e 字符流 InputStreamReader​(InputStream in) InputStreamReader​(InputStream in, String charsetName) InputStreamReader​(InputStream in, Charset cs) InputStreamReader​(InputStream in, CharsetDecoder dec) String getEncoding() int read() int read​(char[] cbuf, int offset, int length) OutputStreamWriter字符流 -\u003e 字节流 OutputStreamWriter​(OutputStream out) OutputStreamWriter​(OutputStream out, String charsetName) OutputStreamWriter​(OutputStream out, Charset cs) OutputStreamWriter​(OutputStream out, CharsetEncoder enc) String getEncoding() void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#outputstreamwriter"},{"categories":["Java"],"content":" Propertieskey和value都是String的Hashtable 构造方法 Properties() Properties​(int initialCapacity) Properties​(Properties defaults) 添加/修改 Object setProperty​(String key, String value) Object put(String key, String value) 删除 V remove(Object key) 查询 Set\u003cString\u003e stringPropertyNames() Set\u003cObject\u003e keySet() Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() boolean containsKey(Object key) String getProperty​(String key) String getProperty​(String key, String defaultValue) Object get(Object key) Object getOrDefault(Object key, Object defaultValue) 序列化 void load​(InputStream inStream) void load​(Reader reader) void loadFromXML​(InputStream in) void store​(OutputStream out, String comments) void store​(Writer writer, String comments) void storeToXML​(OutputStream os, String comment) void storeToXML​(OutputStream os, String comment, String encoding) void storeToXML​(OutputStream os, String comment, Charset charset) # properties key1=value1 key2=value2 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u003e \u003cproperties\u003e \u003centry key=\"key1\"\u003evalue1\u003c/entry\u003e \u003centry key=\"key2\"\u003evalue2\u003c/entry\u003e \u003c/properties\u003e ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#properties"},{"categories":["Java"],"content":" Lambda 表达式 方法传入参数为接口。 接口有且只有一个抽象方法。 不产生.class文件。 // 无参数 () -\u003e { // return } // 一个参数 a -\u003e { // return } // 多个参数 (a, b) -\u003e { // return } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#lambda-表达式"},{"categories":["Java"],"content":" 异常","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#异常"},{"categories":["Java"],"content":" 分类 java.lang.Throwable java.lang.Error：严重错误 java.lang.Exception java.lang.RuntimeException：运行时异常 编译时异常：编译器能够检查出的异常，需要进行异常处理 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#分类-1"},{"categories":["Java"],"content":" 异常处理 try { } catch (Exception e) { } finally { // 一定会执行，就算没有出现异常 // 即使 try 程序块中有 return 语句，也是在执行了 finally 语句块后再返回 } // 不处理，向上继续抛出 void func() throws Exception {} void func() { // 主动抛出异常 throw new Exception(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#异常处理"},{"categories":["Java"],"content":" 自定义异常 class DIYException extends Exception { public DIYException() { super(); } public DIYException(String message) { super(message); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#自定义异常"},{"categories":["Python","教程"],"content":"Python 是现在最受欢迎的语言。 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#"},{"categories":["Python","教程"],"content":" 运算符 # 位运算 # 按位与 \u0026 a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a \u0026 b # 00 00 00 01 : 1 # 按位或 | a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a | b # 00 00 01 11 : 7 # 按位取反 ~ a = 3 # 00 00 00 11 ~a # 11 11 11 00 # 按位异或 ^ （相同为0，不同为1） a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a ^ b # 00 00 01 10 : 6 # 任何值与自身异或为0 a ^ a # 00 00 00 00 : 0 # 任何值与0异或不变 a ^ 0 # 00 00 00 11 : 3 # 按位左移 \u003c\u003c # 三元运算符 smaller = x if x \u003c y else y # 其他运算符 'A' in ['A', 'B', 'C'] 'D' not in ['A', 'B', 'C'] \"hello\" is \"hello\" \"Hello\" is not \"hello\" # is 对比的是两个变量的内存地址 # == 对比的是两个变量的值 # 地址不可变的类型（str 等），那么 is 和 == 完全等价 # 地址可变的类型（list，dict，tuple 等），两者不等价 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#运算符"},{"categories":["Python","教程"],"content":" 异常处理 # 异常处理 try: a = 1 / 0 except ZeroDivisionError: print('除数不能为0') # 指定精度 from decimal import Decimal decimal.getcontext().prec = 4 c = Decimal(1) / Decimal(3) # 0.3333 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#异常处理"},{"categories":["Python","教程"],"content":" 内置函数 # 获取类型信息 isinstance(1, int) # type() 不会认为子类是一种父类类型，不考虑继承关系 # isinstance() 会认为子类是一种父类类型，考虑继承关系 # 类型转换 int('520') # 520 float('520.52') # 520.52 str(520) # '520' # print # print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) # sep 分隔符 # end 结束符 # file 输出的文件 # flush 立即输出，不作缓存 abs(x) # 返回绝对值。若参数为复数，则返回复数的模。 divmod(a, b) # 返回 tuple(a // b, a % b) input(words) # 打印 words，读取用户输入，返回 str 类型 ord(c) # 返回字符对应的 ASCII 数值，或者 Unicode 数值 chr(i) # 返回整数（0～255，10进制或16进制）对应的 ASCII 字符。 bin(i) # 返回一个整数（int 或 long int）的二进制表示，str 类型。 any() # 是否存在大于0 all() # 是否全大于0 complex(real=0, image=0) # 复数 7.bit_length() # 3 0.25.as_integer_ratio() # (1, 4) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#内置函数"},{"categories":["Python","教程"],"content":" 数据结构","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#数据结构"},{"categories":["Python","教程"],"content":" 列表 a = [1] a.append(2) # [1, 2] a.pop() # 2 a.index(1) # 0 找不到报错 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#列表"},{"categories":["Python","教程"],"content":" 复数 c = 12 + 3j print(c.real) # 12.0 print(c.imag) # 3.0 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#复数"},{"categories":["Python","教程"],"content":" 字符串 pluto_mass = 1.303 * 10**22 earth_mass = 5.9722 * 10**24 population = 52910390 # {:.2} 2位有效数字 # {:.3%} 3位有效数字，百分数形式表示 # {:,} 数字每隔3位用逗号隔开 \"{} weighs about {:.2} kilograms ({:.3%} of Earth's mass). It is home to {:,} Plutonians.\".format( planet, pluto_mass, pluto_mass / earth_mass, population ) # Pluto weighs about 1.3e+22 kilograms (0.218% of Earth's mass). It is home to 52,910,390 Plutonians. # 根据位置使用变量 s = \"\"\"Pluto's a {0}. No, it's a {1}. {0}! {1}!\"\"\".format('planet', 'dwarf planet') # Pluto's a planet. # No, it's a dwarf planet. # planet! # dwarf planet! '123'.isdigit() # True 参考： PyFormat ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#字符串"},{"categories":["Python","教程"],"content":" 字典 dict() # {} dict(a=1, b=2, c=3) # {'a': 1, 'b': 2, 'c': 3} dict(zip(['a', 'b', 'c'], [1, 2, 3])) # {'a': 1, 'b': 2, 'c': 3} dict([('a', 1), ('b', 2), ('c', 3)]) # {'a': 1, 'b': 2, 'c': 3} ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:4","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#字典"},{"categories":["Python","教程"],"content":" staticmethod声明静态方法，即可以不实例化类而直接调用该方法。类中类也可以。 class C(object): @staticmethod def f(arg1, arg2, ...): ... ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#staticmethod"},{"categories":["Python","教程"],"content":" enumerate将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和下标，一般用在 for 循环中。 enumerate(sequence, start=0) list(enumerate([1, 2, 3])) # [(0, 1), (1, 2), (2, 3)] list(enumerate((1, 2, 3))) # [(0, 1), (1, 2), (2, 3)] list(enumerate('abc')) # [(0, 'a'), (1, 'b'), (2, 'c')] list(enumerate('abc', start=1)) # [(1, 'a'), (2, 'b'), (3, 'c')] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:6","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#enumerate"},{"categories":["Python","教程"],"content":" int 若 x 为数字，返回整数部分。（不能有 base 参数，否则报错） 若 x 为字符串，则将 x 视为 base 进制的数，返回转换为 10 进制后的数。（x 不能为小数或不存在的数，否则报错） int(x, base=10) int() # 0 int(3.9) # 3 int(-3.9) # -3 int('10', 2) # 2 int('0xA', 16) # 10 int('aB', 16) # 171 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:7","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#int"},{"categories":["Python","教程"],"content":" 常用内置库","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#常用内置库"},{"categories":["Python","教程"],"content":" randomrandom库 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#random"},{"categories":["Python","教程"],"content":" osos模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.pathos.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' -\u003e 'A' # 'A' -\u003e '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' -\u003e ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' -\u003e ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#os"},{"categories":["Python","教程"],"content":" osos模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.pathos.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' -\u003e 'A' # 'A' -\u003e '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' -\u003e ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' -\u003e ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#ospath"},{"categories":["Python","教程"],"content":" 文件操作 open() ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#文件操作"},{"categories":["Python","教程"],"content":" 技巧","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#技巧"},{"categories":["Python","教程"],"content":" 数字编号前置 0 s1 = \"12\" s1.zfill(4) # \"0012\" s2 = \"-12\" s2.zfill(4) # \"-0012\" a = 12 '%04d' % a # \"0012\" ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#数字编号前置-0"},{"categories":["Python","教程"],"content":" 列表推导式 [i * 2 for i in range(3)] # [0, 2, 4] [str(a) + b for a in range(2) for b in 'ab'] # ['0a', '0b', '1a', '1b'] [i * 2 if i % 2 else i for i in range(4)] # [0, 2, 2, 6] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#列表推导式"},{"categories":["Python","教程"],"content":" 匿名函数 + map list(map(lambda x: 2 * x, range(3))) # [0, 2, 4] list(map(lambda x, y: str(x) + y, range(3), 'abc')) # ['0a', '1b', '2c'] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#匿名函数--map"},{"categories":["Python","教程"],"content":" zip list(zip('01', 'ab')) # [('0', 'a'), ('1', 'b')] dict(zip('01', 'ab')) # {'0': 'a', '1': 'b'} for x, y in zip('ab', 'xy'): print(x, y) # a x # b y ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:4","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#zip"},{"categories":["Python","教程"],"content":" enumerate list(enumerate('ab')) # [(0, 'a'), (1, 'b')] for i, x in enumerate('ab'): print(i, x) # 0 a # 1 b ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:5","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#enumerate-1"},{"categories":["Python","教程"],"content":" Q\u0026A","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#qa"},{"categories":["Python","教程"],"content":" UnicodeDecodeError问题描述: UnicodeDecodeError: 'gbk' codec can't decode byte 0xad in position 7: illegal multibyte sequence 解决方案: 将open(filename, 'r')改为open(filename, 'r', encoding='utf-8') ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#unicodedecodeerror"},{"categories":["Python","教程"],"content":" Python 风格规范 不要在行尾加分号，也不要用分号将两条命令放在同一行。 每行不超过80个字符。（导入和注释例外） 不要使用反斜杠连接行。（Python 会将括号中的行隐式连接起来） foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 文本字符串在一行放不下，可以使用括号来实现隐式行连接。 s = ('This will build a very long long ' 'long long long long long long string') 除非是用于实现行连接，否则不要在返回语句或条件语句中使用括号。 用4个空格来缩进代码 # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = { long_dictionary_key: value1 + value2, ... } # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... } 顶级定义之间空两行（全局类、全局函数、全局变量），方法定义之间空一行（类内函数之间、类与第一个函数之间）。 括号内表达式两端不要有空格。 在逗号、分号、冒号后面加空格，前面不加。（行尾除外） 参数列表、索引或切片的左括号前不加空格。 二元操作符两边都加上一个空格。 ‘=‘用于指示参数值或默认值时，不在其两侧使用空格。 不要用空格来垂直对齐多行间的标记。（如’#’、’=’、’:‘等） 类注释和函数注释规范 class SampleClass(object): \"\"\"Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. \"\"\" def __init__(self, likes_spam=False): \"\"\"Inits SampleClass with blah.\"\"\" self.likes_spam = likes_spam self.eggs = 0 def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): \"\"\"Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: {'Serak': ('Rigel VII', 'Pr","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#python-风格规范"},{"categories":["C++","教程"],"content":"标准模板库（Standard Template Library，STL）是一组 C++ 模板类，提供常见的数据结构和函数，如列表、堆栈、数组等。它是由容器类、算法和迭代器构成的一个通用库，它的组件是参数化的。 STL 包含以下四个组件： 算法（Algorithms）：头文件\u003calgorithm\u003e定义了一组函数，作用于容器，并为容器中的内容提供各种操作方法。 容器（Containers）：用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，如 deque、list、vector、map、set、bitset 等。 函数（Functions）： 迭代器（Iterators）：遍历容器。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#"},{"categories":["C++","教程"],"content":" \u003cvector\u003evector是一个动态数组，需要#include \u003cvector\u003e。 数组大小动态改变 可以进行逻辑操作（是否相等、比较大小） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vector"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u003cint\u003e v1; // {} vector\u003cint\u003e v2 = {1, 2, 3}; // {1, 2, 3} vector\u003cint\u003e v3({1, 2, 3}); // {1, 2, 3} vector\u003cint\u003e v4 = v3; // {1, 2, 3} vector\u003cint\u003e v5(v3); // {1, 2, 3} vector\u003cint\u003e v6(3); // {0, 0, 0} vector\u003cint\u003e v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector\u003cint\u003e v8(arr, arr + 1); // {1} vector\u003cint\u003e v9(v4.begin(), v4.begin() + 2); // {1, 2} vector\u003cvector\u003cint\u003e\u003e v10(2, vector\u003cint\u003e(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定位置构造并插入元素 iterator insert(const_iterator position, const value_type\u0026 val) 在指定位置插入元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 在指定位置插入 n 个 val iterator insert(const_iterator position, InputIterator first, InputIterator last) 在指定位置插入数组或迭代器 [first, last) 区间内的元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) 在指定位置插入指定列表中的元素 vector\u003cpair\u003cstring, int\u003e\u003e v; v.push_back(make_pair(\"Mike\", 1)); v.emplace_back(\"John\", 2); // 隐式地构造了 pair 并插入末尾 1.3 删除 void pop_back() 删除最后一个元素 iterator erase(const_iterator position) 删除指定位置的元素 iterator erase(const_iterator first, const_iterator last) 删除迭代器 [first, last) 区间内的元素 void clear() noexcept 清空 1.4 容量 bool empty() const 判断容器是否为空 size_type size() const 返回元素个数 size_type capacity() const noexcept 返回已分配存储容量的大小 void resize(size_type n) 改变大小，变小截断，变大补 0 void resize(size_type n, const value_type\u0026 val) 改变大小，变小截断，变大补 val 1.5 其他操作 void assign(size_type n, const value_type\u0026 val) 赋值为 n 个 val void assign(InputIterator first, InputIterator last) 赋值为数组或迭代器 [firs","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vector-1"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#11-初始化"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#12-添加"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#13-删除"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#14-容量"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#15-其他操作"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#16-遍历"},{"categories":["C++","教程"],"content":" vector\u003cbool\u003e基本操作同 vector。 特殊操作： void flip() noexcept 所有位都翻转 static void swap(reference ref1, reference ref2) noexcept 交换两个位置的值 vector\u003cbool\u003e mask; mask.push_back(true); mask.push_back(false); // {1 0} mask.flip(); // {0 1} mask.swap(mask[0], mask[1]); // {1 0} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vectorbool"},{"categories":["C++","教程"],"content":" \u003cstack\u003estack是一个栈，需要#include \u003cstack\u003e。 后进先出（LIFO） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#stack"},{"categories":["C++","教程"],"content":" 2.1 初始化 默认底层容器是 deque 可以显式设置底层容器为 vector stack\u003cint\u003e st1; stack\u003cint\u003e st2(st1); stack\u003cint\u003e st3({1, 2, 3}); // st3.top() == 3 deque\u003cint\u003e dq(2, 3); stack\u003cint\u003e st4(dq); // 默认底层容器是 deque vector\u003cint\u003e v({1, 2, 3}); stack\u003cint, vector\u003cint\u003e\u003e st5(v); // 设置底层容器为 vector ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#21-初始化"},{"categories":["C++","教程"],"content":" 2.2 操作 void push(const value_type\u0026 val) 栈顶添加元素 void emplace(Args\u0026\u0026... args) 栈顶添加元素 void pop() 栈顶弹出元素 reference\u0026 top() 返回栈顶元素 bool empty() const 判断栈是否为空 size_type size() const 返回元素个数 void swap(stack\u0026 x) noexcept 交换两个栈 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#22-操作"},{"categories":["C++","教程"],"content":" \u003clist\u003elist是一个双向链表，需要#include \u003clist\u003e。 无法按索引访问元素 插入删除元素效率高 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#list"},{"categories":["C++","教程"],"content":" 3.1 基本操作基本操作同 vector。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#31-基本操作"},{"categories":["C++","教程"],"content":" 3.2 特殊操作添加： void push_front(const value_type\u0026 val) 在开头插入元素 void emplace_front(Args\u0026\u0026... args) 在开头构造并插入元素 void splice(const_iterator position, list\u0026 x) 将 x 中的元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator i) 将 x 中的位置为 i 元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator first, const_iterator last) 将 x 中的 [first, last) 区间内的元素转移到指定位置 void merge(list\u0026 x) void merge(list\u0026 x, Compare comp) 删除： void pop_front() 删除第一个元素 void remove(const value_type\u0026 val) 删除值为 val 的所有元素 void remove_if(Predicate pred) 删除满足自定义一元函数的元素 void unique() 删除连续重复元素，只保留一个 void unique(BinaryPredicate binary_pred) 删除满足自定义二元函数的元素 其他： void sort() 按升序排序 void sort(Compare comp) 按自定义二元函数排序 void reverse() noexcept 逆序 list\u003cint\u003e l = {1, 1, 1, 2, 1, 2}; l.unique(); // {1, 2, 1, 2} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#32-特殊操作"},{"categories":["C++","教程"],"content":" \u003cqueue\u003equeue是一个单向队列容器，需要#include \u003clist\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#queue"},{"categories":["C++","教程"],"content":" queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue\u003cint\u003e q1; // 空 queue queue\u003cint\u003e q2(5, 2); // 大小为 5 的 queue，值均为 2 queue\u003cint\u003e q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue\u003cint\u003e q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; queue\u003cint\u003e q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue\u003cint\u003e q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#queue-1"},{"categories":["C++","教程"],"content":" queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue q1; // 空 queue queue q2(5, 2); // 大小为 5 的 queue，值均为 2 queue q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; queue q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#411-初始化"},{"categories":["C++","教程"],"content":" queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue q1; // 空 queue queue q2(5, 2); // 大小为 5 的 queue，值均为 2 queue q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; queue q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#412-操作"},{"categories":["C++","教程"],"content":" priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue\u003cint\u003e pq1; // 空 priority_queue priority_queue\u003cint\u003e pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue\u003cint\u003e pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue\u003cint\u003e pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; priority_queue\u003cint\u003e pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue\u003cint\u003e pq6(v); // 复制 vector priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e pq7; // 最大优先队列（最大堆） priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq8; // 最小优先队列（最小堆） 4.2.2 操作 void push(const value_type\u0026 val) 添加元素 void emplace(Args\u0026\u0026... args) 添加元素 void pop() 删除队首（堆顶）元素 const_reference top() const 返回队首（堆顶）元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(priority_queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#priority_queue"},{"categories":["C++","教程"],"content":" priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue pq1; // 空 priority_queue priority_queue pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; priority_queue pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue pq6(v); // 复制 vector priority_queue","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#421-初始化"},{"categories":["C++","教程"],"content":" priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue pq1; // 空 priority_queue priority_queue pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; priority_queue pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue pq6(v); // 复制 vector priority_queue","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#422-操作"},{"categories":["C++","教程"],"content":" \u003cdeque\u003edeque是一个双端队列容器，需要#include \u003cdeque\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#deque"},{"categories":["C++","教程"],"content":" 5.1 初始化 deque\u003cint\u003e dq1; // 空 deque deque\u003cint\u003e dq2(5, 2); // 大小为 5 的 deque，值均为 2 deque\u003cint\u003e dq3(dq2); // 复制 deque deque\u003cint\u003e dq4(dq2.begin(), dq2.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 int arr[] = {1, 2, 3}; deque\u003cint\u003e dq5(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; deque\u003cint\u003e dq6(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 deque\u003cint\u003e dq7 = dq6; deque\u003cint\u003e dq8 = {1, 2, 3}; ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#51-初始化"},{"categories":["C++","教程"],"content":" 5.2 修改 void push_back(const value_type\u0026 val) 队尾添加元素 void push_front(const value_type\u0026 val) 队首添加元素 void emplace_back(Args\u0026\u0026... args) 队尾添加元素 void emplace_front(Args\u0026\u0026... args) 队首添加元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, const value_type\u0026 val) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 迭代器指定位置前面添加 n 个相同元素 iterator insert(const_iterator position, InputIterator first, InputIterator last) 迭代器指定位置前面添加 [first, last) 区间内元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) void pop_back() 删除队尾 void pop_front() 删除队首 iterator erase(iterator position) 删除迭代器指向元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 区间内元素 void clear() noexcept 清空 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#52-修改"},{"categories":["C++","教程"],"content":" 5.3 遍历 deque\u003cint\u003e dq; for (auto it = dq.begin(); it != dq.end(); it++) {*it;} for (auto it = dq.rbegin(); it != dq.rend(); it++) {*it;} for (int e : dq) {e;} for (int\u0026 e : dq) {e;} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#53-遍历"},{"categories":["C++","教程"],"content":" 5.4 操作 size_type size() const noexcept 返回大小 void resize(size_type n) 调整大小为 n，调大补 0，调小末尾截断 void resize(size_type n, const value_type\u0026 val) 调整大小为 n，调大补 val，调小末尾截断 bool empty() const noexcept 判断是否为空 reference operator[](size_type n) 访问指定位置元素，越界报错 reference at(size_type n) 访问指定位置元素，越界抛出 out_of_range 异常 const_reference back() const 返回队尾元素 const_reference front() const 返回队首元素 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:4","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#54-操作"},{"categories":["C++","教程"],"content":" \u003cmap\u003emap是一个有序键值对容器，每个元素由关键字（key）和该关键字对应的值（value）组合而成。需要#include \u003cmap\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#map"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map\u003cchar, int\u003e m1; map\u003cchar, int\u003e m2(m1); map\u003cchar, int\u003e m3(m1.begin(), m1.end()); map\u003cchar, int, less\u003cchar\u003e\u003e m4; // 按 key 升序排列，相当于 map\u003cchar, int\u003e map\u003cchar, int, greater\u003cchar\u003e\u003e m5; // 按 key 降序排列 6.2 添加 map\u003cchar, int\u003e m1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair\u003cchar, int\u003e('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 map\u003cchar, int\u003e m; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-\u003efirst; it-\u003esecond; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-\u003efirst; it-\u003esecond; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() const noexcept 判断是否为空 void swap(map\u0026 x) 交换两个 map iterator find(const key_type\u0026 k) 查找 key 值为 k 的元素，未找到返回 map::end() size_type count(const key_type\u0026 k) const 返回 key 值为 k 的元素的数量，由于 key 唯一，则存在返回 1，不存在返回 0 iterator lower_bound(const key_type\u0026 k) 返回指向第一个 key 大于等于 k 的元素的迭代器 iterator upper_bound(const key_type\u0026 k) 返回指向第一个 key 大于 k 的元素的迭代器 pair\u003citerator, iterator\u003e equal_range(const key_type\u0026 k) 返回指向 key 等于 k 的所有元素的范围的边界元素的迭代器 [first, second) map\u003cchar, int\u003e m; m['a'] = 0; m.find('b'); // m.end() m.count('a'); // 1 m.count('b'); // 0 6.6 排序 map没有随机迭代器，只有顺序迭代器，所以不能用sort 6.6.1 按 key 排序key 升序，value 随机 默认情况，map\u003cint, char\u003e，相当于map\u003cint, char, less\u003cint\u003e\u003e。 当 key 为自定义类时： typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; return a.two \u003c b.two; } }; map\u003cGrade, int, Cmp\u003e m; typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; ret","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#map-1"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#61-初始化"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#62-添加"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#63-删除"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#64-遍历"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#65-其他操作"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#66-排序"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#661-按-key-排序"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#662-按-value-排序"},{"categories":["C++","教程"],"content":" multimap key允许重复 默认按key升序排列 底层二叉搜索树实现，速度比unordered_multimap慢 基本使用方法同 map。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#multimap"},{"categories":["C++","教程"],"content":" \u003cunordered_map\u003e","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_map"},{"categories":["C++","教程"],"content":" unordered_map key唯一且不能修改，可以添加或删除 无序 速度比map快 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_map-1"},{"categories":["C++","教程"],"content":" unordered_multimap","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_multimap"},{"categories":["C++","教程"],"content":" \u003cset\u003eset是一个有序集合容器。需要#include \u003cset\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#set"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set\u003cint\u003e s1; // {} set\u003cint\u003e s2 = {1, 2, 3}; // { 1 2 3 } set\u003cint\u003e s3 = s2; // { 1 2 3 } set\u003cint\u003e s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set\u003cint\u003e s5(arr, arr + 3); // { 1 2 3 } set\u003cint\u003e s6(arr, arr + 1); // { 1 } set\u003cint\u003e s7(s4); // { 1 2 3 } set\u003cint\u003e s8(s4.begin(), s4.end()); // { 1 2 3 } set\u003cint\u003e s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set\u003cint, CompClass\u003e s10; // { 1 2 3 } 修改 pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args) 添加一个元素 pair\u003citerator, bool\u003e insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list\u003cvalue_type\u003e il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair\u003citerator, iterator\u003e equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#set-1"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#初始化"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#修改"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#容量"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#遍历"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#操作"},{"categories":["C++","教程"],"content":" multiset 允许重复元素 元素默认升序 速度比unordered_set慢 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#multiset"},{"categories":["C++","教程"],"content":" \u003cunordered_set\u003eunordered_set是一个无序集合容器。需要#include \u003cunordered_set\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_set"},{"categories":["C++","教程"],"content":" unordered_set 元素唯一 无序 底层哈希表实现，速度比set快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_set-1"},{"categories":["C++","教程"],"content":" unordered_multiset 允许重复元素 无序 速度比multiset快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_multiset"},{"categories":["C++","教程"],"content":" \u003cbitset\u003ebitset模拟一个 bool 数组，每个元素只能是 0 或 1. ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#bitset"},{"categories":["C++","教程"],"content":" 初始化 bitset\u003c4\u003e b1; // 0000 bitset\u003c4\u003e b2(\"100\"); // 0100, b2[0] == 0 bitset\u003c4\u003e b3(\"1100\"); // 1100 bitset\u003c4\u003e b4(\"11100\"); // 1110 bitset\u003c4\u003e b5(b2); // 0100 string s = \"1010\"; bitset\u003c4\u003e b6(s); // 1010 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#初始化-1"},{"categories":["C++","教程"],"content":" 位运算 bitset\u003c4\u003e a(\"1001\"), b(\"1010\"); a \u0026 b; // 1000 AND a | b; // 1011 OR a ^ b; // 0011 XOR ~a; // 0110 NOT a \u003c\u003c 1; // 0010 SHL a \u003e\u003e 1; // 0100 SHR a == b; // false a != b; // true ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#位运算"},{"categories":["C++","教程"],"content":" 操作 reference operator[](size_t pos) 访问指定位置，0 是最右边一位，即最低位 size_t count() const noexcept 返回 1 的 个数 size_t size() const noexcept 返回长度 bool test(size_t pos) const 判断指定位置是否为 1 bool any() const noexcept 判断是否存在某一位是 1 bool none() const noexcept 判断是否全是 0 bool all() const noexcept 判断是否全是 1 bitset\u0026 set() noexcept 全部置为 1 bitset\u0026 set(size_t pos, bool val = true) 指定位置置为 1 bitset\u0026 reset() noexcept 全部置为 0 bitset\u0026 reset(size_t pos) 指定位置置为 0 bitset\u0026 flip() noexcept 翻转 bitset\u0026 flip(size_t pos) 翻转指定位置 string to_string() const 返回该二进制数的字符串 unsigned long to_ulong() const 返回该 2 进制数对应的整数，类型 unsigned long unsigned long long to_ullong() const 返回该 2 进制数对应的整数，类型 unsigned long long ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#操作-1"},{"categories":["C++","教程"],"content":" \u003calgorithm\u003e","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#algorithm"},{"categories":["C++","教程"],"content":" sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector\u003cint\u003e v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#sort"},{"categories":["C++","教程"],"content":" sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#数组排序"},{"categories":["C++","教程"],"content":" sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#类结构体排序"},{"categories":["C++","教程"],"content":" reverse","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#reverse"},{"categories":["C++","教程"],"content":" lower_bound","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#lower_bound"},{"categories":["C++","教程"],"content":" upper_bound","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:4","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#upper_bound"},{"categories":["C++","教程"],"content":" search","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:5","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#search"},{"categories":["C++","教程"],"content":" \u003ctuple\u003etuple将不同类型的许多元素打包成一个对象，便于访问，（就像定义了一个只有属性的类，并且属性只定义了类型，未定义名字）。需要#include \u003ctuple\u003e。 元素类型任意 元素数量任意 tuple\u003cint, string\u003e t1; tuple\u003cint, string\u003e t2{t1}; tuple\u003cint, string\u003e t3(t2); tuple\u003cint, string\u003e t4{1, \"one\"}; get\u003c0\u003e(t4); // 1 get\u003c1\u003e(t4); // one get\u003cint\u003e(t4); // 1 get\u003cstring\u003e(t4); // one make_tuple(2, string(\"two\")); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#tuple"},{"categories":["C++","教程"],"content":" \u003cnumeric\u003e该头文件包括了一组对数组进行某些操作的算法。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#numeric"},{"categories":["C++","教程"],"content":" accumulate T accumulate(InputIterator first, InputIterator last, T init)：默认求和 T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)：自定义函数 int res = 0; int arr[3] = {1, 2, 3}; vector\u003cint\u003e vec(arr, arr + 3); accumulate(arr, arr + 3, res); // 求和，6 accumulate(vec.begin(), vec.end(), res); // 求和，6 accumulate(arr, arr + 3, res, minus\u003cint\u003e()); // 累减，-6 accumulate(arr, arr + 3, res, [z](int x, int y) { return x + 2 * y; }); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#accumulate"},{"categories":["C++","教程"],"content":" 参考 Standard C++ Library Reference - cplusplus.com ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:14:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#参考"},{"categories":["PowerShell","教程"],"content":"PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 所有指令或参数均不区分大小写！ PowerShell Bash ls、dir、Get-ChildItem、gci ls -l ls -force ls -a ls -name ls mkdir、New-Item -itemtype \"directory\" mkdir echo、Write-Output、write echo ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["PowerShell","教程"],"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/#"},{"categories":["Hugo"],"content":"使用 Hugo 搭建一个博客，并使用 Github Action 自动部署到 Github Pages。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#"},{"categories":["Hugo"],"content":" 1.安装 Windows 到 Github 下载hugo_extended_0.XX.X_Windows-64bit.zip，解压并将hugo.exe所在目录添加到系统环境变量。 到 Git 官网 下载安装 Git。 Chocolatey (Windows) choco install hugo-extended git Scoop (Windows) scoop install hugo-extended git Homebrew (macOS) brew install hugo git ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#1安装"},{"categories":["Hugo"],"content":" 2.创建网站 打开命令行，输入以下内容，其中MyBlog可修改。 在 Hugo Themes 寻找更多主题。若更换别的主题，将 git 地址和 DoIt 替换。 hugo new site MyBlog cd MyBlog git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#2创建网站"},{"categories":["Hugo"],"content":" 3.添加内容","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#3添加内容"},{"categories":["Hugo"],"content":" 3.1 新建博客输入hugo new posts/My-First-Blog.md，然后打开My-First-Blog.md，显示如下： --- title: \"My First Blog\" date: 2021-02-04T16:18:47+08:00 draft: true --- Markdown 语法见 Markdown 基本语法。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#31-新建博客"},{"categories":["Hugo"],"content":" 3.2 在文章中添加图片将图片存放于static文件夹。 若图片路径为static/xxx/yyy.jpg，在博客中使用/xxx/yyy.jpg来显示图片。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#32-在文章中添加图片"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#32-shortcodes"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#321-图片"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#322-横幅"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#323-公式"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#324-代码"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#325-gist"},{"categories":["Hugo"],"content":" 4.本地部署 hugo server/serve hugo server -D # 渲染草稿，即也渲染 draft: true 的内容 浏览器打开 localhost:1313 即可看到渲染后的网站。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#4本地部署"},{"categories":["Hugo"],"content":" 5.主题自定义主题配置文件为根目录下的config.toml文件。（也可以是config.yaml、config.json） ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#5主题自定义"},{"categories":["Hugo"],"content":" 5.1 简单配置 # 域名 baseURL = \"https://backtraxe.github.io/\" # 默认语言 [en, zh-cn, ...] defaultContentLanguage = \"zh-cn\" # 语言 [zh-CN, en-us, ...] languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 标题 title = \"traXe\" # 主题 theme = \"DoIt\" [params] # 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是Backsided的博客\" # 作者配置 [author] name = \"Backsided\" email = \"\" link = \"\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#51-简单配置"},{"categories":["Hugo"],"content":" 5.2 高级配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#52-高级配置"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#53-params"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsapp"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssearch"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsheader"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsfooter"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssection"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramslist"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramshome"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssocial"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspage"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagetoc"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagecode"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagemath"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagemapbox"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspageshare"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagecomment"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagelibrary"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspageseo"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramstypeit"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsverification"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsseo"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsanalytics"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscookieconsent"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscdn"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscompatibility"},{"categories":["Hugo"],"content":" [markup] # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:4","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#markup"},{"categories":["Hugo"],"content":" [author] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:5","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#author"},{"categories":["Hugo"],"content":" [sitemap] # 网站地图配置 [sitemap] changefreq = \"weekly\" filename = \"sitemap.xml\" priority = 0.5 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:6","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#sitemap"},{"categories":["Hugo"],"content":" [Permalinks] # Permalinks 配置 [Permalinks] # posts = \":year/:month/:filename\" posts = \":filename\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:7","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#permalinks"},{"categories":["Hugo"],"content":" [privacy] # 隐私信息配置 [privacy] [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:8","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#privacy"},{"categories":["Hugo"],"content":" [mediaTypes] # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\"text/plain\"] suffixes = [\"md\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:9","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#mediatypes"},{"categories":["Hugo"],"content":" [outputFormats.MarkDown] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \"text/plain\" isPlainText = true isHTML = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:10","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#outputformatsmarkdown"},{"categories":["Hugo"],"content":" [outputs] # 用于 Hugo 输出文档的设置 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] page = [\"HTML\", \"MarkDown\"] section = [\"HTML\", \"RSS\"] taxonomy = [\"HTML\", \"RSS\"] taxonomyTerm = [\"HTML\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:11","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#outputs"},{"categories":["Hugo"],"content":" 6.发布","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#6发布"},{"categories":["Hugo"],"content":" 6.1 静态页面发布输入hugo，渲染后的静态页面在public文件夹中，可将该文件夹中的内容复制到 Web 服务器进行发布。 可用hugo -d/--destination或在config.toml中修改publishdir来指定输出的文件夹。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#61-静态页面发布"},{"categories":["Hugo"],"content":" 6.2 Github Pages 发布 在 Github 新建两个仓库： \u003cUSERNAME\u003e.github.io.data 用于存放内容，仓库名称随意，可设置为私有仓库。 \u003cUSERNAME\u003e.github.io 用于部署页面。 在MyBlog根目录下运行命令行，输入以下内容： git remote add origin https://github.com/backtraxe/backtraxe.github.io.data.git git add --all git commit -m \"init blog\" git push --set-upstream origin master -f 在 Github 中创建一个 Personal access token，命名随意，勾选repo，复制其中内容。 进入\u003cUSERNAME\u003e.github.io.data仓库，点击Settings-\u003eSecrets，名称为ACCESS_TOKEN，内容填入刚才复制的token。 然后点击Actions-\u003eNew workflow-\u003eset up a workflow yourself，输入以下内容： name: Hugo Deploy on: push: branches: [ main ] # 指定分支 workflow_dispatch: # 允许手动启动 jobs: build: runs-on: ubuntu-latest steps: - name: 1. Checkout # 克隆仓库 uses: actions/checkout@v2 with: submodules: true # 启用子模块 fetch-depth: 0 - name: 2. Disable quotePath # 解决中文显示问题 run: git config --global core.quotePath false - name: 3. Setup Hugo # 安装 hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: 4. Build Hugo # 渲染页面 run: hugo --gc --minify --cleanDestinationDir - name: 5. Deploy Hugo # 将渲染后的页面复制到指定仓库，然后发布 uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.ACCESS_TOKEN }} # 与 Secrets 的名称相同 external_repository: backtraxe/backtraxe.github.io # 指定发布的仓库 publish_branch: main # 指定发布仓库的分支 publish_dir: ./public # 指定要发布的目录 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#62-github-pages-发布"},{"categories":["Hugo"],"content":" 6.3 环境迁移在新设备克隆仓库，同步所有内容。 git clone --recursive https://github.com/backtraxe/backtraxe.github.io.data.git ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#63-环境迁移"},{"categories":["Hugo"],"content":" 7.全局详细配置 # 域名 baseURL = \"\" # 构建时包含草稿 buildDrafts = false # 内容文件夹 contentDir = \"content\" # 数据文件夹 dataDir = \"data\" # 内容默认语言（中文：zh-cn） defaultContentLanguage = \"en\" # 根目录跳转到默认语言目录 defaultContentLanguageInSubdir = false # 禁用指定类型页面：page, home, section, taxonomy, term, RSS, sitemap, robotsTXT, 404 disableKinds = [] # 禁用实时重载 disableLiveReload = false # 禁用将 url/path 转小写字母 disablePathToLower = false # 启用 Emoji enableEmoji = false # 使用文件的最后 git 提交日期更新 Lastmod 参数 enableGitInfo = false # 启用 inline shortcode enableInlineShortcodes = false # 是否生成 robots.txt 文件 enableRobotsTXT = false # 日期设置 [frontmatter] # 脚注锚的前缀 footnoteAnchorPrefix = \"\" # 脚注返回链接显示的文本 footnoteReturnLinkContents = \"\" # Google Analytics 跟踪 ID googleAnalytics = \"\" # 自动检测内容中的中文/日文/韩文 hasCJKLanguage = false # 图片设置 [imaging] # 语言设置 [languages] # 启用日志 log = false # 日志保存目录 logFile = \"\" # 主题设置 [markup] # 目录设置 [menu] # 最小化构建设置 [minify] # 模块设置 [module] # 每页的默认文章数量 paginate = 10 # 固定链接 [permalinks] # 生成静态网页的目录 publishDir = \"public\" # 相关设置 [related] # 网站地图设置 [sitemap] # 静态文件目录设置 staticDir = \"static\" # 分类设置 [taxonomies] # 主题 theme = \"\" # 主题目录 themesDir = \"themes\" # 标题 title = \"\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:7:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#7全局详细配置"},{"categories":["Hugo"],"content":" 参考 Quick Start | Hugo GitHub Pages 文档 - GitHub Docs Host on GitHub - Hugo 开始使用 DoIt - 系列 - DoIt How to Create Your First Hugo Blog: a Practical Guide 创建 GitHub Pages 站点 - Github 使用Hugo和GitHub搭建博客 - Félix | Medium Configure Hugo | Hugo ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:8:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#参考"},{"categories":["Markdown"],"content":" 1.标题 # 一级标题 h1 ## 二级标题 h2 ### 三级标题 h3 #### 四级标题 h4 ##### 五级标题 h5 ###### 六级标题 h6 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#1标题"},{"categories":["Markdown"],"content":" 2.强调 **粗体** *斜体* ~~删除线~~ ***斜体加粗*** ~~**删除线加粗**~~ ~~*斜体删除线*~~ ~~***斜体删除线加粗***~~ 粗体、斜体、删除线、斜体加粗、删除线加粗、斜体删除线、斜体删除线加粗 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#2强调"},{"categories":["Markdown"],"content":" 3.引用 \u003e 引用 \u003e\u003e 嵌套引用 引用 嵌套引用 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#3引用"},{"categories":["Markdown"],"content":" 4.分割线 --- *** ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#4分割线"},{"categories":["Markdown"],"content":" 5.图片 ![Backtraxe's Blog](https://backtraxe.github.io/apple-touch-icon.png \"Backtraxe's Blog\") \u003cdiv style=\"text-align: center\"\u003e \u003cimg src=\"https://backtraxe.github.io/apple-touch-icon.png\" alt=\"Backtraxe's Blog\" width=\"10%\" align=\"center\"\u003e \u003c/div\u003e Backtraxe's Blog ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#5图片"},{"categories":["Markdown"],"content":" 6.超链接 [Backtraxe's Blog](https://backtraxe.github.io/) \u003chttps://backtraxe.github.io/\u003e 这个链接用 1 作为网址变量 [traXe][1] 这个链接用 traxe 作为网址变量 [traXe][traxe] 然后在文档的结尾为变量赋值（网址） [1]: https://backtraxe.github.io/ [traxe]: https://backtraxe.github.io/ Backtraxe’s Blog https://backtraxe.github.io/ 这个链接用 1 作为网址变量 traXe 这个链接用 traxe 作为网址变量 traXe 然后在文档的结尾为变量赋值（网址） ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#6超链接"},{"categories":["Markdown"],"content":" 7.列表","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#7列表"},{"categories":["Markdown"],"content":" 7.1 无序列表 - 北京 - 上海 - 广州 - 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#71-无序列表"},{"categories":["Markdown"],"content":" 7.2 有序列表 1. 北京 1. 上海 1. 广州 1. 深圳 或者 1. 北京 2. 上海 3. 广州 4. 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#72-有序列表"},{"categories":["Markdown"],"content":" 7.3 列表嵌套 - 北京 - 上海 - 广东 1. 广州 2. 深圳 北京 上海 广东 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:3","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#73-列表嵌套"},{"categories":["Markdown"],"content":" 8.表格","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#8表格"},{"categories":["Markdown"],"content":" 8.1 markdown 风格 姓名|分数|排名 --|:--:|--: 张三|100|1 李四|85|2 王五|60|3 姓名 分数 排名 张三 100 1 李四 85 2 王五 60 3 --，:-- : 左对齐 :--: : 居中 --: : 右对齐 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#81-markdown-风格"},{"categories":["Markdown"],"content":" 8.2 html 风格 \u003ctable\u003e \u003cth\u003e \u003ctd style=\"text-align: center\"\u003e\u003cb\u003e姓名\u003c/b\u003e\u003c/td\u003e \u003ctd style=\"text-align: center\"\u003e\u003cb\u003e分数\u003c/b\u003e\u003c/td\u003e \u003ctd style=\"text-align: center\"\u003e\u003cb\u003e排名\u003c/b\u003e\u003c/td\u003e \u003c/th\u003e \u003ctr\u003e \u003ctd\u003e张三\u003c/td\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e1\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e李四\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e王五\u003c/td\u003e \u003ctd\u003e60\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 姓名 分数 排名 张三 100 1 李四 85 2 王五 60 3 Tables Generator ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#82-html-风格"},{"categories":["Markdown"],"content":" 9.代码","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#9代码"},{"categories":["Markdown"],"content":" 9.1 单行代码 `print(\"Hello World!\")` print(\"Hello World!\") ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#91-单行代码"},{"categories":["Markdown"],"content":" 9.2 多行代码 ```cpp #include\u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ``去掉` #include\u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#92-多行代码"},{"categories":["Markdown"],"content":" 10.公式","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#10公式"},{"categories":["Markdown"],"content":" 10.1 行内公式 $E=mc^2$ $E=mc^2$ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#101-行内公式"},{"categories":["Markdown"],"content":" 10.2 多行公式 $$ \\sum_{i=1}^n a_i=0 $$ $$ \\sum_{i=1}^n a_i=0 $$ $$ \\begin{align} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{align} $$ $$ \\begin{align} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{align} $$ $$ \\begin{aligned} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{aligned} $$ $$ \\begin{aligned} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{aligned} $$ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#102-多行公式"},{"categories":null,"content":"test ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"about","uri":"/about/#"},{"categories":null,"content":" 你没有连接至互联网。 ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"离线模式","uri":"/offline/#"}]