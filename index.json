[{"categories":["导航"],"content":" 在线工具 PDF： iLovePDF easy PDF PDF24 Tools PDF2GO 图片： ClipDrop： 去除背景 图片放大 魔法消除 PhotoRoom： 去除背景 魔法消除 模糊背景 PixelBin.io： 去除背景 图片放大 图片压缩 去除水印 jpg： 图片放大 魔法消除 老照片修复 ImgCleaner：魔法消除。 去去去：魔法消除。 Recompressor：图片压缩。 PIX FIX：JPG去噪。 iLoveIMG：压缩图片、调整图片大小、裁剪图片、格式转换、旋转图片、添加水印、HTML转图片。 ezGIF：制作GIF、视频转GIF、调整GIF大小、裁剪GIF、旋转GIF、压缩GIF、图片webp互相转换。 视频： bigmp4 音频： 网易见外 OCR： EasyScreenOCR Online OCR 下载： Image Extractor：网页图片打包下载。 X2Download：Youtube iiilab：YouTube、微博、哔哩哔哩、Twitter、Instagram、全民K歌、Facebook、云音乐 Yout：YouTube、Twitter、Facebook AddYoutube：YouTube DownSub：YouTube、Bilibili、Facebook SavePorn 图标： 小米风格Logo 图标制作 Favicon生成器 背景： Figen fffuel Meshy：Generate beautiful mesh gradients. 图表： ProcessOn diagrams.net Excalidraw 数学： Mathway Apple： The Mac index Steam： SteamDB 字体： 萝卜工坊 Weird Fonts LaTeX： Overleaf 公式编辑器 打字练习： dazidazi Qwerty Learner ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:1:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#在线工具"},{"categories":["导航"],"content":" 在线娱乐 影视： 低端影视 奈菲影视 看片狂人 NO视频 LIBVIO影视 动漫： AGE动漫 樱花动漫 ZzzFun动漫视频网 漫岛动漫 EDD动漫 打驴动漫 ギリギリ爱弹幕网 卡通站 漫画： 漫画DB 动漫之家 包子漫画 小说： 天天看小说 体育： CCTV5 JRKAN 小说： 小说排版助手 工具书： 工具书 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:2:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#在线娱乐"},{"categories":["导航"],"content":" 程序开发 IDE： OnlineGDB C++ shell futurecoder KalkiCode Compiler Explorer：查看各种语言编译后的汇编代码或字节码。Github Replit：在线 IDE。 Git： Learn Git 正则表达式： regex101 RegexLearn 破解： 吾爱破解 可视化： 数据结构和算法动态可视化 HTML \u0026 CSS： uiverse.io：HTML 和 CSS 样式库。 代码截图 Carbon CodeToImg 代码格式化 Code Beautify API 文档 DevDocs VIM VIM Adventures：Learn VIM while playing a game. Interactive Vim tutorial Glyphs：特殊符号。 IT Tools：常用开发工具合集。 CodeCode：智能分析程序时空复杂度。 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:3:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#程序开发"},{"categories":["导航"],"content":" 资源下载 搜索： 搜番 磁力爬 八爪鱼 无极磁链 影视： 高清MP4 片源网 BT天堂 WebHD FIX字幕侠 牛牛美剧 音范丝 Nyaa RARBG 纪录片天地 BTNull 动漫： 动漫领域 肥羊-Raws 动漫花园 萌番组 不移之火 漫画： Mox.moe trackers： trackerslist ACGTracker 字幕： SubHD 字幕库 A4k字幕网 射手网(伪) 体育： 90分钟足球网 书籍： 知轩藏书 莫若书单 游戏： 叽哩叽哩 Office： Word联盟 优品PPT PPT超级市场 第1PPT 图片： Unsplash DeviantArt Pinterest 天空之城 NegativeSpace Free Stock Images 壁纸： 极简壁纸1 极简壁纸2 Wallpaper Abyss wallhaven Ocean of Wallpapers Rare Gallery 素材： Freepik Storyset StickPNG 图标： Worldvectorlogo Iconduck StickPNG Iconfont 设计之家 Notion Icons 5.0 iOS Icon Gallery macOS Icon Gallery watchOS Icon Gallery Lucide 配色： Color Hunt Color Palettes Hello Color NIPPON COLORS 中国色 Blend ColorSpace 系统： Windows 11 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:4:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#资源下载"},{"categories":["导航"],"content":" 导航资讯 游戏： Liquipedia DST-MOD Wiki 资源： 不死鸟 好棒的羊毛站 A姐分享 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:5:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#导航资讯"},{"categories":["导航"],"content":" 软件APP 安卓： Uptodown APKMirror APKCombo 果核剥壳 异星软件空间 易酷软件 Windows： 果核剥壳 Downloadastro Crack Softwares Easy To Direct Download Pc Software Mac： MacWk 腾讯柠檬精选 iOS： 捷径库 每日限免： 反斗限免 Appwall Today Mergeek 软件推荐： 小众软件 反斗软件 Awesome Windows Best Windows Apps 推荐软件 安卓：MiXplorer Silver|1DM+|FolderSync|Tachiyomi|全是漫画|阅读3.0 iOS： Windows：ShareX|Snipaste|uTools|Bandizip|Everything|Honeycam|PDFPatcher|Rufus|Ventoy|微PE工具箱|AS SSD Benchmark|GPU-Z|CPU-Z|adb \u0026 fastboot Mac： Linux： 浏览器扩展：沙拉查词|Chrono下载管理器|Tampermonkey 油猴插件：AC-baidu|秒传链接提取|网盘直链下载助手 ","date":"2021-04-19","objectID":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/:6:0","series":null,"tags":["导航"],"title":"网站收藏🔝","uri":"/posts/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/#软件app"},{"categories":["导航"],"content":" 学习指南 社区 Dataquest AI研习社 AMiner 博客 构建我的被动收入 为什么这么设计系列文章 优质资料 我的计算机学习网站集合 程序员应该访问的最佳网站中文版 大学资料 CS自学指南 清华大学计算机系课程攻略 浙江大学课程攻略共享计划 Awesome Roadmaps ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#学习指南"},{"categories":["导航"],"content":" 算法 网站 力扣 牛客网 Codeforces AtCoder 书籍 《Algorithms》 刷题 LeetCode难题代码和算法要点分析：C++。 LeetCode 101：C++。 C++算法编程指南 图解算法数据结构：《剑指 Offer》解题代码，C++/Java/Python。 1500 most common data structures and algorithms solutions：常用代码片段，所有语言实现。 labuladong 的算法小抄：在线阅读 算法珠玑：在线阅读 Awesome Algorithms The Algorithms 不懂动态规划？21道 LeetCode题目带你学会动态规划！ 五万字《十大排序算法》动图讲解 Learn-Algorithms: 算法学习笔记 Best Resources to Learn Data Structures and Algorithms DSA-Bootcamp-Java 可视化 Data Structure Visualizations ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#算法"},{"categories":["导航"],"content":" 编程语言","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#编程语言"},{"categories":["导航"],"content":" C C Programming Course ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:1","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#c"},{"categories":["导航"],"content":" C++ 书籍 《Effective Modern C++ 》翻译版 《Effective Modern C++》解读笔记 《Effective Debugging》中文版 《现代 C++ 教程：高速上手 C++ 11/14/17/20（第二版）》 《C++ Primer 中文版（第5版）》笔记和习题 C++ Core Guidelines C++ Developer Roadmap cplusplus.com C++那些事 在拥挤和变化的世界中茁壮成长：C++ 2006–2020 Modern CPP Tricks ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:2","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#c-1"},{"categories":["导航"],"content":" Python Python-Mini-Projects: 一组简单的 Python 迷你项目来增强你的 Python 技能。 《Python Cookbook in Chinese》 3rd Edition 翻译 爬取你要的数据：爬虫技术 Matplotlib 40000 字！全网最强 Matplotlib 实操指南! ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:3","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#python"},{"categories":["导航"],"content":" Java Java SE Documentation：Java SE 文档。 JDK 11 API JDK 8 API How2J 的 Java教程 深入浅出Java多线程 toBeBetterJavaer JavaGuide guide-rpc-framework ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:4","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#java"},{"categories":["导航"],"content":" Go mmcgrana/gobyexample：使用带注释的示例程序进行 Go 操作的实践介绍。 Go by Example quii/learn-go-with-tests：通过编写测试学习 Go 语言。 Learn Go with tests Tutorial: Get started with Go：Go 官方教程。 Practical Go Lessons Introduction-to-Golang：最全空降 golang 资料补给包（满血战斗），包含文章，书籍，作者论文，理论分析，开源框架，云原生，大佬视频，大厂实战分享 ppt。 《Go入门指南》 Go 101 Go语言101 Go语言精进之路 《Go 入门指南》：《The Way to Go》中文版。 《Go 语言原本》：本书就是一本讨论 Go 语言源码工程中的技术原理及其演进历程的书籍。 Golang-Internal-Notes：Go 源码分析。 《玩转 GO》：《Mastering GO》中文版。 Go Course：Master the fundamentals and advanced features of the Go programming language. Golang 编译器代码浅析 《Go语言定制指南》 《µGo语言实现》：从头开发一个迷你 Go 语言编译器。 《Go 语言设计与实现》 Golang资料补给包 《Go语言标准库》：2022/3/6 Go Standard Library By Example：2018/1/10 算法 《algorithm-note》中文版：在线阅读，Go。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:5","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#go"},{"categories":["导航"],"content":" HTML/CSS/JS/TS Learn to Code HTML \u0026 CSS code-segment 50 Projects in 50 Days - HTML/CSS and JavaScript clean-code-javascript: Clean Code concepts adapted for JavaScript 带你入门前端工程: 国内访问（Gitee） 国外访问（Github） 图解 React 源码系列: 图解 React 源码，用大量配图的方式，致力于将 React 原理表述清楚。 深入理解 TypeScript: TypeScript Deep Dive的中文翻译版 在线阅读 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:6","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#htmlcssjsts"},{"categories":["导航"],"content":" 计算机基础 操作系统 逸仙OS简明教程 Systems Programming Cheat Sheet 从零开始制作一个操作系统 计算机网络 不为人知的网络编程 通透，23 个问题 TCP 疑难杂症全解析 计算机网络知识点全面总结 How to hide your IP address 数据库 SQLBolt: interactive lessons and exercises 设计数据密集型应用 设计数据密集型应用 - 中文翻译 Let’s Build a Simple Database：Writing a sqlite clone from scratch in C. 从零开始写数据库：500行代码实现 LSM 数据库 Use The Index, Luke!：A site explaining SQL indexing to developers. Linux Bash Advanced Bash-Scripting Guide Linux命令行与Shell脚本教程 explainshell.com Linux常用命令行小技巧 命令行的艺术 Linux Upskill Challenge 内核 Linux内核学习资料 Linux操作系统内核学习 Arch Linux 安装使用教程 Linux网络编程与加密 LinuxGuide：Linux系统配置、工具使用、脚本语法以及访问控制。 代码风格 Google Style Guides ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#计算机基础"},{"categories":["导航"],"content":" 计算机进阶 位运算 Bit Twiddling Hacks 正则表达式 Learn Regex the Easy Way RegExp Example：正则表达式实例搜集，通过实例来学习正则表达式。 Regex-vis：正则表达式可视化。 Regular Expression Tester and Visualizer Cheatsheet for regex syntaxes: Read Online 软件工程 《Software Engineering at Google》中文版 Awesome Software Architecture 设计模式 design-patterns-for-humans-cn: Design patterns for humans中文版 《设计模式：可复用面向对象软件的基础》学习笔记 图说设计模式 设计模式 Docker Docker Getting Started Tutorial: Docker入门。 区块链 区块链黑暗森林自救手册 音视频开发 《FFmpeg原理》 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#计算机进阶"},{"categories":["导航"],"content":" 求职面试 简历 vCard：Personal portfolio. FlowCV Make a Resume in LaTeX! How to Write a Kickass Resume CS-Notes： 在线 Coding Interview University： 中文 2021笔试面试题 Google’s Tech Dev Guide: grow your technical skills, supplement your coursework, and prepare for interviews. awesome-cs-books: 经典编程书籍大全，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试等 Career Guru99：Top Interview Questions and Answers. 扩展知识 这几种神级性能优化手段，你用过几个？ ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:6:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#求职面试"},{"categories":["导航"],"content":" AI","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#ai"},{"categories":["导航"],"content":" 博客 『A Course in Machine Learning』by Hal Daumé III AI算法工程师手册 AI on Ubuntu Platform：AI 实验环境搭建和深度学习算法。 《Neural Networks For Chess》 Brandon Rohrer’s Blog ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:1","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#博客"},{"categories":["导航"],"content":" 教程 Deep Learning Tuning Playbook：深度学习模型调优指南。 工业界的推荐系统 Modern Deep Learning Techniques Applied to Natural Language Processing 100 numpy exercises 《利用 Python 进行数据分析（第2版）》 GitBook 《Python for Data Analysis》代码 《Pandas Cookbook》 《Pandas Cookbook》代码 《简明的 TensorFlow 2》 | 在线 📅2021/07/15 🌟3484 30天吃掉那只TensorFlow2 ｜ GitBook 📅2021/05/27 🌟8855 TensorFlow 2.0 Tutorials 📅2020/09/23 🌟5993 20天吃掉那只Pytorch 20210704 深度学习500问 20210317 nlp-tutorial 20210502 Machine Learning for Beginners - A Curriculum 20210721 《Deep Learning》 《The Elements of Statistical Learning》中文版 《Interpretable machine learning》 | 在线 20210713 《动手学深度学习》李沐 | 在线 20210717 《神经网络与深度学习》邱锡鹏 | 在线 20210518 深度学习论文翻译 深度学习入门教程, 优秀文章 AiLearning: 机器学习：在线 机器学习原理：在线 Data-Science-Notes CS229 课程讲义中文翻译：在线 斯坦福大学2014（吴恩达）机器学习教程中文笔记：在线 《神经网络与深度学习》 邱锡鹏：在线 Deep Learning with PaddlePaddle：在线 Joyful-Pandas | 在线 20210331 User Guide — pandas pytorch handbook: 帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门。 【关于 NLP】那些你不知道的事 【关于 NLP】百问百答 Start Machine Learning in 2021: 2021 年开始和改进机器学习 (ML)、人工智能 (AI) 的完整指南，无需任何该领域的背景，并随时了解最新消息和最先进技术！ PyTorch 中文手册: 这是一本开源的书籍，目标是帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门。 【关于 NLP】 那些你不知道的事: 研读顶会论文，复现论文相关代码 PythonAiRoad Start Machine Learning in 2021: A complete guide to start and improve in machine learning (ML), artificial intelligence (AI) in 2021 without ANY background in the field and stay up-to-date with the latest news and state-of-the-art techniques! Best Resources to Learn Natural Language Processing in 2021 deepcourse: Deep Learning for Computer Vision, Read Online Machine Learning Crash Course: Google’s fast-paced, practical introduction to machine learning matplotlib/cheatsheets: Official Matplotlib cheat sheets ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:2","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#教程"},{"categories":["导航"],"content":" 论文 Paper Style Guide Papers With Code: The latest in Machine Learning. CVF Open Access Best Paper Awards in CS 卖萌屋学术站: 每日学术论文。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:3","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#论文"},{"categories":["导航"],"content":" 竞赛 阿里云天池 Kaggle The Kaggle Book ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:7:4","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#竞赛"},{"categories":["导航"],"content":" 网络安全 《CTF竞赛权威指南》 | GitBook TryHackMe Attack-Defense Online Lab XSS 挑战 CTF - Application Security Challenge Command Challenge Exploit Education Google CTF Hack The Box Defend the Web Hacksplaining Hacker101 CTF 未分类 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:8:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#网络安全"},{"categories":["导航"],"content":" 工具 DBER：数据库建表工具。 godeng：生成各种类型的测试数据。 RapidOCR (捷智OCR) F2：命令行批量重命名工具。 Gradio：Build Machine Learning Web Apps. Psyduck：XMind 记录 CS 基础问题。 ReallyConfused PptxGenJS: Create JavaScript PowerPoint Presentations SCI-Hub论文下载可用网址链接 企鹅论文 一键下载 WordTEX Learn LaTeX Darling: Darling is a runtime environment for macOS applications. scrcpy: 显示和控制您的 Android 设备。 Tesseract OCR: Tesseract 开源 OCR 引擎。 PDF.js: 使用 HTML5 构建的 PDF 查看器。 ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:9:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#工具"},{"categories":["导航"],"content":" 其他 HelloGitHub free-project-course: 整理和搜集网络免费的项目实战课程 Digital Privacy MockingBird: AI拟声，5秒内克隆您的声音并生成任意语音内容 LaTeX-OCR: pix2tex, Using a ViT to convert images of equations into LaTeX code Bifrost: Search for visual datasets by task, application, class, label or format Manim Community: Python library for creating mathematical animations SG-NLP: SG-NLP is an initiative by AI Singapore’s NLP Hub A Vim Guide For Experts PearOCR Diffgram: Training data platform for machine learning delivered as a single application Forecasting: Principles and Practice (3rd ed) Greykite: A flexible, intuitive and fast forecasting library flow-forecast: Deep learning PyTorch library for time series forecasting, classification, and anomaly detection Codeimg.io: Convert code to image Macast: A menu bar application using mpv as DLNA Media Renderer. You can push videos, pictures or musics from your mobile phone to your computer Real-time-stock-market-prediction: Server architecture for Real-time Stock-market prediction with ML Open Video Downloader (youtube-dl-gui): A cross-platform GUI for youtube-dl made in Electron and node.js Awesome Scriptable: A curated list of awesome Scriptable scripts and widgets THU-Beamer-Theme: A LaTeX beamer theme template for Tsinghua students, Read Online Versus: 万物皆可对比 Appscope: Progressive Web Apps Examples 英语语法网 中国人民大学英语口语能力标准 Pl@ntNet: 植物图像识别 Table Convert Online:table to markdown, csv, json, latex table, excel, sql, xml GitHub News: Discover the Top Trending Repos Academia: How to write academic essay 图吧工具箱 WallpaperHub 柯帕斯英语网 大耳朵英语 UP-6 英语学习导航 MangaPanda: Read manga online for free in English YouZack: 英语听力精听、背单词 scrcpy: This application provides display and control of Android devices connected on USB. ","date":"2021-04-14","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:10:0","series":null,"tags":["导航"],"title":"学习资料🔝","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/#其他"},{"categories":[],"content":" 字节跳动2022/9/18","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:1:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#字节跳动2022918"},{"categories":[],"content":" 1.金字塔 题目描述： $$ 1 \\le n \\le 5 \\times 10^5 \\newline 1 \\le \\sum{m} \\le 5 \\times 10^5 \\newline 0 \\le p_i \\le 10^9 $$ 用例 1 输入： 3 2 100 280 2 190 360 2 150 360 用例 1 输出： 4 用例 2 输入： 5 5 0 1000 2000 3010 3200 4 40 1050 2049 3100 1 80 1 120 1 160 用例 2 输出： 10 代码： package src.字节2022秋招0918.A; import java.io.File; import java.util.*; // 100% public class Main { public static void main(String[] args) throws Exception { // try (Scanner sc = new Scanner(System.in)) { try (Scanner sc = new Scanner(new File(\"src\\\\字节2022秋招0918\\\\A\\\\input\"))) { // 1 \u003c= n \u003c= 5 * 10^5 // 1 \u003c= sum(m) \u003c= 5 * 10^5 // 0 \u003c= pi \u003c= 10^9 int n = sc.nextInt(); List\u003cInteger\u003e sub = new ArrayList\u003c\u003e(n); // 下一层 int m = sc.nextInt(); while (m-- \u003e 0) { sub.add(sc.nextInt()); } int ans = sub.size(); for (int i = 1; i \u003c n; i++) { List\u003cInteger\u003e next = new ArrayList\u003c\u003e(); m = sc.nextInt(); int len = sub.size(); int j = 0; // 下一层指针 while (m-- \u003e 0) { int cur = sc.nextInt(); while (j \u003c len \u0026\u0026 sub.get(j) + 100 \u003c= cur) j++; if (j == len) continue; if (j + 1 \u003c len \u0026\u0026 sub.get(j + 1) - 100 \u003c cur \u0026\u0026 cur \u003c sub.get(j) + 100) { // 两块砖支撑 next.add(cur); ans++; } else { // 一块砖支撑 if (sub.get(j) - 50 \u003c cur \u0026\u0026 cur \u003c sub.get(j) + 50) { next.add(cur); ans++; } else if (j + 1 \u003c len \u0026\u0026 sub.get(j + 1) - 50 \u003c cur \u0026\u0026 cur \u003c sub.get(j + 1) + 50) { next.add(cur); ans++; } } } sub = next; } System.out.println(ans); } } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:1:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#1金字塔"},{"categories":[],"content":" 2.神奇序列 题目描述： 给定一个仅由 0 和 0 构成的字符串，称长度大于 2，且 0 和 1 间隔排列的字符串为“神奇序列”，求子串中“神奇序列”的最长长度。 用例 1 输入： 0101011101 用例 1 输出： 6 代码： package src.字节2022秋招0918.B; import java.io.File; import java.util.*; // 100% public class Main { public static void main(String[] args) throws Exception { // try (Scanner sc = new Scanner(System.in)) { try (Scanner sc = new Scanner(new File(\"src\\\\字节2022秋招0918\\\\B\\\\input\"))) { // n \u003e= 3 01相邻 神奇序列 String s = sc.next(); int n = s.length(); // dp[i] 表示以 s[i] 结尾的神奇序列的长度 int[] dp = new int[n]; Arrays.fill(dp, 1); int ans = 0; for (int i = 1; i \u003c n; i++) { int cur = s.charAt(i) - '0'; int pre = s.charAt(i - 1) - '0'; if (cur + pre == 1) { dp[i] = dp[i - 1] + 1; } if (dp[i] \u003e= 3) { ans = Math.max(ans, dp[i]); } } System.out.println(ans); } } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:1:2","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#2神奇序列"},{"categories":[],"content":" 3.ASDF 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： ADDF 用例 1 输出： 1 用例 2 输入： ASAFASAFADDD 用例 2 输出： 3 代码： package src.字节2022秋招0918.C; import java.io.File; import java.util.*; // 100% public class Main { public static void main(String[] args) throws Exception { // try (Scanner sc = new Scanner(System.in)) { try (Scanner sc = new Scanner(new File(\"src\\\\字节2022秋招0918\\\\C\\\\input\"))) { // n = 4k // n \u003c= 10^6 String s = sc.next(); int n = s.length(); // 出现次数 int ca, cs, cd, cf; ca = cs = cd = cf = 0; for (int i = 0; i \u003c n; i++) { char c = s.charAt(i); if (c == 'A') ca++; else if (c == 'S') cs++; else if (c == 'D') cd++; else if (c == 'F') cf++; } // 每个字符应该出现 n / 4 次，多余的次数 int t = n / 4; int da = Math.max(ca - t, 0); int ds = Math.max(cs - t, 0); int dd = Math.max(cd - t, 0); int df = Math.max(cf - t, 0); boolean ba = da == 0; boolean bs = ds == 0; boolean bd = dd == 0; boolean bf = df == 0; int ans = n; // 滑动窗口求满足出现次数 da ds dd df 的最小窗口长度 ca = cs = cd = cf = 0; int j = 0; for (int i = 0; i \u003c n; i++) { char c = s.charAt(i); if (c == 'A') ca++; else if (c == 'S') cs++; else if (c == 'D') cd++; else if (c == 'F') cf++; while (j \u003c i) { c = s.charAt(j); if (c == 'A') { if (!ba \u0026\u0026 ca \u003c= da) break; ca--; } else if (c == 'S') { if (!bs \u0026\u0026 cs \u003c= ds) break; cs--; } else if (c == 'D') { if (!bd \u0026\u0026 cd \u003c= dd) break; cd--; } else if (c == 'F') { if (!bf \u0026\u0026 cf \u003c= df) break; cf--; } j++; } if (ca \u003e= da \u0026\u0026 cs \u003e= ds \u0026\u0026 cd \u003e= dd \u0026\u0026 cf \u003e= df) { ans = Math.min(ans, i - j + 1); } } System.out.println(ans); } } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:1:3","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3asdf"},{"categories":[],"content":" 4.书柜 题目描述： $n$ 本书按顺序分成若干组，要求每组内书籍的高度差不超过 $k$，求组的最大容量、对应的组的数量、组中书的序号（从 1 开始）。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： 3 3 14 12 10 用例 1 输出： 2 2 1 2 2 3 用例 2 输入： 2 0 10 10 用例 2 输出： 2 1 1 2 用例 3 输入： 4 5 8 19 10 13 用例 3 输出： 2 1 3 4 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:1:4","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#4书柜"},{"categories":[],"content":" 京东2022/9/17","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:2:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#京东2022917"},{"categories":[],"content":" 1.12排列 题目描述： 输入a代表 1 的数量，b代表 2 的数量，要求排列后相邻数字的乘积为偶数，输出任意排列，以空格隔开，无法形成则输出 -1。 $$ 1 \\le a+b \\le 200000 , \\quad 0 \\le a,b \\le 200000 $$ 输入： 2 2 输出： 1 2 2 1 代码： package src.京东2022秋招0917.A; import java.io.File; import java.util.*; // 100% public class Main { public static void main(String[] args) throws Exception { // try (Scanner sc = new Scanner(System.in)) { try (Scanner sc = new Scanner(new File(\"src\\\\京东2022秋招0917\\\\A\\\\input\"))) { int a = sc.nextInt(); // 1 int b = sc.nextInt(); // 2 if (a \u003e b + 1) { System.out.println(-1); } else { int c = Math.min(a, b); while (c-- \u003e 0) { System.out.printf(\"1 2 \"); a--; b--; } while (a-- \u003e 0) { System.out.printf(\"1 \"); } while (b-- \u003e 0) { System.out.printf(\"2 \"); } } } } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:2:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#112排列"},{"categories":[],"content":" 2.前缀排列 题目描述： 长度为 $n$ 的排列，每次可以交换相邻的两个数，经过若干次交换后，前 $k$ 个数变为长度为 $k$ 的排列，求最小交换次数。 $$ 1 \\le k \\le n \\le 200000 , \\quad 1 \\le a_i \\le n $$ 输入： 5 3 2 4 1 3 5 输出： 2 代码： package src.京东2022秋招0917.B; import java.io.File; import java.util.*; // 100% public class Main { public static void main(String[] args) throws Exception { // try (Scanner sc = new Scanner(System.in)) { try (Scanner sc = new Scanner(new File(\"src\\\\京东2022秋招0917\\\\B\\\\input\"))) { // 1 \u003c= k \u003c= n \u003c= 200000 // 1 \u003c= a[i] \u003c= n int n = sc.nextInt(); int k = sc.nextInt(); int[] a = new int[n]; int[] idx = new int[n + 1]; // 存放下标 long ans = 0L; for (int i = 0; i \u003c n; i++) { a[i] = sc.nextInt(); idx[a[i]] = i; if (i \u003c k \u0026\u0026 a[i] \u003e k) ans -= i; // 需要被换出的元素 } for (int i = 1; i \u003c= k; i++) { if (idx[i] \u003e= k) { ans += idx[i]; // 需要被换入的元素 } } System.out.println(ans); } } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:2:2","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#2前缀排列"},{"categories":[],"content":" 3.漂亮串 题目描述： 称仅由小写字母组成，$red$ 至少出现一次，并且不能出现 $der$ 的字符串为“漂亮串”。求长度为 $n$ 的漂亮串的数量，对 $1000000007$ 取模。 $$ 1 \\le n \\le 10^5 $$ 输入： 4 输出： 52 代码： 京东9.17笔试第三题 ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:2:3","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3漂亮串"},{"categories":[],"content":" 蚂蚁2022/9/15蚂蚁笔试 研发岗 09.15 AC ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:3:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#蚂蚁2022915"},{"categories":[],"content":" A","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:3:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#a"},{"categories":[],"content":" B","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:3:2","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#b"},{"categories":[],"content":" 3.好串 题目描述： 称仅由小写字母组成，只有一个字符出现奇数次，其他字符出现偶数次的字符串为“好串”。求字符串的子串是好串的数量。 $$ 1 \\le n \\le 200000 $$ 输入： 7 输出： 78 代码： import java.util.*; public class Main { public static int maxCount(String s) { if (s == null || s.length() == 0) { return 0; } int status = 0; Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int ans = 0; map.put(0, 1); for (int i = 0; i \u003c s.length(); i++) { status = status ^ (1 \u003c\u003c (s.charAt(i) - 'a')); for (int j = 0; j \u003c 26; j++) { int tmp = status ^ (1 \u003c\u003c j); if (map.containsKey(tmp)) { ans += map.get(tmp); } } map.put(status, map.getOrDefault(status, 0) + 1); } return ans; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); System.out.println(maxCount(s)); } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:3:3","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3好串"},{"categories":[],"content":" 京东","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:4:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#京东"},{"categories":[],"content":" 3.漂亮串 题目描述： 称仅由小写字母组成，$red$ 至少出现两次的字符串为“漂亮串”。求长度为 $n$ 的漂亮串的数量，对 $1000000007$ 取模。 $$ 1 \\le n \\le 10^5 $$ 输入： 7 输出： 78 代码： import java.math.BigInteger; import java.util.*; public class Main { public static int MOD = 1000000007; public static long beautifulStr(int n) { long[] dp1 = new long[n + 1]; long[] dp2 = new long[n + 1]; if (n \u003c= 5) { return 0; } dp1[3] = 1; BigInteger mod = new BigInteger(String.valueOf(MOD)); for (int i = 4; i \u003c= n; i++) { // 计算26的(i-3)次幂，然后对MOD取余 BigInteger bigInteger = new BigInteger(\"26\"); BigInteger num = bigInteger.pow(i - 3); long result = num.mod(mod).longValue(); // dp1转移方程 dp1[i] = (result + 26 * dp1[i - 1] - dp1[i - 3] + MOD) % MOD; } for (int i = 4; i \u003c= n; i++) { // dp2转移方程 dp2[i] = (dp1[i - 3] + 26 * dp2[i - 1] - dp2[i - 3] + MOD) % MOD; } return dp2[n]; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(beautifulStr(n)); } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:4:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3漂亮串-1"},{"categories":[],"content":" 京东","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:5:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#京东-1"},{"categories":[],"content":" 3.漂亮串 题目描述： 称仅由小写字母组成，$red$ 至少出现两次的字符串为“漂亮串”。求长度为 $n$ 的漂亮串的数量，对 $1000000007$ 取模。 $$ 1 \\le n \\le 10^5 $$ 输入： 7 输出： 78 代码： import java.math.BigInteger; import java.util.*; public class Main { public static int MOD = 1000000007; public static long beautifulStr(int n) { long[] dp1 = new long[n + 1]; long[] dp2 = new long[n + 1]; if (n \u003c= 5) { return 0; } dp1[3] = 1; BigInteger mod = new BigInteger(String.valueOf(MOD)); for (int i = 4; i \u003c= n; i++) { // 计算26的(i-3)次幂，然后对MOD取余 BigInteger bigInteger = new BigInteger(\"26\"); BigInteger num = bigInteger.pow(i - 3); long result = num.mod(mod).longValue(); // dp1转移方程 dp1[i] = (result + 26 * dp1[i - 1] - dp1[i - 3] + MOD) % MOD; } for (int i = 4; i \u003c= n; i++) { // dp2转移方程 dp2[i] = (dp1[i - 3] + 26 * dp2[i - 1] - dp2[i - 3] + MOD) % MOD; } return dp2[n]; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(beautifulStr(n)); } } ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:5:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3漂亮串-2"},{"categories":[],"content":" 华为2022/9/14","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:6:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#华为2022914"},{"categories":[],"content":" 1. 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： ADDF 用例 1 输出： 1 用例 2 输入： ASAFASAFADDD 用例 2 输出： 3 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:6:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#1"},{"categories":[],"content":" 2. 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： ADDF 用例 1 输出： 1 用例 2 输入： ASAFASAFADDD 用例 2 输出： 3 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:6:2","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#2"},{"categories":[],"content":" 3.停车场 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： ADDF 用例 1 输出： 1 用例 2 输入： ASAFASAFADDD 用例 2 输出： 3 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:6:3","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3停车场"},{"categories":[],"content":" 华为2022/9/7","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:7:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#华为202297"},{"categories":[],"content":" 1.养猪场 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^9 $$ 用例 1 输入： 5 2 0 1 2 1 3 4 2 4 用例 1 输出： 3 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:7:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#1养猪场"},{"categories":[],"content":" 2.士兵 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： 3 3 SXE BXX BBB 用例 1 输出： 8 用例 2 输入： 6 6 SBBBBB BXXXXB BBXBBB XBBXXB BXBBXB BBXBEB 用例 2 输出： 13 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:7:2","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#2士兵"},{"categories":[],"content":" 3.停车场 题目描述： $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： 5 6 2 1 2 1 2 2 1 2 0 0 0 0 0 0 2 1 2 1 2 1 1 1 2 1 2 2 0 0 0 0 0 0 用例 1 输出： 2 1 2 2 1 2 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:7:3","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3停车场-1"},{"categories":[],"content":" 华为2022/8/31","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:8:0","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#华为2022831"},{"categories":[],"content":" 1. 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： ADDF 用例 1 输出： 1 用例 2 输入： ASAFASAFADDD 用例 2 输出： 3 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:8:1","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#1-1"},{"categories":[],"content":" 2. 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： ADDF 用例 1 输出： 1 用例 2 输入： ASAFASAFADDD 用例 2 输出： 3 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:8:2","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#2-1"},{"categories":[],"content":" 3.停车场 题目描述： 给定一个长度为 4 的倍数且仅由 $A$、$S$、$D$ 和 $F$ 构成的字符串，我们可以将某个子串中的字符进行任意修改（只能出现四种字符），满足整个字符串中四种字符的数量相等，求子串的最短长度。 $$ 0 \\le n \\le 10^6 $$ 用例 1 输入： ADDF 用例 1 输出： 1 用例 2 输入： ASAFASAFADDD 用例 2 输出： 3 代码： ","date":"2022-09-17","objectID":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/:8:3","series":null,"tags":["笔试题"],"title":"笔试题","uri":"/posts/%E7%AC%94%E8%AF%95%E9%A2%98/#3停车场-2"},{"categories":[],"content":" JWT","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#jwt"},{"categories":[],"content":" 什么是 JWT JWT（JSON Web Token）是一个开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，以 JSON 对象的形式在各方之间安全地传输信息。 JWT 是一个数字签名，生成的信息是可以验证并被信任的。 使用密钥（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对 JWT 进行签名。 JWT是目前最流行的跨域认证解决方案。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:1","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#什么是-jwt"},{"categories":[],"content":" JWT 令牌结构JWT 令牌以紧凑的形式由三部分组成，这些部分由点（.）分隔，分别是： Header Payload Signature xxxx.yyyy.zzzz HeaderHeader 通常由两部分组成：令牌的类型（即 JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）。 { \"alg\": \"HS256\", \"typ\": \"JWT\" } Header 会被 Base64 编码为 JWT 的第一部分。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 PayloadPayload 是有关实体（通常是用户）和其他数据的声明，它包含三部分： 注册声明。这些是一组预定义的权利要求，不是强制性的，而是建议使用的，以提供一组有用的可互操作的权利要求。其中一些是： iss（JWT的签发者）， exp（expires,到期时间）， sub（主题）， aud（JWT接收者），iat(issued at，签发时间)等。 公开声明。公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。 私有声明。私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 Base64 是对称解密的，意味着该部分信息可以归类为明文信息。 { \"iat\": 1593955943, \"exp\": 1593955973, \"uid\": 10, \"username\": \"test\", \"scopes\": [ \"admin\", \"user\" ] } Payload 会被 Base64 编码为 JWT 的第二部分。 eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE1OTM5NTU5NDMsInVpZCI6MTAsImV4cCI6MTU5Mzk1NTk3Mywic2NvcGVzIjpbImFkbWluIiwidXNlciJdfQ SignatureSignature 部分的生成需要 Base64 编码之后的 Header，Base64 编码之后的 Payload，密钥（secret），Header 需要指定签字的算法。 例如，如果要使用 HMAC SHA256 算法，则将通过以下方式创建签名： HS256(Base64(Header) + \".\" + Base64(Payload), secretKey) 整体 JWT = Base64(Header) + \".\" + Base64(Payload) + \".\" + $Signature 输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递这些字符串，与基于 XML 的标准（例如 SAML）相比，它更紧凑。 JWT 是无状态授权机制，服务器的受保护路由将 Header 中检查有效的 token，如果存在，则将允许用户访问受保护的资源。如果JWT 包含必要的数据，则可以减少查询数据库中某些操作的需求。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:2","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#jwt-令牌结构"},{"categories":[],"content":" JWT 令牌结构JWT 令牌以紧凑的形式由三部分组成，这些部分由点（.）分隔，分别是： Header Payload Signature xxxx.yyyy.zzzz HeaderHeader 通常由两部分组成：令牌的类型（即 JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）。 { \"alg\": \"HS256\", \"typ\": \"JWT\" } Header 会被 Base64 编码为 JWT 的第一部分。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 PayloadPayload 是有关实体（通常是用户）和其他数据的声明，它包含三部分： 注册声明。这些是一组预定义的权利要求，不是强制性的，而是建议使用的，以提供一组有用的可互操作的权利要求。其中一些是： iss（JWT的签发者）， exp（expires,到期时间）， sub（主题）， aud（JWT接收者），iat(issued at，签发时间)等。 公开声明。公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。 私有声明。私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 Base64 是对称解密的，意味着该部分信息可以归类为明文信息。 { \"iat\": 1593955943, \"exp\": 1593955973, \"uid\": 10, \"username\": \"test\", \"scopes\": [ \"admin\", \"user\" ] } Payload 会被 Base64 编码为 JWT 的第二部分。 eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE1OTM5NTU5NDMsInVpZCI6MTAsImV4cCI6MTU5Mzk1NTk3Mywic2NvcGVzIjpbImFkbWluIiwidXNlciJdfQ SignatureSignature 部分的生成需要 Base64 编码之后的 Header，Base64 编码之后的 Payload，密钥（secret），Header 需要指定签字的算法。 例如，如果要使用 HMAC SHA256 算法，则将通过以下方式创建签名： HS256(Base64(Header) + \".\" + Base64(Payload), secretKey) 整体 JWT = Base64(Header) + \".\" + Base64(Payload) + \".\" + $Signature 输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递这些字符串，与基于 XML 的标准（例如 SAML）相比，它更紧凑。 JWT 是无状态授权机制，服务器的受保护路由将 Header 中检查有效的 token，如果存在，则将允许用户访问受保护的资源。如果JWT 包含必要的数据，则可以减少查询数据库中某些操作的需求。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:2","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#header"},{"categories":[],"content":" JWT 令牌结构JWT 令牌以紧凑的形式由三部分组成，这些部分由点（.）分隔，分别是： Header Payload Signature xxxx.yyyy.zzzz HeaderHeader 通常由两部分组成：令牌的类型（即 JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）。 { \"alg\": \"HS256\", \"typ\": \"JWT\" } Header 会被 Base64 编码为 JWT 的第一部分。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 PayloadPayload 是有关实体（通常是用户）和其他数据的声明，它包含三部分： 注册声明。这些是一组预定义的权利要求，不是强制性的，而是建议使用的，以提供一组有用的可互操作的权利要求。其中一些是： iss（JWT的签发者）， exp（expires,到期时间）， sub（主题）， aud（JWT接收者），iat(issued at，签发时间)等。 公开声明。公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。 私有声明。私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 Base64 是对称解密的，意味着该部分信息可以归类为明文信息。 { \"iat\": 1593955943, \"exp\": 1593955973, \"uid\": 10, \"username\": \"test\", \"scopes\": [ \"admin\", \"user\" ] } Payload 会被 Base64 编码为 JWT 的第二部分。 eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE1OTM5NTU5NDMsInVpZCI6MTAsImV4cCI6MTU5Mzk1NTk3Mywic2NvcGVzIjpbImFkbWluIiwidXNlciJdfQ SignatureSignature 部分的生成需要 Base64 编码之后的 Header，Base64 编码之后的 Payload，密钥（secret），Header 需要指定签字的算法。 例如，如果要使用 HMAC SHA256 算法，则将通过以下方式创建签名： HS256(Base64(Header) + \".\" + Base64(Payload), secretKey) 整体 JWT = Base64(Header) + \".\" + Base64(Payload) + \".\" + $Signature 输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递这些字符串，与基于 XML 的标准（例如 SAML）相比，它更紧凑。 JWT 是无状态授权机制，服务器的受保护路由将 Header 中检查有效的 token，如果存在，则将允许用户访问受保护的资源。如果JWT 包含必要的数据，则可以减少查询数据库中某些操作的需求。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:2","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#payload"},{"categories":[],"content":" JWT 令牌结构JWT 令牌以紧凑的形式由三部分组成，这些部分由点（.）分隔，分别是： Header Payload Signature xxxx.yyyy.zzzz HeaderHeader 通常由两部分组成：令牌的类型（即 JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）。 { \"alg\": \"HS256\", \"typ\": \"JWT\" } Header 会被 Base64 编码为 JWT 的第一部分。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 PayloadPayload 是有关实体（通常是用户）和其他数据的声明，它包含三部分： 注册声明。这些是一组预定义的权利要求，不是强制性的，而是建议使用的，以提供一组有用的可互操作的权利要求。其中一些是： iss（JWT的签发者）， exp（expires,到期时间）， sub（主题）， aud（JWT接收者），iat(issued at，签发时间)等。 公开声明。公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。 私有声明。私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 Base64 是对称解密的，意味着该部分信息可以归类为明文信息。 { \"iat\": 1593955943, \"exp\": 1593955973, \"uid\": 10, \"username\": \"test\", \"scopes\": [ \"admin\", \"user\" ] } Payload 会被 Base64 编码为 JWT 的第二部分。 eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE1OTM5NTU5NDMsInVpZCI6MTAsImV4cCI6MTU5Mzk1NTk3Mywic2NvcGVzIjpbImFkbWluIiwidXNlciJdfQ SignatureSignature 部分的生成需要 Base64 编码之后的 Header，Base64 编码之后的 Payload，密钥（secret），Header 需要指定签字的算法。 例如，如果要使用 HMAC SHA256 算法，则将通过以下方式创建签名： HS256(Base64(Header) + \".\" + Base64(Payload), secretKey) 整体 JWT = Base64(Header) + \".\" + Base64(Payload) + \".\" + $Signature 输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递这些字符串，与基于 XML 的标准（例如 SAML）相比，它更紧凑。 JWT 是无状态授权机制，服务器的受保护路由将 Header 中检查有效的 token，如果存在，则将允许用户访问受保护的资源。如果JWT 包含必要的数据，则可以减少查询数据库中某些操作的需求。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:2","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#signature"},{"categories":[],"content":" JWT 令牌结构JWT 令牌以紧凑的形式由三部分组成，这些部分由点（.）分隔，分别是： Header Payload Signature xxxx.yyyy.zzzz HeaderHeader 通常由两部分组成：令牌的类型（即 JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）。 { \"alg\": \"HS256\", \"typ\": \"JWT\" } Header 会被 Base64 编码为 JWT 的第一部分。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 PayloadPayload 是有关实体（通常是用户）和其他数据的声明，它包含三部分： 注册声明。这些是一组预定义的权利要求，不是强制性的，而是建议使用的，以提供一组有用的可互操作的权利要求。其中一些是： iss（JWT的签发者）， exp（expires,到期时间）， sub（主题）， aud（JWT接收者），iat(issued at，签发时间)等。 公开声明。公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。 私有声明。私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 Base64 是对称解密的，意味着该部分信息可以归类为明文信息。 { \"iat\": 1593955943, \"exp\": 1593955973, \"uid\": 10, \"username\": \"test\", \"scopes\": [ \"admin\", \"user\" ] } Payload 会被 Base64 编码为 JWT 的第二部分。 eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE1OTM5NTU5NDMsInVpZCI6MTAsImV4cCI6MTU5Mzk1NTk3Mywic2NvcGVzIjpbImFkbWluIiwidXNlciJdfQ SignatureSignature 部分的生成需要 Base64 编码之后的 Header，Base64 编码之后的 Payload，密钥（secret），Header 需要指定签字的算法。 例如，如果要使用 HMAC SHA256 算法，则将通过以下方式创建签名： HS256(Base64(Header) + \".\" + Base64(Payload), secretKey) 整体 JWT = Base64(Header) + \".\" + Base64(Payload) + \".\" + $Signature 输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递这些字符串，与基于 XML 的标准（例如 SAML）相比，它更紧凑。 JWT 是无状态授权机制，服务器的受保护路由将 Header 中检查有效的 token，如果存在，则将允许用户访问受保护的资源。如果JWT 包含必要的数据，则可以减少查询数据库中某些操作的需求。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:2","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#整体"},{"categories":[],"content":" 什么时候使用 JWT 授权：一旦用户登录，每个后续请求将包括 JWT，从而允许用户访问该令牌允许的路由，服务和资源。单一登录是当今广泛使用 JWT 的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。这也是 JWT 最常见的方案。 信息交换：JWT 是各方之间安全地传输信息的好办法。对 JWT 进行签名，所以您可以确保发件人是他们所说的人。由于签名可以设置有效时长，所以可以验证内容是否遭到篡改。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:3","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#什么时候使用-jwt"},{"categories":[],"content":" 如何使用 JWT JWT 认证流程 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:4","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#如何使用-jwt"},{"categories":[],"content":" 用户登出，如何设置 token 无效？使用 redis 数据库，用户登出，从 redis 中删除对应的 token，请求访问时，需要从 redis 库中取出对应的 token，若没有，则表明已经登出。 ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:5","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#用户登出如何设置-token-无效"},{"categories":[],"content":" 不同设备，一个设备登出，其他设备如何处理？ 每一个设备与用户生成唯一的 key，保存在 redis 中，即设备 1 的用户登出，只删除对应的 token，设备 2 的 token 仍然存在 服务器端维护一个版本号，相同用户不同设备登入，版本号加1，这样保持key的唯一性（和上面差不多） ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:1:6","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#不同设备一个设备登出其他设备如何处理"},{"categories":[],"content":" 参考 JWT详解_baobao555#的博客-CSDN博客_jwt ","date":"2022-09-13","objectID":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":[],"title":"Java 项目面试","uri":"/posts/java-%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/#参考"},{"categories":["Redis"],"content":" 缓存穿透、缓存击穿、缓存雪崩使用缓存，一般是数据库中存储一份，缓存中复制一份。当收到请求，先从缓存查询数据，如果存在数据，直接返回缓存中的结果。如果缓存中没有数据，则去数据库中查询数据，同时复制到缓存中，然后返回结果。如果数据库中也没有数据，直接返回空。 缓存穿透： 原因：大量用户请求在缓存和数据库中都不存在的数据。 结果：所有的无效请求都会直接落到数据库上，导致数据库压力增大。 解决： 进行合法校验。可以有效拦截大部分不合法的请求。 使用布隆过滤器。不在布隆过滤器中的数据一定不存在，对于频繁更新的数据不适用。 对无效的请求也进行缓存，只是过期时间设置得较短，一般五分钟内。 缓存击穿： 原因：某数据的缓存突然失效，大量用户请求该数据。 结果：大量请求直接落到数据库上，导致数据库压力增大。 解决： 如果是热点数据，可以考虑设置永远不过期。 当数据过期后，设置一个互斥锁，只让一个请求通过，去数据库查询数据并更新缓存。不管结果如何都需要释放锁，否则其他线程会一直等待。 public static String getProductDescById(String id) { String desc = null; int count = 0; // 自旋次数 while (count \u003c 5) { // 设置最大自旋次数，减少资源占用 desc = redis.get(id); // 查询缓存 if (desc == null) { // 缓存为空，已过期 // 互斥锁，只有一个请求可以成功 if (redis.setnx(lock_id, 1, 60) == 1) { try { desc = getFromDB(id); // 查询数据库 redis.set(id, desc, 60 * 60 * 24); // 更新缓存 } catch (Exception e) { LogHelper.error(e); } finally { redis.del(lock_id); // 必须释放锁 return desc; } } else { Thread.sleep(200); // 200ms 自旋一次 count++; } } else { break; } } return desc; } 缓存雪崩： 原因：大量缓存同时或短时间内失效。 结果：大量请求直接落到数据库上，导致数据库压力增大。 解决： 如果是热点数据，可以考虑设置永远不过期。 缓存的过期时间可以考虑设置一定范围内的随机值，有效防止大量缓存同时过期。 设置 Redis 服务器集群。 双缓存。A 设置过期时间，B 不设置过期时间，当 A 中缓存失效时查询 B，同时更新 A，但是更新数据库时需要同步更新两个缓存。 redis.set(id, value, 60 * 60 + Math.random() * 1000); // 设置一定范围内的随机值 ","date":"2022-09-13","objectID":"/posts/redis-%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":["Redis"],"title":"Redis 面试","uri":"/posts/redis-%E9%9D%A2%E8%AF%95/#缓存穿透缓存击穿缓存雪崩"},{"categories":["Redis"],"content":" 分布式锁锁的作用是保证多个进程或线程在并发操作共享资源时资源的正确性。在分布式应用中，一个服务需要部署多个实例，对于操作分布式环境下的共享资源，就需要使用分布式锁来保证操作的正确性。 分布式锁应该具有互斥、可重入、锁超时，高可用等特点。其中前面几个特点和本地锁具体的特点相同，高可用是分布式锁需要具备的重要的特点。 单节点实现： 加锁过程要保证原子性。 保证谁加的锁只能被谁解锁。 设置锁超时时间，防止加锁方异常无法释放锁时其他客户端无法获取锁，同时，超时时间要大于业务处理时间。 多节点实现： RedLock 算法：让客户端和多个独立的Redis实例依次请求加锁，如果能和半数以上的实例加锁成功，就可认为客户端获取分布式锁成功。 ","date":"2022-09-13","objectID":"/posts/redis-%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":["Redis"],"title":"Redis 面试","uri":"/posts/redis-%E9%9D%A2%E8%AF%95/#分布式锁"},{"categories":[],"content":" 数据库","date":"2022-09-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":["数据库"],"title":"数据库 面试","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/#数据库"},{"categories":[],"content":" 数据库范式 1NF(第一范式)：属性不可再分。 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。即新增了主键列。 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖。即删除依赖于其他属性的列。 ","date":"2022-09-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/:1:1","series":["面试"],"tags":["数据库"],"title":"数据库 面试","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/#数据库范式"},{"categories":[],"content":" SQL","date":"2022-09-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":["数据库"],"title":"数据库 面试","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/#sql"},{"categories":[],"content":" SQL 语句分类 DDL: Data Definition Language。创建和修改数据库中数据库对象的结构。一般用户通常不使用这些命令，他们应该通过应用程序访问数据库。 CREATE: This command is used to create the database or its objects (like table, index, function, views, store procedure, and triggers). DROP: This command is used to delete objects from the database. ALTER: This is used to alter the structure of the database. TRUNCATE: This is used to remove all records from a table, including all spaces allocated for the records are removed. COMMENT: This is used to add comments to the data dictionary. RENAME: This is used to rename an object existing in the database. DQL: Data Query Language SELECT: It is used to retrieve data from the database. DML: Data Manipulation Language INSERT: It is used to insert data into a table. UPDATE: It is used to update existing data within a table. DELETE: It is used to delete records from a database table. LOCK: Table control concurrency. CALL: Call a PL/SQL or JAVA subprogram. EXPLAIN PLAN: It describes the access path to data. DCL: Data Control Language GRANT: This command gives users access privileges to the database. REVOKE: This command withdraws the user’s access privileges given by using the GRANT command. TCL: Transaction Control Language. COMMIT: Commits a Transaction. ROLLBACK: Rollbacks a transaction in case of any error occurs. SAVEPOINT: Sets a savepoint within a transaction. SET TRANSACTION: Specify characteristics for the transaction. ","date":"2022-09-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/:2:1","series":["面试"],"tags":["数据库"],"title":"数据库 面试","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/#sql-语句分类"},{"categories":[],"content":" drop、delete 与 truncate 区别 drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。 truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。 delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。 truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。 ","date":"2022-09-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/:2:2","series":["面试"],"tags":["数据库"],"title":"数据库 面试","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95/#dropdelete-与-truncate-区别"},{"categories":["算法"],"content":" 排列数$A_n^m$ 表示从 $n$ 个不同的数字中选择 $m$ 个数字，有序排列，不同排列的数量。 $$ \\begin{aligned} \\newline A_n^0 \u0026= 1 \\newline A_n^1 \u0026= n \\newline A_n^n \u0026= n(n-1)(n-2) \\cdots 1 = n! \\newline A_n^m \u0026= n(n-1)(n-2) \\cdots (n-m+1) = \\frac{n!}{(n-m)!} = \\frac{A_n^n}{A_{n-m}^{n-m}} \\newline A_n^m \u0026= n A_{n-1}^{m-1} \\newline A_n^m \u0026= m A_{n-1}^{m-1} + A_{n-1}^m \\newline \\newline \\end{aligned} $$ ","date":"2022-09-07","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/:1:0","series":null,"tags":["算法","排列","组合"],"title":"算法-排列组合数","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/#排列数"},{"categories":["算法"],"content":" 组合数","date":"2022-09-07","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/:2:0","series":null,"tags":["算法","排列","组合"],"title":"算法-排列组合数","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/#组合数"},{"categories":["算法"],"content":" 公式$C_n^m$ 表示从 $n$ 个不同的数字中选择 $m$ 个数字，无序，不同选择的数量。 $$ \\begin{aligned} \\newline C_n^0 \u0026= C_n^n = 1 \\newline C_n^1 \u0026= n \\newline C_n^m \u0026= C_n^{n-m} \\newline C_n^m \u0026= \\frac{n(n-1) \\cdots (n-m+1)}{m(m-1) \\cdots 1} = \\frac{A_n^m}{A_m^m} = \\frac{n!}{m!(n-m)!} = \\frac{A_n^n}{A_m^m A_{n-m}^{n-m}} \\newline C_n^{n-m} \u0026= \\frac{n(n-1) \\cdots (m+1)}{(n-m)(n-m+1) \\cdots 1} \\newline C_n^m \u0026= C_{n-1}^m + C_{n-1}^{m-1} \\newline 2^n \u0026= C_n^0 + C_n^1 + \\cdots + C_n^n \\newline \\newline \\end{aligned} $$ ","date":"2022-09-07","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/:2:1","series":null,"tags":["算法","排列","组合"],"title":"算法-排列组合数","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/#公式"},{"categories":["算法"],"content":" 实现 static long combination(int n, int m) { // C(n, m) m = Math.max(m, n - m); // C(n, m) = C(n, n - m) long ans = 1L; for (int i = 1; i \u003c= n - m; i++) { ans *= m + i; ans /= i; } return ans; } ","date":"2022-09-07","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/:2:2","series":null,"tags":["算法","排列","组合"],"title":"算法-排列组合数","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/#实现"},{"categories":["算法"],"content":" 计算 捆绑法：n 个不同元素的排列数，要求其中 m 个元素必须相邻。$A_{m}^{m} A_{n-m+1}^{n-m+1}$ 插空法：n 个不同元素的排列数，要求其中 m 个元素不能相邻。$A_{n-m}^{n-m} A_{n-m+1}^m$ 缩倍法：n 个不同元素的排列数，要求固定其中 m 个元素的顺序。$A_n^n / A_m^m$ 隔板法：n 个相同元素分成 m 组的不同划分方法，每组不为空。$C_{n-1}^{m-1}$ ","date":"2022-09-07","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/:3:0","series":null,"tags":["算法","排列","组合"],"title":"算法-排列组合数","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/#计算"},{"categories":["算法"],"content":" 参考 关于排列组合的一个总结 - 知乎 ","date":"2022-09-07","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/:4:0","series":null,"tags":["算法","排列","组合"],"title":"算法-排列组合数","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0/#参考"},{"categories":["工具"],"content":" 前置 安装 FFmpeg。 choco install ffmpeg-full ","date":"2022-09-03","objectID":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["工具"],"title":"视频下载教程","uri":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/#前置"},{"categories":["工具"],"content":" LuxGithub，支持 Bilibili、YouTube 等。 安装。 go install github.com/iawia002/lux@latest 查看视频的所有分辨率，记住对应分辨率的id。 lux -i \u003curl\u003e 根据id下载指定分辨率的视频。 lux -f \u003cid\u003e \u003curl\u003e 指定 cookie 视频的所有分辨率。 lux -c \"\u003ccookie\u003e\" -i \u003curl\u003e 指定 cookie 下载指定分辨率的视频。 lux -c \"\u003ccookie\u003e\" -f \u003cid\u003e \u003curl\u003e ","date":"2022-09-03","objectID":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["工具"],"title":"视频下载教程","uri":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/#lux"},{"categories":["工具"],"content":" youtube-dlGithub，支持 Bilibili、YouTube 等。 安装。 pip install -U youtube-dl # mac only brew install youtube-dl 查看。 # 列出所有清晰度和格式 youtube-dl -F \u003curl\u003e # 列出所有字幕 youtube-dl --list-subs \u003curl\u003e 下载。 # 下载最佳质量 youtube-dl -f bestvideo+bestaudio \u003curl\u003e # cookies youtube-dl --cookies \u003ccookies.txt\u003e -f bestvideo+bestaudio \u003curl\u003e # 下载英文（en）字幕，格式为 srt youtube-dl --sub-lang en --write-auto-sub --sub-format srt --skip-download \u003curl\u003e ","date":"2022-09-03","objectID":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["工具"],"title":"视频下载教程","uri":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/#youtube-dl"},{"categories":["工具"],"content":" you-getGithub，支持 Bilibili、YouTube 等。 安装。 pip install -U you-get 查看。 # 查看所有可选质量与格式 you-get -i/--info \u003cURL\u003e 下载。 # 自定义下载文件路径和名称 you-get -o \u003cpath\u003e \u003curl\u003e you-get -O \u003cfilename\u003e \u003curl\u003e # cookies you-get -c \u003ccookies.txt\u003e \u003curl\u003e ","date":"2022-09-03","objectID":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["工具"],"title":"视频下载教程","uri":"/posts/%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/#you-get"},{"categories":["力扣"],"content":"646. 最长数对链 ","date":"2022-09-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/:0:0","series":null,"tags":["力扣","动态规划","DP","贪心"],"title":"力扣 0646 🟨最长数对链","uri":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/#"},{"categories":["力扣"],"content":" 动态规划 $dp[i]$ 表示以 $pairs[i]$ 结尾的最长数对链的长度。 时间复杂度：$ O(n^2) $ class Solution { public int findLongestChain(int[][] pairs) { int n = pairs.length; int[] dp = new int[n]; Arrays.sort(pairs, (a, b) -\u003e a[0] - b[0]); for (int i = 0; i \u003c n; i++) { int maxLen = 0; for (int j = 0; j \u003c i; j++) if (pairs[j][1] \u003c pairs[i][0]) maxLen = Math.max(maxLen, dp[j]); dp[i] = maxLen + 1; } return dp[n - 1]; } } ","date":"2022-09-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/:1:0","series":null,"tags":["力扣","动态规划","DP","贪心"],"title":"力扣 0646 🟨最长数对链","uri":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/#动态规划"},{"categories":["力扣"],"content":" 动态规划 $dp[i]$ 表示长度为 $i + 1$ 的数对链的末尾最小数字。 时间复杂度：$ O(n \\log n) $ class Solution { public int findLongestChain(int[][] pairs) { int n = pairs.length; int[] dp = new int[n]; Arrays.fill(dp, Integer.MAX_VALUE); int ans = 0; Arrays.sort(pairs, (a, b) -\u003e a[0] - b[0]); for (int[] p : pairs) { // 查找第一个大于等于 p[0] 的下标 int l = 0; int r = n; while (l \u003c r) { int m = l + (r - l) / 2; if (dp[m] \u003e= p[0]) r = m; else l = m + 1; } dp[l] = Math.min(dp[l], p[1]); ans = Math.max(ans, l + 1); } return ans; } } ","date":"2022-09-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/:2:0","series":null,"tags":["力扣","动态规划","DP","贪心"],"title":"力扣 0646 🟨最长数对链","uri":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/#动态规划-1"},{"categories":["力扣"],"content":" 贪心 每次选择第二个数字更小的数对加入数对链。 时间复杂度：$ O(n \\log n) $ class Solution { public int findLongestChain(int[][] pairs) { Arrays.sort(pairs, (a, b) -\u003e a[0] - b[0]); int[] pre = pairs[0]; int ans = 1; for (int[] p : pairs) { if (pre[1] \u003c p[0] || pre[1] \u003e p[1]) { if (pre[1] \u003c p[0]) ans++; pre = p; } } return ans; } } class Solution { public int findLongestChain(int[][] pairs) { // 最长数对链的末尾最小数字。 int tail = Integer.MIN_VALUE; int ans = 0; Arrays.sort(pairs, (a, b) -\u003e a[1] - b[1]); for (int[] p : pairs) { if (tail \u003c p[0]) { tail = p[1]; ans++; } } return ans; } } ","date":"2022-09-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/:3:0","series":null,"tags":["力扣","动态规划","DP","贪心"],"title":"力扣 0646 🟨最长数对链","uri":"/posts/%E5%8A%9B%E6%89%A3-0646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/#贪心"},{"categories":["力扣"],"content":"421. 数组中两个数的最大异或值 class Solution { public int findMaximumXOR(int[] nums) { int ans = 0; Trie trie = new Trie(); for (int x : nums) { trie.add(x); ans = Math.max(ans, x ^ trie.find(x)); } return ans; } } class Trie { static class Node { Node left, right; } private Node root = new Node(); public void add(int x) { Node p = root; for (int i = 31; i \u003e= 0; i--) { boolean left = (x \u0026 (1 \u003c\u003c i)) \u003e 0; if (left) { if (p.left == null) p.left = new Node(); p = p.left; } else { if (p.right == null) p.right = new Node(); p = p.right; } } } public int find(int x) { Node p = root; int ans = 0; for (int i = 31; i \u003e= 0; i--) { boolean left = (x \u0026 (1 \u003c\u003c i)) \u003e 0; if (left \u0026\u0026 p.right != null || !left \u0026\u0026 p.left == null) { p = p.right; ans \u003c\u003c= 1; } else { p = p.left; ans = (ans \u003c\u003c 1) | 1; } } return ans; } } ","date":"2022-09-02","objectID":"/posts/%E5%8A%9B%E6%89%A3-0421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/:0:0","series":null,"tags":["力扣","位运算","Trie","字典树"],"title":"力扣 0421 数组中两个数的最大异或值","uri":"/posts/%E5%8A%9B%E6%89%A3-0421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/#"},{"categories":["Redis"],"content":" 安装 curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg echo \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/redis.list sudo apt-get update sudo apt-get install redis sudo service redis-server start redis-cli ","date":"2022-08-31","objectID":"/posts/redis-%E6%95%99%E7%A8%8B/:1:0","series":["面试"],"tags":["Redis"],"title":"Redis 教程","uri":"/posts/redis-%E6%95%99%E7%A8%8B/#安装"},{"categories":["Redis"],"content":" 基础","date":"2022-08-31","objectID":"/posts/redis-%E6%95%99%E7%A8%8B/:2:0","series":["面试"],"tags":["Redis"],"title":"Redis 教程","uri":"/posts/redis-%E6%95%99%E7%A8%8B/#基础"},{"categories":["Redis"],"content":" 数据类型 Key string：字符串。任意值都可以作为 key，包括字符串、整数、图片、视频、空字符串等。最大 512M。 Value string：字符串。任意值都可以作为 key，包括字符串、整数、图片、视频、空字符串等。最大 512M。 list：双向链表。 ","date":"2022-08-31","objectID":"/posts/redis-%E6%95%99%E7%A8%8B/:2:1","series":["面试"],"tags":["Redis"],"title":"Redis 教程","uri":"/posts/redis-%E6%95%99%E7%A8%8B/#数据类型"},{"categories":["Redis"],"content":" 字符串操作命令 set/get/getset/mset/mget：存取命令。 # 赋值 set \u003cKEY\u003e \u003cVALUE\u003e # 取值，空返回 nil get \u003cKEY\u003e # 空才赋值 set \u003cKEY\u003e \u003cVALUE\u003e nx # 非空才赋值 set \u003cKEY\u003e \u003cVALUE\u003e xx # 赋值并返回原值 getset \u003cKEY\u003e \u003cVALUE\u003e # 同时赋值多个 key mset \u003cKEY1\u003e \u003cVALUE1\u003e \u003cKEY2\u003e \u003cVALUE2\u003e ... # 同时取值多个 key mget \u003cKEY1\u003e \u003cKEY2\u003e ... incr/incrby/decr/decrby：加减命令，原子操作。 # 自增 1 incr \u003cKEY\u003e # 加 N incrby \u003cKEY\u003e \u003cN\u003e # 自减 1 decr \u003cKEY\u003e # 减 N decrby \u003cKEY\u003e \u003cN\u003e exists/del/type：判断 key。 # key 存在返回 1，否则返回 0 exists \u003cKEY\u003e # 删除 key，成功返回 1，失败返回 0 del \u003cKEY\u003e # 返回 value 类型，不存在返回 none type \u003cKEY\u003e expire/ttl/pexpire/pttl/persist：key 自动失效。 # 设置/更新存活时间，单位秒，精度毫秒 expire \u003cKEY\u003e \u003cTIME\u003e # 赋值，同时设置/更新存活时间，单位秒，精度毫秒 set \u003cKEY\u003e \u003cVALUE\u003e ex \u003cTIME\u003e # 返回剩余存活时间，单位秒，已失效返回 -2，永久保存返回 -1 ttl \u003cKEY\u003e # 设置/更新存活时间，单位毫秒 pexpire \u003cKEY\u003e \u003cTIME\u003e # 赋值，同时设置/更新存活时间，单位毫秒 set \u003cKEY\u003e \u003cVALUE\u003e px \u003cTIME\u003e # 返回剩余存活时间，单位毫秒，已失效返回 -2，永久保存返回 -1 pttl \u003cKEY\u003e # 去除存活时间，永久保存，成功返回 1，失败返回 0 persist \u003cKEY\u003e ","date":"2022-08-31","objectID":"/posts/redis-%E6%95%99%E7%A8%8B/:2:2","series":["面试"],"tags":["Redis"],"title":"Redis 教程","uri":"/posts/redis-%E6%95%99%E7%A8%8B/#字符串操作命令"},{"categories":["Redis"],"content":" 双向链表操作命令 lpush/rpush：添加。 # 左侧添加 lpush \u003cLIST\u003e \u003cVALUE1\u003e \u003cVALUE2\u003e ... # 右侧添加 rpush \u003cLIST\u003e \u003cVALUE1\u003e \u003cVALUE2\u003e ... lpop/rpop：删除。 # 左侧删除，空返回 nil lpop \u003cLIST\u003e # 右侧删除，空返回 nil rpop \u003cLIST\u003e lrange：遍历。 # 返回列表 [start, end] 范围内的元素，start 和 end 可以取负数，-1 表示最后一个元素 # 空返回 empty array lrange \u003cLIST\u003e \u003cSTART\u003e \u003cEND\u003e # 返回整个列表的值，空返回 empty array lrange \u003cLIST\u003e 0 -1 ltrim：截取。 # 截取列表 [start, end] 范围内的元素 ltrim \u003cLIST\u003e \u003cSTART\u003e \u003cEND\u003e ","date":"2022-08-31","objectID":"/posts/redis-%E6%95%99%E7%A8%8B/:2:3","series":["面试"],"tags":["Redis"],"title":"Redis 教程","uri":"/posts/redis-%E6%95%99%E7%A8%8B/#双向链表操作命令"},{"categories":["Redis"],"content":" 参考 Redis data types tutorial | Redis ","date":"2022-08-31","objectID":"/posts/redis-%E6%95%99%E7%A8%8B/:3:0","series":["面试"],"tags":["Redis"],"title":"Redis 教程","uri":"/posts/redis-%E6%95%99%E7%A8%8B/#参考"},{"categories":[],"content":" 关键字 数据类型（9）：boolean、byte、char、short、int、long、float、double、void 保留数值（3）：null、true、false 循环语句（6）：while、do、for、continue、break、goto 分支语句（5）：if、else、switch、case、default 其他语句（3）：instanceof、assert、return 访问限制（3）：public、protected、private 其他修饰（4）：static、final、abstract、native 异常处理（5）：try、catch、finally、throw、throws 面向对象（8）：class、interface、enum、extends、implements、this、super、new 包（2）：package、import 多线程（3）：volatile、synchronized、transient 保留关键字（2）：const, strictfp 关键字不能作为变量名。 变量名只能以字母、_和$开始。 变量名只能包含数字、字母、_和$。 内部保留关键字：_。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#关键字"},{"categories":[],"content":" 数值","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#数值"},{"categories":[],"content":" Math.abs(Integer.MIN_VALUE) Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE; ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:2:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#mathabsintegermin_value"},{"categories":[],"content":" 1 / 0 和 1 / 0.0 的区别？ 1 / 0 抛出 java.lang.ArithmeticException: / by zero 异常。 1 / 0.0 返回 Infinity。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:2:2","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#1--0-和-1--00-的区别"},{"categories":[],"content":" 容器 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#容器"},{"categories":[],"content":" ArrayList 扩容机制 ArrayList()使用长度为 0 的数组，第一次扩容时至少为 10。 ArrayList(int initialCapacity)使用指定容量大小的数组。 ArrayList(Collection\u003c? extends E\u003e c)使用 c 的大小作为数组容量。 add(E e)首次扩容为 10（无参初始化），之后每次存满时扩容为当前容量的 1.5 倍，向下取整。 使用无参构造方法初始化时，第一次扩容为10，之后每次扩容为size + (size \u003e\u003e 1)。 使用有参构造方法初始化时，第一次扩容为1，之后每次扩容为Math.max(size + (size \u003e\u003e 1), size + 1)。 addAll(Collection\u003c? extends E\u003e c)：剩余空间不够时，扩容为当前容量的 1.5 倍和加上 c 的元素后的元素数量的更大值。 使用无参构造方法初始化时，第一次扩容为Math.max(10, c.size())，之后每次扩容为Math.max(length + (length \u003e\u003e 1), size + c.size())。 使用有参构造方法初始化时，第一次扩容为size + c.size()，之后每次扩容为Math.max(length + (length \u003e\u003e 1), size + c.size())。 protected transient int modCount = 0; // 修改次数，继承自 AbstractList private static final int DEFAULT_CAPACITY = 10; // 默认容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 最大容量 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 空数组，无参构造器使用 private static final Object[] EMPTY_ELEMENTDATA = {}; // 空数组，其他情况使用 transient Object[] elementData; // 存储元素 private int size; // 已存储元素数量 public ArrayList() { // 共享空数组 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { // 使用指定容量创建数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 共享空数组 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } public ArrayList(Collection\u003c? extends E\u003e c) { Object[] a = c.toArray(); size = a.length; if (size != 0) { if (c.getClass() == ArrayList.class) elementData = a; else elementData = Arrays.copyOf(a, size, Object[].class); } else // 共享空数组 elementData = EMPTY_ELEMENTDATA; } public boolean add(E e) { modCount++; add(e, elementData, size); return true; } public boolean addAll(Collection\u003c? extends E\u003e c) { Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData = this.elementData; final int s = size; if (numNew \u003e elementData.length - s) // 剩余容量不够，扩容到至少 size + c.size() elementData = grow(s + numNew); System.","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#arraylist"},{"categories":[],"content":" ArrayList 扩容机制 ArrayList()使用长度为 0 的数组，第一次扩容时至少为 10。 ArrayList(int initialCapacity)使用指定容量大小的数组。 ArrayList(Collection\u003c? extends E\u003e c)使用 c 的大小作为数组容量。 add(E e)首次扩容为 10（无参初始化），之后每次存满时扩容为当前容量的 1.5 倍，向下取整。 使用无参构造方法初始化时，第一次扩容为10，之后每次扩容为size + (size \u003e\u003e 1)。 使用有参构造方法初始化时，第一次扩容为1，之后每次扩容为Math.max(size + (size \u003e\u003e 1), size + 1)。 addAll(Collection\u003c? extends E\u003e c)：剩余空间不够时，扩容为当前容量的 1.5 倍和加上 c 的元素后的元素数量的更大值。 使用无参构造方法初始化时，第一次扩容为Math.max(10, c.size())，之后每次扩容为Math.max(length + (length \u003e\u003e 1), size + c.size())。 使用有参构造方法初始化时，第一次扩容为size + c.size()，之后每次扩容为Math.max(length + (length \u003e\u003e 1), size + c.size())。 protected transient int modCount = 0; // 修改次数，继承自 AbstractList private static final int DEFAULT_CAPACITY = 10; // 默认容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 最大容量 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 空数组，无参构造器使用 private static final Object[] EMPTY_ELEMENTDATA = {}; // 空数组，其他情况使用 transient Object[] elementData; // 存储元素 private int size; // 已存储元素数量 public ArrayList() { // 共享空数组 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { // 使用指定容量创建数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 共享空数组 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } public ArrayList(Collection\u003c? extends E\u003e c) { Object[] a = c.toArray(); size = a.length; if (size != 0) { if (c.getClass() == ArrayList.class) elementData = a; else elementData = Arrays.copyOf(a, size, Object[].class); } else // 共享空数组 elementData = EMPTY_ELEMENTDATA; } public boolean add(E e) { modCount++; add(e, elementData, size); return true; } public boolean addAll(Collection\u003c? extends E\u003e c) { Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData = this.elementData; final int s = size; if (numNew \u003e elementData.length - s) // 剩余容量不够，扩容到至少 size + c.size() elementData = grow(s + numNew); System.","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#扩容机制"},{"categories":[],"content":" ArrayList 和 LinkedList ArrayList 线程不安全。 底层数组实现，需要分配连续空间。 可根据索引访问。实现了RandomAccess接口。 尾部插入/删除性能高；越靠近首部，插入/删除性能越低，因为需要移动元素。 因为是连续空间，所以可以利用缓存，实现高效访问。 LinkedList 线程不安全。 底层双向链表实现，元素不需要连续存储。 不能根据索引访问。 头部/尾部的插入/删除性能高；越靠近中间，插入/删除性能越低，需要遍历找到对应元素。 结点除了存储元素，还需要存储前/后指针，占用内存多。 public interface RandomAccess {} // ArrayList public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements RandomAccess { transient Object[] elementData; private int size; public E get(int index) { Objects.checkIndex(index, size); return elementData(index); } E elementData(int index) { return (E) elementData[index]; } public E remove(int index) { Objects.checkIndex(index, size); final Object[] es = elementData; E oldValue = (E) es[index]; fastRemove(es, index); return oldValue; } private void fastRemove(Object[] es, int i) { modCount++; final int newSize = size - 1; if (newSize \u003e i) // 移动元素 System.arraycopy(es, i + 1, es, i, newSize - i); size = newSize; es[size] = null; } } // LinkedList public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e { transient int size = 0; transient Node\u003cE\u003e first; transient Node\u003cE\u003e last; private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } public E getFirst() { final Node\u003cE\u003e f = first; if (f == null) throw new NoSuchElementException(); return f.item; } public E getLast() { final Node\u003cE\u003e l = last; if (l == null) throw new NoSuchElementException(); return l.item; } public E get(int index) { checkElementIndex(index); return node(index).item; } public void addFirst(E e) { linkFirst(e); } public void addLast(E e) { linkLast(e); } public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); } public E set(int index, E element) { checkElementIndex(index); Node\u003cE\u003e x = node(index); E oldVal = x.item; x.item = element; return oldVal; } public E removeFirst() { final Node\u003cE\u003e f = first; if (f == null) throw new NoSuchElementExcept","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:2","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#arraylist-和-linkedlist"},{"categories":[],"content":" HashMap public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e { static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16 static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; transient Node\u003cK,V\u003e[] table; transient int size; transient int modCount; int threshold; final float loadFactor; static class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { final int hash; final K key; V value; Node\u003cK,V\u003e next; Node(int hash, K key, V value, Node\u003cK,V\u003e next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry\u003c?, ?\u003e e = (Map.Entry\u003c?, ?\u003e) o; if (Objects.equals(key, e.getKey()) \u0026\u0026 Objects.equals(value, e.getValue())) return true; } return false; } } public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003c 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity \u003e MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } static final int tableSizeFor(int cap) { // 扩容为 2 的次方 int n = -1 \u003e\u003e\u003e Integer.numberOfLeadingZeros(cap - 1); return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { if (key == null) return 0; int h","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:3","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#hashmap"},{"categories":[],"content":" HashMap public class HashMap extends AbstractMap { static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16 static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; transient Node[] table; transient int size; transient int modCount; int threshold; final float loadFactor; static class Node implements Map.Entry { final int hash; final K key; V value; Node next; Node(int hash, K key, V value, Node next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry\u003c?, ?\u003e e = (Map.Entry\u003c?, ?\u003e) o; if (Objects.equals(key, e.getKey()) \u0026\u0026 Objects.equals(value, e.getValue())) return true; } return false; } } public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003c 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity \u003e MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } static final int tableSizeFor(int cap) { // 扩容为 2 的次方 int n = -1 \u003e\u003e\u003e Integer.numberOfLeadingZeros(cap - 1); return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { if (key == null) return 0; int h","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:3","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#为什么-hashmap-的大小是-2-的幂次方"},{"categories":[],"content":" HashMap public class HashMap extends AbstractMap { static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16 static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; transient Node[] table; transient int size; transient int modCount; int threshold; final float loadFactor; static class Node implements Map.Entry { final int hash; final K key; V value; Node next; Node(int hash, K key, V value, Node next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry\u003c?, ?\u003e e = (Map.Entry\u003c?, ?\u003e) o; if (Objects.equals(key, e.getKey()) \u0026\u0026 Objects.equals(value, e.getValue())) return true; } return false; } } public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003c 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity \u003e MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } static final int tableSizeFor(int cap) { // 扩容为 2 的次方 int n = -1 \u003e\u003e\u003e Integer.numberOfLeadingZeros(cap - 1); return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { if (key == null) return 0; int h","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:3","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#为什么-hashmap-多线程会导致死循环"},{"categories":[],"content":" HashMap 和 HashTable HashMap 线程不安全。 key 和 value 都允许null。 初始大小为 16，扩容因子为 0.75，每次扩容为之前的 2 倍；当指定初始大小时会扩容为 2 的次方。 迭代器是 fail-fast。 HashTable 线程安全，使用了volatile和synchronized。 key 和 value 都不允许null。 初始大小为 11，扩容因子为 0.75，每次扩容为之前的 2 倍 + 1。 迭代器是 fail-safe。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:4","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#hashmap-和-hashtable"},{"categories":[],"content":" fail-fast 和 fail-safe fail-fast：遍历过程中若发现容器进行了修改，抛出ConcurrentModificationException。如ArrayList、Vector、LinkedList。 Java 容器类中使用modCount表示容器的修改次数，若遍历过程中modCount发生了改变，则说明容器发生了修改，抛出异常。 fail-safe：正常完成遍历，对容器发生的修改不可见。如CopyOnWriteArrayList。 CopyOnWriteArrayList容器进行修改时会复制一份新数组，不对原数组上进行修改，然后替换原数组。 // ArrayList public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e { protected transient int modCount = 0; // 继承自 AbstractList transient Object[] elementData; private int size; public Iterator\u003cE\u003e iterator() { // 迭代器 return new Itr(); } private class Itr implements Iterator\u003cE\u003e { int cursor; int lastRet = -1; int expectedModCount = modCount; public boolean hasNext() { return cursor != size; } public E next() { checkForComodification(); int i = cursor; if (i \u003e= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u003e= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } } // Vector public class Vector\u003cE\u003e extends AbstractList\u003cE\u003e { protected transient int modCount = 0; // 继承自 AbstractList protected Object[] elementData; protected int elementCount; public synchronized Iterator\u003cE\u003e iterator() { return new Itr(); } private class Itr implements Iterator\u003cE\u003e { int cursor; int lastRet = -1; int expectedModCount = modCount; public boolean hasNext() { return cursor != elementCount; } public E next() { synchronized (Vector.this) { checkForComodification(); int i = cursor; if (i \u003e= elementCount) throw new NoSuchElementException(); cursor = i + 1; return elementData(lastRet = i); } } public void remove() { if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) { checkForComodification(); Vector.this.remove(lastRet); expectedModCount = modCount; } cursor = lastRet; lastRet = -1; } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } /","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:5","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#fail-fast-和-fail-safe"},{"categories":[],"content":" Comparable 和 Comparator Comparable 接口出自 java.lang 包，它有⼀个 compareTo(Object obj) 方法⽤来排序。 interface Comparable { int compareTo(Object obj); } Comparator 接口出自 java.util 包（需要导包），它有⼀个 compare(Object obj1, Object obj2) 方法⽤来排序。 package java.util; interface Comparator { int compare(Object obj1, Object obj2); } compareTo(Object obj) 方法和 compare(Object obj1, Object obj2) 方法的返回值 小于 0 代表升序， 大于 0 代表降序。 Collections.sort()、TreeSet、TreeMap、PriorityQueue使用自定义类时必须实现 Comparable 接口或传入 Comparator 接口的实现类。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:6","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#comparable-和-comparator"},{"categories":[],"content":" Arrays.asList() 和 List.of() Arrays.asList() 返回的对象是 java.util.Arrays 类中的内部类 java.util.Arrays$ArrayList，而不是 java.util.ArrayList。java.util.Arrays$ArrayList 没有实现 add()、remove() 和 clear() 方法，但实现了 set() 方法，因此不能添加和删除元素，只能修改和读取元素。 传入的数组必须是对象数组，不能是基本类型数组。 public class Arrays { public static \u003cT\u003e List\u003cT\u003e asList(T... a) { return new ArrayList\u003c\u003e(a); } private static class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements RandomAccess { private final E[] a; ArrayList(E[] array) { a = Objects.requireNonNull(array); } public int size() {} public E get(int index) {} public E set(int index, E element) {} public int indexOf(Object o) {} public boolean contains(Object o) {} public void sort(Comparator\u003c? super E\u003e c) {} } } public abstract class AbstractList\u003cE\u003e extends AbstractCollection\u003cE\u003e implements List\u003cE\u003e { public void add(int index, E element) { throw new UnsupportedOperationException(); } public E remove(int index) { throw new UnsupportedOperationException(); } } List.of() 返回的是 AbstractImmutableList 接口的实现类，该接口中所有修改操作（add()、remove()、set()等）全都会抛出异常。 public interface List\u003cE\u003e extends Collection\u003cE\u003e { static \u003cE\u003e List\u003cE\u003e of(E... elements) { switch (elements.length) { case 0: return ImmutableCollections.emptyList(); case 1: return new ImmutableCollections.List12\u003c\u003e(elements[0]); case 2: return new ImmutableCollections.List12\u003c\u003e(elements[0], elements[1]); default: return new ImmutableCollections.ListN\u003c\u003e(elements); } } } class ImmutableCollections { static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); } static abstract class AbstractImmutableList\u003cE\u003e extends AbstractImmutableCollection\u003cE\u003e implements List\u003cE\u003e, RandomAccess { @Override public void add(int index, E element) { throw uoe(); } @Override public boolean addAll(int index, Collection\u003c? extends E\u003e c) { throw uoe(); } @Override public E remove(int index) { throw uoe(); } @Override public void replaceAll(UnaryOperator\u003cE\u003e operator) { throw uoe(); } @Override public E set(int index, E element) { throw uoe(); } @Override public void sort(Comparator\u003c? super ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:3:7","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#arraysaslist-和-listof"},{"categories":[],"content":" String \u0026 StringBuilder \u0026 StringBuffer String 初始化后则不可添加/修改，因为未提供修改接口。 底层byte数组实现（JDK 9 之前是char数组）。 StringBuilder 可添加/修改字符，不会创建新的对象。 线程不安全。 StringBuffer 可添加/修改字符，不会创建新的对象。 线程安全，使用了volatile和synchronized。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:4:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#string--stringbuilder--stringbuffer"},{"categories":[],"content":" 面向对象","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:5:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#面向对象"},{"categories":[],"content":" 封装 四种权限修饰符 public 修饰范围：外部类、内部类、方法、属性。 继承特性：可继承。 作用范围：可被任意类访问。 其他特性：一个 Java 文件只能有一个public外部类，且文件名与类名相同。 protected 修饰范围：内部类、方法、属性。 继承特性：可继承。 作用范围：可被同一个包下的类和子类访问。 修饰范围：外部类、内部类、方法、属性、局部变量。 继承特性：可被同一个包下的子类继承。 作用范围：可被同一个包下的类访问。 private 修饰范围：内部类、方法、属性。 继承特性：不可继承。 作用范围：只能本类访问。 protected和private只能修饰内部类，不能修饰外部类。 三种面向对象修饰符 abstract 修饰范围：外部类、内部类、方法（抽象类、接口）。 其他特性： 抽象方法无方法体。 抽象类的子类必须重写父类所有抽象方法后才能创建对象，否则也成为一个抽象类。 static 修饰范围：内部类、方法、属性。 其他特性： 通过类名访问。 所有实例共享。 静态方法中不能访问非静态方法和非静态属性。 静态方法中不能访问this和super。 final 修饰范围：外部类、内部类、方法（非构造方法）、属性、局部变量。 其他特性： 修饰的类不可被继承，类中的方法也被final修饰。 修饰的方法不可被重写。 修饰的属性必须赋值（直接赋值、构造块赋值、构造方法赋值，三选一），且不可修改。 修饰的局部变量一旦赋值便不可修改。 若修饰的是引用类型的变量，则初始化后不可指向另一对象，但对象内容仍可发生改变。 abstract与private、static和final均不可搭配。 private方法会隐式地被指定为final方法。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:5:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#封装"},{"categories":[],"content":" 封装 四种权限修饰符 public 修饰范围：外部类、内部类、方法、属性。 继承特性：可继承。 作用范围：可被任意类访问。 其他特性：一个 Java 文件只能有一个public外部类，且文件名与类名相同。 protected 修饰范围：内部类、方法、属性。 继承特性：可继承。 作用范围：可被同一个包下的类和子类访问。 修饰范围：外部类、内部类、方法、属性、局部变量。 继承特性：可被同一个包下的子类继承。 作用范围：可被同一个包下的类访问。 private 修饰范围：内部类、方法、属性。 继承特性：不可继承。 作用范围：只能本类访问。 protected和private只能修饰内部类，不能修饰外部类。 三种面向对象修饰符 abstract 修饰范围：外部类、内部类、方法（抽象类、接口）。 其他特性： 抽象方法无方法体。 抽象类的子类必须重写父类所有抽象方法后才能创建对象，否则也成为一个抽象类。 static 修饰范围：内部类、方法、属性。 其他特性： 通过类名访问。 所有实例共享。 静态方法中不能访问非静态方法和非静态属性。 静态方法中不能访问this和super。 final 修饰范围：外部类、内部类、方法（非构造方法）、属性、局部变量。 其他特性： 修饰的类不可被继承，类中的方法也被final修饰。 修饰的方法不可被重写。 修饰的属性必须赋值（直接赋值、构造块赋值、构造方法赋值，三选一），且不可修改。 修饰的局部变量一旦赋值便不可修改。 若修饰的是引用类型的变量，则初始化后不可指向另一对象，但对象内容仍可发生改变。 abstract与private、static和final均不可搭配。 private方法会隐式地被指定为final方法。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:5:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#四种权限修饰符"},{"categories":[],"content":" 封装 四种权限修饰符 public 修饰范围：外部类、内部类、方法、属性。 继承特性：可继承。 作用范围：可被任意类访问。 其他特性：一个 Java 文件只能有一个public外部类，且文件名与类名相同。 protected 修饰范围：内部类、方法、属性。 继承特性：可继承。 作用范围：可被同一个包下的类和子类访问。 修饰范围：外部类、内部类、方法、属性、局部变量。 继承特性：可被同一个包下的子类继承。 作用范围：可被同一个包下的类访问。 private 修饰范围：内部类、方法、属性。 继承特性：不可继承。 作用范围：只能本类访问。 protected和private只能修饰内部类，不能修饰外部类。 三种面向对象修饰符 abstract 修饰范围：外部类、内部类、方法（抽象类、接口）。 其他特性： 抽象方法无方法体。 抽象类的子类必须重写父类所有抽象方法后才能创建对象，否则也成为一个抽象类。 static 修饰范围：内部类、方法、属性。 其他特性： 通过类名访问。 所有实例共享。 静态方法中不能访问非静态方法和非静态属性。 静态方法中不能访问this和super。 final 修饰范围：外部类、内部类、方法（非构造方法）、属性、局部变量。 其他特性： 修饰的类不可被继承，类中的方法也被final修饰。 修饰的方法不可被重写。 修饰的属性必须赋值（直接赋值、构造块赋值、构造方法赋值，三选一），且不可修改。 修饰的局部变量一旦赋值便不可修改。 若修饰的是引用类型的变量，则初始化后不可指向另一对象，但对象内容仍可发生改变。 abstract与private、static和final均不可搭配。 private方法会隐式地被指定为final方法。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:5:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#三种面向对象修饰符"},{"categories":[],"content":" 继承","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:5:2","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#继承"},{"categories":[],"content":" 多态","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:5:3","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#多态"},{"categories":[],"content":" 编码 ASCII：共 127 个字符，每个字符占 1B。 ISO-8859-1：共 256 个字符，每个字符占 1B。 GB2312 GBK Unicode（Java 默认）：每个字符占 2B，每个中文字符占 2B。 UTF-8：每个字符占 1-4B，每个中文字符占 3B。 UTF-16：每个字符占 2B 或 4B。 UTF-32：每个字符占 4B。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#编码"},{"categories":[],"content":" 基本数据类型 boolean：单独使用占 4B（当作int），数组使用占 1B（当作byte）。包装类为Boolean。只能取true或false。 byte：占 1B。包装类为Byte。 short：占 2B。包装类为Short。 char：占 2B。包装类为Character。 int：占 4B。包装类为Integer。默认整数类型。 float：占 4B。包装类为Float。如3.14f。 long：占 8B。包装类为Long。如1L。 double：占 8B。包装类为Double。默认浮点数类型。 byte、short、char与整数发生运算时会被向上转型为int。 float与浮点数发生运算时会被向上转型为double。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:7:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#基本数据类型"},{"categories":[],"content":" 常量池","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:8:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#常量池"},{"categories":[],"content":" 反射程序在运行时可以获取任意类的所有信息，可以访问任意对象的所有方法和属性。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:9:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#反射"},{"categories":[],"content":" Class 类每个 Java 类运行时都在 JVM 里表现为一个 Class 对象，包括数组、boolean、byte、char、short、int、float、long、double和void。 每个类被编译后会产生一个 Class 对象（唯一），包含该类的类型信息，保存在同名的 .class 文件中。 每个类对应的 Class 对象只有一个（唯一），无论创建多少个实例对象，其依据的都是用一个 Class 对象。 Class 类的构造方法私有，因此 Class 类的实例不能手动创建，只能由 JVM 创建和加载。 Class 对象的作用是在运行时获取某个对象的类型信息。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:9:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#class-类"},{"categories":[],"content":" 获取 Class 对象的三种方式 // 1.通过类 Class\u003c?\u003e clazz1 = Person.class; // 2.通过实例 Class\u003c?\u003e clazz2 = new Person().getClass(); // 3.通过全限定类名 try { Class\u003c?\u003e clazz3 = Class.forName(\"src.Person\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } class Person {} ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:9:2","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#获取-class-对象的三种方式"},{"categories":[],"content":" 反射操作对象 Person package src; class Person { private String name; private int age; Person() { } private Person(Person p) { } public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { setNameAndAge(name, age); } public void setAge(int age) { setNameAndAge(name, age); } private void setNameAndAge(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person [name=\" + name + \", age=\" + age + \"]\"; } } 简单操作 Class\u003c?\u003e clz = Person.class; String s1 = clz.getSimpleName(); // 类名 String s2 = clz.getName(); // 全限定类名 String s3 = clz.getCanonicalName(); // 包名+类名 boolean b = clz.isInterface(); // 是否接口 Class\u003c?\u003e[] c1 = clz.getInterfaces(); // 返回实现的所有接口的 Class 对象 Class\u003c?\u003e c2 = clz.getSuperclass(); // 返回实父类的 Class 对象 try { Person p1 = (Person) clz.newInstance(); // 创建对象（必须有无参构造方法），从 JDK 9 开始弃用 } catch (Exception e) { e.printStackTrace(); } 一般情况下，getName()和getCanonicalName()返回值相同，但对于内部类、数组，两者返回值不同。只有getName()返回的才是全限定名。 Constructor：获取构造方法。 import java.lang.reflect.Constructor; Class\u003c?\u003e clz = Person.class; Constructor\u003c?\u003e[] c1 = clz.getDeclaredConstructors(); // 返回所有构造方法 Constructor\u003c?\u003e[] c2 = clz.getConstructors(); // 返回包括父类的所有 public 构造方法 try { Constructor\u003c?\u003e c3 = clz.getDeclaredConstructor(String.class, int.class); // 返回指定类型的构造方法 Constructor\u003c?\u003e c4 = clz.getConstructor(String.class, int.class); // 返回指定类型的构造方法 Person person = (Person) c3.newInstance(\"Alice\", 18); // 通过构造方法传入参数创建对象 Class\u003c?\u003e[] c5 = c3.getParameterTypes(); // 获取参数类型 String s1 = c3.getName(); // src.Person String s2 = c3.toGenericString(); // public src.Person(java.lang.String,int) } catch (Exception e) { e.printStackTrace(); } Method：获取方法。 import java.lang.reflect.Method; Class\u003c?\u003e clz = Person.class; Person person = new Person(\"Alice\", 18); Method[] m1 = clz.getDeclaredMethods(); // 返回所有方法 Method[] m2 = clz.getMethods(); // 返回包括父类的所有 public 方法 try { Method m3 = clz.getDeclaredMethod(\"setName\", String.class); // 返回指定类型的方法 Method m4 = clz.getMethod(\"toString\"); // 返回指定类型的方法 m4","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:9:3","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#反射操作对象"},{"categories":[],"content":" 反射过程及实现 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化； 每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上； 反射也是考虑了线程安全的，放心使用； 反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销； 反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器； 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离； 调度反射方法，最终是由jvm执行invoke0()执行 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:9:4","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#反射过程及实现"},{"categories":[],"content":" 注解","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:10:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#注解"},{"categories":[],"content":" 对象克隆","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:11:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#对象克隆"},{"categories":[],"content":" 深拷贝 \u0026 浅拷贝浅拷贝（ShallowClone）： 若变量是基本数据类型，则复制一份给克隆对象。 若变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象指向相同的内存地址。 深拷贝（DeepClone）： 无论变量是基本数据类型还是引用类型，都复制一份给克隆对象。 ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:11:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#深拷贝--浅拷贝"},{"categories":[],"content":" clone() 方法实现的clone()需要满足以下条件均为真： x.clone() != x，强制。 x.clone().getClass() == x.getClass()，非强制。 x.clone().equals(x)，非强制。 public class Object { @HotSpotIntrinsicCandidate protected native Object clone() throws CloneNotSupportedException; } class Book implements Cloneable { public String name; public Person author; // 类中包含引用对象 public int rating; public Book(String name, Person author, int rating) { this.name = name; this.author = author; this.rating = rating; } @Override public Object clone() throws CloneNotSupportedException { // 深拷贝 Book book = (Book) super.clone(); book.author = (Person) author.clone(); // 引用对象也需要调用 clone() return book; } @Override public String toString() { return String.format(\"《%s》%s，%d分\", name, author, rating); } } class Person implements Cloneable { public String name; public int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public String toString() { return String.format(\"%s%d岁\", name, age); } } ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:11:2","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#clone-方法"},{"categories":[],"content":" 新特性","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:12:0","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#新特性"},{"categories":[],"content":" JDK 5 新特性","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:12:1","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#jdk-5-新特性"},{"categories":[],"content":" JDK 8 新特性 lambda Functional Interfaces Optionals Stream Parallel-Streams ","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:12:2","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#jdk-8-新特性"},{"categories":[],"content":" JDK 9 新特性","date":"2022-08-31","objectID":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/:12:3","series":["面试"],"tags":["Java"],"title":"Java 基础面试","uri":"/posts/java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#jdk-9-新特性"},{"categories":["数据结构"],"content":" 介绍","date":"2022-08-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","series":null,"tags":["数据结构","优先队列","堆","二叉堆"],"title":"数据结构 优先队列","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#介绍"},{"categories":["数据结构"],"content":" 大顶堆 class MaxPQ { private int[] data; private int n; // 当前元素个数，因为索引从 1 开始，也是最后一个元素的下标 public MaxPQ(int maxN) { data = new int[maxN + 1]; } public MaxPQ(int[] nums) { data = new int[nums.length + 1]; for (int x : nums) add(x); } public void add(int x) { if (n == data.length - 1) return; data[++n] = x; swim(n); } public int getMax() { if (isEmpty()) return -1; return data[1]; } public int pollMax() { if (isEmpty()) return -1; swap(1, n--); sink(1); return data[n + 1]; } public int size() { return n; } public boolean isEmpty() { return n == 0; } private void swim(int k) { if (k \u003c= 1 || k \u003e n) return; while (k \u003e 1 \u0026\u0026 data[k / 2] \u003c data[k]) { swap(k / 2, k); k /= 2; } } private void sink(int k) { if (k \u003c 1 || k \u003e n / 2) return; while (k * 2 \u003c= n) { int i = k * 2; if (i + 1 \u003c= n \u0026\u0026 data[i] \u003c data[i + 1]) i++; if (data[k] \u003e= data[i]) break; swap(k, i); k = i; } } private void swap(int i, int j) { int temp = data[i]; data[i] = data[j]; data[j] = temp; } } ","date":"2022-08-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","series":null,"tags":["数据结构","优先队列","堆","二叉堆"],"title":"数据结构 优先队列","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#大顶堆"},{"categories":["数据结构"],"content":" 小顶堆 class MinPQ { private int[] data; private int n; // 当前元素个数，因为索引从 1 开始，也是最后一个元素的下标 public MinPQ(int maxN) { data = new int[maxN + 1]; } public MinPQ(int[] nums) { data = new int[nums.length + 1]; for (int x : nums) add(x); } public void add(int x) { if (n == data.length - 1) return; data[++n] = x; swim(n); } public int getMin() { if (isEmpty()) return -1; return data[1]; } public int pollMin() { if (isEmpty()) return -1; swap(1, n--); sink(1); return data[n + 1]; } public int size() { return n; } public boolean isEmpty() { return n == 0; } private void swim(int k) { if (k \u003c= 1 || k \u003e n) return; while (k \u003e 1 \u0026\u0026 data[k / 2] \u003e data[k]) { swap(k / 2, k); k /= 2; } } private void sink(int k) { if (k \u003c 1 || k \u003e n / 2) return; while (k * 2 \u003c= n) { int i = k * 2; if (i + 1 \u003c= n \u0026\u0026 data[i] \u003e data[i + 1]) i++; if (data[k] \u003c= data[i]) break; swap(k, i); k = i; } } private void swap(int i, int j) { int temp = data[i]; data[i] = data[j]; data[j] = temp; } } ","date":"2022-08-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:0","series":null,"tags":["数据结构","优先队列","堆","二叉堆"],"title":"数据结构 优先队列","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#小顶堆"},{"categories":["数据结构"],"content":" 参考","date":"2022-08-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:4:0","series":null,"tags":["数据结构","优先队列","堆","二叉堆"],"title":"数据结构 优先队列","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#参考"},{"categories":["力扣"],"content":"2209. 用地毯覆盖后的最少白色砖块 ","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:0:0","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#"},{"categories":["力扣"],"content":" 动态规划","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:1:0","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#动态规划"},{"categories":["力扣"],"content":" 状态定义$dp[i][j]$ 表示用 $i$ 块地毯铺前 $j$ 块砖块剩余最少白色砖块数量。 ","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:1:1","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#状态定义"},{"categories":["力扣"],"content":" 边界条件不使用地毯，则前 $j$ 块砖块剩余最少白色砖块数量为白色砖块的数量。 $$ dp[0][j] = dp[0][j - 1] + I(s[j] == ‘1’) $$ ","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:1:2","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#边界条件"},{"categories":["力扣"],"content":" 状态转移方程 不铺地毯：若第 $i$ 块砖块为白色砖块，则剩余白色砖块数量加一。 铺地毯：用一个地毯覆盖砖块，并且其末尾刚好覆盖住第 $i$ 块砖块。 $$ dp[i][j] = \\min(dp[i - 1][j] + I(s[j] == ‘1’), dp[i - len][j - 1]) $$ ","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:1:3","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#状态转移方程"},{"categories":["力扣"],"content":" 递推代码 class Solution { public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) { int n = floor.length(); // 能够覆盖所有砖块 if (numCarpets * carpetLen \u003e= n) return 0; // dp[i][j] 表示用 i 块地毯覆盖前 j 块砖块剩余最少白色砖块数量。 int[][] dp = new int[numCarpets + 1][n]; // 不铺地毯时前 j 块砖块剩余最少白色砖块数量为前 j 块砖块中白色砖块的数量。 dp[0][0] = floor.charAt(0) == '1' ? 1 : 0; for (int j = 1; j \u003c n; j++) dp[0][j] = dp[0][j - 1] + (floor.charAt(j) == '1' ? 1 : 0); // 不铺地毯时，若第 j 块砖块为白色砖块，则剩余白色砖块数量加一。 // 铺地毯时，用地毯的边缘覆盖第 j 块砖块。 // 当铺第 i 块地毯时，至少可以覆盖 i * carpetLen 块砖块，所以少于。 for (int i = 1; i \u003c= numCarpets; i++) for (int j = i * carpetLen; j \u003c n; j++) dp[i][j] = Math.min(dp[i][j - 1] + (floor.charAt(j) == '1' ? 1 : 0), dp[i - 1][j - carpetLen]); // 返回用 numCarpets 块地毯覆盖前 n - 1 块砖块剩余最少白色砖块数量。 return dp[numCarpets][n - 1]; } } ","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:1:4","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#递推代码"},{"categories":["力扣"],"content":" 空间优化递推代码 class Solution { public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) { int n = floor.length(); if (numCarpets * carpetLen \u003e= n) return 0; int[] pre = new int[n]; int[] cur = new int[n]; pre[0] = floor.charAt(0) == '1' ? 1 : 0; for (int i = 1; i \u003c n; i++) pre[i] = pre[i - 1] + (floor.charAt(i) == '1' ? 1 : 0); for (int i = 1; i \u003c= numCarpets; i++) { cur[i * carpetLen - 1] = 0; // 设置起点为 0 for (int j = i * carpetLen; j \u003c n; j++) cur[j] = Math.min(cur[j - 1] + (floor.charAt(j) == '1' ? 1 : 0), pre[j - carpetLen]); int[] tmp = cur; // 交换，避免创建新数组 cur = pre; pre = tmp; } return pre[n - 1]; } } ","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:1:5","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#空间优化递推代码"},{"categories":["力扣"],"content":" 参考 动态规划的典型思考策略（Python/Java/C++/Go） - 用地毯覆盖后的最少白色砖块 - 力扣（LeetCode） ","date":"2022-08-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/:2:0","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 2209 🟥用地毯覆盖后的最少白色砖块","uri":"/posts/%E5%8A%9B%E6%89%A3-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/#参考"},{"categories":["RSS"],"content":" 1.安装 Docker # 卸载旧版本 sudo apt-get remove docker docker-engine docker.io containerd runc sudo apt-get update sudo apt-get install -y vim ca-certificates curl gnupg lsb-release # 添加 Docker 源 sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null # 安装 Docker sudo apt-get update sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin # 测试是否安装成功 sudo docker run hello-world docker --version ","date":"2022-08-15","objectID":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["RSS"],"title":"RSSHub Miniflux 搭建","uri":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/#1安装-docker"},{"categories":["RSS"],"content":" 2.部署 Miniflux 和 RSSHub 准备配置文件。 vim docker-compose.yml 填入以下内容。 version: '4.0' services: miniflux: image: miniflux/miniflux:latest container_name: miniflux restart: unless-stopped ports: - \"8888:8080\" # 8888 为自定义端口 depends_on: - db - rsshub environment: - DATABASE_URL=postgres://miniflux:secret@db/miniflux?sslmode=disable - RUN_MIGRATIONS=1 - CREATE_ADMIN=1 - ADMIN_USERNAME=admin # 自定义用户名 - ADMIN_PASSWORD=test123 # 自定义密码 db: image: postgres:latest container_name: postgres restart: unless-stopped environment: - POSTGRES_USER=miniflux # 可修改，需和 DATABASE_URL 中对应 - POSTGRES_PASSWORD=secret # 可修改，需和 DATABASE_URL 中对应 volumes: - miniflux-db:/var/lib/postgresql/data healthcheck: test: [ \"CMD\", \"/usr/bin/miniflux\", \"-healthcheck\", \"auto\" ] interval: 10s start_period: 30s rsshub: image: diygod/rsshub:chromium-bundled container_name: rsshub restart: unless-stopped ports: - '1200:1200' environment: NODE_ENV: production CACHE_TYPE: redis REDIS_URL: 'redis://redis:6379/' PUPPETEER_WS_ENDPOINT: 'ws://browserless:3000' depends_on: - redis - browserless browserless: image: browserless/chrome:latest container_name: browserless restart: unless-stopped ulimits: core: hard: 0 soft: 0 redis: image: redis:alpine container_name: redis restart: unless-stopped volumes: - redis-data:/data volumes: miniflux-db: redis-data: 启动容器。 # 启动 docker compose up -d # 查看容器状态，STATUS 显示正常即可 docker ps -a 配置。 访问http://ip:port，输入刚才自定义的用户名和密码。 设置里启动 fever，然后设置用户名和密码。 ","date":"2022-08-15","objectID":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["RSS"],"title":"RSSHub Miniflux 搭建","uri":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/#2部署-miniflux-和-rsshub"},{"categories":["RSS"],"content":" 3.配置 HTTPS 安装acme.sh。 注册 cloudflare 并将域名解析到 cloudflare。 获取 cloudflare 的 Global API Key。 export CF_Key=\"3a...08\" # 替换为 Global API Key export CF_Email=\"test@gmail.com\" # 替换为 cloudflare 的注册邮箱 acme.sh使用 cloudflare 的 DNS API 申请泛域名证书，任意二级域名都可以使用。将域名换成自己的域名。 # 申请证书 acme.sh --issue --dns dns_cf -d backtraxe.top -d \"*.backtraxe.top\" # 创建目录 mkdir -p /etc/nginx/ssl/backtraxe.top # 复制证书到指定目录 acme.sh --install-cert -d backtraxe.top \\ --key-file /etc/nginx/ssl/backtraxe.top/backtraxe.top.key \\ --fullchain-file /etc/nginx/ssl/backtraxe.top/fullchain.cer \\ --reloadcmd \"service nginx force-reload\" 配置 Nginx，实现rss.backtraxe.top代理https://127.0.0.1:8888，rsshub.backtraxe.top代理https://127.0.0.1:1200。 server { listen 443 ssl; server_name rsshub.backtraxe.top; ssl_certificate \"/etc/nginx/ssl/backtraxe.top/fullchain.cer\"; ssl_certificate_key \"/etc/nginx/ssl/backtraxe.top/backtraxe.top.key\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:1200; } } server { listen 443 ssl; server_name rss.backtraxe.top; ssl_certificate \"/etc/nginx/ssl/backtraxe.top/fullchain.cer\"; ssl_certificate_key \"/etc/nginx/ssl/backtraxe.top/backtraxe.top.key\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8888; } } server { listen 80; listen [::]:80; server_name backtraxe.top; return 301 https://$http_host$request_uri; } ","date":"2022-08-15","objectID":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":["RSS"],"title":"RSSHub Miniflux 搭建","uri":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/#3配置-https"},{"categories":["RSS"],"content":" 4.配置客户端Fever API: url: http://ip:port/fever/ username: 自定义 fever 的用户名 password: 自定义 fever 的密码 ","date":"2022-08-15","objectID":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":["RSS"],"title":"RSSHub Miniflux 搭建","uri":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/#4配置客户端"},{"categories":["RSS"],"content":" 参考 Install Docker Engine on Ubuntu | Docker Documentation Docker Installation | Miniflux Installation Instructions 用Miniflux自建轻便好用的RSS服务 Docker Compose 部署 | RSSHub https://www.psay.cn/toss/126.html https://cloud.tencent.com/developer/article/1840147 https://suzuhafan.com/tutorials/acmesh-use-cloudflare-to-create-ssl.html https://luyuhuang.tech/2020/06/03/cloudflare-free-https.html https://learnku.com/articles/13496/lets-encrypt-pan-domain-name-application-and-configuration https://luyuhuang.tech/2020/06/03/cloudflare-free-https.html https://mincong.io/cn/nginx-subdomains/ ","date":"2022-08-15","objectID":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":["RSS"],"title":"RSSHub Miniflux 搭建","uri":"/posts/rsshub-miniflux-%E6%90%AD%E5%BB%BA/#参考"},{"categories":["力扣"],"content":"5. 最长回文子串 ","date":"2022-08-14","objectID":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:0:0","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 0005 最长回文子串","uri":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/#"},{"categories":["力扣"],"content":" 动态规划 class Solution { public String longestPalindrome(String s) { int n = s.length(); // [start, end) int start = 0; int end = 1; // dp[i][j] 表示 s[i:j+1] 是否是回文串 boolean[][] dp = new boolean[n][n]; for (int i = 0; i \u003c n; i++) { dp[i][i] = true; if (i \u003e 0 \u0026\u0026 s.charAt(i - 1) == s.charAt(i)) { dp[i - 1][i] = true; start = i - 1; end = i + 1; } } for (int len = 2; len \u003c n; len++) { for (int i = 0; i + len \u003c n; i++) { int j = i + len; dp[i][j] = dp[i + 1][j - 1] \u0026\u0026 s.charAt(i) == s.charAt(j); if (dp[i][j]) { start = i; end = j + 1; } } } return s.substring(start, end); } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n^2) $ ","date":"2022-08-14","objectID":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:0","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 0005 最长回文子串","uri":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/#动态规划"},{"categories":["力扣"],"content":" 中心扩散 class Solution { public String longestPalindrome(String s) { int n = s.length(); int start = 0; int end = 0; for (int i = 0; i \u003c n; i++) { int l = i; while (l \u003e= 0 \u0026\u0026 s.charAt(l) == s.charAt(i)) l--; int r = i; while (r \u003c n \u0026\u0026 s.charAt(r) == s.charAt(i)) r++; while (l \u003e= 0 \u0026\u0026 r \u003c n \u0026\u0026 s.charAt(l) == s.charAt(r)) { l--; r++; } if (r - l - 2 \u003e end - start) { start = l + 1; end = r - 1; } } return s.substring(start, end + 1); } } 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ ","date":"2022-08-14","objectID":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:2:0","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 0005 最长回文子串","uri":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/#中心扩散"},{"categories":["力扣"],"content":" Manacher 算法","date":"2022-08-14","objectID":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:3:0","series":null,"tags":["力扣","动态规划","DP"],"title":"力扣 0005 最长回文子串","uri":"/posts/%E5%8A%9B%E6%89%A3-0005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/#manacher-算法"},{"categories":["力扣"],"content":"41. 缺失的第一个正数 ","date":"2022-08-13","objectID":"/posts/%E5%8A%9B%E6%89%A3-0041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/:0:0","series":null,"tags":["力扣"],"title":"力扣 0041 缺失的第一个正数","uri":"/posts/%E5%8A%9B%E6%89%A3-0041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/#"},{"categories":["力扣"],"content":" 原地哈希 长度为 $n$ 的数组中未出现的最小正整数一定在 $[1,n+1]$ 之间。 所以可以将数组用作哈希表，用 $nums[i]$ 来标识 $i+1$ 这个正整数是否出现过。 由于我们只关心范围在 $[1,n]$ 之间的数，所以可以将范围之外的数当做标识，假设选用负数作为标识。 将数组中的非正数置为 $\\gt n$ 的正整数。 对于数组中在 $[1,n]$ 之间的数 $nums[i]$，将 $nums[nums[i] - 1]$ 置为负数。 遍历数组找到第一个正数 $nums[i]$，则 $i+1$ 即为答案。 class Solution { public int firstMissingPositive(int[] nums) { int n = nums.length; // 1. 保证 1 \u003c= nums[i] for (int i = 0; i \u003c n; i++) if (nums[i] \u003c= 0) nums[i] = n + 1; // 2. 将满足 1 \u003c= nums[i] \u003c= n 的 nums[nums[i] - 1] 置为负数 for (int i = 0; i \u003c n; i++) { int j = Math.abs(nums[i]); // 不遗漏每个数 if (j \u003c= n) nums[j - 1] = -Math.abs(nums[j - 1]); } // 3. 第一个 nums[i] != -1 则返回 i + 1 for (int i = 0; i \u003c n; i++) if (nums[i] \u003e 0) return i + 1; return n + 1; } } 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-08-13","objectID":"/posts/%E5%8A%9B%E6%89%A3-0041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/:1:0","series":null,"tags":["力扣"],"title":"力扣 0041 缺失的第一个正数","uri":"/posts/%E5%8A%9B%E6%89%A3-0041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/#原地哈希"},{"categories":["力扣"],"content":" 置换 将在范围 $[1,n]$ 之间的 $nums[i]$ 通过交换归位。 遍历数组，第一个 $nums[i] \\ne i + 1$ 的 $i+1$ 即为答案。 class Solution { public int firstMissingPositive(int[] nums) { int n = nums.length; for (int i = 0; i \u003c n; i++) { int p = nums[i] - 1; // 将 [1, n] 中不在位的归位 while (0 \u003c= p \u0026\u0026 p \u003c n \u0026\u0026 p + 1 != nums[p]) { int next = nums[p] - 1; nums[p] = p + 1; p = next; } } for (int i = 0; i \u003c n; i++) if (nums[i] != i + 1) return i + 1; return n + 1; } } 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-08-13","objectID":"/posts/%E5%8A%9B%E6%89%A3-0041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/:2:0","series":null,"tags":["力扣"],"title":"力扣 0041 缺失的第一个正数","uri":"/posts/%E5%8A%9B%E6%89%A3-0041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/#置换"},{"categories":["力扣"],"content":"4. 寻找两个正序数组的中位数 ","date":"2022-08-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:0:0","series":null,"tags":["力扣"],"title":"力扣 0004 寻找两个正序数组的中位数","uri":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#"},{"categories":["力扣"],"content":" 划分数组中位数的意义是将一些数据划分称为数量相等或数量差不超过 1 的两部分。其中前一部分的最大值小于等于后一部分的最小值。 已知 A 的长度为 $m$，B 的长度为 $n$，假设 $m\u003cn$，若不满足则交换 A 和 B。 将 A 在任意位置划分成为两部分。其中 $i \\in [0, m]$。 $$ A[0], A[1], \\cdots, A[i-1] \\quad | \\quad A[i], A[i+1], \\cdots, A[m-1] $$ 同样，将 B 也划分为两个部分，因为 A 的左半部分加上 B 的左半部分的数量为 $\\frac{m+n}{2}$，则 $j=\\frac{m+n}{2}-i, \\quad j \\in [\\frac{n-m}{2}, \\frac{m+n}{2}]$。 $$ B[0], B[1], \\cdots, B[j-1] \\quad | \\quad B[j], B[j+1], \\cdots, B[n-1] $$ 为了保证两部分元素数量相等，所以 $i$ 和 $j$ 的移动方向相反。 前一部分的最大值为 $maxL=max(A[i-1], B[j-1])$，而后一部分的最小值为 $minR=min(A[i], B[j])$，满足 $maxL \\le minR$ 即可。 若 $maxL \u003e minR$，我们要减小 $maxL$，增大 $minR$。已知 $A[i-1] \\le A[i]$ 和 $B[j-1] \\le B[j]$，则 $A[i-1] \\le A[i] \\lt B[j-1] \\le B[j]$，此时因为 $A[i] \\lt B[j-1]$，所以我们应该将 $i$ 向右移。 $B[j-1] \\le B[j] \\lt A[i-1] \\le A[i]$，此时因为 $B[j] \\lt A[i-1]$，所以我们应该将 $i$ 向左移。 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; if (m == 0) return (nums2[n / 2] + nums2[(n - 1) / 2]) / 2.0; if (n == 0) return (nums1[m / 2] + nums1[(m - 1) / 2]) / 2.0; if (m \u003e n) return findMedianSortedArrays(nums2, nums1); int l = 0; int r = m; int maxL = 0; int minR = 0; while (l \u003c= r) { int i = l + (r - l) / 2; // 将 nums1 划分为 [0:i] [i:m] 两部分 int j = (m + n) / 2 - i; // 将 nums2 划分为 [0:j] [j:n] 两部分 maxL = Math.max( i \u003e= 1 ? nums1[i - 1] : Integer.MIN_VALUE, j \u003e= 1 ? nums2[j - 1] : Integer.MIN_VALUE ); minR = Math.min( i \u003c m ? nums1[i] : Integer.MAX_VALUE, j \u003c n ? nums2[j] : Integer.MAX_VALUE ); if (maxL \u003c= minR) break; // 完成划分 else if (i \u003e= 1 \u0026\u0026 nums1[i - 1] \u003e nums2[j]) r = i; else l = i + 1; } return (m + n) % 2 == 0 ? (maxL + minR) / 2.0 : minR * 1.0; } } 时间复杂度：$ O(\\log(\\min(m, n))) $ 空间复杂度：$ O(1) $ ","date":"2022-08-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:1:0","series":null,"tags":["力扣"],"title":"力扣 0004 寻找两个正序数组的中位数","uri":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#划分数组"},{"categories":["力扣"],"content":" 二分查找假设两个有序数组分别是 $A$ 和 $B$。要找到第 $k$ 小的元素，我们可以比较 $A[\\frac{k}{2}−1]$ 和 $B[\\frac{k}{2}−1]$。由于 $A[\\frac{k}{2}−1]$ 和 $B[\\frac{k}{2}−1]$ 的前面分别有 $\\frac{k}{2}−1$ 个元素，对于 $A[\\frac{k}{2}−1]$ 和 $B[\\frac{k}{2}−1]$ 中的较小值，最多只会有 $\\frac{k}{2}-1+\\frac{k}{2}-1=k−2$ 个元素比它小，则该元素最多是第 $k-1$ 小的元素，此时可以舍弃该元素及其之前的元素，然后查找第 $\\frac{k}{2}$ 小的元素。 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; double ans = findMedian(nums1, 0, m, nums2, 0, n, (m + n) / 2); if ((m + n) % 2 == 0) ans = (ans + findMedian(nums1, 0, m, nums2, 0, n, (m + n - 1) / 2)) / 2.0; return ans; } int findMedian(int[] nums1, int l1, int r1, int[] nums2, int l2, int r2, int k) { // 返回在 nums1[l1:r1] 和 nums2[l2:r2] 中第 k + 1 大的数 int m = r1 - l1; int n = r2 - l2; if (m == 0) return nums2[l2 + k]; if (n == 0) return nums1[l1 + k]; if (k == 0) return Math.min(nums1[l1], nums2[l2]); int h1 = Math.min((k - 1) / 2, m - 1); int h2 = Math.min((k - 1) / 2, n - 1); if (nums1[l1 + h1] \u003e= nums2[l2 + h2]) return findMedian(nums1, l1, r1, nums2, l2 + h2 + 1, r2, k - h2 - 1); return findMedian(nums1, l1 + h1 + 1, r1, nums2, l2, r2, k - h1 - 1); } } 时间复杂度：$ O(\\log(m+n)) $ 空间复杂度：$ O(1) $ ","date":"2022-08-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:2:0","series":null,"tags":["力扣"],"title":"力扣 0004 寻找两个正序数组的中位数","uri":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#二分查找"},{"categories":["力扣"],"content":" 双指针 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; int pre = 0; int cur = 0; for (int i = 0, j = 0; i \u003c m || j \u003c n;) { int a = i \u003c m ? nums1[i] : Integer.MAX_VALUE; int b = j \u003c n ? nums2[j] : Integer.MAX_VALUE; if (a \u003c b) { cur = a; i++; } else { cur = b; j++; } if ((i + j) == (m + n) / 2 + 1) break; // 找到中点 pre = cur; } return (m + n) % 2 == 0 ? (pre + cur) / 2.0 : cur * 1.0; } } 时间复杂度：$ O(m+n) $ 空间复杂度：$ O(1) $ ","date":"2022-08-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:3:0","series":null,"tags":["力扣"],"title":"力扣 0004 寻找两个正序数组的中位数","uri":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#双指针"},{"categories":["力扣"],"content":" 排序 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; int[] arr = Arrays.copyOf(nums1, m + n); for (int i = 0; i \u003c n; i++) arr[m + i] = nums2[i]; Arrays.sort(arr); int pre = arr[(m + n - 1) / 2]; int cur = arr[(m + n) / 2]; return (m + n) % 2 == 0 ? (pre + cur) / 2.0 : cur * 1.0; } } 时间复杂度：$ O((m+n) \\log (m+n)) $ 空间复杂度：$ O(m+n) $ ","date":"2022-08-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:4:0","series":null,"tags":["力扣"],"title":"力扣 0004 寻找两个正序数组的中位数","uri":"/posts/%E5%8A%9B%E6%89%A3-0004-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#排序"},{"categories":["力扣"],"content":"215. 数组中的第K个最大元素 ","date":"2022-08-08","objectID":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/:0:0","series":null,"tags":["力扣","快速选择","堆排序"],"title":"力扣 0215 数组中的第K个最大元素","uri":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#"},{"categories":["力扣"],"content":" 1.快速选择 class Solution { public int findKthLargest(int[] nums, int k) { int n = nums.length; return partition(nums, n - k, 0, n - 1); } static int partition(int[] nums, int k, int left, int right) { // [left, right] 返回 nums 按升序排序后索引 k 位置上的元素，即第 k + 1 小的元素 if (left == right) return nums[left]; int p = left + (int) (Math.random() * (right - left + 1)); int pivot = nums[p]; nums[p] = nums[left]; nums[left] = pivot; int l = left; int r = right; while (l \u003c r) { while (l \u003c r \u0026\u0026 nums[r] \u003e= pivot) r--; nums[l] = nums[r]; while (l \u003c r \u0026\u0026 nums[l] \u003c= pivot) l++; nums[r] = nums[l]; } nums[l] = pivot; if (l == k) return pivot; else if (l \u003e k) return partition(nums, k, left, l - 1); else return partition(nums, k, l + 1, right); } } 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-08-08","objectID":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/:1:0","series":null,"tags":["力扣","快速选择","堆排序"],"title":"力扣 0215 数组中的第K个最大元素","uri":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#1快速选择"},{"categories":["力扣"],"content":" 2.手动堆排序 class Solution { public int findKthLargest(int[] nums, int k) { int heapSize = nums.length; buildMaxHeap(nums, heapSize); for (int i = nums.length - 1; i \u003e= nums.length - k + 1; --i) { swap(nums, 0, i); --heapSize; maxHeapify(nums, 0, heapSize); } return nums[0]; } public void buildMaxHeap(int[] a, int heapSize) { for (int i = heapSize / 2; i \u003e= 0; --i) { maxHeapify(a, i, heapSize); } } public void maxHeapify(int[] a, int i, int heapSize) { int l = i * 2 + 1, r = i * 2 + 2, largest = i; if (l \u003c heapSize \u0026\u0026 a[l] \u003e a[largest]) { largest = l; } if (r \u003c heapSize \u0026\u0026 a[r] \u003e a[largest]) { largest = r; } if (largest != i) { swap(a, i, largest); maxHeapify(a, largest, heapSize); } } public void swap(int[] a, int i, int j) { int temp = a[i]; a[i] = a[j]; a[j] = temp; } } 时间复杂度：$ O(n \\log n) $ 空间复杂度：$ O(\\log n) $ ","date":"2022-08-08","objectID":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/:2:0","series":null,"tags":["力扣","快速选择","堆排序"],"title":"力扣 0215 数组中的第K个最大元素","uri":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#2手动堆排序"},{"categories":["力扣"],"content":" 3.API堆排序 时间复杂度：$ O(n \\log n) $ 空间复杂度：$ O(n) $ ","date":"2022-08-08","objectID":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/:3:0","series":null,"tags":["力扣","快速选择","堆排序"],"title":"力扣 0215 数组中的第K个最大元素","uri":"/posts/%E5%8A%9B%E6%89%A3-0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#3api堆排序"},{"categories":["力扣"],"content":"628. 三个数的最大乘积 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:0:0","series":null,"tags":["力扣"],"title":"力扣 0628 三个数的最大乘积","uri":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/#"},{"categories":["力扣"],"content":" 思路 全是非负数：选择最大的三个非负数，即最大的三个数。 至少两个非负数，只有一个负数： 至少三个非负数：选择最大的三个非负数，即最大的三个数。 只有两个非负数：只有三个数可以选择，即最大的三个数。 至少一个非负数，只有两个负数： 至少三个非负数：选择最大的三个非负数，即最大的三个数；或者选择两个负数和最大的一个非负数，即最小的两个数和最大的一个数。 只有两个非负数：选择两个负数和最大的一个非负数，即最小的两个数和最大的一个数。 只有一个非负数：只有三个数可以选择，即最大的三个数。 全是负数：选择最小的三个负数，即最大的三个数。 综上，结果为最大的三个数和最小的两个数和最大的一个数中的更大值。 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:1:0","series":null,"tags":["力扣"],"title":"力扣 0628 三个数的最大乘积","uri":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/#思路"},{"categories":["力扣"],"content":" 代码 排序 class Solution { public int maximumProduct(int[] nums) { Arrays.sort(nums); int n = nums.length; return Math.max( nums[n - 1] * nums[n - 2] * nums[n - 3], // 最大的三个数 nums[n - 1] * nums[0] * nums[1] // 最小的两个数和最大的一个数 ); } } 不排序 class Solution { public int maximumProduct(int[] nums) { int max1, max2, max3, min1, min2; // 最大的三个数、最小的两个数 max1 = max2 = max3 = Integer.MIN_VALUE; min1 = min2 = Integer.MAX_VALUE; for (int x : nums) { if (x \u003e max1) { max3 = max2; max2 = max1; max1 = x; } else if (x \u003e max2) { max3 = max2; max2 = x; } else if (x \u003e max3) { max3 = x; } if (x \u003c min1) { min2 = min1; min1 = x; } else if (x \u003c min2) { min2 = x; } } return Math.max(max1 * max2 * max3, max1 * min1 * min2); } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:2:0","series":null,"tags":["力扣"],"title":"力扣 0628 三个数的最大乘积","uri":"/posts/%E5%8A%9B%E6%89%A3-0628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/#代码"},{"categories":["力扣"],"content":"459. 重复的子字符串 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["力扣","字符串匹配"],"title":"力扣 0459 重复的子字符串","uri":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/#"},{"categories":["力扣"],"content":" 枚举子串长度若满足题意，则字符串 $s$ 可以写成 $s_1s_1 \\cdots s_1$，其中 $s_1$ 的数量为 $k$，则 $n = k * m \\ (2 \\le k)$，$1 \\le m \\le \\frac{n}{2}$，其中 $n$ 为字符串 $s$ 的长度，$m$ 为子串 $s_1$ 的长度。 class Solution { public boolean repeatedSubstringPattern(String s) { int n = s.length(); for (int len = 1; len * 2 \u003c= n; len++) { // 枚举子串长度 if (n % len != 0) continue; // 剪枝 int i; for (i = len; i \u003c n; i++) if (s.charAt(i - len) != s.charAt(i)) break; if (i == n) return true; } return false; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":null,"tags":["力扣","字符串匹配"],"title":"力扣 0459 重复的子字符串","uri":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/#枚举子串长度"},{"categories":["力扣"],"content":" 字符串匹配若满足要求，则字符串 $s$ 至少可以写成 $s_1s_1$，将两个 $s$ 前后拼接在一起得到 $ss = s_1s_1s_1s_1$，去掉 $ss$ 的首字符和末尾字符得到 $ss_1 = s_2s_1s_1s_2$，则字符串 $s$ 一定是 $ss_1$ 的子串。 class Solution { public boolean repeatedSubstringPattern(String s) { return (s + s).indexOf(s, 1) != s.length(); } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":null,"tags":["力扣","字符串匹配"],"title":"力扣 0459 重复的子字符串","uri":"/posts/%E5%8A%9B%E6%89%A3-0459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/#字符串匹配"},{"categories":["力扣"],"content":"第 304 场周赛 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:0:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#"},{"categories":["力扣"],"content":" 复盘 全国排名：556 / 7426（8.08%） 全球排名：1309 / 26877（4.64%） 分数变化：2095 + 17 = 2112 完成时间：42m20s（+5m） 题目1 难度： 顺序：1 用时：5m46s 错误：0 题目2 难度： 顺序：2 用时：7m28s 错误：0 题目3 难度： 顺序：3 用时：16m28s 错误：1 dp 初始化错误 题目4 难度： 顺序：4 用时：17m38s 错误：0 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:1:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#复盘"},{"categories":["力扣"],"content":" 算术三元组的数目6136. 算术三元组的数目 class Solution { public int arithmeticTriplets(int[] nums, int diff) { HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int n = nums.length; for (int i = 0; i \u003c n; i++) map.put(nums[i], i); int ans = 0; for (int i = 1; i + 1 \u003c n; i++) { int prev = map.getOrDefault(nums[i] - diff, n); int next = map.getOrDefault(nums[i] + diff, -1); if (prev \u003c i \u0026\u0026 next \u003e i) ans++; } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:2:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#算术三元组的数目"},{"categories":["力扣"],"content":" 受限条件下可到达节点的数目6139. 受限条件下可到达节点的数目 class Solution { int ans = 0; public int reachableNodes(int n, int[][] edges, int[] restricted) { List\u003cInteger\u003e[] graph = new ArrayList[n]; for (int i = 0; i \u003c n; i++) graph[i] = new ArrayList\u003c\u003e(); for (int[] edge : edges) { graph[edge[0]].add(edge[1]); graph[edge[1]].add(edge[0]); } HashSet\u003cInteger\u003e res = new HashSet\u003c\u003e(); for (int x : restricted) res.add(x); boolean[] vis = new boolean[n]; dfs(graph, 0, res, vis); return ans; } void dfs(List\u003cInteger\u003e[] graph, int u, HashSet\u003cInteger\u003e res, boolean[] vis) { vis[u] = true; ans++; for (int v : graph[u]) { if (!res.contains(v) \u0026\u0026 !vis[v]) dfs(graph, v, res, vis); } } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:3:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#受限条件下可到达节点的数目"},{"categories":["力扣"],"content":" 检查数组是否存在有效划分6137. 检查数组是否存在有效划分 class Solution { public boolean validPartition(int[] nums) { int n = nums.length; // dp[i] 表示前 i 个元素是否存在有效划分 boolean[] dp = new boolean[n + 1]; dp[0] = true; dp[2] = nums[0] == nums[1]; for (int i = 2; i \u003c n; i++) { dp[i + 1] = dp[i - 1] \u0026\u0026 nums[i] == nums[i - 1] || dp[i - 2] \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 nums[i] == nums[i - 2] || dp[i - 2] \u0026\u0026 nums[i] - 1 == nums[i - 1] \u0026\u0026 nums[i] - 2 == nums[i - 2]; } return dp[n]; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:4:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#检查数组是否存在有效划分"},{"categories":["力扣"],"content":" 最长理想子序列6138. 最长理想子序列 class Solution { public int longestIdealString(String s, int k) { int[] dp = new int[26]; for (char c : s.toCharArray()) { int x = c - 'a'; int maxLen = 0; for (int i = Math.max(0, x - k); i \u003c= Math.min(25, x + k); i++) maxLen = Math.max(maxLen, dp[i]); d[x] = maxLen + 1; } int ans = 0; for (int x : dp) ans = Math.max(ans, x); return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:5:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#最长理想子序列"},{"categories":["力扣"],"content":" 总结 考察 dp ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:6:0","series":null,"tags":["力扣","周赛"],"title":"力扣第305场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#总结"},{"categories":["力扣"],"content":"第 84 场双周赛 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:0:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#"},{"categories":["力扣"],"content":" 复盘 全国排名：745 / 4574（16.29%） 全球排名：1631 / 23102（7.06%） 分数变化：2112 - 5 = 2107 完成时间：1h52m53s（+25m） 题目1 难度： 顺序：1 用时：2m46s 错误：0 题目2 难度： 顺序：3 用时：6m41s 错误：2 WA：int 溢出 题目3 难度： 顺序：2 用时：25m49s 错误：0 题目4 难度： 顺序：4 用时：20m6s 错误：3 WA：思路错误 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:1:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#复盘"},{"categories":["力扣"],"content":" 合并相似的物品6141. 合并相似的物品 class Solution { public List\u003cList\u003cInteger\u003e\u003e mergeSimilarItems(int[][] items1, int[][] items2) { TreeMap\u003cInteger, Integer\u003e map = new TreeMap\u003c\u003e(); for (int[] a : items1) map.put(a[0], map.getOrDefault(a[0], 0) + a[1]); for (int[] a : items2) map.put(a[0], map.getOrDefault(a[0], 0) + a[1]); List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); for (int key : map.keySet()) ans.add(List.of(key, map.get(key))); return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:2:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#合并相似的物品"},{"categories":["力扣"],"content":" 统计坏数对的数目6142. 统计坏数对的数目 class Solution { public long countBadPairs(int[] nums) { int n = nums.length; long ans = (long) n * (n - 1) / 2; Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c n; i++) { int x = i - nums[i]; ans -= map.getOrDefault(x, 0); map.put(x, map.getOrDefault(x, 0) + 1); } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:3:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#统计坏数对的数目"},{"categories":["力扣"],"content":" 任务调度器 II6174. 任务调度器 II class Solution { public long taskSchedulerII(int[] tasks, int space) { HashMap\u003cInteger, Long\u003e map = new HashMap\u003c\u003e(); // 任务起始时间 long ans = 0; for (int task : tasks) { // 当前任务开始之前必须上个任务结束并且上个同类型任务间隔 space 天 ans = Math.max(ans + 1, map.getOrDefault(task, 0L)); map.put(task, ans + space + 1); } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:4:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#任务调度器-ii"},{"categories":["力扣"],"content":" 将数组排序的最少替换次数6144. 将数组排序的最少替换次数 class Solution { public long minimumReplacement(int[] nums) { long ans = 0; int next = Integer.MAX_VALUE; for (int i = nums.length - 1; i \u003e= 0; i--) { if (nums[i] \u003e next) { int x = (nums[i] + next - 1) / next; // 向上取整 ans += x - 1; next = nums[i] / x; } else { next = nums[i]; } } return ans; } } ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:5:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#将数组排序的最少替换次数"},{"categories":["力扣"],"content":" 总结 哈希表 遍历 ","date":"2022-08-07","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:6:0","series":null,"tags":["力扣","周赛"],"title":"力扣第84场双周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#总结"},{"categories":["力扣"],"content":"1545. 找出第 N 个二进制字符串中的第 K 位 class Solution { public char findKthBit(int n, int k) { if (n == 1 || k == 1) return '0'; int mid = 1 \u003c\u003c (n - 1); // 找中点 if (k == mid) return '1'; else if (k \u003c mid) return findKthBit(n - 1, k); // 顺序找左边 else return (char) ('0' + '1' - findKthBit(n - 1, mid * 2 - k)); // 逆序找右边，且翻转 } } ","date":"2022-08-06","objectID":"/posts/%E5%8A%9B%E6%89%A3-1545-%E6%89%BE%E5%87%BA%E7%AC%ACn%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%BD%8D/:0:0","series":null,"tags":["力扣","递归"],"title":"力扣 1545 🟨找出第N个二进制字符串中的第K位","uri":"/posts/%E5%8A%9B%E6%89%A3-1545-%E6%89%BE%E5%87%BA%E7%AC%ACn%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%BD%8D/#"},{"categories":["算法"],"content":" 1.首尾双指针 要求数组有序。 两数之和： 167. 两数之和 II - 输入有序数组 class Solution { public int[] twoSum(int[] numbers, int target) { int l = 0; int r = numbers.length - 1; while (l \u003c r) { int sum = numbers[l] + numbers[r]; if (sum \u003e target) r--; else if (sum \u003c target) l++; else return new int[] { l + 1, r + 1 }; } return null; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#1首尾双指针"},{"categories":["算法"],"content":" 2.快慢双指针检测链表中的环： ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#2快慢双指针"},{"categories":["算法"],"content":" 3.二路归并 ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:3:0","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#3二路归并"},{"categories":["算法"],"content":" 3.三指针荷兰国旗问题： 75. 颜色分类 class Solution { public void sortColors(int[] nums) { int l = 0; int m = 0; int r = nums.length - 1; while (m \u003c= r) { if (nums[m] == 0) { swap(nums, l, m); l++; m++; } else if (nums[m] == 1) { m++; } else if (nums[m] == 2) { swap(nums, m, r); r--; } } } static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } 三向切分快排： static void quickSort(int[] arr, int low, int high) { // [low, high] if (low \u003e= high) return; // 1. 随机选取 pivot int pivotIndex = low + (int) (Math.random() * (high - low + 1)); // 2. partition int pivot = arr[pivotIndex]; int l = low; int m = low; int r = high; while (m \u003c= r) { if (arr[m] \u003c pivot) { swap(arr, l, m); l++; m++; } else if (arr[m] \u003e pivot) { swap(arr, m, r); r--; } else { m++; } } // 3. 递归子数组 quickSort(arr, low, l - 1); quickSort(arr, r + 1, high); } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:4:0","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#3三指针"},{"categories":["算法"],"content":" 4. k 路归并","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:5:0","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#4-k-路归并"},{"categories":["算法"],"content":" 实战","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:0","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#实战"},{"categories":["算法"],"content":" 🟩移动零283. 移动零 快慢双指针 class Solution { public void moveZeroes(int[] nums) { int j = 0; // 指向 0 for (int i = 0; i \u003c nums.length; i++) if (nums[i] != 0) swap(nums, i, j++); } void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:1","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#移动零"},{"categories":["算法"],"content":" 🟩链表的中间结点876. 链表的中间结点 快慢双指针 class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null \u0026\u0026 fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:2","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#链表的中间结点"},{"categories":["算法"],"content":" 🟩反转字符串344. 反转字符串 首尾双指针 class Solution { public void reverseString(char[] s) { for (int l = 0, r = s.length - 1; l \u003c r; l++, r--) { char temp = s[l]; s[l] = s[r]; s[r] = temp; } } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:3","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#反转字符串"},{"categories":["算法"],"content":" 🟩有序数组的平方977. 有序数组的平方 首尾双指针 class Solution { public int[] sortedSquares(int[] nums) { int n = nums.length; int[] ans = new int[n]; int k = n - 1; for (int i = 0, j = n - 1; i \u003c= j;) { if (Math.abs(nums[i]) \u003e Math.abs(nums[j])) { ans[k--] = nums[i] * nums[i++]; } else { ans[k--] = nums[j] * nums[j--]; } } return ans; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:4","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#有序数组的平方"},{"categories":["算法"],"content":" 🟨盛最多水的容器11. 盛最多水的容器 首尾双指针 public class Solution { public int maxArea(int[] height) { int ans = 0; for (int l = 0, r = height.length - 1; l \u003c r;) { ans = Math.max(ans, Math.min(height[l], height[r]) * (r - l)); if (height[l] \u003c= height[r]) l++; else r--; } return ans; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:5","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#盛最多水的容器"},{"categories":["算法"],"content":" 🟨删除链表的倒数第 N 个结点19. 删除链表的倒数第 N 个结点 快慢双指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); ListNode front = head; while (front != null \u0026\u0026 n-- \u003e 0) front = front.next; ListNode rear = dummy; while (front != null) { front = front.next; rear = rear.next; } rear.next = rear.next.next; return dummy.next; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:6","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#删除链表的倒数第-n-个结点"},{"categories":["算法"],"content":" 🟨两数之和 II167. 两数之和 II - 输入有序数组 首尾双指针 class Solution { public int[] twoSum(int[] numbers, int target) { for (int l = 0, r = numbers.length - 1; l \u003c r;) { int sum = numbers[l] + numbers[r]; if (sum == target) return new int[] { l + 1, r + 1 }; else if (sum \u003e target) r--; else l++; } return null; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:7","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#两数之和-ii"},{"categories":["算法"],"content":" 🟨两数之和1. 两数之和 首尾双指针 class Solution { public int[] twoSum(int[] nums, int target) { int n = nums.length; int[][] arr = new int[n][2]; for (int i = 0; i \u003c n; i++) { arr[i][0] = nums[i]; arr[i][1] = i; } Arrays.sort(arr, (a, b) -\u003e a[0] - b[0]); for (int l = 0, r = n - 1; l \u003c r;) { int sum = arr[l][0] + arr[r][0]; if (sum == target) return new int[] { arr[l][1], arr[r][1] }; else if (sum \u003e target) r--; else l++; } return null; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:8","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#两数之和"},{"categories":["算法"],"content":" 🟩两数之和 III170. 两数之和 III - 数据结构设计 首尾双指针 class TwoSum { private List\u003cInteger\u003e arr = new ArrayList\u003c\u003e(); private boolean sorted = true; public void add(int number) { arr.add(number); sorted = false; } public boolean find(int value) { if (!sorted) { Collections.sort(arr); sorted = true; } for (int l = 0, r = arr.size() - 1; l \u003c r;) { int sum = arr.get(l) + arr.get(r); if (sum == value) return true; else if (sum \u003e value) r--; else l++; } return false; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:9","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#两数之和-iii"},{"categories":["算法"],"content":" 🟩两数之和 IV653. 两数之和 IV - 输入二叉搜索树 首尾双指针 class Solution { public boolean findTarget(TreeNode root, int k) { if (root == null) return false; Deque\u003cTreeNode\u003e seq = new ArrayDeque\u003c\u003e(); // 中序遍历 Deque\u003cTreeNode\u003e rev = new ArrayDeque\u003c\u003e(); // 逆序的中序遍历 seq.push(root); rev.push(root); boolean goLeft = true; boolean goRight = true; while (!seq.isEmpty() \u0026\u0026 !rev.isEmpty()) { if (goLeft) { TreeNode p = seq.peek(); while (p.left != null) { seq.push(p.left); p = p.left; } } if (goRight) { TreeNode p = rev.peek(); while (p.right != null) { rev.push(p.right); p = p.right; } } TreeNode head = seq.peek(); TreeNode tail = rev.peek(); if (head == tail) return false; int sum = head.val + tail.val; if (sum == k) return true; else if (sum \u003e k) { rev.pop(); goLeft = false; goRight = true; } else { seq.pop(); goLeft = true; goRight = false; } if (goLeft \u0026\u0026 head.right != null) seq.push(head.right); else goLeft = false; if (goRight \u0026\u0026 tail.left != null) rev.push(tail.left); else goRight = false; } return false; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:10","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#两数之和-iv"},{"categories":["算法"],"content":" 🟩小于 K 的两数之和1099. 小于 K 的两数之和 首尾双指针 class Solution { public int twoSumLessThanK(int[] nums, int k) { Arrays.sort(nums); int ans = -1; for (int l = 0, r = nums.length - 1; l \u003c r;) { if (nums[l] + nums[r] \u003e= k) r--; else { ans = Math.max(ans, nums[l] + nums[r]); l++; } } return ans; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:11","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#小于-k-的两数之和"},{"categories":["算法"],"content":" 🟨三数之和15. 三数之和 首尾双指针 class Solution { public List\u003cList\u003cInteger\u003e\u003e threeSum(int[] nums) { Arrays.sort(nums); List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); int n = nums.length; for (int i = 0; i \u003c n; i++) { // 相同元素只选择第一个 if (i \u003e 0 \u0026\u0026 nums[i - 1] == nums[i]) continue; for (int j = i + 1, k = n - 1; j \u003c k;) { int sum = nums[i] + nums[j] + nums[k]; if (sum == 0) { ans.add(List.of(nums[i], nums[j++], nums[k--])); // 避免重复 while (j \u003c k \u0026\u0026 nums[j] == nums[j - 1] \u0026\u0026 nums[k] == nums[k + 1]) { j++; k--; } } else if (sum \u003e 0) k--; else j++; } } return ans; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:12","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#三数之和"},{"categories":["算法"],"content":" 🟨最接近的三数之和16. 最接近的三数之和 首尾双指针 class Solution { public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int ans = 0; int minDiff = Integer.MAX_VALUE; for (int a = 0; a \u003c nums.length; a++) { // 重复元素只选第一个 if (a \u003e 0 \u0026\u0026 nums[a - 1] == nums[a]) continue; for (int b = a + 1, c = nums.length - 1; b \u003c c;) { int diff = nums[a] + nums[b] + nums[c] - target; if (diff == 0) return target; if (Math.abs(diff) \u003c minDiff) { ans = diff + target; minDiff = Math.abs(diff); } if (diff \u003e 0) c--; else b++; } } return ans; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:13","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#最接近的三数之和"},{"categories":["算法"],"content":" 🟨较小的三数之和259. 较小的三数之和 首尾双指针 class Solution { public int threeSumSmaller(int[] nums, int target) { Arrays.sort(nums); int ans = 0; int n = nums.length; for (int a = 0; a \u003c n; a++) { for (int b = a + 1, c = n - 1; b \u003c c;) { int sum = nums[a] + nums[b] + nums[c]; if (sum \u003e= target) c--; else { ans += c - b; b++; } } } return ans; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:14","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#较小的三数之和"},{"categories":["算法"],"content":" 🟨四数之和18. 四数之和 首尾双指针 class Solution { public List\u003cList\u003cInteger\u003e\u003e fourSum(int[] nums, int target) { Arrays.sort(nums); List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); int n = nums.length; for (int a = 0; a \u003c n; a++) { // 重复元素只选第一个 if (a \u003e 0 \u0026\u0026 nums[a - 1] == nums[a]) continue; for (int b = a + 1; b \u003c n; b++) { // 重复元素只选第一个 if (b \u003e a + 1 \u0026\u0026 nums[b - 1] == nums[b]) continue; for (int c = b + 1, d = n - 1; c \u003c d;) { long sum = (long) nums[a] + nums[b] + nums[c] + nums[d]; if (sum == target) { ans.add(List.of(nums[a], nums[b], nums[c++], nums[d--])); // 避免重复 while (c \u003c d \u0026\u0026 nums[c - 1] == nums[c] \u0026\u0026 nums[d] == nums[d + 1]) { c++; d--; } } else if (sum \u003e target) d--; else c++; } } } return ans; } } ","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:15","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#四数之和"},{"categories":["算法"],"content":" 参考","date":"2022-08-04","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:7:0","series":null,"tags":["算法","双指针"],"title":"算法-双指针","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/#参考"},{"categories":["力扣"],"content":"15. 三数之和 ","date":"2022-08-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","series":null,"tags":["力扣","双指针"],"title":"力扣 0015 三数之和","uri":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/#"},{"categories":["力扣"],"content":" 方法一：排序+双指针+跳过重复项 class Solution { public List\u003cList\u003cInteger\u003e\u003e threeSum(int[] nums) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i \u003c n; i++) { if (nums[i] \u003e 0) break; // 保证第一个数不重复 if (i \u003e 0 \u0026\u0026 nums[i - 1] == nums[i]) continue; for (int j = i + 1, k = n - 1; j \u003c k;) { // 双指针 int sum = nums[i] + nums[j] + nums[k]; if (sum == 0) { ans.add(List.of(nums[i], nums[j], nums[k])); j++; k--; // 保证第二和第三个数不重复 while (j \u003c k \u0026\u0026 nums[j] == nums[j - 1] \u0026\u0026 nums[k] == nums[k + 1]) { j++; k--; } } else if (sum \u003e 0) k--; else j++; } } return ans; } } ","date":"2022-08-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","series":null,"tags":["力扣","双指针"],"title":"力扣 0015 三数之和","uri":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/#方法一排序双指针跳过重复项"},{"categories":["力扣"],"content":" 方法二：排序+双指针+哈希表去重 时间复杂度更高 class Solution { public List\u003cList\u003cInteger\u003e\u003e threeSum(int[] nums) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); HashSet\u003cList\u003cInteger\u003e\u003e set = new HashSet\u003c\u003e(); Arrays.sort(nums); int n = nums.length; for (int i = 0; i \u003c n; i++) { for (int j = i + 1, k = n - 1; j \u003c k;) { int sum = nums[i] + nums[j] + nums[k]; List\u003cInteger\u003e tuple = List.of(nums[i], nums[j], nums[k]); if (sum == 0 \u0026\u0026 !set.contains(tuple)) { set.add(tuple); ans.add(tuple); j++; k--; } else if (sum \u003e 0) k--; else j++; } } return ans; } } ","date":"2022-08-03","objectID":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:2:0","series":null,"tags":["力扣","双指针"],"title":"力扣 0015 三数之和","uri":"/posts/%E5%8A%9B%E6%89%A3-0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/#方法二排序双指针哈希表去重"},{"categories":["力扣"],"content":"第 304 场周赛 ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:0:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#"},{"categories":["力扣"],"content":" 复盘 全国排名：596 / 7372（8.08%） 全球排名：1246 / 26877（4.64%） 分数变化：2095 + 17 = 2112 完成时间：1h18s（+5m） 题目1 难度： 顺序：1 用时：5m27s 错误：0 题目2 难度： 顺序：4 用时：6m41s 错误：0 题目3 难度： 顺序：2 用时：31m22s 错误：0 题目4 难度： 顺序：3 用时：11m48s 错误：1 WA：把vis误用为onPath ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:1:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#复盘"},{"categories":["力扣"],"content":" 使数组中所有元素都等于零6132. 使数组中所有元素都等于零 class Solution { public int minimumOperations(int[] nums) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); // 去重 for (int x : nums) set.add(x); int ans = 0; int sub = 0; for (int x : set) { if (x == 0) continue; x -= sub; ans++; sub += x; } return ans; } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:2:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#使数组中所有元素都等于零"},{"categories":["力扣"],"content":" 分组的最大数量6133. 分组的最大数量 class Solution { public int maximumGroups(int[] grades) { int n = grades.length; int ans = (int) Math.sqrt(n * 2); if (ans * (ans + 1) / 2 \u003e n) ans--; return ans; } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:3:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#分组的最大数量"},{"categories":["力扣"],"content":" 找到离给定两个节点最近的节点6134. 找到离给定两个节点最近的节点 class Solution { int[] edges; int[] dis; boolean[] vis; int ans = -1; int minDis = Integer.MAX_VALUE; public int closestMeetingNode(int[] edges, int node1, int node2) { this.edges = edges; int n = edges.length; dis = new int[n]; Arrays.fill(dis, -1); vis = new boolean[n]; dfs1(node1, 0); vis = new boolean[n]; dfs2(node2, 0); return ans; } void dfs1(int node, int step) { vis[node] = true; dis[node] = step; if (edges[node] != -1 \u0026\u0026 !vis[edges[node]]) dfs1(edges[node], step + 1); } void dfs2(int node, int step) { vis[node] = true; if (dis[node] != -1) { int d = Math.max(step, dis[node]); if (d \u003c minDis) { minDis = d; ans = node; } else if (d == minDis \u0026\u0026 ans \u003e node) { ans = node; } } if (edges[node] != -1 \u0026\u0026 !vis[edges[node]]) dfs2(edges[node], step + 1); } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:4:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#找到离给定两个节点最近的节点"},{"categories":["力扣"],"content":" 图中的最长环6135. 图中的最长环 class Solution { int[] edges; int[] vis; boolean[] onPath; int ans = -1; public int longestCycle(int[] edges) { this.edges = edges; int n = edges.length; vis = new int[n]; onPath = new boolean[n]; for (int i = 0; i \u003c n; i++) if (vis[i] == 0) dfs(i, 1); return ans; } void dfs(int node, int step) { onPath[node] = true; vis[node] = step; if (edges[node] != -1) { if (onPath[edges[node]]) ans = Math.max(ans, step - vis[edges[node]] + 1); if (vis[edges[node]] == 0) dfs(edges[node], step + 1); } onPath[node] = false; } } ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:5:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#图中的最长环"},{"categories":["力扣"],"content":" 总结 考察图论算法：环检测。 变相考察 DFS 和 BFS。 ","date":"2022-07-31","objectID":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/:6:0","series":null,"tags":["力扣","周赛"],"title":"力扣第304场周赛复盘","uri":"/posts/%E5%8A%9B%E6%89%A3%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/#总结"},{"categories":[],"content":" 格式化打印 // 整数 int i = -12; printf(\"^%d$\\n\", i); // ^-12$ printf(\"^%1d$\\n\", i); // ^-12$ printf(\"^%5d$\\n\", i); // ^ -12$ printf(\"^%-1d$\\n\", i); // ^-12$ printf(\"^%-5d$\\n\", i); // ^-12 $ printf(\"^%01d$\\n\", i); // ^-12$ printf(\"^%05d$\\n\", i); // ^-0012$ // 长整数 long x = 12L; printf(\"^%ld$\\n\", x); // ^12$ printf(\"^%5ld$\\n\", x); // ^ 12$ printf(\"^%05ld$\\n\", x); // ^00012$ printf(\"^%-5ld$\\n\", x); // 浮点数 double d = 12.345; printf(\"^%f$\\n\", d); // ^12.345000$ printf(\"^%.1f$\\n\", d); // ^12.3$ printf(\"^%.5f$\\n\", d); // ^12.34500$ printf(\"^%1.1f$\\n\", d); // ^12.3$ printf(\"^%1.5f$\\n\", d); // ^12.34500$ printf(\"^%5.1f$\\n\", d); // ^ 12.3$ printf(\"^%5.5f$\\n\", d); // ^12.34500$ printf(\"^%-5.1f$\\n\", d); // ^12.3 $ printf(\"^%e$\\n\", d); // ^1.234500e+01$ printf(\"^%E$\\n\", d); // ^1.234500E+01$ // 字符 char c = 'a'; printf(\"%c\\n\", c); // a // 字符串 char s[] = \"Hello, world!\"; printf(\"%s\\n\", s); // Hello, world! // 八进制 int m = 12; printf(\"%o\\n\", m); // 14 int k = 014; printf(\"%d\\n\", k); // 12 // 十六进制 int n = 12; printf(\"%x\\n\", n); // c printf(\"%X\\n\", n); // C int q = 0xc; printf(\"%d\\n\", q); // 12 整数 %d：打印单个整数。 %Nd：固定长度为 N，右对齐，填充空格，不截取。(\"%5d\", -12) == \"^^-12\"。 %-Nd：固定长度为 N，左对齐，填充空格，不截取。(\"%-5d\", -12) == \"-12^^\"。 %0Nd：固定长度为 N，右对齐，填充 0，不截取。(\"%05d\", -12) == \"-0012\"。 浮点数 %f：打印单个浮点数 字符 %c：打印单个字符 布尔值 %b：打印单个布尔值 符号 含义 %c 字符 %d 整数 %8d 整数，固定长度，左侧补空白字符，不会截断整数 %8d 整数，固定长度，左侧补空白字符，不会截断整数 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#格式化打印"},{"categories":[],"content":" C++","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:2:0","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#c"},{"categories":[],"content":" Java","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:0","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#java"},{"categories":[],"content":" I/O读取数据 Scanner in = new Scanner(System.in); while (in.hasNext()) { String s = in.next(); int i = in.nextInt(); long l = in.nextLong(); double d = in.nextDouble(); char c = in.nextChar(); byte b = in.nextByte(); } 打印数据 System.out.println(); System.out.print(); System.out.printf(\"%.2f\", Math.PI); // 3.14 重定向 // 从 input.txt 读取输入并输出到 output.txt 中 java Main \u003c input.txt \u003e output.txt # 将 Main1 的输出作为 Main2 的输入 java Main1 | java Main2 命令行参数 class Main { public static void main(String[] args) { // java Main 1 two String a = args[0]; // \"1\" String b = args[1]; // \"two\" } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:1","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#io"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#字符串"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#构造方法"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#常用方法"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#比较"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查找"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#替换"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#分割合并"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#处理"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#子串"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#类型转换"},{"categories":[],"content":" 字符串 构造方法 String​(byte[] bytes) String​(byte[] bytes, int offset, int length) String​(char[] value) String​(char[] value, int offset, int count) String​(StringBuffer buffer) String​(StringBuilder builder) 常用方法 int length()：返回字符串长度。 boolean isEmpty()：字符串是否为空。 String concat(String str)：将 str 拼接到字符串末尾，等同于 +=。 String repeat(int count)：返回重复 count 次得到的字符串。 比较 boolean equals(Object anObject)：字符串是否相等。 boolean equalsIgnoreCase(String anotherString)：字符串是否相等，忽略大小写。 boolean contentEquals(CharSequence cs)：字符串是否相等（可比较 String、StringBuilder、StringBuffer）。 int compareTo(String anotherString)：比较字符串，小于返回 -1，相等返回 0，大于返回 1。 int compareToIgnoreCase​(String str)：比较字符串，忽略大小写，小于返回 -1，相等返回 0，大于返回 1。 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) boolean matches(String regex) boolean contains(CharSequence s) boolean isBlank()：字符串是否为空白（由空格、制表符、换行符、回车符构成）。 查找 char charAt(int index)：返回索引 index 处的字符。 int indexOf(int ch)：返回字符 ch 第一次出现的索引，未找到返回 -1。 int indexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int indexOf(String str)：：返回字符串 str 第一次出现的索引，未找到返回 -1。 int indexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处第一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch)：返回字符 ch 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(int ch, int fromIndex)：返回字符 ch 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str)：返回字符串 str 最后一次出现的索引，未找到返回 -1。 int lastIndexOf(String str, int fromIndex)：返回字符串 str 从 fromIndex 处最后一次出现的索引，未找到返回 -1。 替换 String replace(char oldChar, char newChar)：替换所有指定字符。 String replace(CharSequence target, CharSequence replacement)：替换所有字符串。 String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 分割/合并 String[] split(String regex)：按 regex 分割字符串，支持正则表达式。 String[] split(String regex, int limit) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) 处理 String toLowerCase() String toUpperCase() String strip() String stripLeading(","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#字符判断"},{"categories":[],"content":" 数组 // 一维数组 int[] arr1 = new int[3]; int[] arr2 = { 1, 2, 3 }; // 二维数组 int[][] arr3 = new int[2][2]; int[][] arr4 = { { 1, 2 }, { 3, 4 } }; // 对象数组 User[] arr5 = new User[3]; for (int i = 0; i \u003c 3; i++) arr5[i] = new User(); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:3","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#数组"},{"categories":[],"content":" 变长数组 List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:4","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#变长数组"},{"categories":[],"content":" 链表 // 双向链表 List\u003cInteger\u003e list = new LinkedList\u003c\u003e(); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:5","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#链表"},{"categories":[],"content":" 栈 // 数组实现 Deque\u003cInteger\u003e stack1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque\u003cInteger\u003e stack2 = new LinkedList\u003c\u003e(); API 1: boolean offerLast(E e)：向栈顶添加元素。 E pollLast()：从栈顶删除元素并返回该元素，若栈为空返回 null。 E peekLast()：返回栈顶元素，若栈为空返回 null。 API 2: void push(E e)：向栈顶添加元素。 E pop()：从栈顶删除元素并返回该元素，若栈为空抛出java.util.NoSuchElementException。 E peek()：返回栈顶元素，若栈为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:6","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#栈"},{"categories":[],"content":" 队列 普通队列 // 数组实现 Queue\u003cInteger\u003e queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Queue\u003cInteger\u003e queue2 = new LinkedList\u003c\u003e(); boolean offer(E e)：添加元素到队尾。 E poll()：从队头删除元素并返回该元素，若队列为空返回 null。 E peek()：返回队头元素，若队列为空返回 null。 int size()：返回队列中元素数量。 boolean isEmpty()：返回队列是否为空。 // 遍历，不支持增强 for 循环和迭代器。 while (!queue.isEmpty()) { int e = queue.poll(); } 双端队列 // 数组实现 Deque\u003cInteger\u003e queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque\u003cInteger\u003e queue2 = new LinkedList\u003c\u003e(); boolean offerFirst(E e)：队首添加元素。 boolean offerLast(E e)：队尾添加元素。 E pollFirst()：删除队首元素并返回，若队列为空返回 null。 E pollLast()：删除队尾元素并返回，若队列为空返回 null。 E peekFirst()：返回队首元素，若队列为空返回 null。 E peekLast()：返回队尾元素，若队列为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:7","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#队列"},{"categories":[],"content":" 队列 普通队列 // 数组实现 Queue queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Queue queue2 = new LinkedList\u003c\u003e(); boolean offer(E e)：添加元素到队尾。 E poll()：从队头删除元素并返回该元素，若队列为空返回 null。 E peek()：返回队头元素，若队列为空返回 null。 int size()：返回队列中元素数量。 boolean isEmpty()：返回队列是否为空。 // 遍历，不支持增强 for 循环和迭代器。 while (!queue.isEmpty()) { int e = queue.poll(); } 双端队列 // 数组实现 Deque queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque queue2 = new LinkedList\u003c\u003e(); boolean offerFirst(E e)：队首添加元素。 boolean offerLast(E e)：队尾添加元素。 E pollFirst()：删除队首元素并返回，若队列为空返回 null。 E pollLast()：删除队尾元素并返回，若队列为空返回 null。 E peekFirst()：返回队首元素，若队列为空返回 null。 E peekLast()：返回队尾元素，若队列为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:7","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#普通队列"},{"categories":[],"content":" 队列 普通队列 // 数组实现 Queue queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Queue queue2 = new LinkedList\u003c\u003e(); boolean offer(E e)：添加元素到队尾。 E poll()：从队头删除元素并返回该元素，若队列为空返回 null。 E peek()：返回队头元素，若队列为空返回 null。 int size()：返回队列中元素数量。 boolean isEmpty()：返回队列是否为空。 // 遍历，不支持增强 for 循环和迭代器。 while (!queue.isEmpty()) { int e = queue.poll(); } 双端队列 // 数组实现 Deque queue1 = new ArrayDeque\u003c\u003e(); // 链表实现 Deque queue2 = new LinkedList\u003c\u003e(); boolean offerFirst(E e)：队首添加元素。 boolean offerLast(E e)：队尾添加元素。 E pollFirst()：删除队首元素并返回，若队列为空返回 null。 E pollLast()：删除队尾元素并返回，若队列为空返回 null。 E peekFirst()：返回队首元素，若队列为空返回 null。 E peekLast()：返回队尾元素，若队列为空返回 null。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:7","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#双端队列"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map\u003cString, Integer\u003e map1 = new HashMap\u003c\u003e(); Map\u003cString,Integer\u003e map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#哈希表"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#无序哈希表"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#添加"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#删除"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#排序"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#有序哈希表"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化-1"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询-1"},{"categories":[],"content":" 哈希表 无序哈希表 初始化 Map map1 = new HashMap\u003c\u003e(); Map map2 = new HashMap\u003c\u003e() {{ put(\"one\", 1); put(\"two\", 2); }}; 添加 V put​(K key, V value) key 存在：覆盖旧值，返回旧值。 key 不存在：添加元素，返回 null。 map.put(\"one\", 1); // null {one=1} map.put(\"one\", 2); // 1 {one=2} map.put(\"one\", null); // 2 {one=null} map.put(\"two\", null); // null {one=null, two=null} map.put(null, 1); // null {null=1, one=null, two=null} map.put(null, 2); // 1 {null=2, one=null, two=null} V compute​(K key, BiFunction\u003c? super K, ​? super V,​? extends V\u003e remappingFunction) key 存在：若新值为 null 则删除元素，返回 null；若新值不为 null 则覆盖旧值，返回新值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.compute(\"one\", (k, v) -\u003e 1); // 1 {one=1} map.compute(\"two\", (k, v) -\u003e 2); // 2 {one=1, two=2} map.compute(\"two\", (k, v) -\u003e null); // null {one=1} V putIfAbsent​(K key, V value) key 存在：返回旧值。 key 不存在：添加元素，返回 null。 map.putIfAbsent(\"one\", 10); // 1 {one=1} map.putIfAbsent(\"two\", 2); // null {one=1, two=2} V computeIfAbsent​(K key, Function\u003c? super K,​? extends V\u003e mappingFunction) key 存在：返回旧值。 key 不存在：若新值为 null 则返回 null；若新值不为 null 则添加元素，返回新值。 map.computeIfAbsent(\"one\", k -\u003e 10); // 1 {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e null); // null {one=1, two=2} map.computeIfAbsent(\"three\", k -\u003e 3); // 3 {one=1, three=3, two=2} V computeIfPresent​(K key, BiFunction\u003c? super K,​? super V,​? extends V\u003e remappingFunction) key 存在：覆盖旧值. key 不存在：返回 null。 map.computeIfPresent​(\"one\", (k, v) -\u003e 10); map.computeIfPresent​(\"two\", (k, v) -\u003e null); map.computeIfPresent​(\"two\", (k, v) -\u003e 2); map.computeIfPresent​(\"four\", (k, v) -\u003e null); void putAll​(Map\u003c? extends K, ​? extends V\u003e m)：添加另一个 Map 中的所有元素。 删除 V remove​(Object key)：删除元素。key 存在则返回旧值；key 不存在则返回 null。 void clear()：清空 Map。 boolean remove​(Object key, Object value)：删除指定键值对。 查询 V get​(Object key)：key 存在返回对应的值；key 不存在返回 null。 V getOrDefault​(Object key, V defaultValue)：key 存在返回对应的值；key 不存在返回 defaultValue。 boolean containsKey​(Object key)：是否存在指定 key。 boolean containsValue​(Object value)：是否存在指定 value。 int size()：大小。 boolean isEmpty","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:8","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet\u003cInteger\u003e set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet\u003cInteger\u003e set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator\u003cE\u003e descendingIterator() NavigableSet\u003cE\u003e descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#集合"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#无序集合"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化-2"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#添加-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#删除-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询-2"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历-2"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#排序-1"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#有序集合"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#初始化-3"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#查询-3"},{"categories":[],"content":" 集合 无序集合 初始化 添加 删除 查询 遍历 排序 有序集合 初始化 TreeSet​(Collection\u003c? extends E\u003e c)：使用其他容器进行初始化。 TreeSet​(Comparator\u003c? super E\u003e comparator)：自定义排序规则。 TreeSet set1 = new TreeSet\u003c\u003e(List.of(2, 1, 1, 3, 2)); // [1, 2, 3] TreeSet set2 = new TreeSet\u003c\u003e((a, b) -\u003e b - a); // 降序 查询 E floor(E e)：返回最后一个小于等于 e 的元素，若无返回 null。 E ceiling(E e)：返回第一个大于等于 e 的元素，若无返回 null。 E lower(E e)：返回最后一个小于 e 的元素，若无返回 null。 E higher(E e)：返回第一个大于 e 的元素，若无返回 null。 E first()：返回第一个元素，若无抛出java.util.NoSuchElementException。 E last()：返回最后一个元素，若无抛出java.util.NoSuchElementException。 E pollFirst()：删除并返回第一个元素，若无返回 null。 E pollLast()：删除并返回最后一个元素，若无返回 null。 使用同 TreeMap。 遍历 Iterator descendingIterator() NavigableSet descendingSet() 使用同 TreeMap。 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:9","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#遍历-3"},{"categories":[],"content":" 优先队列","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:10","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#优先队列"},{"categories":[],"content":" 常量 Integer.MAX_VALUE == 2147483647; Integer.MIN_VALUE == -2147483648; Double.POSITIVE_INFINITY; Double.NEGATIVE_INFINITY; ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:11","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#常量"},{"categories":[],"content":" 类型转换 // String 转 int，不能转换抛出 java.lang.NumberFormatException int i = Integer.parseInt(\"123\"); // int 转 二进制字符串 String s = Integer.toBinaryString(123); ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:3:12","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#类型转换-1"},{"categories":[],"content":" 算法模板","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:4:0","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#算法模板"},{"categories":[],"content":" 数据规模","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:4:1","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#数据规模"},{"categories":[],"content":" getMin 功能的栈 两个栈：一个存元素，一个存最小值。最小值可以同步存，也可以不同步。 一个栈：捆绑元素和最小值。 class MinStack { Deque\u003cInteger\u003e stackData = new ArrayDeque\u003c\u003e(); Deque\u003cInteger\u003e stackMin = new ArrayDeque\u003c\u003e(); public void push(int e) { stackData.push(e); if (stackMin.isEmpty()) stackMin.push(e); else stackMin.push(Math.min(e, getMin())); } public int pop() { if (stackData.isEmpty()) throw new Exception(\"栈中没有元素\"); stackMin.pop(); return stackData.pop(); } public int peek() { if (stackData.isEmpty()) throw new Exception(\"栈中没有元素\"); return stackData.peek(); } public int getMin() { if (stackData.isEmpty()) throw new Exception(\"栈中没有元素\"); return stackMin.peek(); } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:4:2","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#getmin-功能的栈"},{"categories":[],"content":" 两个栈组成队列 class TwoStackQueue { Deque\u003cInteger\u003e stackIn = new ArrayDeque\u003c\u003e(); Deque\u003cInteger\u003e stackOut = new ArrayDeque\u003c\u003e(); public void offer(int e) { stackIn.push(e); } public int poll() { check(); return stackOut.pop(); } public int peek() { check(); return stackOut.peek(); } private void check() { if (stackOut.isEmpty() \u0026\u0026 stackIn.isEmpty()) throw new Exception(\"队列中没有元素\"); if (stackOut.isEmpty()) while (!stackIn.isEmpty()) stackOut.push(stackIn.pop()); } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:4:3","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#两个栈组成队列"},{"categories":[],"content":" 用递归函数和栈逆序一个栈 static void reverseStack(Deque\u003cInteger\u003e stack) { if (stack.isEmpty()) return; int bottom = getAndRemoveBottom(stack); reverseStack(stack); stack.push(bottom); } static int getAndRemoveBottom(Deque\u003cInteger\u003e stack) { int top = stack.poll(); if (stack.isEmpty()) return top; else { int bottom = getAndRemoveBottom(stack); stack.push(top); return bottom; } } ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:4:4","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#用递归函数和栈逆序一个栈"},{"categories":[],"content":" 猫狗队列 ","date":"2022-07-30","objectID":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/:4:5","series":null,"tags":[],"title":"竞赛编程","uri":"/posts/%E7%AB%9E%E8%B5%9B%E7%BC%96%E7%A8%8B/#猫狗队列"},{"categories":[],"content":" 什么是网络协议？在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#什么是网络协议"},{"categories":[],"content":" TCP/IP 和 OSI TCP/IP：四层。应用层（Application）、传输层（Transport）、网际层（Internet）、网络接口层（Network Access）。 OSI：七层。应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#tcpip-和-osi"},{"categories":[],"content":" 为什么要对网络协议分层？优点： 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述。 缺点： 功能可能出现在多个层里，产生了额外开销。 开放系统互联基本参考模型（OSI/RM），简称为 OSI，其概念清楚，理论也较完整，但既复杂又不实用。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:2:1","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#为什么要对网络协议分层"},{"categories":[],"content":" 应用层应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。 基于 TCP 的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 HTTPS（HTTP over SSL，安全超文本传输协议），HTTP 协议的安全版本。 FTP（File Transfer Protocol，文件传输协议），文件传输。 POP3（Post Office Protocol version 3，邮局协议），收邮件。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），发邮件。 SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 基于 UDP 的协议： DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 基于 TCP 和 UDP 的协议： DNS（Domain Name System，域名系统），根据域名查找 IP。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:2:2","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#应用层"},{"categories":[],"content":" 传输层传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用 TCP 和 UDP 两种协议。 TCP（Transmission Control Protocol，传输控制协议）：提供面向连接的，可靠的数据传输服务。 UDP（User Datagram Protocol，用户数据报协议）：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一、一对多、多对一和多对多交互通信 一对一通信 传输方式 面向报文 面向字节流 首部开销 首部8B 首部20B-60B 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:2:3","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#传输层"},{"categories":[],"content":" 网际层网际层（Internet Layer）的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网际层使用 IP（Internet Protocol，网际协议）协议，因此分组也叫 IP 数据报，简称数据报。 互联网是由大量的异构（Heterogeneous）网络通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的 IP 协议和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:2:4","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#网际层"},{"categories":[],"content":" 数据链路层数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 web 应用的通信传输流 发送端在上层向下层传输数据时，每经过一层时会添加一个该层所属的首部信息。反之，接收端在下层向上层传输数据时，每经过一层时会把对应该层的首部信息去除，只传输数据。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:2:5","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#数据链路层"},{"categories":[],"content":" 物理层在物理层上所传送的数据单位是比特。物理层（Physical Layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。 比特流的透明传送：表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:2:6","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#物理层"},{"categories":[],"content":" TCP 三次握手和四次挥手TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。 所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。 TCP 可以看成是一种字节流，它会处理网际层或更低层的丢包、重复以及错误问题。 在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 一个 TCP 连接由一个 4 元组构成，分别是两个 ip 地址和两个端口号。 一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。 通过三次握手建立一个链接，通过四次挥手来关闭一个连接。 当一个连接被建立或被关闭时，交换的报文段只包含 TCP 头部，而没有数据。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#tcp-三次握手和四次挥手"},{"categories":[],"content":" TCP 报文的头部结构 TCP 报文的头部结构 序号（Sequence Number，seq）：32 bit，4B，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号（Acknowledgement Number，ack）：32 bit，4B，只有 ACK 标志位置为 1 时，确认序号字段才有效，确认方ack=发送方seq+1。 标志位：1 bit，6 个共 6 bit。 URG（urgent）：紧急指针（Urgent Pointer）有效。 ACK（acknowledgment）：确认序号有效。 PSH（push）：接收方应该尽快将这个报文交给应用层。 RST（reset）：重置连接。 SYN（synchronize）：发起一个新连接。 FIN（finish）：释放一个连接。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:1","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#tcp-报文的头部结构"},{"categories":[],"content":" 建立连接的三次握手三次握手的本质是确认通信双方接收和发送数据的能力。 握手前。我不知道我能否发送和接收数据；对方也不知道他能否发送和接收数据。 第一次握手。我发送数据，对方收到，则对方知道我能发送数据，他自己能接收数据。 第二次握手。对方发送数据，他告诉我收到了我之前发送的数据，我收到，则我知道对方能发送和接收数据，我自己能发送和接收数据。 第三次握手。我发送数据，我告诉对方收到了他之前发送的数据，对方收到，则对方知道我能发送和接收数据，他自己能发送和接收数据。 握手后。双方都确认对方能够发送和接收数据，自己也能够发送和接收数据。连接建立。 TCP 建立连接的三次握手 第一次握手。客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（假设 100），那客户端向服务端发送的报文段 SYN=1，seq=100。 第二次握手。服务端收到客户端发过来的报文后，发现 SYN=1，知道这是一个连接请求，于是将客户端的起始序列号 100 存起来，并且随机生成一个服务端的起始序列号（假设 300）。然后给客户端回复一段报文，回复报文段 SYN=1、ACK=1、seq=300、ack=101（客户端seq + 1）。 第三次握手。客户端收到服务端的回复后发现 ACK=1、ack=101，于是知道服务端已经收到了序列号为 100 的报文；同时发现 SYN=1，知道了服务端同意了这次连接，于是就将服务端的起始序列号 300 保存下来。然后客户端再回复一段报文给服务端，报文 ACK=1、ack=301（服务端seq + 1)、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次 seq 就从 101 开始）。当服务端收到报文后发现 ACK=1、ack=301，就知道客户端已经收到序列号为 300 的报文，就这样客户端和服务端就通过 TCP 建立了连接。 不携带数据的 ACK 报文是不占据序列号的，所以后面第一次正式发送数据时 seq 还是 101。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:2","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#建立连接的三次握手"},{"categories":[],"content":" 关闭连接的四次挥手四次挥手的本质是确认通信双方是否想关闭连接。 挥手前。双方可以互相发送数据。 第一次挥手。我发送数据，告诉对方我想要关闭连接，对方收到，则对方知道我想关闭连接，且我已经准备好关闭连接。 第二次挥手。对方发送数据，告诉我收到了我之前发送的数据，我收到，但我不知道对方是否想关闭连接。 第三次挥手。对方发送数据，告诉我他也想要关闭连接，我收到，则我知道了对方也想关闭连接，因此我正式关闭连接。 第四次挥手。我发送数据，告诉对方收到了他之前发送的数据，对方收到，则对方知道了我知道他也想关闭连接，因此对方正式关闭连接。 挥手后。连接关闭。 TCP 关闭连接的四次挥手 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位 (FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外 FIN报文段即使不携带数据也要占据一个序列号。 第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号 seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。 第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、 序列号seq=2350(2300+50)。 第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、 序列号seq=2350(2300+50)。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:3","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#关闭连接的四次挥手"},{"categories":[],"content":" 为什么 TCP 建立连接是 3 次握手？因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据， 而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端 发过来的数据。 如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进 行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:4","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#为什么-tcp-建立连接是-3-次握手"},{"categories":[],"content":" 为什么 TCP 建立连接是 3 次握手，关闭连接却是 4 次挥手？因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端 收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户 端发FIN报文(所以不能一次性将确认报文和 FIN报文发给客户端，就是这里多出来了一次)。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:5","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#为什么-tcp-建立连接是-3-次握手关闭连接却是-4-次挥手"},{"categories":[],"content":" 为什么客户端第四次挥手后要等 2 MSL 才能释放连接？这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认 ack报文就会重发第三次挥手的报文，这样报文一去一回 长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:6","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#为什么客户端第四次挥手后要等-2-msl-才能释放连接"},{"categories":[],"content":" 如果已经建立连接，但是客户端出现故障？TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:3:7","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#如果已经建立连接但是客户端出现故障"},{"categories":[],"content":" HTTP 和 HTTPS","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:4:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#http-和-https"},{"categories":[],"content":" 常用 HTTP 状态码HTTP 状态码表示客户端 HTTP 请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。 1XX：Informational（信息性），接受的请求正在处理。 100：Continue（继续）。 101：Switching Protocol（切换协议）。 2XX：Success（成功），请求正常处理完毕。 200：OK（成功），表示从客户端发来的请求在服务器端被正确处理。 201：Created（已创建）。 202：Accepted（已创建）。 203：Non-Authoritative Information（未授权信息）。 204：No Content（无内容），表示请求成功，但响应报文不含实体的主体部分。 205：Reset Content（重置内容）。 206：Partial Content（部分内容），进行范围请求成功。 3XX：Redirection（重定向），需要进行附加操作以完成请求。（对于 301/302/303 状态码，几乎所有浏览器都会删除报文主体并自动用 GET 方法重新请求） 300：Multiple Choice（多种选择）。 301：Moved Permanently（永久移动），永久性重定向，表示资源已被分配了新的 URL。 302：Found（临时移动），临时性重定向，表示资源临时被分配了新的 URL。 303：See Other（查看其他位置），表示资源存在着另一个 URL，应使用 GET 方法获取资源。 304：Not Modified（未修改），表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）。 305：Use Proxy（使用代理）。 306：Unused（未使用）。 307：Temporary Redirect（临时重定向），临时性重定向，和 302 类似，但是期望客户端保持请求方法不变向新的地址发出请求。 308：Permanent Redirect（永久重定向）。 4XX：Client Error（客户端错误），服务器无法处理请求。 400：Bad Request（错误请求），请求报文存在语法错误。 401：Unauthorized（未授权），表示发送的请求需要有通过 HTTP 认证的认证信息。 402：Payment Required（需要付款）。 403：Forbidden（禁止访问），表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述。 404：Not found（未找到），表示在服务器上没有找到请求的资源。 405：Method Not Allowed（不允许使用该方法）。 406：Not Acceptable（无法接受）。 407：Proxy Authentication Required（要求代理身份验证）。 408：Request Timeout（请求超时）。 409：Conflict（冲突）。 410：Gone（已失效）。 411：Length Required（需要内容长度头）。 412：Precondition Failed（预处理失败）。 413：Request Entity Too Large（请求实体过长）。 414：Request-URI Too Long（请求网址过长）。 415：Unsupported Media Type（媒体类型不支持）。 416：Requested Range Not Satisfiable（请求范围不合要求）。 417：Expectation Failed（预期结果失败）。 5XX：Server Error（服务器错误），服务器处理请求出错。 500：Internal Sever Error（内部服务器错误），表示服务器端在执行请求时发生了错误。 501：Not Implemented（未实现），表示服务器不支持当前请求所需要的某个功能。 502：Bad Gateway（网关错误）。 503：Service Unavailable（服务不可用），表明服务器暂时处于超负载或正在停机维护，无法处理请求。 504：Gateway Timeout（网关超时）。 505：HTTP Version Not Supported（HTTP 版本不受支持）。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:4:1","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#常用-http-状态码"},{"categories":[],"content":" GET 和 POST说到GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。 HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。 HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。 GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。 POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。 PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。 DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。 GET 和 POST 的区别 Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。 Get请求提交的url中的数据 多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。 Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 Get执行效率却比Post方法好。Get是form提交的默认方法。 GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:4:2","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#get-和-post"},{"categories":[],"content":" 浏览器访问网站的详细过程首先是查找浏览器缓存，浏览器会保存一段时间你之前访问过的一些网址的DNS信息，不同浏览器保存的时常不等。 如果没有找到对应的记录，这个时候浏览器会尝试调用系统缓存来继续查找这个网址的对应DNS信息。 如果还是没找到对应的IP，那么接着会发送一个请求到路由器上，然后路由器在自己的路由器缓存上查找记录，路由器一般也存有DNS信息。 如果还是没有，这个请求就会被发送到ISP（注：Internet Service Provider，互联网服务提供商，就是那些拉网线到你家里的运营商，中国电信中国移动什么的），ISP也会有相 应的ISP DNS服务器，一听中国电信就知道这个DNS服务器的规模肯定不会小，所以基本上都能在这里找得到。题外话：会跑到这里进行查询是因为你没有改动过\"网络中 心\"的\"ipv4\"的DNS地址，万恶的电信联通可以改动了这个DNS服务器，换句话说他们可以让你的浏览器跳转到他们设定的页面上，这也就是人尽皆知的DNS和HTTP劫持，ISP们 还美名曰“免费推送服务”。强烈鄙视这种霸王行为。我们也可以自行修改DNS服务器来防止DNS被ISP污染。 如果还是没有的话， 你的ISP的DNS服务器会将请求发向根域名服务器进行搜索。根域名服务器就是面向全球的顶级DNS服务器，共有13台逻辑上的服务器，从A到M命名，真正 的实体服务器则有几百台，分布于全球各大洲。所以这些服务器有真正完整的DNS数据库。如果到了这里还是找不到域名的对应信息，那只能说明一个问题：这个域名本来就不 存在，它没有在网上正式注册过。或者卖域名的把它回收掉了（通常是因为欠费）。 这也就是为什么打开一个新页面会有点慢，因为本地没什么缓存，要这样递归地查询下去。 多说一句，例如\"mp3.baidu.com\"，域名先是解析出这是个.com的域名，然后跑到管理.com域名的服务器上进行进一步查询，然后是.baidu，最后是mp3， 所以域名结构为：三级域名.二级域名.一级域名。 浏览器终于得到了IP以后，浏览器接着给这个IP的服务器发送了一个http请求，方式为get，例如访问nbut.cn 这个get请求包含了主机（host）、用户代理(User-Agent)，用户代理就是自己的浏览器，它是你的\"代理人\"，Connection（连接属性）中的keep-alive表示浏览器告诉对方服务 器在传输完现在请求的内容后不要断开连接，不断开的话下次继续连接速度就很快了。其他的顾名思义就行了。还有一个重点是Cookies，Cookies保存了用户的登陆信息，在每 次向服务器发送请求的时候会重复发送给服务器。Corome上的F12与Firefox上的firebug(快捷键shift+F5)均可查看这些信息。 发送完请求接下来就是等待回应了 当然了，服务器收到浏览器的请求以后（其实是WEB服务器接收到了这个请求，WEB服务器有iis、apache等），它会解析这个请求（读请求头），然后生成一个响应头和具体响 应内容。接着服务器会传回来一个响应头和一个响应，响应头告诉了浏览器一些必要的信息，例如重要的Status Code，2开头如200表示一切正常，3开头表示重定向，4开头， 如404，呵呵。响应就是具体的页面编码，就是那个……，浏览器先读了关于这个响应的说明书（响应头），然后开始解析这个响应并在页面上显示出来。在下一次CF的时候（不 是穿越火线，是http://codeforces.com/），由于经常难以承受几千人的同时访问，所以CF页面经常会出现崩溃页面，到时候可以点开火狐的firebug或是Chrome的F12看看状 态，不过这时候一般都急着看题和提交代码，似乎根本就没心情理会这个状态吧-.-。 如果是个静态页面，那么基本上到这一步就没了，但是如今的网站几乎没有静态的了吧，基本全是动态的。所以这时候事情还没完，根据我们的经验，浏览器打开一个网址的时 候会慢慢加载这个页面，一部分一部分的显示，直到完全显示，最后标签栏上的圈圈就不转了。 这是因为，主页（index）页面框架传送过来以后，浏览器还要继续向服务器发送请求，请求的内容是主页里面包含的一些资源，如图片，视频，css样式等等。这些\"非静态\"的 东西要一点点地请求过来，所以标签栏转啊转，内容刷啊刷，最后全部请求并加载好了就终于好了。 需要说明的是，对于静态的页面内容，浏览器通常会进行缓存，而对于动态的内容，浏览器通常不会进行缓存。缓存的内容通常也不会保存很久，因为难保网站不会被改动。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:5:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#浏览器访问网站的详细过程"},{"categories":[],"content":" ping 网站的详细过程首先根据目的 IP 和路由表决定走哪个网卡，再根据网卡的子网掩码地址判断目的 IP 是否在子网内。如果不在则会通过 ARP 缓存查询 IP 的网卡地址，不存在的话会通过广播询问目的 IP 的 MAC 地址，得到后就开始发包了，同时 MAC 地址也会被 ARP 缓存起来。 ","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#ping-网站的详细过程"},{"categories":[],"content":" ARP 协议和 RARP 协议","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:7:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#arp-协议和-rarp-协议"},{"categories":[],"content":" DNS 域名解析的过程","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:8:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#dns-域名解析的过程"},{"categories":[],"content":" CDN 原理","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:9:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#cdn-原理"},{"categories":[],"content":" RPC","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:10:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#rpc"},{"categories":[],"content":" 为什么要有 RPC？","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:10:1","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#为什么要有-rpc"},{"categories":[],"content":" 什么是 RPC？","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:10:2","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#什么是-rpc"},{"categories":[],"content":" RPC 架构组件","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:10:3","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#rpc-架构组件"},{"categories":[],"content":" poll、epoll 和 select","date":"2022-07-26","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/:11:0","series":["面试"],"tags":["计算机网络"],"title":"计算机网络面试","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/#pollepoll-和-select"},{"categories":["操作系统"],"content":" 并发","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:0","series":["面试"],"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#并发"},{"categories":["操作系统"],"content":" 参考 编程语言是如何实现并发的之并发模型篇 · 构建我的被动收入 编程语言是如何实现并发的之操作系统篇 · 构建我的被动收入 ","date":"2022-07-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:0","series":["面试"],"tags":["操作系统"],"title":"操作系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#参考"},{"categories":["力扣"],"content":"919. 完全二叉树插入器 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:0:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#"},{"categories":["力扣"],"content":" 方法一：每次insert时BFS查找待插入结点的位置","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法一每次insert时bfs查找待插入结点的位置"},{"categories":["力扣"],"content":" 解题思路插入。BFS 遍历树，找到的第一个左孩子或者右孩子不存在的结点则为待插入结点的父结点。 若左孩子不存在，则新插入结点为父结点的左孩子。 若右孩子不存在，则新插入结点为父结点的右孩子。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; public CBTInserter(TreeNode root) { this.root = root; } public int insert(int val) { Queue\u003cTreeNode\u003e que = new ArrayDeque\u003c\u003e(); que.offer(root); while (!que.isEmpty()) { TreeNode node = que.poll(); if (node.left == null) { node.left = new TreeNode(val); return node.val; } else if (node.right == null) { node.right = new TreeNode(val); return node.val; } que.offer(node.left); que.offer(node.right); } return -1; } public TreeNode get_root() { return root; } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(1)$ insert：$O(n)$，$n$ 为二叉树结点数量，每次insert时执行一遍 BFS 需要遍历大概一半的结点数。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:1:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析"},{"categories":["力扣"],"content":" 方法二：存储最后两层的结点","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法二存储最后两层的结点"},{"categories":["力扣"],"content":" 解题思路 初始化。通过 BFS 遍历树，存储最后两层的结点。 插入。 若最后一层已满，新插入结点为新的一层的第一个结点，其父结点为上一层第一个结点。然后更新最后两层。 若最后一层未满，大小为k，新插入结点插入该层的末尾，其父结点为上一层的第k/2个结点，若k为偶数，则作为左孩子插入，否则是右孩子。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路-1"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; List\u003cTreeNode\u003e row1, row2; // 最后一层，倒数第二层。 int level; // 层数 public CBTInserter(TreeNode root) { this.root = root; Queue\u003cTreeNode\u003e que = new ArrayDeque\u003c\u003e(); que.offer(root); while (!que.isEmpty()) { int size = que.size(); List\u003cTreeNode\u003e row = new ArrayList\u003c\u003e(); while (size-- \u003e 0) { TreeNode node = que.poll(); row.add(node); if (node.left != null) que.offer(node.left); if (node.right != null) que.offer(node.right); } level++; // 更新最后两层 row2 = row1; row1 = row; } ensureLastRow(); } public int insert(int val) { TreeNode node = new TreeNode(val); int k = row1.size(); TreeNode parent = row2.get(k / 2); if (k % 2 == 0) parent.left = node; else parent.right = node; row1.add(node); ensureLastRow(); return parent.val; } public TreeNode get_root() { return root; } void ensureLastRow() { if (row1.size() == 1 \u003c\u003c (level - 1)) { // 最后一层已满 row2 = row1; row1 = new ArrayList\u003c\u003e(); level++; } } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码-1"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(n)$，$n$ 为二叉树结点数量，执行了一遍 BFS。 insert：$O(1)$。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:2:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析-1"},{"categories":["力扣"],"content":" 方法三：队列存储出度小于 2 的结点（即左右孩子不全有）","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法三队列存储出度小于-2-的结点即左右孩子不全有"},{"categories":["力扣"],"content":" 解题思路 初始化。通过 BFS 遍历树，保留遍历队列，找到第一个左孩子或右孩子不存在的结点为止。 插入。队列的队头结点即为父结点，若新插入结点为右孩子则从队列中删除父结点，然后将新插入结点加入队列。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路-2"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; Queue\u003cTreeNode\u003e que = new ArrayDeque\u003c\u003e(); public CBTInserter(TreeNode root) { this.root = root; que.offer(root); while (!que.isEmpty()) { TreeNode node = que.peek(); if (node.left != null) que.offer(node.left); else break; if (node.right != null) { que.offer(node.right); que.poll(); } else break; } } public int insert(int val) { TreeNode node = new TreeNode(val); TreeNode parent = que.peek(); if (parent.left == null) parent.left = node; else { parent.right = node; que.poll(); } que.offer(node); return parent.val; } public TreeNode get_root() { return root; } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码-2"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(n)$，$n$ 为二叉树结点数量，执行了一遍 BFS。 insert：$O(1)$。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:3:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析-2"},{"categories":["力扣"],"content":" 方法四：根据结点的序号的二进制查找结点","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:0","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#方法四根据结点的序号的二进制查找结点"},{"categories":["力扣"],"content":" 解题思路根据完全二叉树可以通过数组存储的性质，定义根结点序号为 1，则序号为k的结点的父结点序号为k/2，左孩子序号为2*k，右孩子序号为2*k+1。 将序号进行二进制表示（忽略最高位的 1），0表示取左子树，1取右子树，则该二进制为根结点到指定序号结点的路径。 例：序号为 5 (二进制为 0b101) 的结点为根结点的左孩子(0)的右孩子(1)。 初始化。通过 DFS 遍历树计算结点数量n。 插入。待插入结点为第n+1个结点，通过其序号二进制找到父结点。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:1","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#解题思路-3"},{"categories":["力扣"],"content":" 代码 class CBTInserter { TreeNode root; int n; // 结点数 public CBTInserter(TreeNode root) { this.root = root; dfs(root); } public int insert(int val) { String path = Integer.toBinaryString(++n); TreeNode node = new TreeNode(val); TreeNode parent = root; // 忽略最高位 1；倒数第二位为父结点 for (int i = 1; i + 1 \u003c path.length(); i++) { if (path.charAt(i) == '0') parent = parent.left; else parent = parent.right; } if (parent.left == null) parent.left = node; else parent.right = node; return parent.val; } public TreeNode get_root() { return root; } void dfs(TreeNode root) { if (root == null) return; n++; dfs(root.left); dfs(root.right); } } ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:2","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#代码-3"},{"categories":["力扣"],"content":" 复杂度分析 初始化：$O(n)$，$n$ 为二叉树结点数量，执行了一遍 DFS。 insert：$O(\\log{n})$，$n$ 个结点的完全二叉树的最大高度为 $\\log_2{n}$。 ","date":"2022-07-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/:4:3","series":null,"tags":["力扣","二叉树"],"title":"力扣 0919 完全二叉树插入器","uri":"/posts/%E5%8A%9B%E6%89%A3-0919-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/#复杂度分析-3"},{"categories":["力扣"],"content":" 图论","date":"2022-07-24","objectID":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/:1:0","series":null,"tags":["力扣"],"title":"力扣题解","uri":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/#图论"},{"categories":["力扣"],"content":" 拓扑排序 207. 课程表 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List\u003cInteger\u003e[] graph = new ArrayList[numCourses]; boolean[] vis = new boolean[numCourses]; boolean[] onPath = new boolean[numCourses]; for (int i = 0; i \u003c numCourses; i++) graph[i] = new ArrayList\u003c\u003e(); for (int[] course : prerequisites) // 建图 graph[course[1]].add(course[0]); for (int u = 0; u \u003c numCourses; u++) // DFS 遍历 if (!vis[u] \u0026\u0026 dfs(graph, u, vis, onPath)) return false; return true; } boolean dfs(List\u003cInteger\u003e[] graph, int u, boolean[] vis, boolean[] onPath) { // 返回是否存在环 vis[u] = true; onPath[u] = true; for (int v : graph[u]) { if (onPath[v]) // 找到环 return true; if (!vis[v] \u0026\u0026 dfs(graph, v, vis, onPath)) // 已找到环，剪枝 return true; } onPath[u] = false; // 回溯 return false; } } ","date":"2022-07-24","objectID":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/:1:1","series":null,"tags":["力扣"],"title":"力扣题解","uri":"/posts/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/#拓扑排序"},{"categories":["算法"],"content":" 质数","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:1:0","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#质数"},{"categories":["算法"],"content":" 判断质数 static boolean isPrime(int n) { if (n \u003c 2) return false; // i * i \u003c= n 可能溢出 for (int i = 2; i \u003c= n / i; i++) if (n % i == 0) return false; return true; } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:1:1","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#判断质数"},{"categories":["算法"],"content":" 埃氏筛法求质数 // isNotPrime[i] 表示 i 是否不是质数 static boolean[] isNotPrime = new boolean[10000]; static void getPrime(int n) { // 判断 [1, n] 中每个数是否是质数 for (int i = 2; i \u003c= n; i++) { if (isNotPrime[i]) continue; for (int j = i; j \u003c= n / i; j++) isNotPrime[i * j] = true; } } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:1:2","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#埃氏筛法求质数"},{"categories":["算法"],"content":" 质因数分解 static List\u003cList\u003cInteger\u003e\u003e decomposition(int n) { // 质因数从小到大排序 // factors[i][0] 表示第 i 个质因数 // factors[i][1] 表示第 i 个质因数的数量 List\u003cList\u003cInteger\u003e\u003e factors = new ArrayList\u003c\u003e(); for (int i = 2; i \u003c= n / i; i++) { if (n % i == 0) { // 质因数 List\u003cInteger\u003e factor = new ArrayList\u003c\u003e(); factor.add(i); int cnt = 0; while (n % i == 0) { // 计算质因数数量 cnt++; n /= i; } factor.add(cnt); factors.add(factor); } } if (n \u003e 1) { // 最后剩下的质因数 List\u003cInteger\u003e factor = new ArrayList\u003c\u003e(); factor.add(n); factor.add(1); factors.add(factor); } return factors; } // 质因数从小到大排序 // factors[i][0] 表示第 i 个质因数 // factors[i][1] 表示第 i 个质因数的数量 int factors[100][2]; int n_factor = 0; // 不同质因数的数量 void decomposition(int n) { for (int i = 2; i \u003c= n / i; i++) { if (n % i == 0) { factors[n_factor][0] = i; while (n % i == 0) { factors[n_factor][1]++; n /= i; } n_factor++; } } if (n \u003e 1) { factors[n_factor][0] = n; factors[n_factor++][1] = 1; } } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:1:3","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#质因数分解"},{"categories":["算法"],"content":" 最大公约数、最小公倍数Greatest Common Divisor Least Common Multiple static int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } static int lcm(int a, int b) { return a * b / gcd(a, b); } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:2:0","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#最大公约数最小公倍数"},{"categories":["算法"],"content":" 平方根","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:3:0","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#平方根"},{"categories":["算法"],"content":" 二分法 static double sqrt(double x) { if (x \u003c 0) return Double.NaN; double threshold = 1e-15; double left = 0.0; double right = x; while (true) { double mid = (left + right) / 2; if (Math.abs(mid * mid - x) \u003c threshold) return mid; else if (mid * mid \u003e x) right = mid; else left = mid; } } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:3:1","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#二分法"},{"categories":["算法"],"content":" 牛顿迭代法 对于函数 $y=\\sqrt{x}$，计算 $y_0=\\sqrt{x_0}$。 $$ y = \\sqrt{x} \\newline y’ = \\frac{1}{2\\sqrt{x}} $$ static double sqrt(double x) { if (x \u003c 0) return Double.NaN; double threshold = 1e-15; double x1 = x; while (Math.abs(x1 - x / x1) \u003e threshold * x1) x1 = (x / x1 + x1) / 2; return x1; } ","date":"2022-07-23","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/:3:2","series":null,"tags":["算法","数论"],"title":"算法-数论","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/#牛顿迭代法"},{"categories":[],"content":" 面向对象设计模式","date":"2022-06-21","objectID":"/posts/java-ee-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Java EE 教程","uri":"/posts/java-ee-%E6%95%99%E7%A8%8B/#面向对象设计模式"},{"categories":[],"content":" DAO 模式DAO（Data Access Objects，数据访问对象）是指位于业务逻辑和持久化数据之间实现对持久化数据的访问。通俗来讲，就是将数据库操作都封装起来。 DAO 模式的优势： 隔离了数据访问代码和业务逻辑代码。业务逻辑代码直接调用 DAO 方法即可，完全感觉不到数据库表的存在。分工明确，数据访问层代码变化不影响业务逻辑代码，这符合单一职能原则，降低了耦合性，提高了可复用性。 隔离了不同数据库实现。采用面向接口编程，如果底层数据库变化，如由 MySQL 变成 Oracle 只要增加 DAO 接口的新实现类即可，原有 MySQL 实现不用修改。这符合“开-闭”原则。该原则降低了代码的耦合性，提高了代码扩展性和系统的可移植性。 DAO 模式组成部分： DAO 接口。把对数据库的所有操作定义成抽象方法，可以提供多种实现。 package org.example.dao; import org.example.entity.Website; import java.util.List; public interface WebsiteDAO { public void insert(Website website) throws Exception; public void update(Website website) throws Exception; public void delete(int websiteId) throws Exception; public Website queryById(int websiteId) throws Exception; public List\u003cWebsite\u003e queryAll() throws Exception; } DAO 实现类。针对不同数据库给出 DAO 接口定义方法的具体实现。 package org.example.dao.impl; import org.example.dao.WebsiteDAO; import org.example.entity.Website; import org.example.utils.DBConnectionUtil; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.ArrayList; import java.util.List; public class WebsiteDAOImpl implements WebsiteDAO { @Override public void insert(Website website) throws Exception { String sql = \"insert into websites (website_name, website_url, website_rank, website_country) values (?, ?, ?, ?)\"; PreparedStatement stmt = null; DBConnectionUtil util = null; try { util = new DBConnectionUtil(); stmt = util.getConnection().prepareStatement(sql); stmt.setString(1, website.getWebsiteName()); stmt.setString(2, website.getWebsiteUrl()); stmt.setInt(3, website.getWebsiteRank()); stmt.setString(4, website.getWebsiteCountry()); stmt.executeUpdate(); stmt.close(); } catch (Exception e) { throw new Exception(\"操作出现异常\"); } finally { if (util != null) { util.close(); } } } @Override public void update(Website website) throws Exception { String sql = \"update websites set website_name=?, website_url=?, website_rank=?, website_country=? where website_id=?\"; PreparedStatement stmt = null; DBConnectionUtil util = null; try { util = new DBConnectionUtil(); stmt = util.getC","date":"2022-06-21","objectID":"/posts/java-ee-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"Java EE 教程","uri":"/posts/java-ee-%E6%95%99%E7%A8%8B/#dao-模式"},{"categories":[],"content":" Java 连接 MySQL 下载并在项目中导入mysql-connector-java-8.0.29.jar。 若是 Maven 项目，则在pom.xml中添加依赖。 \u003c!-- pom.xml --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.29\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class MySQLConnectionDemo { // MySQL 8.0 以下版本 // private static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; private static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; private static final String DB_URL = \"jdbc:mysql://localhost:3306/demo\"; public static void main(String[] args) { try { // 注册 JDBC 驱动 Class.forName(JDBC_DRIVER); // 建立连接 Connection conn = DriverManager.getConnection(DB_URL, \"root\", \"12345678\"); // 执行 SQL Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(\"select * from websites\"); while (rs.next()) { int websiteId = rs.getInt(\"website_id\"); String websiteName = rs.getString(\"website_name\"); System.out.println(websiteId + \" \" + websiteName); } // 关闭资源 rs.close(); stmt.close(); conn.close(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2022-06-21","objectID":"/posts/java-ee-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Java EE 教程","uri":"/posts/java-ee-%E6%95%99%E7%A8%8B/#java-连接-mysql"},{"categories":[],"content":" 索引","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#索引"},{"categories":[],"content":" 为什么使用索引 索引记录数据所在磁盘位置的目录，提升查询速度，减少IO。 索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。 优点 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:1","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#为什么使用索引"},{"categories":[],"content":" 索引的存储位置 InnoDB存储引擎：数据和索引都存放于*.ibd MyISAM存储引擎：数据*.MYD，索引*.MYI ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:2","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#索引的存储位置"},{"categories":[],"content":" 索引数据结构 哈希表为什么 MySQL 没有使用其作为索引的数据结构呢？ Hash 冲突问题 Hash 索引不支持顺序和范围查询 B 树 \u0026 B+树B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。 MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为非聚簇索引。 InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为聚簇索引（或聚集索引），而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:3","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#索引数据结构"},{"categories":[],"content":" 索引数据结构 哈希表为什么 MySQL 没有使用其作为索引的数据结构呢？ Hash 冲突问题 Hash 索引不支持顺序和范围查询 B 树 \u0026 B+树B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。 MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为非聚簇索引。 InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为聚簇索引（或聚集索引），而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:3","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#哈希表"},{"categories":[],"content":" 索引数据结构 哈希表为什么 MySQL 没有使用其作为索引的数据结构呢？ Hash 冲突问题 Hash 索引不支持顺序和范围查询 B 树 \u0026 B+树B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。 MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为非聚簇索引。 InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为聚簇索引（或聚集索引），而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:3","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#b-树--b树"},{"categories":[],"content":" 索引分类 主键索引：主键自带索引。 普通索引：为普通列创建索引。create index \u003cidx_name\u003e on \u003ctable\u003e(\u003ccolumn\u003e) 唯一索引：为有唯一约束的列创建索引。create unique index \u003cidx_name\u003e on \u003ctable\u003e(\u003ccolumn\u003e) 联合索引：为多个列创建索引。create index \u003cidx_name\u003e on \u003ctable\u003e(\u003ccolumn1\u003e, \u003ccolumn2\u003e) 全文索引：在不同列或不同表中查询，MyISAM 存储引擎支持，但实际生产中使用 ElasticSearch、Solr 等代替。 联合索引建议不超过 5 个列。 主键索引(Primary Key)数据表的主键列使用的就是主键索引。 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。 在 MySQL 的 InnoDB 的表中，当没有显式地指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。 二级索引(辅助索引)二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:4","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#索引分类"},{"categories":[],"content":" 索引分类 主键索引：主键自带索引。 普通索引：为普通列创建索引。create index on () 唯一索引：为有唯一约束的列创建索引。create unique index on () 联合索引：为多个列创建索引。create index on (, ) 全文索引：在不同列或不同表中查询，MyISAM 存储引擎支持，但实际生产中使用 ElasticSearch、Solr 等代替。 联合索引建议不超过 5 个列。 主键索引(Primary Key)数据表的主键列使用的就是主键索引。 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。 在 MySQL 的 InnoDB 的表中，当没有显式地指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。 二级索引(辅助索引)二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:4","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#主键索引primary-key"},{"categories":[],"content":" 索引分类 主键索引：主键自带索引。 普通索引：为普通列创建索引。create index on () 唯一索引：为有唯一约束的列创建索引。create unique index on () 联合索引：为多个列创建索引。create index on (, ) 全文索引：在不同列或不同表中查询，MyISAM 存储引擎支持，但实际生产中使用 ElasticSearch、Solr 等代替。 联合索引建议不超过 5 个列。 主键索引(Primary Key)数据表的主键列使用的就是主键索引。 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。 在 MySQL 的 InnoDB 的表中，当没有显式地指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。 二级索引(辅助索引)二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:4","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#二级索引辅助索引"},{"categories":[],"content":" 聚簇索引和非聚簇索引 聚簇索引聚簇索引即索引结构和数据一起存放的索引。主键索引属于聚簇索引。 在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。 优点 聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 缺点 依赖于有序的数据 ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。 非聚簇索引非聚簇索引即索引结构和数据分开存放的索引。 二级索引属于非聚簇索引。 非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 优点 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。 缺点 跟聚簇索引一样，非聚簇索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。当查询列为索引列时（覆盖索引），无需回表查询。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:5","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#聚簇索引和非聚簇索引"},{"categories":[],"content":" 聚簇索引和非聚簇索引 聚簇索引聚簇索引即索引结构和数据一起存放的索引。主键索引属于聚簇索引。 在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。 优点 聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 缺点 依赖于有序的数据 ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。 非聚簇索引非聚簇索引即索引结构和数据分开存放的索引。 二级索引属于非聚簇索引。 非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 优点 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。 缺点 跟聚簇索引一样，非聚簇索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。当查询列为索引列时（覆盖索引），无需回表查询。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:5","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#聚簇索引"},{"categories":[],"content":" 聚簇索引和非聚簇索引 聚簇索引聚簇索引即索引结构和数据一起存放的索引。主键索引属于聚簇索引。 在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。 优点 聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 缺点 依赖于有序的数据 ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。 非聚簇索引非聚簇索引即索引结构和数据分开存放的索引。 二级索引属于非聚簇索引。 非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 优点 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。 缺点 跟聚簇索引一样，非聚簇索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。当查询列为索引列时（覆盖索引），无需回表查询。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:5","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#非聚簇索引"},{"categories":[],"content":" 覆盖索引如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！ 覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:6","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#覆盖索引"},{"categories":[],"content":" 联合索引使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。 最左前缀匹配原则在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 \u003e、\u003c、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。 索引下推索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引（MyISAM）遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:7","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#联合索引"},{"categories":[],"content":" 联合索引使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。 最左前缀匹配原则在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 \u003e、\u003c、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。 索引下推索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引（MyISAM）遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:7","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#最左前缀匹配原则"},{"categories":[],"content":" 联合索引使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。 最左前缀匹配原则在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 \u003e、\u003c、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。 索引下推索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引（MyISAM）遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:7","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#索引下推"},{"categories":[],"content":" 索引注意事项 选择合适的字段创建索引： 不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。 被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。 被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。 频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。 被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。 被频繁更新的字段应该慎重建立索引。 虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。 尽可能的考虑建立联合索引而不是单列索引。 因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。 注意避免冗余索引。 冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a)，那么索引(a)就是冗余索引。如（name,city）和（name）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的，在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。 考虑在字符串类型的字段上使用前缀索引代替普通索引。 前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:1:8","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#索引注意事项"},{"categories":[],"content":" 存储引擎","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#存储引擎"},{"categories":[],"content":" MyISAM 和 InnoDB 的区别是否支持行级锁 MyISAM 只有表级锁(table-level locking)。 InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁。 是否支持事务 MyISAM 不提供事务支持。 InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。 是否支持外键 MyISAM 不支持。 InnoDB 支持。 是否支持数据库异常崩溃后的安全恢复 MyISAM 不支持。 InnoDB 支持。 是否支持 MVCC MyISAM 不支持。 InnoDB 支持。 索引和数据是否分开存储 MyISAM 分开存储，.MYI存索引，.MYD存数据。 InnoDB 一起存储，.ibd文件。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:2:1","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#myisam-和-innodb-的区别"},{"categories":[],"content":" 事务事务是逻辑上的一组操作，要么都执行，要么都不执行。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:3:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#事务"},{"categories":[],"content":" 事务的 ACID 特性 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）：执行事务前后，数据保持一致。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:3:1","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#事务的-acid-特性"},{"categories":[],"content":" InnoDB 如何实现事务 InnoDB 使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 InnoDB 通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:3:2","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#innodb-如何实现事务"},{"categories":[],"content":" 并发事务的 4 个问题 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:3:3","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#并发事务的-4-个问题"},{"categories":[],"content":" 事务隔离级别 READ-UNCOMMITTED（读未提交）： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED（读已提交）： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ（可重复读）： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE（串行化）： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重复读）。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是 InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读） 并不会有任何性能损失。 InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE(串行化) 隔离级别。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:3:4","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#事务隔离级别"},{"categories":[],"content":" 如何避免幻读 将事务隔离级别调整为 SERIALIZABLE 在可重复读的事务级别下，给事务操作的这张表添加表锁 在可重复读的事务级别下，给事务操作的这张表添加 Next-Key Locks ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:3:5","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#如何避免幻读"},{"categories":[],"content":" 锁","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:4:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#锁"},{"categories":[],"content":" 表级锁和行级锁 表级锁： MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。 行级锁： MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:4:1","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#表级锁和行级锁"},{"categories":[],"content":" InnoDB 的锁算法 Record lock：行锁，单个行记录上的锁。 Gap lock：间隙锁，锁定一个范围，不包括记录本身。 Next-key lock：行锁+间隙锁，锁定一个范围，包含记录本身。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:4:2","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#innodb-的锁算法"},{"categories":[],"content":" 优化 使用 or 会使索引会失效，在数据量较大的时候查找效率较低，通常建议使用 union 代替 or。如果 or 两边的字段都有索引 就不会失效。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:5:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#优化"},{"categories":[],"content":" 三大日志 binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#三大日志"},{"categories":[],"content":" 三大日志 binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#binlog"},{"categories":[],"content":" 三大日志 binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#redo-log"},{"categories":[],"content":" 三大日志 binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#两阶段提交"},{"categories":[],"content":" 三大日志 binlog二进制日志 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。 不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。 MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。 记录格式 statement：记录的内容是SQL语句原文。同步时，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。 row：记录具体数据，不可视化。字段和数据全都记录，能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。 mixed：MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。 写入机制 binlog 的写入时机也非常简单，事务执行过程中，先把日志写（write）到 binlog cache，事务提交的时候，再把 binlog cache 写（fsync）到 binlog 文件中。 sync_binlog 0：每次提交事务都只 write，由系统自行判断什么时候执行 fsync。机器宕机，page cache里面的 binlog 会丢失。 1：每次提交事务都会执行 fsync。 N：每次提交事务都 write，但累积 N 个事务后才 fsync。机器宕机，会丢失最近 N 个事务的 binlog 日志。 redo log事务日志 redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 当 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。 缓存 lazy 机制 MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。 后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。 更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。 然后会把“在某个数据页上做了什么修改”（lazy 标记）记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。 刷盘策略 0 ：每次事务提交时不进行刷盘操作 1 ：每次事务提交时都将进行刷盘操作（默认值） 2 ：每次事务提交时都只把 redo log buffer 内容写入 page cache InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。 当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。 日志文件组 硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的 redo 日志文件大小都是一样的。 它采用的是环形数组形式（队列）。 write pos（队尾入队） 是当前记录的位置，一边写一边后移。 checkpoint（队头出队） 是当前要擦除的位置，也是往后推移。 每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。 每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。 两阶段提交解决 binlog 和 redo log 之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。 将 redo log 的写入拆成了两个步骤 prepare 和 commit。 当写入 binlog 时发生异常时，MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。其他情况则提交事务，恢复数据。 undo logundo log（回滚日志），保证事务的原子性。 如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。 回滚日志会先于数据持久化到磁盘上。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#undo-log"},{"categories":[],"content":" 常见问题","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:7:0","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#常见问题"},{"categories":[],"content":" 1. MySQL 驱动是什么？MySQL 驱动会在底层跟数据库建立网络连接，之后才能发送请求给数据库服务器，Java 代码才能基于这个连接去执行各种各样的增删改查 SQL 语句。 MySQL 官方会提供对应各种语言的 MySQL 驱动，让各种语言编写的系统通过 MySQL 驱动去访问 MySQL 数据库。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:7:1","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#1-mysql-驱动是什么"},{"categories":[],"content":" 2. 数据库连接池是什么？Tomcat 有多个线程来并发的处理同时接收到的多个请求，若这些线程争用一个数据库连接去访问数据库的话，效率十分低下。 数据库连接池，即存放多个数据库连接的“池塘”，让多个线程可以使用里面的数据库连接去执行 SQL 语句，执行完之后把连接放回池子里，后续还可以继续使用。 常见的数据库连接池有 DBCP、C3P0、Druid 等。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:7:2","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#2-数据库连接池是什么"},{"categories":[],"content":" 3. MySQL 数据库中的连接池是什么？MySQL 内维护的与系统之间的多个数据库连接的“池塘”。 当系统每次跟 MySQL 建立连接时，进行账号密码的验证、库表权限的验证。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:7:3","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#3-mysql-数据库中的连接池是什么"},{"categories":[],"content":" 4. MySQL 如何执行 SQL 语句？现在假设我们的数据库服务器的连接池中的某个连接接收到了网络请求，假设就是一条SQL语句，那么大家先思考一个问题， 谁负责从这个连接中去监听网络请求?谁负责从网络连接里把请求数据读取出来? 我想很多人恐怕都没思考过这个问题，但是如果大家对计算机基础知识有一个简单了解的话，应该或多或少知道一点，那就是 网络连接必须得分配给一个线程去进行处理，由一个线程来监听请求以及读取请求数据，比如从网络连接中读取和解析出来一 条我们的系统发送过去的SQL语句，如下图所示: 所以MySQL内部首先提供了一个组件，就是 SQL接口(SQL Interface)，他是一套执行SQL语句的接口，专门用于执行我们 发送给MySQL的那些增删改查的SQL语句 因此MySQL的工作线程接收到SQL语句之后，就会转交给SQL接口去执行，如下图。 MySQL自己本 身也是一个系统，是一个数据库管理系统，他没法直接理解这些SQL语句! 查询解析器(Parser) 就是负责对SQL语句进行解析的，比如对上面那个SQL语句进行一下拆解，拆解成以下几个部分: 我们现在要从“users”表里查询数据 查询“id”字段的值等于1的那行数据 对查出来的那行数据要提取里面的“id,name,age”三个字段。 当我们通过解析器理解了SQL语句要干什么之后，接着会找 查询优化器(Optimizer) 来选择一个最优的查询路径。 所以查询优化器大概就是干这个的，他会针对你编写的几十行、几百行甚至上千行的复杂SQL语句生成查询路径树，然后从里 面选择一条最优的查询路径出来。 最后一步，就是把查询优化器选择的最优查询路径，也就是你到底应该按照一个什么样的顺序和步骤去执行这个SQL语句的计 划，把这个计划交给底层的存储引擎去真正的执行。 但是存储引擎的话，他是支持各种各样的存储引擎的，比如我们常见的InnoDB、MyISAM、Memory等等，我们是可以选择 使用哪种存储引擎来负责具体的SQL语句执行的。 其实我们现在还漏了一个 执行器 的概念，这个执行器会根据优化器选择的执行方案，去调用存储引擎的接口按照一定的顺序和 步骤，就把SQL语句的逻辑给执行了。 执行器就会去根据我们的优化器生成的一套执行计划，然后不停的调用存储引擎的各种接口去完成SQL 语句的执行计划，大致就是不停的更新或者提取一些数据出来 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:7:4","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#4-mysql-如何执行-sql-语句"},{"categories":[],"content":" 5. InnoDB 存储引擎如何查询数据？InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是 缓冲池(Buffer Pool)，这里面会缓存很多的数据， 以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了。 ","date":"2022-06-21","objectID":"/posts/mysql-%E9%9D%A2%E8%AF%95/:7:5","series":["面试"],"tags":["MySQL"],"title":"MySQL 面试","uri":"/posts/mysql-%E9%9D%A2%E8%AF%95/#5-innodb-存储引擎如何查询数据"},{"categories":["算法"],"content":" 1.区间重叠252. 会议室 按区间左端点升序排序。 若上个区间的右端点大于下个区间的左端点，则两区间重叠。 class Solution { public boolean canAttendMeetings(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); for (int i = 1; i \u003c intervals.length; i++) if (intervals[i - 1][1] \u003e intervals[i][0]) return false; return true; } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#1区间重叠"},{"categories":["算法"],"content":" 2.区间合并56. 合并区间 ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#2区间合并"},{"categories":["算法"],"content":" 2.1 排序 按区间左端点升序排序。 若两区间重叠则合并两个区间。 class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); int[][] ans = new int[intervals.length][2]; int index = -1; for (int[] interval : intervals) { if (index == -1 || interval[0] \u003e ans[index][1]) ans[++index] = interval; else ans[index][1] = Math.max(ans[index][1], interval[1]); } return Arrays.copyOf(ans, index + 1); } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:2:1","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#21-排序"},{"categories":["算法"],"content":" 2.2 位图 位图上的 1 表示在区间内，0 表示不在区间内。 将所有区间表示在位图上，最后每个连续的全 1 区间即为合并后的区间。 class Solution { public int[][] merge(int[][] intervals) { BitSet bitSet = new BitSet(); int maxRight = 0; for (int[] interval : intervals) { // 乘 2 为了使像 [1, 2] 和 [3, 4] 这样的区间不连续 // [1, 2] -\u003e [2, 4] // [3, 4] -\u003e [6, 8] int left = interval[0] * 2; int right = interval[1] * 2 + 1; bitSet.set(left, right); // [left, right) maxRight = Math.max(maxRight, right); } int left = 0; int len = 0; while (left \u003c maxRight) { // [left, right) left = bitSet.nextSetBit(left); // 下一个为 1 的位置 int right = bitSet.nextClearBit(left); // 下一个为 0 的位置 intervals[len][0] = left / 2; intervals[len][1] = right / 2; len++; left = right; } return Arrays.copyOf(intervals, len); } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:2:2","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#22-位图"},{"categories":["算法"],"content":" 3.插入区间57. 插入区间 按区间左端点升序排序。 二分查找待插入区间的左端点和右端点位置，合并这些区间。 class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { int n = intervals.length; // 1. 在 intervals 中查找最后一个右端点小于 newInterval 左端点的区间 // 该区间（包含）及之前的区间不用合并 int left = 0; int right = n; int mid; while (left \u003c right) { mid = left + (right - left) / 2; if (intervals[mid][1] \u003c newInterval[0]) left = mid + 1; else right = mid; } // 在 newInterval 之前最后一个不用合并的区间的下标 int start = right - 1; // 2. 在 intervals 中查找第一个左端点大于 newInterval 右端点的区间 // 该区间（包含）及之后的区间不用合并 left = 0; right = n; while (left \u003c right) { mid = left + (right - left) / 2; if (intervals[mid][0] \u003e newInterval[1]) right = mid; else left = mid + 1; } // 在 newInterval 之后第一个不用合并的区间的下标 int end = left; // 3. 合并区间 // [start + 1, end - 1] 区间内的区间需要合并成 1 个区间 int[][] ans = new int[(start + 1) + 1 + (n - end)][2]; int idx = 0; for (int i = 0; i \u003c= start; i++) ans[idx++] = intervals[i]; ans[idx][0] = newInterval[0]; ans[idx][1] = newInterval[1]; if (start + 1 \u003c n) // 需要合并 ans[idx][0] = Math.min(ans[idx][0], intervals[start + 1][0]); if (end - 1 \u003e= 0) // 需要合并 ans[idx][1] = Math.max(ans[idx][1], intervals[end - 1][1]); idx++; for (int i = end; i \u003c n; i++) ans[idx++] = intervals[i]; return ans; } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:3:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#3插入区间"},{"categories":["算法"],"content":" 4.删除区间435. 无重叠区间 按区间左端点升序排序。 当两个区间重叠时，我们选择右端点更小的那个区间。（贪心） class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); int ans = 0; int pre = 0; for (int i = 1; i \u003c intervals.length; i++) { if (intervals[i][0] \u003c intervals[pre][1]) { // 重叠 if (intervals[i][1] \u003c intervals[pre][1]) pre = i; // 被包含 ans++; } else pre = i; // 不重叠 } return ans; } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:4:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#4删除区间"},{"categories":["算法"],"content":" 5. 区间合并、插入、删除综合715. Range 模块 ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:5:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#5-区间合并插入删除综合"},{"categories":["算法"],"content":" 5.1 有序集合 随时保证有序集合中的区间不重叠。 插入区间 $[left, right)$： 二分查找最后一个 $l_i \\le left$，即 $l_i \\le left \u0026\u0026 l_{i+1} \\gt left$ 的区间 $[l_i, r_i)$ 若 若 若 若 删除区间[left, right)： class RangeModule { TreeMap\u003cInteger, Integer\u003e ranges = new TreeMap\u003c\u003e(); // {l=r} public void addRange(int left, int right) { Integer ll = ranges.floorKey(left); // 左侧区间的左端点 ll \u003c= left Integer rl = ranges.floorKey(right); // 右侧区间的左端点 rl \u003c= right // [ll, lr) 和 [left, right) 区间重叠 ll \u003c= left \u003c= lr (ll \u003c lr) if (ll != null \u0026\u0026 ranges.get(ll) \u003e= left) left = ll; // [left, right) 和 [rl, rr) 区间重叠 rl \u003c= right \u003c= rr (rl \u003c rr) if (rl != null \u0026\u0026 ranges.get(rl) \u003e= right) right = ranges.get(rl); // 将 [left, right) 向两端扩充为合并后的区间 ranges.put(left, right); // 迭代器删除被 [left, right) 包含的区间 var it = ranges.keySet().iterator(); while (it.hasNext()) { int l = it.next(); int r = ranges.get(l); if (left \u003c l \u0026\u0026 r \u003c= right) it.remove(); } } public boolean queryRange(int left, int right) { Integer ll = ranges.floorKey(left); // 左侧区间的左端点 ll \u003c= left // 若 ll \u003c= left \u003c right \u003c= lr，则返回 true return ll == null ? false : right \u003c= ranges.get(ll); } public void removeRange(int left, int right) { Integer ll = ranges.lowerKey(left); // 左侧区间的左端点 ll \u003c left Integer rl = ranges.lowerKey(right); // 右侧区间的左端点 rl \u003c right if (ll != null) { int lr = ranges.get(ll); if (lr \u003e right) { // 分割区间 ll \u003c left \u003c right \u003c lr ranges.put(ll, left); ranges.put(right, lr); } else if (lr \u003e left) { // 分割区间 ll \u003c left \u003c lr \u003c= right ranges.put(ll, left); } } if (rl != null) { int rr = ranges.get(rl); // 若 rl \u003c left，则 rl == ll，之前已经分割 if (rr \u003e right) { // 分割区间 left \u003c= rl \u003c right \u003c rr ranges.put(rl, right); // 减小区间，便于删除 ranges.put(right, rr); } } // 迭代器删除被 [left, right) 包含的区间 var it = ranges.keySet().iterator(); while (it.hasNext()) { int l = it.next(); int r = ranges.get(l); if (left \u003c= l \u0026\u0026 r \u003c= right) it.remove(); } } } ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:5:1","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#51-有序集合"},{"categories":["算法"],"content":" 参考 秒懂力扣区间题目：重叠区间、合并区间、插入区间 【C++】【高频考题】剑指 Offer II 074. 合并区间 题解：排序、扫描线基础题 - 合并区间 - 力扣（LeetCode） ","date":"2022-06-20","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/:6:0","series":null,"tags":["算法","区间问题"],"title":"算法-区间问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#参考"},{"categories":["算法"],"content":" 实战 ","date":"2022-06-16","objectID":"/posts/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":["算法","贪心算法"],"title":"算法-贪心算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/#实战"},{"categories":["力扣"],"content":"730. 统计不同回文子序列 ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/:0:0","series":null,"tags":["力扣","动态规划","三维DP"],"title":"力扣 0730 统计不同回文子序列","uri":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/#"},{"categories":["力扣"],"content":" 方法一：三维DP状态定义： dp[x][i][j]表示在字符串区间s[i:j]（包含j）中以字符x开头和结尾的不同回文序列数量。 则答案为求 $\\sum_{i=0}^Cdp[x_i][0][n-1] \\bmod 1000000007$，其中 $x_i \\in S$，$S$ 为字符串中出现的字符集合，$C$ 为该字符集合的大小。 状态转移方程： s[i]==x \u0026\u0026 s[j]==x时，s[i+1:j-1]中的回文序列加上s[i]和s[j]会构成新的以x开头和结尾的回文序列。再加上xx和x两个回文序列。 $$ dp[x][i][j]=2+\\sum_{k=0}^Cdp[x_k][i+1][j-1] $$ s[i]==x \u0026\u0026 s[j]!=x时 $$ dp[x][i][j]=dp[x][i][j-1] $$ s[i]!=x \u0026\u0026 s[j]==x时 $$ dp[x][i][j]=dp[x][i+1][j] $$ s[i]!=x \u0026\u0026 s[j]!=x时 $$ dp[x][i][j]=dp[x][i+1][j-1] $$ 边界条件： 当i==j \u0026\u0026 s[i]==x时，dp[x][i][j]=1 当i==j \u0026\u0026 s[i]!=x时，dp[x][i][j]=0 当i\u003ej时，dp[x][i][j]=0 代码实现： class Solution { static final int MOD = (int) 1e9 + 7; public int countPalindromicSubsequences(String s) { int n = s.length(); int[][][] dp = new int[4][n][n]; // 初始化边界条件 for (int i = 0; i \u003c n; i++) { dp[s.charAt(i) - 'a'][i][i] = 1; } // 遍历 i 和 j for (int step = 1; step \u003c n; step++) { for (int i = 0; i + step \u003c n; i++) { int j = i + step; int x1 = s.charAt(i) - 'a'; int x2 = s.charAt(j) - 'a'; // 状态转移 for (int x = 0; x \u003c 4; x++) { if (x1 == x \u0026\u0026 x2 == x) { dp[x][i][j] = 2; for (int k = 0; k \u003c 4; k++) { dp[x][i][j] = (dp[x][i][j] + dp[k][i + 1][j - 1]) % MOD; } } else if (x1 == x \u0026\u0026 x2 != x) { dp[x][i][j] = dp[x][i][j - 1]; } else if (x1 != x \u0026\u0026 x2 == x) { dp[x][i][j] = dp[x][i + 1][j]; } else { dp[x][i][j] = dp[x][i + 1][j - 1]; } } } } int ans = 0; for (int x = 0; x \u003c 4; x++) { ans = (ans + dp[x][0][n - 1]) % MOD; } return ans; } } 复杂度分析： 时间复杂度：$ O(C^2 \\times n^2) $ 空间复杂度：$ O(C \\times n^2) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/:1:0","series":null,"tags":["力扣","动态规划","三维DP"],"title":"力扣 0730 统计不同回文子序列","uri":"/posts/%E5%8A%9B%E6%89%A3-0730-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/#方法一三维dp"},{"categories":["力扣"],"content":"69. x 的平方根 ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:0:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#"},{"categories":["力扣"],"content":" 方法一：数学 $\\sqrt{x}=x^{\\frac{1}{2}}=(e^{\\ln x})^{\\frac{1}{2}}=e^{\\frac{1}{2}\\ln x}$ 由于计算机无法存储浮点数的精确值，因此运算过程中会存在误差。例如当 $x = 2147395600$ 时的计算结果与正确值 $46340$ 相差 $10^{-11}$，这样在对结果取整数部分时，会得到 $46339$ 这个错误的结果。 class Solution { public int mySqrt(int x) { if (x == 0) return 0; int ans = (int) Math.exp(0.5 * Math.log(x)); return (long) (ans + 1) * (ans + 1) \u003c= x ? ans + 1 : ans; } } 时间复杂度：$ O(1) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:1:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#方法一数学"},{"categories":["力扣"],"content":" 方法二：二分查找 public class Solution { public int mySqrt(int x) { int left = 0; int right = x; while (left \u003c= right) { int mid = left + (right - left) / 2; if ((long) mid * mid \u003c= x) left = mid + 1; else right = mid - 1; } return right; } } 时间复杂度：$ O(\\log x) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:2:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#方法二二分查找"},{"categories":["力扣"],"content":" 方法三：牛顿迭代法 由 $\\sqrt{x} = z$ 得 $z^2-x=0 \\ (z\u003e0)$，则 $z$ 为 $f(z)=z^2-x$ 的零点。 我们任取一个 $z_0$ 作为初始值。 在每一步的迭代中，我们找到函数图像上的点 $(z_i, f(z_i))$，过该点作一条斜率为该点导数 $f’(z_i)=2z_i$ 的直线 $$g(z)=2z_i(z-z_i)+f(z_i)=2z_iz-z_i^2-x$$ 该直线与 x 轴的交点为 $(z_{i+1},0)$，即 $(\\frac{x+z_i^2}{2z_i},0)$。 经过多次迭代后，$z_i$ 会逐渐接近零点。 class Solution { public int mySqrt(int x) { if (x == 0) return 0; double z0 = x; while (true) { double zi = (x + z0 * z0) / (2 * z0); if (Math.abs(z0 - zi) \u003c 1e-7) break; z0 = zi; } return (int) z0; } } 时间复杂度：$ O(\\log x) $ ","date":"2022-06-10","objectID":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/:3:0","series":null,"tags":["力扣","数学","二分查找","牛顿迭代法"],"title":"力扣 0069 X的平方根","uri":"/posts/%E5%8A%9B%E6%89%A3-0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/#方法三牛顿迭代法"},{"categories":["算法"],"content":" 1.基础","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#1基础"},{"categories":["算法"],"content":" 水塘抽样$$ \\begin{aligned} P \u0026= P(第i个节点的值成为最后被返回的值) \\newline \u0026= P(第i次随机选择的值=0) \\times P(第i+1次随机选择的值 \\ne 0) \\times \\cdots \\times P(第n次随机选择的值 \\ne 0) \\newline \u0026= \\frac{1}{i} \\times (1-\\frac{1}{i+1}) \\times \\cdots \\times (1-\\frac{1}{n}) \\newline \u0026= \\frac{1}{i} \\times \\frac{i}{i+1} \\times \\cdots \\times \\frac{n-1}{n} \\newline \u0026= \\frac{1}{n} \\end{aligned} $$ ","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:1:1","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#水塘抽样"},{"categories":["算法"],"content":" 2.实战","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#2实战"},{"categories":["算法"],"content":" 非重叠矩形中的随机点497. 非重叠矩形中的随机点 ","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:2:1","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#非重叠矩形中的随机点"},{"categories":["算法"],"content":" 🟨链表随机节点382. 链表随机节点 水塘抽样 class Solution { ListNode head; Random random; public Solution(ListNode head) { this.head = head; random = new Random(); } public int getRandom() { int i = 1; int ans = 0; for (ListNode node = head; node != null; node = node.next) { // 1/i 的概率选中（替换为答案） if (random.nextInt(i) == 0) ans = node.val; ++i; } return ans; } } ","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:2:2","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#链表随机节点"},{"categories":["算法"],"content":" 参考 链表随机节点 - 链表随机节点 - 力扣（LeetCode） ","date":"2022-06-09","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/:3:0","series":null,"tags":["算法","概率问题"],"title":"算法-概率问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/#参考"},{"categories":["算法"],"content":" 1.介绍 快速求出数组中某一段连续区间的和。 前缀和数组长度为原数组长度加 1 nums = { 1, 2, 3, 4, 5 } prefixSum = { 0, 1, 3, 6, 10, 15 } nums[l] + nums[l + 1] + ... + nums[r] = prefixSum[r + 1] - prefixSum[l] static int[] getPrefixSum(int[] nums) { int n = nums.length; int[] pre = new int[n + 1]; for (int i = 0; i \u003c n; i++) pre[i + 1] = pre[i] + nums[i]; return pre; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:1:0","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#1介绍"},{"categories":["算法"],"content":" 2.实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:2:0","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#2实战"},{"categories":["算法"],"content":" 🟨和为 K 的子数组560. 和为 K 的子数组 class Solution { public int subarraySum(int[] nums, int k) { int n = nums.length; int[] pre = new int[n + 1]; for (int i = 0; i \u003c n; i++) pre[i + 1] = pre[i] + nums[i]; HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int ans = 0; for (int x : pre) { ans += map.getOrDefault(x - k, 0); // pre[j + 1] - pre[i] == k map.put(x, map.getOrDefault(x, 0) + 1); } return ans; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:2:1","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#和为-k-的子数组"},{"categories":["算法"],"content":" 🟨除自身以外数组的乘积238. 除自身以外数组的乘积 class Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] ans = new int[n]; Arrays.fill(ans, 1); int left = 1; int right = 1; for (int i = 0; i \u003c n; i++) { ans[i] *= left; left *= nums[i]; ans[n - 1 - i] *= right; right *= nums[n - 1 - i]; } return ans; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:2:2","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#除自身以外数组的乘积"},{"categories":["算法"],"content":" 参考","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/:3:0","series":null,"tags":["算法","前缀和"],"title":"算法-前缀和","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C/#参考"},{"categories":["算法"],"content":" int[] getDiff(int[] nums) { int n = nums.length; for (int i = n; i \u003e 0; i--) { nums[i] -= nums[i - 1]; } return nums; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%B7%AE%E5%88%86/:0:0","series":null,"tags":null,"title":"算法-差分","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%B7%AE%E5%88%86/#"},{"categories":["算法"],"content":" 1.介绍单调栈可以帮助快速找到每个元素之前/之后第一个大于/大于等于/小于/小于等于当前元素的元素或者其下标。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:1:0","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#1介绍"},{"categories":["算法"],"content":" 2.单调栈存储下标","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:2:0","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#2单调栈存储下标"},{"categories":["算法"],"content":" 2.1 下一个元素的下标 说明 元素 输入 [5, 8, 3, 1, 3, 3, 5] 下个更大的元素的下标 [1, -1, 6, 4, 6, 6, -1] 下个大于等于的元素的下标 [1, -1, 4, 4, 5, 6, -1] 下个更小的元素的下标 [2, 2, 3, -1, -1, -1, -1] 下个小于等于的元素的下标 [2, 2, 3, -1, 5, -1, -1] static int[] getMonoStack(int[] nums) { int n = nums.length; int[] ans = new int[n]; Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = n - 1; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003c= nums[i]) st.pop(); // 下个更大的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003c nums[i]) st.pop(); // 下个大于等于的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e= nums[i]) st.pop(); // 下个更小的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e nums[i]) st.pop(); // 下个小于等于的元素的下标 ans[i] = st.isEmpty() ? -1 : st.peek(); st.push(i); // 存下标 } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:2:1","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#21-下一个元素的下标"},{"categories":["算法"],"content":" 2.2 上一个元素的下标 说明 元素 输入 [5, 8, 3, 1, 3, 3, 5] 上个更大的元素的下标 [-1, -1, 1, 2, 1, 1, 1] 上个大于等于的元素的下标 [-1, -1, 1, 2, 2, 4, 1] 上个更小的元素的下标 [-1, 0, -1, -1, 3, 3, 5] 上个小于等于的元素的下标 [-1, 0, -1, -1, 3, 4, 5] static int[] getMonoStack(int[] nums) { int n = nums.length; int[] ans = new int[n]; Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = 0; i \u003c n; i++) { while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003c= nums[i]) st.pop(); // 上个更大的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003c nums[i]) st.pop(); // 上个大于等于的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e= nums[i]) st.pop(); // 上个更小的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e nums[i]) st.pop(); // 上个小于等于的元素的下标 ans[i] = st.isEmpty() ? -1 : st.peek(); st.push(i); // 存下标 } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:2:2","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#22-上一个元素的下标"},{"categories":["算法"],"content":" 2.3 上一个和下一个元素的下标 static int[][] getMonoStack(int[] nums) { int n = nums.length; int[][] ans = new int[2][n]; Arrays.fill(ans[1], -1); Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = 0; i \u003c n; i++) { // 上个更大的元素的下标 + 下个大于等于的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003c= nums[i]) ans[1][st.pop()] = i; // 上个大于等于的元素的下标 + 下个更大的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003c nums[i]) ans[1][st.pop()] = i; // 上个更小的元素的下标 + 下个小于等于的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e= nums[i]) ans[1][st.pop()] = i; // 上个小于等于的元素的下标 + 下个更小的元素的下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e nums[i]) ans[1][st.pop()] = i; ans[0][i] = st.isEmpty() ? -1 : st.peek(); st.push(i); // 存下标 } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:2:3","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#23-上一个和下一个元素的下标"},{"categories":["算法"],"content":" 3.单调栈存储元素","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:3:0","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#3单调栈存储元素"},{"categories":["算法"],"content":" 3.1 下一个元素 说明 元素 输入 [5, 8, 3, 1, 3, 3, 5] 下个更大的元素 [8, -1, 5, 3, 5, 5, -1] 下个大于等于的元素 [8, -1, 3, 3, 3, 5, -1] 下个更小的元素 [3, 3, 1, -1, -1, -1, -1] 下个小于等于的元素 [3, 3, 1, -1, 3, -1, -1] static int[] getMonoStack(int[] nums) { int n = nums.length; int[] ans = new int[n]; Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = n - 1; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 st.peek() \u003c= nums[i]) st.pop(); // 下个更大的元素 while (!st.isEmpty() \u0026\u0026 st.peek() \u003c nums[i]) st.pop(); // 下个大于等于的元素 while (!st.isEmpty() \u0026\u0026 st.peek() \u003e= nums[i]) st.pop(); // 下个更小的元素 while (!st.isEmpty() \u0026\u0026 st.peek() \u003e nums[i]) st.pop(); // 下个小于等于的元素 ans[i] = st.isEmpty() ? -1 : st.peek(); st.push(nums[i]); // 存元素 } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:3:1","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#31-下一个元素"},{"categories":["算法"],"content":" 3.2 上一个元素 说明 元素 输入 [5, 8, 3, 1, 3, 3, 5] 上个更大的元素 [-1, -1, 8, 3, 8, 8, 8] 上个大于等于的元素 [-1, -1, 8, 3, 3, 3, 8] 上个更小的元素 [-1, 5, -1, -1, 1, 1, 3] 上个小于等于的元素 [-1, 5, -1, -1, 1, 3, 3] static int[] getMonoStack(int[] nums) { int n = nums.length; int[] ans = new int[n]; Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = 0; i \u003c n; i++) { while (!st.isEmpty() \u0026\u0026 st.peek() \u003c= nums[i]) st.pop(); // 上个更大的元素 while (!st.isEmpty() \u0026\u0026 st.peek() \u003c nums[i]) st.pop(); // 上个大于等于的元素 while (!st.isEmpty() \u0026\u0026 st.peek() \u003e= nums[i]) st.pop(); // 上个更小的元素 while (!st.isEmpty() \u0026\u0026 st.peek() \u003e nums[i]) st.pop(); // 上个小于等于的元素 ans[i] = st.isEmpty() ? -1 : st.peek(); st.push(nums[i]); // 存元素 } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:3:2","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#32-上一个元素"},{"categories":["算法"],"content":" 4.总结 // 找下一个元素 for (int i = n - 1; i \u003e= 0; i--) // 找上一个元素 for (int i = 0; i \u003c n; i++) // 存下标 while (!st.isEmpty() \u0026\u0026 nums[st.peek()] ...) st.push(i); // 存元素 while (!st.isEmpty() \u0026\u0026 st.peek() ...) st.push(nums[i]); // 更大的元素 while (!st.isEmpty() \u0026\u0026 ... \u003c= nums[i]) // 大于等于的元素 while (!st.isEmpty() \u0026\u0026 ... \u003c nums[i]) // 更小的元素 while (!st.isEmpty() \u0026\u0026 ... \u003e= nums[i]) // 小于等于的元素 while (!st.isEmpty() \u0026\u0026 ... \u003e nums[i]) ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:4:0","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#4总结"},{"categories":["算法"],"content":" 5.实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:5:0","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#5实战"},{"categories":["算法"],"content":" 🟩商品折扣后的最终价格1475. 商品折扣后的最终价格 class Solution { public int[] finalPrices(int[] prices) { int n = prices.length; int[] ans = new int[n]; // 单调栈，找到下个小于等于当前值的元素 Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = n - 1; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 st.peek() \u003e prices[i]) st.pop(); ans[i] = prices[i] - (st.isEmpty() ? 0 : st.peek()); st.push(prices[i]); } return ans; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:5:1","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#商品折扣后的最终价格"},{"categories":["算法"],"content":" 🟩下一个更大元素 I496. 下一个更大元素 I class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int n1 = nums1.length; int n2 = nums2.length; HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c n1; i++) map.put(nums1[i], i); int[] nextGT = getMonoStack(nums2); int[] ans = new int[n1]; for (int i = 0; i \u003c n2; i++) if (map.containsKey(nums2[i])) ans[map.get(nums2[i])] = nextGT[i]; return ans; } static int[] getMonoStack(int[] nums) { int n = nums.length; int[] ans = new int[n]; Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = n - 1; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 st.peek() \u003c= nums[i]) st.pop(); // 下个更大的元素 ans[i] = st.isEmpty() ? -1 : st.peek(); st.push(nums[i]); // 存元素 } return ans; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:5:2","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#下一个更大元素-i"},{"categories":["算法"],"content":" 🟨下一个更大元素 II503. 下一个更大元素 II class Solution { public int[] nextGreaterElements(int[] nums) { int n = nums.length; int[] ans = new int[n * 2]; Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = 2 * n - 1; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 st.peek() \u003c= nums[i % n]) st.pop(); // 下个更大的元素 ans[i] = st.isEmpty() ? -1 : st.peek(); st.push(nums[i % n]); // 存元素 } return Arrays.copyOf(ans, n); } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:5:3","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#下一个更大元素-ii"},{"categories":["算法"],"content":" 🟨每日温度739. 每日温度 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] ans = new int[n]; Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); for (int i = n - 1; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 temperatures[st.peek()] \u003c= temperatures[i]) st.pop(); // 下个更大的元素的下标 ans[i] = st.isEmpty() ? 0 : st.peek() - i; st.push(i); // 存下标 } return ans; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:5:4","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#每日温度"},{"categories":["算法"],"content":" 参考","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/:6:0","series":null,"tags":["算法","单调栈"],"title":"算法-单调栈","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88/#参考"},{"categories":["数据结构"],"content":" 一棵 n 个节点的树，有 n-1 条边。 一棵 n 个节点的树，有 n 棵子树。 根节点：唯一，无入度的节点 节点的深度：节点距离根节点的距离。 typedef struct treeNode { treeNode(int x): value(x) {} int value; vector\u003ctreeNode*\u003e child; } TreeNode; class TreeNode { public int val; public TreeNode[] children; TreeNode() { this.val = 0; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/#"},{"categories":["算法"],"content":" 排列 \u0026 组合 \u0026 子集","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#排列--组合--子集"},{"categories":["算法"],"content":" 无重 \u0026 不放回 子集 static List\u003cList\u003cInteger\u003e\u003e subsets(int[] nums) { // 返回无重数组的所有子集 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); dfs(nums, 0, set, ans); return ans; } static void dfs(int[] nums, int start, List\u003cList\u003cInteger\u003e\u003e ans, LinkedList\u003cInteger\u003e set) { ans.add(new LinkedList\u003c\u003e(set)); for (int i = start; i \u003c nums.length; i++) { set.add(nums[i]); dfs(nums, i + 1); set.pollLast(); } } 组合 static List\u003cList\u003cInteger\u003e\u003e combinations(int n, int k) { // 返回 0-n 中所有 k 个数构成的组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); dfs(n, k, 0, ans, set); return ans; } static void dfs(int n, int k, int start, List\u003cList\u003cInteger\u003e\u003e ans, LinkedList\u003cInteger\u003e set) { if (set.size() == k) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = start; i \u003c= n; i++) { set.add(i); dfs(n, k, i + 1, ans, set); set.pollLast(); } } 排列 static List\u003cList\u003cInteger\u003e\u003e permutations(int[] nums) { // 返回无重数组的全部排列 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); dfs(nums, ans, new LinkedList\u003c\u003e(), new boolean[nums.length]); return ans; } static void dfs(int[] nums, List\u003cList\u003cInteger\u003e\u003e ans, LinkedList\u003cInteger\u003e set, boolean[] vis) { int n = nums.length; if (set.size() == n) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = 0; i \u003c n; i++) { // 防止重复选 if (vis[i]) continue; vis[i] = true; set.add(nums[i]); dfs(nums, ans, set, vis); set.pollLast(); vis[i] = false; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:1:1","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#无重--不放回"},{"categories":["算法"],"content":" 无重 \u0026 有放回 组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, 0, 0); return ans; } void dfs(int[] candidates, int target, int start, int sum) { if (sum == target) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = start; i \u003c candidates.length; i++) { // 剪枝 if (sum + candidates[i] \u003c= target) { set.add(candidates[i]); // 可选范围不变 dfs(candidates, target, i, sum + candidates[i]); set.pollLast(); } } } 排列 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); List\u003cList\u003cInteger\u003e\u003e permuteDup(int[] nums) { dfs(nums); return ans; } void dfs(int[] nums) { int n = nums.length; if (set.size() == n) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = 0; i \u003c n; i++) { set.add(nums[i]); dfs(nums); // 回溯 set.pollLast(); } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:1:2","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#无重--有放回"},{"categories":["算法"],"content":" 有重 \u0026 不放回 子集 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); List\u003cList\u003cInteger\u003e\u003e subsetsWithDup(int[] nums) { Arrays.sort(nums); dfs(nums, 0); return ans; } void dfs(int[] nums, int start) { ans.add(new LinkedList\u003c\u003e(set)); for (int i = start; i \u003c nums.length; i++) { // 剪枝：相同元素已经选过就不再重复选择 if (i \u003e start \u0026\u0026 nums[i - 1] == nums[i]) { continue; } set.add(nums[i]); dfs(nums, i + 1); // 回溯 set.pollLast(); } } 组合 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); List\u003cList\u003cInteger\u003e\u003e combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, 0, 0); return ans; } void dfs(int[] candidates, int target, int start, int sum) { if (sum == target) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = start; i \u003c candidates.length; i++) { // 剪枝1：相同元素已经选过就不再重复选择 // 即相同元素只能连续选择，不能间隔选择 if (i \u003e start \u0026\u0026 candidates[i - 1] == candidates[i]) { continue; } // 剪枝2：只有加上当前元素后元素和不超过 target 才选择 if (sum + candidates[i] \u003c= target) { set.add(candidates[i]); dfs(candidates, target, i + 1, sum + candidates[i]); set.pollLast(); } } } 排列 List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); LinkedList\u003cInteger\u003e set = new LinkedList\u003c\u003e(); boolean[] vis; List\u003cList\u003cInteger\u003e\u003e permuteUnique(int[] nums) { vis = new boolean[nums.length]; Arrays.sort(nums); dfs(nums); return ans; } void dfs(int[] nums) { int n = nums.length; if (set.size() == n) { ans.add(new LinkedList\u003c\u003e(set)); return; } for (int i = 0; i \u003c n; i++) { if (!vis[i]) { // 剪枝：相同元素已经选过就不再重复选择 // 即相同元素只能连续选择，不能间隔选择 if (i \u003e 0 \u0026\u0026 !vis[i - 1] \u0026\u0026 nums[i - 1] == nums[i]) { continue; } vis[i] = true; set.add(nums[i]); dfs(nums); // 回溯 set.pollLast(); vis[i] = false; } } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:1:3","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#有重--不放回"},{"categories":["算法"],"content":" 实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:0","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#实战"},{"categories":["算法"],"content":" 🟨所有可能的路径797. 所有可能的路径 class Solution { public List\u003cList\u003cInteger\u003e\u003e allPathsSourceTarget(int[][] graph) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); dfs(graph, 0, new ArrayList\u003c\u003e(), ans); return ans; } void dfs(int[][] graph, int u, List\u003cInteger\u003e path, List\u003cList\u003cInteger\u003e\u003e ans) { path.add(u); if (u == graph.length - 1) ans.add(new ArrayList\u003c\u003e(path)); else for (int v : graph[u]) dfs(graph, v, path, ans); path.remove(path.size() - 1); } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:1","series":null,"tags":null,"title":"算法-回溯算法","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#所有可能的路径"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#jarvis-算法"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#graham-算法"},{"categories":["算法"],"content":"在给定点集中找出所有的边界点。 Jarvis 算法暴力 Graham 算法 Andrew 算法安装栅栏 - 安装栅栏 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"算法-凸包问题","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/#andrew-算法"},{"categories":["算法"],"content":" 1.介绍 快速求x的n次幂。 时间复杂度：$O(\\log n)$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:1:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#1介绍"},{"categories":["算法"],"content":" 2.迭代写法 static double fastPow(double x, int n) { if (x == 0) return 0; if (x == 1) return 1; // 防止 n = -214748328 时，-n 溢出 long nn = n; if (nn \u003c 0) { x = 1 / x; nn = -nn; } double ans = 1.0; while (nn \u003e 0) { if ((nn \u0026 1) == 1) ans *= x; // nn % 2 == 1 x *= x; nn \u003e\u003e= 1; // nn /= 2; } return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:2:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#2迭代写法"},{"categories":["算法"],"content":" 3.递归写法 static double fastPow(double x, int n) { if (x == 0) return 0; if (x == 1) return 1; // 防止 n = -214748328 时，-n 溢出 long nn = n; if (nn \u003c 0) { x = 1 / x; nn = -nn; } return fastPow(x, nn); } static double fastPow(double x, long n) { if (n == 0) return 1; if (n == 1) return x; double half = fastPow(x, n \u003e\u003e 1); if ((n \u0026 1) == 1) return half * half * x; else return half * half; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:3:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#3递归写法"},{"categories":["算法"],"content":" 4.矩阵快速幂 static int[][] fastPow(int[][] mat, int n) { if (n == 0) return mat; // 单位矩阵 int m = mat.length; int[][] ans = new int[m][m]; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c m; j++) if (i == j) ans[i][j] = 1; while (n \u003e 0) { if ((n \u0026 1) == 1) ans = matMul(ans, mat); mat = matMul(mat, mat); n \u003e\u003e= 1; } return ans; } static int[][] matMul(int[][] a, int[][] b) { // [m, h] * [h, n] -\u003e [m, n] int m = a.length; int h = a[0].length; int h1 = b.length; int n = b[0].length; if (h != h1) return null; int[][] ans = new int[m][n]; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c n; j++) for (int k = 0; k \u003c h; k++) ans[i][j] += a[i][k] * b[k][j]; return ans; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:4:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#4矩阵快速幂"},{"categories":["算法"],"content":" 5.实战 372. 超级次方 50. Pow(x, n) ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/:5:0","series":null,"tags":["算法","快速幂","矩阵快速幂"],"title":"算法-快速幂","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/#5实战"},{"categories":["算法"],"content":" 窗口大小可任意调整 // 窗口大小可任意调整 int left = 0; int right = 0; int ans = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 while (condition) { // 约束值满足调整窗口的条件 // 缩小窗口 // 左端点 left 操作 // 修改约束值 left++; } ans = Math.max(ans, right - left + 1); right++; } 窗口大小单调递增 // 窗口大小单调递增 int left = 0; int right = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 if (condition) { // 约束值满足调整窗口的条件 // 此时左端点移动最多使窗口大小不变 // 左端点 left 操作 // 修改约束值 left++; } right++; } int ans = right - left; ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","series":null,"tags":null,"title":"算法-滑动窗口","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#"},{"categories":["算法"],"content":" 窗口大小可任意调整 // 窗口大小可任意调整 int left = 0; int right = 0; int ans = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 while (condition) { // 约束值满足调整窗口的条件 // 缩小窗口 // 左端点 left 操作 // 修改约束值 left++; } ans = Math.max(ans, right - left + 1); right++; } 窗口大小单调递增 // 窗口大小单调递增 int left = 0; int right = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 if (condition) { // 约束值满足调整窗口的条件 // 此时左端点移动最多使窗口大小不变 // 左端点 left 操作 // 修改约束值 left++; } right++; } int ans = right - left; ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","series":null,"tags":null,"title":"算法-滑动窗口","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#窗口大小可任意调整"},{"categories":["算法"],"content":" 窗口大小可任意调整 // 窗口大小可任意调整 int left = 0; int right = 0; int ans = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 while (condition) { // 约束值满足调整窗口的条件 // 缩小窗口 // 左端点 left 操作 // 修改约束值 left++; } ans = Math.max(ans, right - left + 1); right++; } 窗口大小单调递增 // 窗口大小单调递增 int left = 0; int right = 0; // [left, right] while (right \u003c n) { // 增大窗口 // 右端点 right 操作 // 修改约束值 if (condition) { // 约束值满足调整窗口的条件 // 此时左端点移动最多使窗口大小不变 // 左端点 left 操作 // 修改约束值 left++; } right++; } int ans = right - left; ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:0","series":null,"tags":null,"title":"算法-滑动窗口","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/#窗口大小单调递增"},{"categories":["算法"],"content":"找出游戏的获胜者 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:0:0","series":null,"tags":["算法"],"title":"算法-约瑟夫环","uri":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/#"},{"categories":["算法"],"content":" 原理倒推法 还剩1个人，此人获胜，下标为 $$f(1,k)=0$$ 还剩2个人，淘汰第k个人，即淘汰下标(k-1)%2，下次从k%2开始，则获胜者下标为 $$f(2,k)=(f(1,k)+k)\\mod 2=(0+k)\\mod 2$$ 还剩3个人，淘汰第k个人，即淘汰下标(k-1)%3，下次从k%3开始，则获胜者下标为 $$f(3,k)=(f(2,k)+k)\\mod 3=((0+k)\\mod 2+k)\\mod 3$$ … n个人，淘汰第k个人，即淘汰下标(k-1)%n，下次从k%n开始，则获胜者下标为 $$f(n,k)=(f(n-1,k)+k)\\bmod{n}=(\\cdots((0+k)\\bmod{2}+k)\\bmod{3}\\cdots)\\bmod{n}$$ int findTheWinner(int n, int k) { int ans = 0; for (int i = 2; i \u003c= n; i++) { ans = (ans + k) % i; } return ans + 1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/:1:0","series":null,"tags":["算法"],"title":"算法-约瑟夫环","uri":"/posts/%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/#原理"},{"categories":["算法"],"content":" 1.基础 要求序列非递减，即nums[i - 1] \u003c= nums[i] 时间复杂度：$O(\\log n)$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#1基础"},{"categories":["算法"],"content":" 2.等于指定值 返回值： 返回数组中等于指定值的元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; binarySearch(nums, 3); // -1 binarySearch(nums, 4); // 0 binarySearch(nums, 5); // 1 或 2 binarySearch(nums, 6); // 3 binarySearch(nums, 7); // 4 binarySearch(nums, 8); // -1 闭区间写法： static int binarySearch(int[] nums, int target) { // 二分查找等于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid - 1; } return -1; } 左闭右开写法： static int binarySearch(int[] nums, int target) { // 二分查找等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid; } return -1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#2等于指定值"},{"categories":["算法"],"content":" 3.第一个大于指定值 返回值： 返回数组中大于指定值的最小元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; higher(nums, 3); // 0 higher(nums, 4); // 1 higher(nums, 5); // 3 higher(nums, 6); // 4 higher(nums, 7); // 5 higher(nums, 8); // 5 闭区间写法： static int higher(int[] nums, int target) { // 二分查找第一个大于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e target) right = mid - 1; else left = mid + 1; } return left; } 左闭右开写法： static int higher(int[] nums, int target) { // 二分查找第一个大于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e target) right = mid; else left = mid + 1; } return left; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#3第一个大于指定值"},{"categories":["算法"],"content":" 4.第一个大于等于指定值 返回值： 返回数组中大于等于指定值的最小元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; ceiling(nums, 3); // 0 ceiling(nums, 4); // 0 ceiling(nums, 5); // 1 ceiling(nums, 6); // 3 ceiling(nums, 7); // 4 ceiling(nums, 8); // 5 闭区间写法： static int ceiling(int[] nums, int target) { // 二分查找第一个大于等于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e= target) right = mid - 1; else left = mid + 1; } return left; } 左闭右开写法： static int ceiling(int[] nums, int target) { // 二分查找第一个大于等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e= target) right = mid; else left = mid + 1; } return left; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#4第一个大于等于指定值"},{"categories":["算法"],"content":" 5.最后一个小于指定值 返回值： 返回数组中小于指定值的最大元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; lower(nums, 3); // -1 lower(nums, 4); // -1 lower(nums, 5); // 0 lower(nums, 6); // 2 lower(nums, 7); // 3 lower(nums, 8); // 4 闭区间写法： static int lower(int[] nums, int target) { // 二分查找第一个小于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) left = mid + 1; else right = mid - 1; } return right; } 左闭右开写法： static int lower(int[] nums, int target) { // 二分查找第一个小于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) left = mid + 1; else right = mid; } return right - 1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:5:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#5最后一个小于指定值"},{"categories":["算法"],"content":" 6.最后一个小于等于指定值 返回值： 返回数组中小于等于指定值的最大元素的下标。 测试结果： int[] nums = { 4, 5, 5, 6, 7 }; floor(nums, 3); // -1 floor(nums, 4); // 0 floor(nums, 5); // 2 floor(nums, 6); // 3 floor(nums, 7); // 4 floor(nums, 8); // 4 闭区间写法： static int floor(int[] nums, int target) { // 二分查找最后一个小于等于 target 的下标 // 闭区间 [left, right] int left = 0; int right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= target) left = mid + 1; else right = mid - 1; } return right; } 左闭右开写法： static int floor(int[] nums, int target) { // 二分查找最后一个小于等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= target) left = mid + 1; else right = mid; } return right - 1; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:6:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#6最后一个小于等于指定值"},{"categories":["算法"],"content":" 7.总结 闭区间 vs 左闭右开： // 闭区间 int right = nums.length - 1; while (left \u003c= right) right = mid - 1; // 左闭右开 int right = nums.length; while (left \u003c right) right = mid; 大于等于 vs 小于等于 vs 大于 vs 小于： // 大于等于 if (nums[mid] \u003e= target) // right return left; // 小于等于 if (nums[mid] \u003c= target) // left return right; // 闭区间 return right - 1; // 左闭右开 // 大于 if (nums[mid] \u003e target) // right return left; // 小于 if (nums[mid] \u003c target) // left return right; // 闭区间 return right - 1; // 左闭右开 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:7:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#7总结"},{"categories":["算法"],"content":" 8.实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:8:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#8实战"},{"categories":["算法"],"content":" 二分查找704. 二分查找 class Solution { public int search(int[] nums, int target) { return binarySearch(nums, target); } static int binarySearch(int[] nums, int target) { // 二分查找等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else right = mid; } return -1; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:8:1","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#二分查找"},{"categories":["算法"],"content":" 第一个错误的版本278. 第一个错误的版本 public class Solution extends VersionControl { public int firstBadVersion(int n) { int l = 1; int r = n; while (l \u003c r) { int m = l + (r - l) / 2; if (isBadVersion(m)) r = m; else l = m + 1; } return l; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:8:2","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#第一个错误的版本"},{"categories":["算法"],"content":" 搜索插入位置35. 搜索插入位置 class Solution { public int searchInsert(int[] nums, int target) { return ceiling(nums, target); } static int ceiling(int[] nums, int target) { // 二分查找第一个大于等于 target 的下标 // 左闭右开 [left, right) int left = 0; int right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003e= target) right = mid; else left = mid + 1; } return left; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:8:3","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#搜索插入位置"},{"categories":["算法"],"content":" 🟥阶乘函数后 K 个零793. 阶乘函数后 K 个零 一个数字末尾 0 的数量就是其因子中 10 的数量，也就是 2 的数量和 5 的数量的更小值。 x! 的因子中 5 的数量一定少于 2 的数量，所以 x! 的末尾有 k 个 0 即因子中 5 的数量为 k。 形如 f * 5 的数，每个数字在阶乘中贡献 1 个 5。 形如 f * 25 的数，每个数字在阶乘中额外贡献 1 个 5，共贡献了 2 个 5。 形如 f * 125 的数，每个数字在阶乘中额外贡献 1 个 5，共贡献了 3 个 5。 … 总结，形如 f * 5 ^ p 的数，每个数字在阶乘中共贡献了 p 个 5。 数 f * 5、f * 5 + 1、f * 5 + 2、f * 5 + 3、f * 5 + 4 中因子 5 的数量不变，所以若 k 合法，则返回 5，若 k 不合法，则返回 0。 class Solution { public int preimageSizeFZF(int k) { int l = 0; int r = k; while (l \u003c= r) { int m = l + (r - l) / 2; long x = m * 5L; int cnt = 0; while (x \u003e 0) { cnt += x / 5; x /= 5; } if (cnt == k) return 5; else if (cnt \u003e k) r = m - 1; else l = m + 1; } return 0; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:8:4","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#阶乘函数后-k-个零"},{"categories":["算法"],"content":" 参考","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:9:0","series":null,"tags":["算法","二分查找"],"title":"算法-二分查找","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#参考"},{"categories":["数据结构"],"content":"MySQL 的索引采用这种数据结构。一棵 $m$ 阶的B+树需满足下列条件： 每个分支结点最多有 $m$ 棵子树。 非叶根结点至少有两棵子树，其他每个分支结点至少有 $\\lceil \\frac{m}{2} \\rceil$ 棵子树。 每个结点的子树个数与关键字个数相等。 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字从小到大排序，并且相邻叶结点从小到大相互链接起来。 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。 查找 B+树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。所以，在B+树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。 B+树与B树的差异 在B+树中，具有n个关键字的结点含有n棵子树；而在B树中，具有n个关键字的结点含有n+1棵子树。 在B+树中，每个结点的关键字个数n的范围是 $\\lceil \\frac{m}{2} \\rceil \\le n \\le m$（根结点：$1 \\le n \\le m$）；在B树中，每个结点的关键字个数n的范围是 $\\lceil \\frac{m}{2} \\rceil-1 \\le n \\le m-1$（根结点：$1 \\le n \\le m-1$)。 在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点（最外层内部结点）包含的关键字和其他结点包含的关键字是不重复的。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b+%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-B+树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b+%E6%A0%91/#"},{"categories":["数据结构"],"content":"又称多路平衡查找树，规定B树的阶 $m$ 为每个结点的最大孩子数量。 每个结点最多 $m$ 个孩子。 若根结点不是叶结点，则至少有两个孩子。 除根结点外，每个非叶结点至少有 $\\lceil \\frac{m}{2} \\rceil$ 个孩子。 结点中关键字从小到大排序，关键字两侧为指向孩子的指针。 关键字左侧指针指向的子树中的关键字均小于该关键字，右侧则大于。 所有叶结点在同一层，不存储信息（空结点）。 高度 对任意一棵包含 $n$ 个关键字、高度为 $h$、阶数为 $m$ 的B树（不考虑空的叶结点）： 下界：每层关键字越多，则高度越矮。B树中每个结点最多有 $m$ 棵子树，$m-1$ 个关键字，所以 $$ \\begin{align} n\u0026\\le(m-1)(1+m+m^2+\\cdots+m^{h-1})=m^h-1 \\\\ h\u0026\\ge\\log_m(n+1) \\end{align} $$ 上界：每层关键字越少，则高度越高。B树中根结点最少1个关键字，非叶结点最少 $\\lceil \\frac{m}{2} \\rceil$ 棵子树， $\\lceil \\frac{m}{2} \\rceil-1$ 个关键字，所以 $$ \\begin{align} n\u0026\\ge1+2\\times(\\lceil \\frac{m}{2} \\rceil-1)(1+\\lceil \\frac{m}{2} \\rceil+\\lceil \\frac{m}{2} \\rceil^2+\\cdots+\\lceil \\frac{m}{2} \\rceil^{h-2})=2\\times\\lceil \\frac{m}{2} \\rceil^{h-1}-1 \\\\ h\u0026\\le\\log_{\\lceil \\frac{m}{2} \\rceil}(\\frac{n+1}{2})+1 \\end{align} $$ 查找 查找结点。将结点信息读入内存。 结点中查找关键字。在结点关键字表中二分查找，未找到则查找对应子树。 若子树为空，则查找失败。 插入 定位。利用查找算法，找出插入该关键字的最底层中的某个非叶结点。 插入。除了根结点，每个结点的关键字个数都在区间 $[\\lceil \\frac{m}{2} \\rceil-1,m-1]$ 内。若插入后的结点关键字个数在范围内，则可以直接插入，否则必须对结点进行分裂。 分裂。将待分裂结点从中间位置（$\\lceil \\frac{m}{2} \\rceil$）将其中的关键宇分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（$\\lceil \\frac{m}{2} \\rceil$）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。 删除 定位。 删除。 借位。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-B树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b%E6%A0%91/#"},{"categories":["数据结构"],"content":"LFU (Least Frequently Used) class Node { int key, value; Node prev, next; public Node (int key, int value) { this.key = key; this.value = value; } } class BiLinkedList { final Node head, tail; int length; public BiLinkedList() { this.head = new Node(0, 0); this.tail = new Node(0, 0); this.length = 0; head.next = tail; tail.prev = head; } public void addLast(Node node) { node.prev = tail.prev; node.next = tail; tail.prev.next = node; tail.prev = node; length++; } public void remove(Node node) { if (node.prev == null || node.next == null) { return; } node.prev.next = node.next; node.next.prev = node.prev; length--; } public void removeFirst() { if (length == 0) { return; } head.next.next.prev = head; head.next = head.next.next; length--; } } class LFUCache { HashMap\u003cInteger, Node\u003e keyToNode; HashMap\u003cInteger, Integer\u003e keyToFreq; HashMap\u003cInteger, BiLinkedList\u003e freqToNodes; final int capacity; int length; int minFreq; public LFUCache(int capacity) { this.keyToNode = new HashMap\u003c\u003e(); this.keyToFreq = new HashMap\u003c\u003e(); this.freqToNodes = new HashMap\u003c\u003e(); this.capacity = capacity; this.length = 0; this.minFreq = -1; } public int get(int key) { if (keyToNode.containsKey(key)) { Node node = keyToNode.get(key); // 更新频率 int freq = keyToFreq.get(key); keyToFreq.put(key, freq + 1); // 删除结点 freqToNodes.get(freq).remove(node); // 添加结点 if (freqToNodes.containsKey(freq + 1)) { freqToNodes.get(freq + 1).addLast(node); } else { BiLinkedList list = new BiLinkedList(); list.addLast(node); freqToNodes.put(freq + 1, list); } // 更新 minFreq if (freq == minFreq) { while (freqToNodes.get(minFreq).length == 0) { minFreq++; } } return node.value; } else { return -1; } } public void put(int key, int value) { if (keyToNode.containsKey(key)) { // 更新值 Node node = keyToNode.get(key); node.value = value; // 更新频率 int freq = keyToFreq.get(key); keyToFreq.put(key, freq + 1); // 删除结点 freqToNodes.get(freq).remove(node); // 添加结点 if (freqToNodes.containsKey(freq + 1)) { freqToNodes.get(freq + 1).addLast(node); } else { BiLinkedList list = new BiLinkedList(","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lfu/:0:0","series":null,"tags":null,"title":"数据结构-LFU","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lfu/#"},{"categories":["数据结构"],"content":"LRU (Least Recently Used) 最近最少使用算法。当容量满时，将最久没有使用过的缓存删除。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/:0:0","series":null,"tags":["数据结构"],"title":"数据结构-LRU","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/#"},{"categories":["数据结构"],"content":" 实现 class Node { int key, val; Node prev, next; public Node(int key, int val) { this.key = key; this.val = val; } } class BiLinkedList { final Node head, tail; final int capacity; int length; public BiLinkedList(int capacity) { this.capacity = capacity; length = 0; head = new Node(0, 0); tail = new Node(0, 0); head.next = tail; tail.prev = head; } /** * 将结点加入双向链表的尾部 * * @param node 待加入结点 */ public void addLast(Node node) { node.prev = tail.prev; node.next = tail; node.prev.next = node; tail.prev = node; length++; } /** * 将 node 从双向链表中删除 * * @param node 待加入结点 */ public void remove(Node node) { node.prev.next = node.next; node.next.prev = node.prev; length--; } /** * 将双向链表的第一个结点删除 */ public void removeFirst() { if (length == 0) { return; } head.next = head.next.next; head.next.prev = head; length--; } } class LRUCache { private BiLinkedList list; private HashMap\u003cInteger, Node\u003e keyToNode; public LRUCache(int capacity) { list = new BiLinkedList(capacity); keyToNode = new HashMap\u003c\u003e(); } public int get(int key) { if (keyToNode.containsKey(key)) { Node node = keyToNode.get(key); list.remove(node); list.addLast(node); return node.val; } else { return -1; } } public void put(int key, int value) { if (keyToNode.containsKey(key)) { Node node = keyToNode.get(key); node.val = value; list.remove(node); list.addLast(node); } else { if (list.length == list.capacity) { keyToNode.remove(list.head.next.key); list.removeFirst(); } Node node = new Node(key, value); keyToNode.put(key, node); list.addLast(node); } } } class LRUCache { class ListNode { int key, val; ListNode prev, next; public ListNode(int key, int val) { this.key = key; this.val = val; } } HashMap\u003cInteger, ListNode\u003e key2node; ListNode head; // 双链表头结点 int capacity; public LRUCache(int capacity) { key2node = new HashMap\u003c\u003e(); head = new ListNode(0, 0); head.prev = head.next = head; // 循环链表 this.capacity = capacity; } public int get(int key) { ListNode node = key2node.get(key); if (node == null) return -1; // 取出 node node.prev.next = node.next; node.next.prev = node.prev; ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/:1:0","series":null,"tags":["数据结构"],"title":"数据结构-LRU","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/#实现"},{"categories":["数据结构"],"content":" API class LRUCache { private LinkedHashMap\u003cInteger, Integer\u003e data; private int capacity; public LRUCache(int capacity) { this.data = new LinkedHashMap\u003c\u003e(); this.capacity = capacity; } public int get(int key) { int val = data.getOrDefault(key, -1); if (data.containsKey(key)) { data.remove(key); data.put(key, val); } return val; } public void put(int key, int value) { data.remove(key); data.put(key, value); if (data.size() \u003e this.capacity) { data.remove(data.keySet().iterator().next()); } } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/:2:0","series":null,"tags":["数据结构"],"title":"数据结构-LRU","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru/#api"},{"categories":["数据结构"],"content":"Balanced Binary Search Tree，BBST 通过旋转来保持树的平衡。 class TreeNode { int val; TreeNode left, right; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-AVL树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl%E6%A0%91/#"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#性质"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#自平衡"},{"categories":["数据结构"],"content":"Red Black Tree 性质 每个结点可红可黑。 根结点是黑色。 叶结点（null）是黑色。 红色结点的孩子是黑色。 任意结点到叶结点的路径都包含相同数量的黑色结点。 红黑树不是完美平衡二叉查找树，左右子树高度差可能大于1。 自平衡 左旋：右孩子V变为当前结点P的父结点，当前结点P变为右孩子V的左孩子，右孩子V的左子树R变为当前结点的右子树。 右旋：左孩子F变为当前结点P的父结点，当前结点P变为左孩子F的右孩子，左孩子F的右子树K变为当前结点的左子树。 变色：结点黑红互转。 插入 空树： 30张图带你彻底理解红黑树 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/:0:0","series":null,"tags":null,"title":"数据结构-红黑树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/#插入"},{"categories":["数据结构"],"content":" 1.基础","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:0","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#1基础"},{"categories":["数据结构"],"content":" 1.1 介绍","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:1","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#11-介绍"},{"categories":["数据结构"],"content":" 1.2 模板 定义 class UnionFind { private int[] parent; // 指向父结点 private int size; // 连通块的数量 public UnionFind(int n) { parent = new int[n]; for (int i = 0; i \u003c n; i++) parent[i] = i; size = n; } public int find(int i) { // 寻找根结点 if (parent[i] != i) // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } public boolean isConnected(int i, int j) { // 判断是否连通 return find(i) == find(j); } public void union(int i, int j) { // 连通 if (find(i) != find(j)) size--; parent[find(j)] = find(i); // j 加入 i } public int size() { return size; } } 使用 UnionFind uf = new UnionFind(n); int root = uf.find(i); uf.isConnected(i, j); uf.union(i, j); int size = uf.size(); ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:2","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#12-模板"},{"categories":["数据结构"],"content":" 2.实战","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:0","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#2实战"},{"categories":["数据结构"],"content":" Flood Fill 图像渲染733. 图像渲染 class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { int oldColor = image[sr][sc]; if (oldColor == color) return image; int m = image.length; int n = image[0].length; UnionFind uf = new UnionFind(m * n); for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 image[i][j] == image[i][j + 1]) uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 image[i][j] == image[i + 1][j]) uf.union(x, x + n); } } int x = sr * n + sc; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c n; j++) if (uf.isConnected(x, i * n + j)) image[i][j] = color; return image; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i] = find(p[i]); // 路径压缩 return p[i]; } } 岛屿数量200. 岛屿数量 class Solution { public int numIslands(char[][] grid) { int m = grid.length; int n = grid[0].length; UnionFind uf = new UnionFind(m * n); int zeroCount = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 grid[i][j + 1] == '1') uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 grid[i + 1][j] == '1') uf.union(x, x + n); } else zeroCount++; } } // 连通块数量 - 0 的数量 = 1 的连通块数量 return uf.size() - zeroCount; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:1","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#flood-fill"},{"categories":["数据结构"],"content":" Flood Fill 图像渲染733. 图像渲染 class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { int oldColor = image[sr][sc]; if (oldColor == color) return image; int m = image.length; int n = image[0].length; UnionFind uf = new UnionFind(m * n); for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 image[i][j] == image[i][j + 1]) uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 image[i][j] == image[i + 1][j]) uf.union(x, x + n); } } int x = sr * n + sc; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c n; j++) if (uf.isConnected(x, i * n + j)) image[i][j] = color; return image; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i] = find(p[i]); // 路径压缩 return p[i]; } } 岛屿数量200. 岛屿数量 class Solution { public int numIslands(char[][] grid) { int m = grid.length; int n = grid[0].length; UnionFind uf = new UnionFind(m * n); int zeroCount = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 grid[i][j + 1] == '1') uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 grid[i + 1][j] == '1') uf.union(x, x + n); } else zeroCount++; } } // 连通块数量 - 0 的数量 = 1 的连通块数量 return uf.size() - zeroCount; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:1","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#图像渲染"},{"categories":["数据结构"],"content":" Flood Fill 图像渲染733. 图像渲染 class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { int oldColor = image[sr][sc]; if (oldColor == color) return image; int m = image.length; int n = image[0].length; UnionFind uf = new UnionFind(m * n); for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 image[i][j] == image[i][j + 1]) uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 image[i][j] == image[i + 1][j]) uf.union(x, x + n); } } int x = sr * n + sc; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c n; j++) if (uf.isConnected(x, i * n + j)) image[i][j] = color; return image; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i] = find(p[i]); // 路径压缩 return p[i]; } } 岛屿数量200. 岛屿数量 class Solution { public int numIslands(char[][] grid) { int m = grid.length; int n = grid[0].length; UnionFind uf = new UnionFind(m * n); int zeroCount = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 grid[i][j + 1] == '1') uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 grid[i + 1][j] == '1') uf.union(x, x + n); } else zeroCount++; } } // 连通块数量 - 0 的数量 = 1 的连通块数量 return uf.size() - zeroCount; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:1","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#岛屿数量"},{"categories":["数据结构"],"content":" Flood Fill 图像渲染733. 图像渲染 class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { int oldColor = image[sr][sc]; if (oldColor == color) return image; int m = image.length; int n = image[0].length; UnionFind uf = new UnionFind(m * n); for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 image[i][j] == image[i][j + 1]) uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 image[i][j] == image[i + 1][j]) uf.union(x, x + n); } } int x = sr * n + sc; for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c n; j++) if (uf.isConnected(x, i * n + j)) image[i][j] = color; return image; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i] = find(p[i]); // 路径压缩 return p[i]; } } 岛屿数量200. 岛屿数量 class Solution { public int numIslands(char[][] grid) { int m = grid.length; int n = grid[0].length; UnionFind uf = new UnionFind(m * n); int zeroCount = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { int x = i * n + j; // 只需判断右、下 if (j + 1 \u003c n \u0026\u0026 grid[i][j + 1] == '1') uf.union(x, x + 1); if (i + 1 \u003c m \u0026\u0026 grid[i + 1][j] == '1') uf.union(x, x + n); } else zeroCount++; } } // 连通块数量 - 0 的数量 = 1 的连通块数量 return uf.size() - zeroCount; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:1","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#被围绕的区域"},{"categories":["数据结构"],"content":" 二分图 判断二分图785. 判断二分图 class Solution { public boolean isBipartite(int[][] graph) { int n = graph.length; UnionFind uf = new UnionFind(n); for (int u = 0; u \u003c n; u++) { // 非连通图 for (int v : graph[u]) { if (uf.isConnected(u, v)) return false; // 相邻顶点不连通 uf.union(graph[u][0], v); // 连通 u 的所有相邻顶点 } } return true; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i] = find(p[i]); // 路径压缩 return p[i]; } } 等式方程的可满足性990. 等式方程的可满足性 class Solution { public boolean equationsPossible(String[] equations) { Arrays.sort(equations, (a, b) -\u003e b.charAt(1) - a.charAt(1)); UnionFind uf = new UnionFind(26); for (String eq : equations) { int i = eq.charAt(0) - 'a'; int j = eq.charAt(3) - 'a'; if (eq.charAt(1) == '=') uf.union(i, j); else if (uf.isConnected(i, j)) return false; } return true; } } class UnionFind { private int[] parent; // 指向父结点 private int size; // 连通块的数量 public UnionFind(int n) { parent = new int[n]; for (int i = 0; i \u003c n; i++) parent[i] = i; size = n; } public int find(int i) { // 寻找根结点 if (parent[i] != i) // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } public boolean isConnected(int i, int j) { // 判断是否连通 return find(i) == find(j); } public void union(int i, int j) { // 连通 if (find(i) != find(j)) size--; parent[find(j)] = find(i); // j 加入 i } public int size() { return size; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:2","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#二分图"},{"categories":["数据结构"],"content":" 二分图 判断二分图785. 判断二分图 class Solution { public boolean isBipartite(int[][] graph) { int n = graph.length; UnionFind uf = new UnionFind(n); for (int u = 0; u \u003c n; u++) { // 非连通图 for (int v : graph[u]) { if (uf.isConnected(u, v)) return false; // 相邻顶点不连通 uf.union(graph[u][0], v); // 连通 u 的所有相邻顶点 } } return true; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i] = find(p[i]); // 路径压缩 return p[i]; } } 等式方程的可满足性990. 等式方程的可满足性 class Solution { public boolean equationsPossible(String[] equations) { Arrays.sort(equations, (a, b) -\u003e b.charAt(1) - a.charAt(1)); UnionFind uf = new UnionFind(26); for (String eq : equations) { int i = eq.charAt(0) - 'a'; int j = eq.charAt(3) - 'a'; if (eq.charAt(1) == '=') uf.union(i, j); else if (uf.isConnected(i, j)) return false; } return true; } } class UnionFind { private int[] parent; // 指向父结点 private int size; // 连通块的数量 public UnionFind(int n) { parent = new int[n]; for (int i = 0; i \u003c n; i++) parent[i] = i; size = n; } public int find(int i) { // 寻找根结点 if (parent[i] != i) // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } public boolean isConnected(int i, int j) { // 判断是否连通 return find(i) == find(j); } public void union(int i, int j) { // 连通 if (find(i) != find(j)) size--; parent[find(j)] = find(i); // j 加入 i } public int size() { return size; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:2","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#判断二分图"},{"categories":["数据结构"],"content":" 二分图 判断二分图785. 判断二分图 class Solution { public boolean isBipartite(int[][] graph) { int n = graph.length; UnionFind uf = new UnionFind(n); for (int u = 0; u \u003c n; u++) { // 非连通图 for (int v : graph[u]) { if (uf.isConnected(u, v)) return false; // 相邻顶点不连通 uf.union(graph[u][0], v); // 连通 u 的所有相邻顶点 } } return true; } } class UnionFind { private int[] p; // 指向父结点 private int count; // 树的数量 public UnionFind(int n) { p = new int[n]; for (int i = 0; i \u003c n; i++) p[i] = i; count = n; } public boolean isConnected(int i, int j) { return find(i) == find(j); } public void union(int i, int j) { // 合并两棵树 if (find(i) != find(j)) count--; p[find(j)] = find(i); // j 插入 i } public int size() { return count; } private int find(int i) { // 寻找根结点 if (p[i] != i) p[i] = find(p[i]); // 路径压缩 return p[i]; } } 等式方程的可满足性990. 等式方程的可满足性 class Solution { public boolean equationsPossible(String[] equations) { Arrays.sort(equations, (a, b) -\u003e b.charAt(1) - a.charAt(1)); UnionFind uf = new UnionFind(26); for (String eq : equations) { int i = eq.charAt(0) - 'a'; int j = eq.charAt(3) - 'a'; if (eq.charAt(1) == '=') uf.union(i, j); else if (uf.isConnected(i, j)) return false; } return true; } } class UnionFind { private int[] parent; // 指向父结点 private int size; // 连通块的数量 public UnionFind(int n) { parent = new int[n]; for (int i = 0; i \u003c n; i++) parent[i] = i; size = n; } public int find(int i) { // 寻找根结点 if (parent[i] != i) // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } public boolean isConnected(int i, int j) { // 判断是否连通 return find(i) == find(j); } public void union(int i, int j) { // 连通 if (find(i) != find(j)) size--; parent[find(j)] = find(i); // j 加入 i } public int size() { return size; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:2","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#等式方程的可满足性"},{"categories":["数据结构"],"content":" 参考 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/:3:0","series":null,"tags":["数据结构","并查集"],"title":"数据结构-并查集","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/#参考"},{"categories":["数据结构"],"content":" 1. 介绍线段树是常用的用来维护区间信息的数据结构，在区间动态修改的同时还能够高效查询区间信息。 功能： 单点修改 第i个元素增加x 第i个元素减少x 第i个元素修改为x 区间修改 区间[i, j]中的元素都增加x 区间[i, j]中的元素都减少x 区间[i, j]中的元素都修改为x 区间查询 查询区间[i, j]中的元素和 查询区间[i, j]中的元素最大值 查询区间[i, j]中的元素最小值 查询区间[i, j]中的元素最大公因数 结构： 每个结点代表一个区间，结点的值根据问题进行定义（区间和、区间最大值等）。 结点的左右孩子平分父结点的区间。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:1:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#1-介绍"},{"categories":["数据结构"],"content":" 2. 实现","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#2-实现"},{"categories":["数据结构"],"content":" 2.1 基于链表实现 结点定义 class Node { int val; Node left, right; public Node() {} public Node(int val) { this.val = val; } } 建树 void buildTree(Node node, int start, int end) { // } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:1","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#21-基于链表实现"},{"categories":["数据结构"],"content":" 2.2 基于数组实现 class SegmentTree { private int[] tree; // 维护区间 private int[] lazy; // 惰性标记，维护修改值 public SegmentTree(int[] nums) { int n = nums.length; // 线断树有 n 个叶结点，总结点个数设为 x // 非叶结点都有 2 棵子树，则 // x - 1 = (x - n) * 2 // x = 2 * n - 1 // 根结点索引从 1 开始 tree = new int[n * 2]; lazy = new int[n * 2]; build(nums, 0, nums.length - 1, 1); } void build(int[] nums, int left, int right, int root) { // 对 [left, right] 区间建立线段树,当前根的编号为 root if (left == right) { // 叶结点 tree[root] = nums[left]; return; } // + 优先级高于 \u003e\u003e int mid = left + ((right - left) \u003e\u003e 1); build(nums, left, mid, root \u003c\u003c 1); // root * 2 // \u003c\u003c 优先级高于 | build(nums, mid + 1, right, root \u003c\u003c 1 | 1); // root * 2 + 1 // 子树信息更新父结点信息 tree[root] = tree[root \u003c\u003c 1] + tree[root \u003c\u003c 1 | 1]; } int rangeSum(int qLeft, int qRight, int left, int right, int root) { // 查询区间 [qLeft, qRight] 的元素总和 if (qLeft \u003c= left \u0026\u0026 right \u003c= qRight) { // 当前区间是查询区间的子区间 return tree[root]; } pushDown(left, right, root); int mid = left + ((right - left) \u003e\u003e 1); int sum = 0; if (qLeft \u003c= mid) { sum += rangeSum(qLeft, qRight, left, mid, root \u003c\u003c 1); } if (mid \u003c qRight) { sum += rangeSum(qLeft, qRight, mid + 1, right, root \u003c\u003c 1 | 1); } return sum; } void update(int qLeft, int qRight, int val, int left, int right, int root) { // 将区间 [qLeft, qRight] 内的元素加 val if (qLeft \u003c= left \u0026\u0026 right \u003c= qRight) { tree[root] += val * (right - left + 1); // 不必此时修改到叶结点，将修改值记录到父结点的 lazy 标记 // 下次查询到需要修改的叶结点时再修改 lazy[root] += val; return; } pushDown(left, right, root); int mid = left + ((right - left) \u003e\u003e 1); if (qLeft \u003c= mid) { update(qLeft, qRight, val, left, mid, root \u003c\u003c 1); } if (mid \u003c qRight) { update(qLeft, qRight, val, mid + 1, right, root \u003c\u003c 1 | 1); } tree[root] = tree[root \u003c\u003c 1] + tree[root \u003c\u003c 1 | 1]; } private void pushDown(int left, int right, int root) { // lazy 标记处理 int mid = left + ((right - left) \u003e\u003e 1); if (lazy[root] \u003e 0 \u0026\u0026 left \u003c right) { // 如果当前节点的 lazy 标记非空，则更新当前节点两个子节点的值和 lazy 标记 tree[root \u003c\u003c 1] += lazy[root] * (mid - left + 1); tree[root \u003c\u003c 1 | 1] += lazy[root] * (right - mid); lazy[root \u003c\u003c 1] += lazy[root]; lazy[roo","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:2","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#22-基于数组实现"},{"categories":["数据结构"],"content":" 3. 分析 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:3:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#3-分析"},{"categories":["数据结构"],"content":" 参考 线段树详解「汇总级别整理 🔥🔥🔥」 - 我的日程安排表 I - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/:4:0","series":null,"tags":["数据结构","线段树"],"title":"数据结构-线段树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/#参考"},{"categories":["数据结构"],"content":"树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i \u003c n - 1; i++) { add(i, nums[i]); } } public void add(int index, int val) { // 下标从 1 开始 index++; // 单点修改，增加数组 index 元素的值 while (index \u003c n) { tree[index] += val; // 更新父结点 index += lowBit(index); } } public int preSum(int index) { // 查询前缀和 int sum = 0; while (index \u003e 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":null,"title":"数据结构-树状数组","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#"},{"categories":["数据结构"],"content":"树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i \u003c n - 1; i++) { add(i, nums[i]); } } public void add(int index, int val) { // 下标从 1 开始 index++; // 单点修改，增加数组 index 元素的值 while (index \u003c n) { tree[index] += val; // 更新父结点 index += lowBit(index); } } public int preSum(int index) { // 查询前缀和 int sum = 0; while (index \u003e 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":null,"title":"数据结构-树状数组","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#查询前缀和"},{"categories":["数据结构"],"content":"树状数组是一种可以动态维护序列前缀和的数据结构（下标从 1 开始），它的功能是： 单点修改add(index, val)：把序列第index个元素增加val 区间查询preSum(index)：查询前index个元素的前缀和 查询前缀和 class TreeArray { private int[] tree; // sum(nums[i]) private int n; public TreeArray(int[] nums) { n = nums.length + 1; tree = new int[n]; for (int i = 0; i \u003c n - 1; i++) { add(i, nums[i]); } } public void add(int index, int val) { // 下标从 1 开始 index++; // 单点修改，增加数组 index 元素的值 while (index \u003c n) { tree[index] += val; // 更新父结点 index += lowBit(index); } } public int preSum(int index) { // 查询前缀和 int sum = 0; while (index \u003e 0) { sum += tree[index]; // 查询子结点 index -= lowBit(index); } return sum; } private static int lowBit(int x) { // 返回 x 二进制最低位 1 的值 // eg. 6(0b110) 返回 2(0b010) return x \u0026 (-x); } } 复杂度分析 时间复杂度： 构造函数：$O(n \\log n)$ add函数：$O(\\log n)$ preSum函数：$O(\\log n)$ 空间复杂度：$O(n)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":null,"title":"数据结构-树状数组","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#复杂度分析"},{"categories":["数据结构"],"content":" 1.介绍前缀树，又称字典树（Trie） ，是一种特殊的 N 叉树。 前缀树用来存储字符串，每条边代表一个字符。每一个节点会有多个子节点，则通往不同子节点的路径上有着不同的字符。 从根节点通往某节点路径上所有的字符组成对应的字符串。 根节点表示空字符串。 节点所有的后代都与该节点相关的字符串有着共同的前缀。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:1:0","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#1介绍"},{"categories":["数据结构"],"content":" 2.实现数组： 优点：访问结点快速。 缺点：空间浪费。通过下标访问结点。 哈希表： 优点：通过字符访问结点。节约空间。 缺点：速度稍慢。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:2:0","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#2实现"},{"categories":["数据结构"],"content":" 3.代码","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:0","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#3代码"},{"categories":["数据结构"],"content":" 3.1 数组 class TrieNode { boolean isEnd = false; TrieNode[] next = new TrieNode[26]; } class Trie { TrieNode root; public Trie() { root = new TrieNode(); } public void insert(String s) { // 插入字符串 TrieNode p = root; for (char c : s.toCharArray()) { int i = c - 'a'; if (p.next[i] == null) p.next[i] = new TrieNode(); p = p.next[i]; } p.isEnd = true; } public boolean search(String s) { // 查找字符串 s 是否在树中 TrieNode p = root; for (char c : s.toCharArray()) { if (p.next[c - 'a'] == null) return false; p = p.next[c - 'a']; } return p.isEnd; } public boolean startsWith(String s) { // 查找是否存在前缀字符串 s TrieNode p = root; for (char c : s.toCharArray()) { if (p.next[c - 'a'] == null) return false; p = p.next[c - 'a']; } return true; } } 时间复杂度：字符串长度为 len。$ O(len) $ 空间复杂度：节点数量为 n，字符集大小为 k。$ O(n * k) $ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:1","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#31-数组"},{"categories":["数据结构"],"content":" 3.2 哈希表 class TrieNode { Map\u003cCharacter, TrieNode\u003e children = new HashMap\u003c\u003e(); isEnd = false; } class Trie { TrieNode root; Trie() { root = new TrieNode(); } void insert(String s) { TrieNode p = root; for (char c : s.toCharArray()) { p.children.putIfAbsent(c, new TrieNode()); p = p.children.get(c); } p.isEnd = true; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:2","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#32-哈希表"},{"categories":["数据结构"],"content":" 3.3 二维数组 class Trie { static final int MAX_N = 100009; int[][] trie; // 以当前字符结尾的单词的数量 int[] count; // 尚未使用的索引开始位置 int index; public Trie() { trie = new int[MAX_N][26]; count = new int[MAX_N]; index = 0; } public void insert(String s) { // 插入 s int p = 0; for (int i = 0; i \u003c s.length(); i++) { int u = s.charAt(i) - 'a'; if (trie[p][u] == 0) trie[p][u] = ++index; p = trie[p][u]; } count[p]++; } public boolean search(String s) { // 是否存在 s int p = 0; for (int i = 0; i \u003c s.length(); i++) { int u = s.charAt(i) - 'a'; if (trie[p][u] == 0) return false; p = trie[p][u]; } return count[p] != 0; } public boolean startsWith(String s) { // 是否存在前缀 s int p = 0; for (int i = 0; i \u003c s.length(); i++) { int u = s.charAt(i) - 'a'; if (trie[p][u] == 0) return false; p = trie[p][u]; } return true; } } 时间复杂度：字符串长度为 len。$ O(len) $ 空间复杂度：节点数量为 n，字符集大小为 k。$ O(n * k) $ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/:3:3","series":null,"tags":["数据结构","前缀树","字典树","Trie"],"title":"数据结构-前缀树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91/#33-二维数组"},{"categories":["算法"],"content":" 1.基础Dynamic Programming 定义： 存在「重叠子问题」 具备「最优子结构」 步骤： 确定「初始条件」 确定「状态」 确定「可选择列表」 确定「状态转移方程」 数组优化时间 降维优化空间 思路： 自顶向下 def fib(n): return fib(n - 1) + fib(n - 2) 自底向上 def fib(n): for i in range(n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#1基础"},{"categories":["算法"],"content":" 线性DP 最长上升子序列（LIS）Longest Increasing Subsequence 状态定义： $$ dp[i]=s[0:i]的最长上升子序列长度 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]=\\max(dp[i],dp[j] + 1) \\quad \\text{if } j \\lt i \\text{ and } s_j \\lt s_i $$ 最长公共子序列（LCS）Longest Common Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最长公共上升子序列（LCIS）Longest Common Increasing Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共上升子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最小编辑距离 状态定义： $$ dp[i][j]=x[0:i]到y[0:j]的最小操作次数 $$ 状态初始化： $$ \\begin{aligned} dp[i][0] \u0026= i \\newline dp[0][j] \u0026= j \\end{aligned} $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j]\u0026 \\text{if } x_i = y_j \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#线性dp"},{"categories":["算法"],"content":" 线性DP 最长上升子序列（LIS）Longest Increasing Subsequence 状态定义： $$ dp[i]=s[0:i]的最长上升子序列长度 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]=\\max(dp[i],dp[j] + 1) \\quad \\text{if } j \\lt i \\text{ and } s_j \\lt s_i $$ 最长公共子序列（LCS）Longest Common Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最长公共上升子序列（LCIS）Longest Common Increasing Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共上升子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最小编辑距离 状态定义： $$ dp[i][j]=x[0:i]到y[0:j]的最小操作次数 $$ 状态初始化： $$ \\begin{aligned} dp[i][0] \u0026= i \\newline dp[0][j] \u0026= j \\end{aligned} $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j]\u0026 \\text{if } x_i = y_j \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长上升子序列lis"},{"categories":["算法"],"content":" 线性DP 最长上升子序列（LIS）Longest Increasing Subsequence 状态定义： $$ dp[i]=s[0:i]的最长上升子序列长度 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]=\\max(dp[i],dp[j] + 1) \\quad \\text{if } j \\lt i \\text{ and } s_j \\lt s_i $$ 最长公共子序列（LCS）Longest Common Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最长公共上升子序列（LCIS）Longest Common Increasing Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共上升子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最小编辑距离 状态定义： $$ dp[i][j]=x[0:i]到y[0:j]的最小操作次数 $$ 状态初始化： $$ \\begin{aligned} dp[i][0] \u0026= i \\newline dp[0][j] \u0026= j \\end{aligned} $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j]\u0026 \\text{if } x_i = y_j \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长公共子序列lcs"},{"categories":["算法"],"content":" 线性DP 最长上升子序列（LIS）Longest Increasing Subsequence 状态定义： $$ dp[i]=s[0:i]的最长上升子序列长度 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]=\\max(dp[i],dp[j] + 1) \\quad \\text{if } j \\lt i \\text{ and } s_j \\lt s_i $$ 最长公共子序列（LCS）Longest Common Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最长公共上升子序列（LCIS）Longest Common Increasing Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共上升子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最小编辑距离 状态定义： $$ dp[i][j]=x[0:i]到y[0:j]的最小操作次数 $$ 状态初始化： $$ \\begin{aligned} dp[i][0] \u0026= i \\newline dp[0][j] \u0026= j \\end{aligned} $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j]\u0026 \\text{if } x_i = y_j \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长公共上升子序列lcis"},{"categories":["算法"],"content":" 线性DP 最长上升子序列（LIS）Longest Increasing Subsequence 状态定义： $$ dp[i]=s[0:i]的最长上升子序列长度 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]=\\max(dp[i],dp[j] + 1) \\quad \\text{if } j \\lt i \\text{ and } s_j \\lt s_i $$ 最长公共子序列（LCS）Longest Common Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最长公共上升子序列（LCIS）Longest Common Increasing Subsequence 状态定义： $$ dp[i][j]=x[0:i]和y[0:j]的最长公共上升子序列长度 $$ 状态初始化： $$ dp[i][0] = dp[0][j] = 0 $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j] + 1\u0026 \\text{if } x_i = y_j \\newline \\max(dp[i+1][j],dp[i][j+1])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 最小编辑距离 状态定义： $$ dp[i][j]=x[0:i]到y[0:j]的最小操作次数 $$ 状态初始化： $$ \\begin{aligned} dp[i][0] \u0026= i \\newline dp[0][j] \u0026= j \\end{aligned} $$ 状态转移方程： $$ dp[i+1][j+1]= \\begin{aligned} \\begin{cases} dp[i][j]\u0026 \\text{if } x_i = y_j \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最小编辑距离"},{"categories":["算法"],"content":" 背包问题 0-1 背包 状态定义： $$ dp[i][j]=只选前i个物品所能获得的最大价值 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]= \\begin{aligned} \\begin{cases} dp[i-1] + v_i\u0026 \\text{if } w + w_i \\le W \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 多重背包 完全背包","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:2","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#背包问题"},{"categories":["算法"],"content":" 背包问题 0-1 背包 状态定义： $$ dp[i][j]=只选前i个物品所能获得的最大价值 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]= \\begin{aligned} \\begin{cases} dp[i-1] + v_i\u0026 \\text{if } w + w_i \\le W \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 多重背包 完全背包","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:2","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#0-1-背包"},{"categories":["算法"],"content":" 背包问题 0-1 背包 状态定义： $$ dp[i][j]=只选前i个物品所能获得的最大价值 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]= \\begin{aligned} \\begin{cases} dp[i-1] + v_i\u0026 \\text{if } w + w_i \\le W \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 多重背包 完全背包","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:2","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#多重背包"},{"categories":["算法"],"content":" 背包问题 0-1 背包 状态定义： $$ dp[i][j]=只选前i个物品所能获得的最大价值 $$ 状态初始化： $$ dp[0] = 0 $$ 状态转移方程： $$ dp[i]= \\begin{aligned} \\begin{cases} dp[i-1] + v_i\u0026 \\text{if } w + w_i \\le W \\newline 1+\\min(dp[i+1][j],dp[i][j+1],dp[i][j])\u0026 \\text{if } x_i \\ne y_j \\end{cases} \\end{aligned} $$ 多重背包 完全背包","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:2","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#完全背包"},{"categories":["算法"],"content":" 区间DP 最长回文子串 状态定义： $$ dp[i][j]=s[i:j+1]是否是回文串 $$ 状态初始化： $$ \\begin{aligned} \u0026dp[i][i] = true \u0026dp[i][i+1] = true \\quad \\text{ if } s_i = s_{i+1} \\end{aligned} $$ 状态转移方程： $$ dp[i][i+j]=dp[i+1][i+j-1] \\land s_i = s_{i+j} $$ 括号匹配","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#区间dp"},{"categories":["算法"],"content":" 区间DP 最长回文子串 状态定义： $$ dp[i][j]=s[i:j+1]是否是回文串 $$ 状态初始化： $$ \\begin{aligned} \u0026dp[i][i] = true \u0026dp[i][i+1] = true \\quad \\text{ if } s_i = s_{i+1} \\end{aligned} $$ 状态转移方程： $$ dp[i][i+j]=dp[i+1][i+j-1] \\land s_i = s_{i+j} $$ 括号匹配","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长回文子串"},{"categories":["算法"],"content":" 区间DP 最长回文子串 状态定义： $$ dp[i][j]=s[i:j+1]是否是回文串 $$ 状态初始化： $$ \\begin{aligned} \u0026dp[i][i] = true \u0026dp[i][i+1] = true \\quad \\text{ if } s_i = s_{i+1} \\end{aligned} $$ 状态转移方程： $$ dp[i][i+j]=dp[i+1][i+j-1] \\land s_i = s_{i+j} $$ 括号匹配","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#括号匹配"},{"categories":["算法"],"content":" 树形DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:4","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#树形dp"},{"categories":["算法"],"content":" 状压DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:5","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#状压dp"},{"categories":["算法"],"content":" 数位DP","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:6","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#数位dp"},{"categories":["算法"],"content":" 2.实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#2实战"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#线性dp-1"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#买卖股票的最佳时机"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#1-买卖股票的最佳时机-最多1次"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#2-买卖股票的最佳时机-无限制"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#3-买卖股票的最佳时机-最多2次"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#4-买卖股票的最佳时机-最多k次"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#5-买卖股票的最佳时机-冷冻期"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#6-买卖股票的最佳时机-手续费"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长递增子序列lis"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长公共子序列lcs-1"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长公共子序列"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#两个字符串的删除操作"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长回文子序列"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最短公共超序列"},{"categories":["算法"],"content":" 线性DP 买卖股票的最佳时机 1 买卖股票的最佳时机-最多1次121. 买卖股票的最佳时机 定义状态：$dp[i]$ 表示前 $i$ 天的最大利润。 状态转移： $$ dp[i] = \\max(dp[i-1], prices[i] - 前i-1天的最低价格) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[] dp = new int[n]; int minPrice = prices[0]; for (int i = 1; i \u003c n; i++) { dp[i] = Math.max(dp[i - 1], prices[i] - minPrice); minPrice = Math.min(minPrice, prices[i]); } return dp[n - 1]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int ans = 0; int minPrice = Integer.MAX_VALUE; for (int price : prices) { ans = Math.max(ans, price - minPrice); minPrice = Math.min(minPrice, price); } return ans; } } 2 买卖股票的最佳时机-无限制122. 买卖股票的最佳时机 II 定义状态：$dp[i][0]$ 表示第 $i$ 天未持有股票的最大利润，$dp[i][1]$ 表示第 $i$ 天持有股票的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ dp[i][0] = \\max(dp[i-1][0],dp[i-1][1] + prices[i]) \\newline dp[i][1] = \\max(dp[i-1][1],dp[i-1][0] - prices[i]) $$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][1] = -prices[0]; for (int i = 1; i \u003c n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } } 空间优化：每一天的状态只与前一天的状态有关。 class Solution { public int maxProfit(int[] prices) { int n = prices.length; // 最开始不可能持有股票，状态不存在，置为负无穷 int[] dp = { 0, Integer.MIN_VALUE }; for (int price : prices) { int[] temp = { Math.max(dp[0], dp[1] + price), Math.max(dp[1], dp[0] - price) }; dp = temp; } return dp[0]; } } 3 买卖股票的最佳时机-最多2次123. 买卖股票的最佳时机 III 定义状态： $dp[i][0][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][0]$ 表示第 $i$ 天未持有股票且前 $i$ 天进行过 2 次购买的最大利润。 $dp[i][0][1]$ 表示第 $i$ 天持有股票且前 $i$ 天未进行过购买的最大利润。 $dp[i][1][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 1 次购买的最大利润。 $dp[i][2][1]$ 表示第 $i$ 天持有股票且前 $i$ 天进行过 2 次购买的最大利润。 状态转移： 未持有-\u003e未持有。 未持有-\u003e持有。（购买，交易数+1） 持有-\u003e未持有。（出售） 持有-\u003e持有。 $$ \\begin{aligned} dp[i][0][0] \u0026= dp[i-1][0][0] \\newline dp[i][1][0] \u0026= \\max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]) \\","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:1","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长公共上升子序列lcis-1"},{"categories":["算法"],"content":" 统计不同回文子序列力扣-0730-统计不同回文子序列 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:2","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#统计不同回文子序列"},{"categories":["算法"],"content":" 二维DP 最长公共子序列1035. 不相交的线 最小路径和64. 最小路径和 class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; for (int i = 1; i \u003c m; i++) grid[i][0] += grid[i - 1][0]; for (int j = 1; j \u003c n; j++) grid[0][j] += grid[0][j - 1]; for (int i = 1; i \u003c m; i++) for (int j = 1; j \u003c n; j++) grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#二维dp"},{"categories":["算法"],"content":" 二维DP 最长公共子序列1035. 不相交的线 最小路径和64. 最小路径和 class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; for (int i = 1; i \u003c m; i++) grid[i][0] += grid[i - 1][0]; for (int j = 1; j \u003c n; j++) grid[0][j] += grid[0][j - 1]; for (int i = 1; i \u003c m; i++) for (int j = 1; j \u003c n; j++) grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最长公共子序列-1"},{"categories":["算法"],"content":" 二维DP 最长公共子序列1035. 不相交的线 最小路径和64. 最小路径和 class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; for (int i = 1; i \u003c m; i++) grid[i][0] += grid[i - 1][0]; for (int j = 1; j \u003c n; j++) grid[0][j] += grid[0][j - 1]; for (int i = 1; i \u003c m; i++) for (int j = 1; j \u003c n; j++) grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:3","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#最小路径和"},{"categories":["算法"],"content":" 状压DP 火柴拼正方形473. 火柴拼正方形 class Solution { public boolean makesquare(int[] matchsticks) { int totalLen = Arrays.stream(matchsticks).sum(); if (totalLen % 4 != 0) { return false; } int len = totalLen / 4, n = matchsticks.length; int[] dp = new int[1 \u003c\u003c n]; Arrays.fill(dp, -1); dp[0] = 0; for (int s = 1; s \u003c (1 \u003c\u003c n); s++) { for (int k = 0; k \u003c n; k++) { if ((s \u0026 (1 \u003c\u003c k)) == 0) { continue; } int s1 = s \u0026 ~(1 \u003c\u003c k); if (dp[s1] \u003e= 0 \u0026\u0026 dp[s1] + matchsticks[k] \u003c= len) { dp[s] = (dp[s1] + matchsticks[k]) % len; break; } } } return dp[(1 \u003c\u003c n) - 1] == 0; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:4","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#状压dp-1"},{"categories":["算法"],"content":" 状压DP 火柴拼正方形473. 火柴拼正方形 class Solution { public boolean makesquare(int[] matchsticks) { int totalLen = Arrays.stream(matchsticks).sum(); if (totalLen % 4 != 0) { return false; } int len = totalLen / 4, n = matchsticks.length; int[] dp = new int[1 \u003c\u003c n]; Arrays.fill(dp, -1); dp[0] = 0; for (int s = 1; s \u003c (1 \u003c\u003c n); s++) { for (int k = 0; k \u003c n; k++) { if ((s \u0026 (1 \u003c\u003c k)) == 0) { continue; } int s1 = s \u0026 ~(1 \u003c\u003c k); if (dp[s1] \u003e= 0 \u0026\u0026 dp[s1] + matchsticks[k] \u003c= len) { dp[s] = (dp[s1] + matchsticks[k]) % len; break; } } } return dp[(1 \u003c\u003c n) - 1] == 0; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:4","series":null,"tags":["算法","动态规划"],"title":"算法-动态规划","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#火柴拼正方形"},{"categories":["算法","字符串匹配"],"content":" KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:1:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#kmp-算法"},{"categories":["算法","字符串匹配"],"content":" KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:1:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理"},{"categories":["算法","字符串匹配"],"content":" KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:1:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#代码"},{"categories":["算法","字符串匹配"],"content":" KMP 算法Knuth-Morris-Pratt 算法。 原理主串text长度为n，匹配串pattern长度为m。 KMP 算法首先算出一个next数组，匹配串每轮匹配在j位置失配时，匹配串向右滑动的距离为j - next[j]。 next[0] = -1 j \u003e 0时next[j]为匹配串中区间[0, j - 1]的严格前缀子串和严格后缀子串中最长公共子串的长度。 设匹配串为abcdabd。 j 子串 严格前缀子串 严格后缀子串 最长公共子串 next[j] 0 -1 1 a 0 2 ab a b 0 3 abc a、ab bc、c 0 4 abcd a 、 ab、abc bcd、cd 、 d 0 5 abcda a 、 ab 、 abc、abcd bcda、cda 、 da 、 a a 1 6 abcdab a 、 ab 、 abc 、 abcd、abcda bcdab、cdab、dab、ab、b ab 2 时间复杂度：O(n + m) 代码 int[] getNext(char[] pattern) { int m = pattern.length; int[] next = new int[m]; next[0] = -1; // 特殊情况 int i = 0; // [0, i - 1] 区间的最长公共子串 int j = -1; while (i \u003c m - 1) { if (j == -1 || pattern[i] == pattern[j]) { i++; j++; next[i] = j; } else { j = next[j]; } } return next; } int kmpSearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; if (m == 0) { return 0; } int[] next = getNext(pattern); int i = 0; // 主串指针 int j = 0; // 匹配串指针 while (i \u003c n \u0026\u0026 j \u003c m) { if (j == -1 || text[i] == pattern[j]) { i++; j++; } else { j = next[j]; } } return j == m ? i - j : -1; } 参考 字符串匹配的KMP算法 - 阮一峰的网络日志 如何更好地理解和掌握 KMP 算法? - 知乎 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:1:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考"},{"categories":["算法","字符串匹配"],"content":" BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar\u003cchar, int\u003e和goodSuffix[]。 代码 HashMap\u003cCharacter, Integer\u003e getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap\u003cCharacter, Integer\u003e badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap\u003cCharacter, Integer\u003e badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:2:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#bm-算法"},{"categories":["算法","字符串匹配"],"content":" BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMap getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:2:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理-1"},{"categories":["算法","字符串匹配"],"content":" BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMap getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:2:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#代码-1"},{"categories":["算法","字符串匹配"],"content":" BM 算法Boyer-Moore 算法。 原理主串text长度为n，匹配串pattern长度为m。 匹配串从后往前匹配 坏字符：将主串中未与匹配串匹配的第一个字符pattern[j]称为坏字符，然后匹配串向右滑动的距离为j - 匹配串中该字符上次出现的位置（未出现返回-1）。 示例 设匹配串为abcdabc。 字符 匹配串中该字符上次出现的位置 a 4 b 5 c 6 d 3 其他 -1 好后缀：匹配串中已匹配的后缀子串称为好后缀，然后然后匹配串向右滑动的距离为m - 好后缀和匹配串前缀子串的最长公共子串长度。特殊地，当j == m - 1时无已匹配部分，定义goodSuffix[m - 1] = m - 1。 示例 设匹配串为abcdabc。 j 好后缀 最长公共子串 goodSuffix[j] 6 6 5 c 0 4 bc、c 0 3 abc、bc、c abc 3 2 dabc、abc、bc、c abc 3 1 cdabc、dabc、abc、bc、c abc 3 0 bcdabc、cdabc 、 dabc 、 abc 、 bc 、 c abc 3 每次匹配串向右滑动这两个规则之中的较大值。可以预处理出badChar和goodSuffix[]。 代码 HashMap getBadChar(String pattern) { int m = pattern.length(); // 坏字符 HashMap badChar = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { badChar.put(pattern.charAt(i), i); } return badChar; } int[] getGoodSuffix(String pattern) { int m = pattern.length(); // 好后缀 int[] goodSuffix = new int[m]; goodSuffix[m - 1] = m - 1; int maxLen = 0; for (int i = m - 2; i \u003e= 0; i--) { int j = 0; // 查找公共子串 while (i + j + 1 \u003c m \u0026\u0026 pattern.charAt(j) == pattern.charAt(i + j + 1)) { j++; } if (i + j + 1 \u003c m) { // 不存在公共子串 goodSuffix[i] = maxLen; } else { goodSuffix[i] = j; maxLen = j; } } return goodSuffix; } int bmSearch(String text, String pattern) { int n = text.length(); int m = pattern.length(); if (n == 0 || m == 0) { return -1; } HashMap badChar = getBadChar(pattern); int[] goodSuffix = getGoodSuffix(pattern); int i = m - 1; while (i \u003c n) { // 匹配串从后往前匹配 int j = m - 1; while (j \u003e= 0) { char c = text.charAt(i + j - m + 1); if (c != pattern.charAt(j)) { int badCharDis = j - badChar.getOrDefault(c, -1); int goodSuffixDis = m - goodSuffix[j]; i += Math.max(badCharDis, goodSuffixDis); break; } j--; } if (j == -1) { return i - m + 1; } } return -1; } 参考 字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 字符串匹配算法详解 - 云+社区 - 腾讯云 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:2:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考-1"},{"categories":["算法","字符串匹配"],"content":" Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap\u003cCharacter, Integer\u003e pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:3:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#sunday-算法"},{"categories":["算法","字符串匹配"],"content":" Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:3:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理-2"},{"categories":["算法","字符串匹配"],"content":" Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:3:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#代码-2"},{"categories":["算法","字符串匹配"],"content":" Sunday 算法 原理 主串text长度为n，匹配串pattern长度为m。 当text[i + j] != pattern[j]时，观察主串中匹配串的下一个字符text[i + m]： 若text[i + m]在pattern中存在，则i += m - c最后出现的位置 若text[i + m]在pattern中不存在，则i += m + 1 时间复杂度 平均：O(n) 最坏：O(n * m) 代码 int sundaySearch(char[] text, char[] pattern) { int n = text.length; int m = pattern.length; // 字符最后出现的位置 HashMap pos = new HashMap\u003c\u003e(); for (int i = 0; i \u003c m; i++) { pos.put(pattern[i], i); } int i = 0; while (i + m \u003c= n) { int j = 0; while (j \u003c m) { if (text[i + j] != pattern[j]) { if (i + m \u003c n \u0026\u0026 pos.containsKey(text[i + m])) { i += m - pos.get(text[i + m]); } else { i += m + 1; } break; } j++; } if (j == m) { return i; } } return -1; } 参考 Sunday 解法 - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:3:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考-2"},{"categories":["算法","字符串匹配"],"content":" Rabin Karp","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:4:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#rabin-karp"},{"categories":["算法","字符串匹配"],"content":" 原理使用字符串哈希算法将字符串比较转化为整数比较。然后通过滚动计算哈希来降低时间复杂度。最后防止出现哈希冲突，再朴素比较一遍。 区间[i,j]的哈希值为 $$ hash1 = s[i] \\times K^{j-i} + s[i+1] \\times K^{j-i-1} + \\cdots + s[j-1] \\times K + s[j] $$ 区间[i+1,j+1]的哈希值为 $$ \\begin{aligned} hash2 \u0026= s[i+1] \\times K^{j-i} + \\cdots + s[j-1] \\times K^2 + s[j] \\times K + s[j+1] \\newline \u0026= hash1 \\times K - s[i] \\times K^{j-i+1} + s[j+1] \\newline \u0026= hash1 \\times K - s[i] \\times G + s[j+1] \\quad (G = K^{j-i+1}) \\end{aligned} $$ 如果字符串过长，最后计算哈希可能会溢出。为了解决这个问题，使用取余。 $$ \\begin{aligned} hash2 \u0026= (hash1 \\times K - s[i] \\times G + s[j+1]) \\bmod Q \\newline hash2 \u0026= (hash2 + Q) \\bmod Q \\end{aligned} $$ 其中，$K$ 和 $Q$ 分别取合适的质数即可。并且预处理出 $G = K^{j-i+1}$，减少时间复杂度。 时间复杂度：$O(n + m)$，文本串 $text$ 长度为 $n$，模式串 $pattern$ 长度为 $m$。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:4:1","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#原理-3"},{"categories":["算法","字符串匹配"],"content":" 实现 static int strStr(String s, String p) { int n = s.length(); int m = p.length(); if (n \u003c m) return -1; int Q = 10000007; int K = 107; int G = 1; int sHash = 0; int pHash = 0; for (int i = 0; i \u003c m; i++) { sHash = (sHash * K + s.charAt(i)) % Q; if (sHash \u003c 0) sHash += Q; pHash = (pHash * K + p.charAt(i)) % Q; if (pHash \u003c 0) pHash += Q; G = (G * K) % Q; if (G \u003c 0) G += Q; } if (equals(s, p, 0, sHash, pHash)) return 0; for (int i = 1; i + m \u003c= n; i++) { sHash = (sHash * K - s.charAt(i - 1) * G + s.charAt(i + m - 1)) % Q; if (sHash \u003c 0) sHash += Q; if (equals(s, p, i, sHash, pHash)) return i; } return -1; } static boolean equals(String s, String p, int k, int sHash, int pHash) { if (sHash != pHash) return false; for (int i = 0; i \u003c p.length(); i++) if (s.charAt(i + k) != p.charAt(i)) return false; return true; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:4:2","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#实现"},{"categories":["算法","字符串匹配"],"content":" 参考 字符串匹配算法-Rabin Karp算法 | coolcao的小站 简单易懂的Rabin Karp算法详解！ - 实现 strStr() - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/:5:0","series":null,"tags":["算法"],"title":"算法-字符串匹配","uri":"/posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#参考-3"},{"categories":["算法"],"content":" 1.基础","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:1:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#1基础"},{"categories":["算法"],"content":" 1.1 术语介绍 稳定排序：相同大小的元素在排序前后保持相对顺序不变。 不稳定排序：相同大小的元素在排序前后的相对顺序发生变化。 内部排序：在内存中进行的排序。 外部排序：数据量太大不能全部读入内存，需要通过内存和磁盘结合进行的排序。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:1:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#11-术语介绍"},{"categories":["算法"],"content":" 1.2 数组中元素交换的方法 static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:1:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#12-数组中元素交换的方法"},{"categories":["算法"],"content":" 2.冒泡排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#2冒泡排序"},{"categories":["算法"],"content":" 2.1 原理 将整个数组划分为两个区域：未排序区、已排序区。数组左侧为未排序区，右侧为已排序区。 从左往右进行排序，当进行第一轮排序时，未排序区大小为 n，已排序区大小为 0。 每次比较相邻的两个数，若左侧的数字大于右侧的数字，则交换这两个数字。 当比较到未排序区的末尾时，未排序区的最后一个数字即为未排序区的最大数字，将其放入已排序区，则未排序区大小减 1，已排序区大小加 1，此时完成一轮排序。 当进行了 n - 1 轮排序后，未排序区的大小减为 1 时，排序结束。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#21-原理"},{"categories":["算法"],"content":" 2.2 优化 限制区域（默认）：每一轮只用比较未排序区的元素。当进行了 i 轮排序后，已排序区的大小为 i，未排序区的大小为 n - i。 提前结束：当某一轮未发生交换时，说明排序已经完成，可以提前结束。可设置一个布尔值记录一轮排序是否有发生交换。 冒泡界优化：若当前轮使多个元素有序，则下一轮只需比较之前的元素。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#22-优化"},{"categories":["算法"],"content":" 2.3 代码 // 1.未优化 static void bubbleSort(int[] nums) { int n = nums.length; for (int epoch = 1; epoch \u003c n; epoch++) for (int i = 0; i \u003c n - epoch; i++) if (nums[i] \u003e nums[i + 1]) swap(nums, i, i + 1); } // 2.提前结束优化 static void bubbleSort(int[] nums) { int n = nums.length; for (int epoch = 1; epoch \u003c n; epoch++) { boolean swapped = false; for (int i = 0; i \u003c n - epoch; i++) { if (nums[i] \u003e nums[i + 1]) { swap(nums, i, i + 1); swapped = true; } } if (!swapped) break; } } // 3.冒泡界优化 static void bubbleSort(int[] nums) { int n = nums.length; int firstSortedIndex = n - 1; for (int epoch = 1; epoch \u003c n; epoch++) { boolean swapped = false; int lastSwappedIndex; for (int i = 0; i \u003c firstSortedIndex; i++) { if (nums[i] \u003e nums[i + 1]) { swap(nums, i, i + 1); swapped = true; lastSwappedIndex = i; } } if (!swapped) break; firstSortedIndex = lastSwappedIndex; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#23-代码"},{"categories":["算法"],"content":" 2.4 分析 时间复杂度：$ O(n^2) $ $$ \\sum_{epoch=1}^{n-1}\\sum_{i=0}^{n-epoch-1}1=\\sum_{epoch=1}^{n-1}(n-epoch-1)=(n-2)+(n-3)+\\cdots+0=\\frac{(n-1)(n-2)}{2} $$ 空间复杂度：$ O(1) $ 稳定性：稳定 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:2:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#24-分析"},{"categories":["算法"],"content":" 3.选择排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#3选择排序"},{"categories":["算法"],"content":" 3.1 介绍将数组分为排序区（当前索引以前部分）和未排序区（当前索引及以后部分），每次将未排序区中的最小元素和未排序区的第一个元素进行交换，然后将该元素加入排序区。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#31-介绍"},{"categories":["算法"],"content":" 3.2 特点 时间复杂度：$ O(n ^ 2) $ 空间复杂度：$ O(1) $ 非稳定排序 原地排序 每一轮排序至少确定一个元素的位置 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#32-特点"},{"categories":["算法"],"content":" 3.3 步骤 将数组分为排序区（当前索引以前部分）和未排序区（当前索引及以后部分），每次将未排序区中的最小元素和未排序区的第一个元素进行交换，然后将该元素加入排序区。 重复步骤 1，直到未排序区没有元素。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#33-步骤"},{"categories":["算法"],"content":" 3.4 代码 static void selectionSort(int[] arr) { int n = arr.length; // 排序区：[0, i)，未排序区：[i, n) for (int i = 0; i \u003c n; i++) { int minIdx = i; for (int j = i + 1; j \u003c n; j++) if (arr[j] \u003c arr[minIdx]) minIdx = j; int temp = arr[i]; arr[i] = arr[minIdx]; arr[minIdx] = temp; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:3:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#34-代码"},{"categories":["算法"],"content":" 4.插入排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:4:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#4插入排序"},{"categories":["算法"],"content":" 4.1 介绍将数组分为排序区（当前索引以前部分）和未排序区（当前索引及以后部分），每次将未排序区中的第一个元素插入到排序区中的对应位置。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:4:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#41-介绍"},{"categories":["算法"],"content":" 4.2 特点 时间复杂度：$ O(n ^ 2) $ 空间复杂度：$ O(1) $ 稳定排序 原地排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:4:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#42-特点"},{"categories":["算法"],"content":" 4.3 步骤 将数组分为排序区（当前索引以前部分）和未排序区（当前索引及以后部分）。 若当前索引元素比前一个元素小，则将前一个元素后移一位。 重复步骤 2，直到没有上一个元素或者上一个元素小于等于当前元素为止，在当前位置插入该元素。 重复步骤 2 和 3，直到未排序区没有元素。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:4:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#43-步骤"},{"categories":["算法"],"content":" 4.4 代码 static void insertionSort(int[] arr) { int n = arr.length; for (int i = 1; i \u003c n; i++) { int temp = arr[i]; int j = i - 1; for (; j \u003e= 0 \u0026\u0026 arr[j] \u003e temp; j--) arr[j + 1] = arr[j]; arr[j + 1] = temp; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:4:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#44-代码"},{"categories":["算法"],"content":" 5.希尔排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:5:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#5希尔排序"},{"categories":["算法"],"content":" 5.1 介绍改进插入排序，将插入排序中相邻元素比较改为间隔为 h 的元素进行比较，使数组中任意间隔为 h 的元素都有序。只要最后按 h = 1 进行插入排序，就能将数组排序。对于每个 h，使用插入排序独立进行排序。 一般取 h = 1 / 2 * (3 * k - 1)，称为递增序列。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:5:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#51-介绍"},{"categories":["算法"],"content":" 5.2 特点 时间复杂度：$ O(n ^ {\\frac{3}{2}}) $ 空间复杂度：$ O(1) $ 稳定排序 原地排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:5:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#52-特点"},{"categories":["算法"],"content":" 5.3 代码 static void shellSort(int[] arr) { int n = arr.length; int h = 1; while (h \u003c n / 3) h = 3 * h - 1; // 1, 4, 13, 40, 121, ... while (h \u003e= 1) { for (int i = h; i \u003c n; i++) { int temp = arr[i]; int j = i - h; for (; j \u003e= 0 \u0026\u0026 arr[j] \u003e temp; j -= h) // 间隔为 h 的插入排序 arr[j + h] = arr[j]; arr[j + h] = temp; } h /= 3; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:5:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#53-代码"},{"categories":["算法"],"content":" 6.归并排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#6归并排序"},{"categories":["算法"],"content":" 6.1 介绍使用分治的思想将数组划分为大小相等的两部分，然后分别对这两部分进行排序，再将有序的这两部分归并成大的有序数组。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#61-介绍"},{"categories":["算法"],"content":" 6.2 特点 时间复杂度：$ O(n \\log n) $ 空间复杂度：$ O(n) $，需要一个辅助数组帮助进行归并。 稳定排序 非原地排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#62-特点"},{"categories":["算法"],"content":" 6.3 步骤 将数组按中间位置分为前后两个部分。 递归对前后两部分进行排序。 将有序的前后两部分归并为有序数组。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#63-步骤"},{"categories":["算法"],"content":" 6.1 自顶向下 static void mergeSort(int[] arr) { int[] copy = new int[arr.length]; mergeSort(arr, 0, arr.length, copy); } static void mergeSort(int[] arr, int low, int high, int[] copy) { // [low, high) if (low + 1 \u003e= high) return; int mid = low + (high - low) / 2; mergeSort(arr, low, mid, copy); mergeSort(arr, mid, high, copy); merge(arr, low, mid, high, copy); } static void merge(int[] arr, int low, int mid, int high, int[] copy) { // 将 [low, mid) 和 [mid, high) 归并 int i = low; int j = mid; for (int k = low; k \u003c high; k++) copy[k] = arr[k]; for (int k = low; k \u003c high; k++) { if (i \u003e= mid) arr[k] = copy[j++]; else if (j \u003e= high) arr[k] = copy[i++]; else if (copy[i] \u003c copy[j]) arr[k] = copy[i++]; else arr[k] = copy[j++]; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#61-自顶向下"},{"categories":["算法"],"content":" 6.2 自底向上 static void mergeSort(int[] arr) { int n = arr.length; int[] copy = new int[n]; for (int sz = 1; sz \u003c n; sz *= 2) // [i, i + sz) [i + sz, i + sz * 2) for (int i = 0; i + sz \u003c= n; i += sz * 2) merge(arr, i, i + sz, Math.min(i + sz * 2, n), copy); } static void merge(int[] arr, int low, int mid, int high, int[] copy) { // 将 [low, mid) 和 [mid, high) 归并 int i = low; int j = mid; for (int k = low; k \u003c high; k++) copy[k] = arr[k]; for (int k = low; k \u003c high; k++) { if (i \u003e= mid) arr[k] = copy[j++]; else if (j \u003e= high) arr[k] = copy[i++]; else if (copy[i] \u003c copy[j]) arr[k] = copy[i++]; else arr[k] = copy[j++]; } } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:6:5","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#62-自底向上"},{"categories":["算法"],"content":" 7.快速排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#7快速排序"},{"categories":["算法"],"content":" 7.1 介绍与归并排序一样，快速排序也是一种利用 分治思想 的排序方法，确定 主轴及分区 是快速排序的核心操作。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#71-介绍"},{"categories":["算法"],"content":" 7.2 特点 时间复杂度：平均/最优为 $O(n \\log n)$，最坏为 $O(n^2)$。 实现简单 原地排序 每一轮确定一个元素的位置 非稳定排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#72-特点"},{"categories":["算法"],"content":" 7.3 步骤 在数组中随机取出一个数，称之为基数（pivot）。 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域。 从左向右遍历找到第一个大于等于基数的元素。 从右向左遍历找到第一个小于等于基数的元素。 交换两个元素。 将左右两个区域视为两个数组，重复前两个步骤，当子数组排序完成即整个数组排序完成。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#73-步骤"},{"categories":["算法"],"content":" 7.4 标准快排 static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } static void quickSort(int[] arr, int low, int high) { // [low, high] if (low \u003e= high) return; // 1. 随机选取 pivot，并交换到第 1 个 int pid = low + (int) (Math.random() * (high - low + 1)); int temp = arr[low]; arr[low] = arr[pid]; arr[pid] = temp; // 2. partition 划分 pid = partition(arr, low, high); // 3. 递归子数组 quickSort(arr, low, pid - 1); quickSort(arr, pid + 1, high); } static int partition(int[] arr, int low, int high) { int pivot = arr[low]; int l = low; int r = high; while (l \u003c r) { // pivot 在左侧则先右后左，pivot 在右侧则先左后右 while (l \u003c r \u0026\u0026 arr[r] \u003e= pivot) r--; arr[l] = arr[r]; while (l \u003c r \u0026\u0026 arr[l] \u003c= pivot) l++; arr[r] = arr[l]; } arr[l] = pivot; return l; } partition 的其他实现方法 static int partition(int[] arr, int low, int high) { int pivot = arr[low]; int l = low; int r = high + 1; while (true) { while (l \u003c high \u0026\u0026 arr[++l] \u003c pivot); while (low \u003c r \u0026\u0026 arr[--r] \u003e pivot); if (l \u003e= r) break; swap(arr, l, r); } swap(arr, low, r); return r; } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 非递归实现 static void quickSort(int[] arr) { Deque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); // [low, high] st.push(0); st.push(arr.length - 1); while (!st.isEmpty()) { int high = st.poll(); int low = st.poll(); if (low \u003e= high) continue; int pid = low + (int) (Math.random() * (high - low + 1)); int temp = arr[low]; arr[low] = arr[pid]; arr[pid] = temp; pid = partition(arr, low, high); st.push(low); st.push(pid - 1); st.push(pid + 1); st.push(high); } } static int partition(int[] arr, int low, int high) { int pivot = arr[low]; int l = low; int r = high; while (l \u003c r) { // pivot 在左侧则先右后左，pivot 在右侧则先左后右 while (l \u003c r \u0026\u0026 arr[r] \u003e= pivot) r--; arr[l] = arr[r]; while (l \u003c r \u0026\u0026 arr[l] \u003c= pivot) l++; arr[r] = arr[l]; } arr[l] = pivot; return l; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#74-标准快排"},{"categories":["算法"],"content":" 7.5 三向切分快排将数组切分为三个部分：小于 pivot、等于 pivot、大于 pivot。 当数组中存在重复元素时效率更高。 每一轮确定 r - l + 1 个元素的位置。 static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } static void quickSort(int[] arr, int low, int high) { // [low, high] if (low \u003e= high) return; // 1. 随机选取 pivot int pid = low + (int) (Math.random() * (high - low + 1)); // 2. partition int pivot = arr[pid]; int l = low; int m = low; int r = high; while (m \u003c= r) { if (arr[m] \u003c pivot) swap(arr, l++, m++); else if (arr[m] \u003e pivot) swap(arr, m, r--); else m++; } // 3. 递归子数组 quickSort(arr, low, l - 1); quickSort(arr, r + 1, high); } static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:7:5","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#75-三向切分快排"},{"categories":["算法"],"content":" 8.堆排序","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:8:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#8堆排序"},{"categories":["算法"],"content":" 8.1 介绍利用二叉堆实现一个能够插入元素、快速找出最大（或最小）元素的数据结构。 饿汉式：不保证元素的顺序，在需要找出最大（或最小）的元素时才采取行动。 懒汉式：保证元素的相对顺序，则可快速找出最大（或最小）的元素。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:8:1","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#81-介绍"},{"categories":["算法"],"content":" 8.2 特点 时间复杂度：$ O(n \\log n) $ 空间复杂度：$ O(1) $ 数据结构 插入元素 删除最值 有序数组 $O(n)$ $O(1)$ 无需数组 $O(1)$ $O(n)$ 二叉堆 $O(\\log n)$ $O(\\log n)$ 理想情况 $O(1)$ $O(1)$ ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:8:2","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#82-特点"},{"categories":["算法"],"content":" 8.3 步骤 使用数组实现最大堆（或最小堆）。 用数组实现一棵完全二叉树，根结点为 arr[1]，arr[k] 的父结点为 arr[k / 2]，左孩子为 arr[k * 2]，右孩子为 arr[k * 2 + 1]。 若为最大堆（或最小堆），父结点的值大于（或小于）等于两个孩子的值。 建堆（堆的有序化）。 上浮：当堆底添加了一个新元素时，需要自下而上恢复堆。 下沉：当堆顶被删除而用堆底元素替换时，需要自上而下恢复堆。 插入。 将新元素加到数组末尾，增大堆的大小，然后从该位置进行上浮操作。 删除最值。 将根结点元素和数组末尾元素交换，减小堆的大小，然后从根结点开始下沉操作。 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:8:3","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#83-步骤"},{"categories":["算法"],"content":" 8.4 代码 public static void heapSort(int[] arr) { int n = arr.length; int[] heap = new int[n + 1]; for (int i = 1; i \u003c= n; i++) { heap[i] = arr[i - 1]; swim(heap, i, i); } for (int i = n; i \u003e= 1; i--) { swap(heap, 1, i); sink(heap, i - 1, 1); } for (int i = 1; i \u003c= n; i++) arr[i - 1] = heap[i]; } private static void swim(int[] heap, int n, int k) { while (k \u003e 1 \u0026\u0026 heap[k / 2] \u003c heap[k]) { swap(heap, k / 2, k); k /= 2; } } private static void sink(int[] heap, int n, int k) { while (k * 2 \u003c n) { int i = k * 2; if (i + 1 \u003c n \u0026\u0026 heap[i] \u003c heap[i + 1]) i++; if (heap[k] \u003e= heap[i]) break; swap(heap, k, i); k = i; } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:8:4","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#84-代码"},{"categories":["算法"],"content":" 9.计数排序 统计每个元素的出现次数，入桶。 按元素大小从小到大排序，桶有序。 依次取出元素进行排序，出桶。 static void countingSort(int[] arr) { if (arr == null || arr.length \u003c 2) return; // 压缩桶的数量 int minVal = arr[0]; int maxVal = arr[0]; for (int x : arr) { minVal = Math.min(minVal, x); maxVal = Math.max(maxVal, x); } int[] bucket = new int[maxVal - minVal + 1]; // 入桶 for (int x : arr) bucket[x]++; // 出桶，排序 int k = 0; for (int i = minVal; i \u003c= maxVal; i++) while (bucket[i - minVal]-- \u003e 0) arr[k++] = i; } ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:9:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#9计数排序"},{"categories":["算法"],"content":" 10.基数排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:10:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#10基数排序"},{"categories":["算法"],"content":" 11.桶排序 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:11:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#11桶排序"},{"categories":["算法"],"content":" 12.总结 算法 最好 平均 最坏 空间 稳定性 冒泡排序 $ O(n) $ $ O(n^2) $ $ O(n^2) $ $ O(1) $ 稳定 选择排序 $ O(n^2) $ $ O(n^2) $ $ O(n^2) $ $ O(1) $ 不稳定 插入排序 $ O(n) $ $ O(n^2) $ $ O(n^2) $ $ O(1) $ 稳定 希尔排序 $ O(n \\log(2n)) $ $ O(n^{1.5}) $ $ O(n^2) $ $ O(1) $ 不稳定 归并排序 $ O(n \\log n) $ $ O(n \\log n) $ $ O(n \\log n) $ $ O(n) $ 稳定 快速排序 $ O(n \\log n) $ $ O(n \\log n) $ $ O(n^2) $ $ O(1) $ 不稳定 堆排序 $ O(n \\log n) $ $ O(n \\log n) $ $ O(n \\log n) $ $ O(1) $ 不稳定 计数排序 $ O(n + k) $ $ O(n + k) $ $ O(n + k) $ $ O(k) $ 稳定 基数排序 $ O(nk) $ $ O(nk) $ $ O(nk) $ $ O(k) $ 稳定 ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:12:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#12总结"},{"categories":["算法"],"content":" 13.实战","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:13:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#13实战"},{"categories":["算法"],"content":" 参考 当我谈排序时，我在谈些什么🤔 复习基础排序算法（Java） - 排序数组 - 力扣（LeetCode） 十大排序从入门到入赘 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/:14:0","series":null,"tags":["算法","排序"],"title":"算法-排序","uri":"/posts/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/#参考"},{"categories":["数据结构"],"content":" 基础满二叉树：一个高度为 d 的二叉树，有 $2^d-1$ 个节点。即除叶节点外，每个节点都有两个孩子，即节点的出度只为 0 或 2。 完全二叉树：只有最后一层可能未满，且节点严格从左往右排列。即出度为 1 的节点一定只有左孩子；若某节点出度小于 2，则其右边的节点出度为 0。 二叉树第 $i$ 层最多有 $2^{i-1}$ 个节点。 高度为 $d$ 的二叉树最多有 $2^d-1$ 个节点。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#基础"},{"categories":["数据结构"],"content":" 定义 class TreeNode { public int val; public TreeNode left, right; public TreeNode() {} public TreeNode(int val) { this.val = val; } public TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } // 3 // / \\ // 1 5 // \\ / \\ // 2 4 6 TreeNode n2 = new TreeNode(2); TreeNode n1 = new TreeNode(1, null, n2); TreeNode n4 = new TreeNode(4); TreeNode n6 = new TreeNode(6); TreeNode n5 = new TreeNode(5, n4, n6); TreeNode n3 = new TreeNode(3, n1, n5); ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:2:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#定义"},{"categories":["数据结构"],"content":" 遍历","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:3:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#遍历"},{"categories":["数据结构"],"content":" 前序遍历 递归：根左右 List\u003cInteger\u003e preorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); dfs(root, ans); return ans; } void dfs(TreeNode root, List\u003cInteger\u003e ans) { if (root == null) return; ans.add(root.val); dfs(root.left, ans); dfs(root.right, ans); } 递归：带结点深度 List\u003cInteger\u003e preorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); dfs(root, 0, ans); return ans; } void dfs(TreeNode root, int depth, List\u003cInteger\u003e ans) { if (root == null) return; ans.add(root.val); dfs(root.left, depth + 1, ans); dfs(root.right, depth + 1, ans); } 非递归：栈根右左 List\u003cInteger\u003e preorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); if (root == null) return ans; Deque\u003cTreeNode\u003e st = new ArrayDeque\u003c\u003e(); st.push(root); while (!st.isEmpty()) { TreeNode p = st.pop(); ans.add(p.val); if (p.right != null) st.push(p.right); if (p.left != null) st.push(p.left); } return ans; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:3:1","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#前序遍历"},{"categories":["数据结构"],"content":" 中序遍历 递归：左根右 List\u003cInteger\u003e inorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); dfs(root, ans); return ans; } void dfs(TreeNode root, List\u003cInteger\u003e ans) { if (root == null) return; dfs(root.left, ans); ans.add(root.val); dfs(root.right, ans); } 递归：带结点深度 List\u003cInteger\u003e inorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); dfs(root, 0, ans); return ans; } void dfs(TreeNode root, int depth, List\u003cInteger\u003e ans) { if (root == null) return; dfs(root.left, depth + 1, ans); ans.add(root.val); dfs(root.right, depth + 1, ans); } 非递归：有左则左，无左则根，有右继续 List\u003cInteger\u003e inorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); if (root == null) return ans; Deque\u003cTreeNode\u003e st = new ArrayDeque\u003c\u003e(); while (!st.isEmpty() || root != null) { while (root != null) { st.push(root); root = root.left; } TreeNode p = st.pop(); ans.add(p.val); root = p.right; } return ans; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:3:2","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#中序遍历"},{"categories":["数据结构"],"content":" 后序遍历 递归：左右根 List\u003cInteger\u003e postorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); dfs(root, ans); return ans; } void dfs(TreeNode root, List\u003cInteger\u003e ans) { if (root == null) return; dfs(root.left, ans); dfs(root.right, ans); ans.add(root.val); } 递归：带结点深度 List\u003cInteger\u003e postorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); dfs(root, 0, ans); return ans; } void dfs(TreeNode root, int depth, List\u003cInteger\u003e ans) { if (root == null) return; dfs(root.left, depth + 1, ans); dfs(root.right, depth + 1, ans); ans.add(root.val); } 非递归：栈根左右，最后逆序 List\u003cInteger\u003e postorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); if (root == null) return ans; Deque\u003cTreeNode\u003e st = new ArrayDeque\u003c\u003e(); st.push(root); while (!st.isEmpty()) { TreeNode p = st.pop(); ans.add(p.val); if (p.left != null) st.push(p.left); if (p.right != null) st.push(p.right); } // Collections.reverse(ans); for (int i = 0, j = ans.size() - 1; i \u003c j; i++, j--) { // Collections.swap(ans, i, j); int temp = ans.get(i); ans.set(i, ans.get(j)); ans.set(j, temp); } return ans; } 非递归：栈根左右，首部添加，无需逆序 List\u003cInteger\u003e postorder(TreeNode root) { List\u003cInteger\u003e ans = new LinkedList\u003c\u003e(); if (root == null) return ans; Deque\u003cTreeNode\u003e st = new ArrayDeque\u003c\u003e(); st.push(root); while (!st.isEmpty()) { TreeNode p = st.pop(); ans.add(0, p.val); if (p.left != null) st.push(p.left); if (p.right != null) st.push(p.right); } return ans; } 非递归：记录上个结点 List\u003cInteger\u003e postorder(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); if (root == null) return ans; Deque\u003cTreeNode\u003e st = new ArrayDeque\u003c\u003e(); TreeNode prev = null; while (!st.isEmpty() || root != null) { while (root != null) { st.push(root); root = root.left; } TreeNode p = st.peek(); if (p.right != null \u0026\u0026 p.right != prev) { root = p.right; } else { ans.add(p.val); st.pop(); } prev = p; } return ans; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:3:3","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#后序遍历"},{"categories":["数据结构"],"content":" 层序遍历 BFS List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); if (root == null) return ans; Queue\u003cTreeNode\u003e que = new ArrayDeque\u003c\u003e(); que.offer(root); int depth = 0; while (!que.isEmpty()) { int size = que.size(); List\u003cInteger\u003e level = new ArrayList\u003c\u003e(); while (size-- \u003e 0) { root = que.poll(); level.add(root.val); if (root.left != null) que.offer(root.left); if (root.right != null) que.offer(root.right); } depth++; ans.add(level); } return ans; } DFS List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); dfs(root, 0, ans); return ans; } void dfs(TreeNode root, int depth, List\u003cList\u003cInteger\u003e\u003e ans) { if (root == null) return; if (depth == ans.size()) ans.add(new ArrayList\u003c\u003e()); ans.get(depth).add(root.val); dfs(root.left, depth + 1, ans); dfs(root.right, depth + 1, ans); } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:3:4","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#层序遍历"},{"categories":["数据结构"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:4:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#二叉搜索树"},{"categories":["数据结构"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:4:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#性质"},{"categories":["数据结构"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:4:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#插入"},{"categories":["数据结构"],"content":" 二叉搜索树Binary Search Tree，BST 性质 左子树结点均小于根结点，右子树结点均大于根结点 左右子树均为二叉搜索树 中序遍历结果为升序 插入小左大右 递归 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } else if (root.val \u003e val) { root.left = insert(root.left, val); } else if (root.val \u003c val) { root.right = insert(root.right, val); } // 跳过相同值 return root; } 迭代 TreeNode insert(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode p = root; while (p != null) { if (p.val \u003e val) { if (p.left == null) { p.left = new TreeNode(val); break; } p = p.left; } else if (p.val \u003c val) { if (p.right == null) { p.right = new TreeNode(val); break; } p = p.right; } else { // 跳过相同值 break; } } return root; } 删除 若删除结点为叶结点，直接删除。 若删除结点为非叶结点，将左子树最大结点或者右子树最小结点移至当前位置。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:4:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#删除"},{"categories":["数据结构"],"content":" 实战","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#实战"},{"categories":["数据结构"],"content":" 🟩二叉树的所有路径257. 二叉树的所有路径 class Solution { public List\u003cString\u003e binaryTreePaths(TreeNode root) { List\u003cString\u003e ans = new ArrayList\u003c\u003e(); char[] path = new char[512]; dfs(root, path, 0, ans); return ans; } void dfs(TreeNode root, char[] path, int idx, List\u003cString\u003e allPath) { if (root == null) return; String s = Integer.toString(root.val); for (int i = 0; i \u003c s.length(); i++) path[idx++] = s.charAt(i); if (root.left == null \u0026\u0026 root.right == null) { allPath.add(String.valueOf(path, 0, idx)); } else { path[idx++] = '-'; path[idx++] = '\u003e'; dfs(root.left, path, idx, allPath); dfs(root.right, path, idx, allPath); } } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:1","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#二叉树的所有路径"},{"categories":["数据结构"],"content":" 🟨求和路径面试题 04.12. 求和路径 class Solution { public int pathSum(TreeNode root, int sum) { if (root == null) return 0; return dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum); } int dfs(TreeNode root, int sum) { // 查找从 root 开始的路径 if (root == null) return 0; sum -= root.val; return (sum == 0 ? 1 : 0) + dfs(root.left, sum) + dfs(root.right, sum); } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:2","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#求和路径"},{"categories":["数据结构"],"content":" 🟩路径总和112. 路径总和 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:3","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#路径总和"},{"categories":["数据结构"],"content":" 🟨路径总和 II113. 路径总和 II ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:4","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#路径总和-ii"},{"categories":["数据结构"],"content":" 🟨路径总和 III437. 路径总和 III ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:5","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#路径总和-iii"},{"categories":["数据结构"],"content":" 🟨从叶结点开始的最小字符串988. 从叶结点开始的最小字符串 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:6","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#从叶结点开始的最小字符串"},{"categories":["数据结构"],"content":" 🟥二叉树中的最大路径和124. 二叉树中的最大路径和 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:7","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#二叉树中的最大路径和"},{"categories":["数据结构"],"content":" 🟨最长同值路径687. 最长同值路径 class Solution { public int longestUnivaluePath(TreeNode root) { return dfs(root)[0]; } int[] dfs(TreeNode root) { // { 最长同值路径的长度，以根结点为端点的同值路径的长度 } if (root == null) return new int[] { 0, 0 }; int[] leftAns = dfs(root.left); int[] rightAns = dfs(root.right); // 最长同值路径可能在左子树上，也可能在右子树上，取两者的更大值 int maxLen = Math.max(leftAns[0], rightAns[0]); // 最长同值路径的长度 int rootLen = 0; // 以 root 结点为端点的同值路径的长度 int leftVal = root.left == null ? Integer.MAX_VALUE : root.left.val; int rightVal = root.right == null ? Integer.MAX_VALUE : root.right.val; if (root.val == leftVal \u0026\u0026 root.val == rightVal) { // 当左孩子、右孩子和 root 的值相同时，可以形成一条经过根结点的同值路径 // 此时，以根结点为端点的同值路径只能选择左右子树中的更长的路径 maxLen = Math.max(maxLen, 2 + leftAns[1] + rightAns[1]); rootLen = 1 + Math.max(leftAns[1], rightAns[1]); } else if (root.val == leftVal) { // 当左孩子和 root 的值相同时，以左孩子为端点的同值路径可以添加 root 结点 rootLen = 1 + leftAns[1]; } else if (root.val == rightVal) { // 当右孩子和 root 的值相同时，以右孩子为端点的同值路径可以添加 root 结点 rootLen = 1 + rightAns[1]; } return new int[] { Math.max(maxLen, rootLen), rootLen }; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:8","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#最长同值路径"},{"categories":["数据结构"],"content":" 🟩二叉树的直径543. 二叉树的直径 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:9","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#二叉树的直径"},{"categories":["数据结构"],"content":" 🟨寻找重复的子树 哈希表 二叉树序列化 652. 寻找重复的子树 class Solution { int id = 1; // 自增 id HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); // 二叉树序列号 -\u003e 自增 id HashMap\u003cString, Integer\u003e cnt = new HashMap\u003c\u003e(); // 二叉树序列号 -\u003e 二叉树数量 List\u003cTreeNode\u003e ans = new ArrayList\u003c\u003e(); public List\u003cTreeNode\u003e findDuplicateSubtrees(TreeNode root) { dfs(root); return ans; } int dfs(TreeNode root) { if (root == null) return 0; // 二叉树序列化值 String code = root.val + \"/\" + dfs(root.left) + \"/\" + dfs(root.right); // 将相同结构的二叉树映射为相同值，用于减小 code 的长度 int nodeId = map.computeIfAbsent(code, k -\u003e id++); cnt.put(code, cnt.getOrDefault(code, 0) + 1); // 第二次出现 if (cnt.get(code) == 2) ans.add(root); return nodeId; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:5:10","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#寻找重复的子树"},{"categories":["数据结构"],"content":" 参考 「代码随想录」帮你对二叉树不再迷茫，彻底吃透前中后序递归法（递归三部曲）和迭代法（不统一写法与统一写法） - 二叉树的后序遍历 - 力扣（LeetCode） 一篇文章解决所有二叉树路径问题（问题分析+分类模板+题目剖析） - 最长同值路径 - 力扣（LeetCode） ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/:6:0","series":null,"tags":["数据结构","二叉树"],"title":"数据结构-二叉树","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/#参考"},{"categories":["算法"],"content":" 1.实现","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:0","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#1实现"},{"categories":["算法"],"content":" 1.1 单向链表 class ListNode { int val; ListNode next; public ListNode() {} public ListNode(int val) { this.val = val; } public ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class SingleLinkedList { // 哨兵结点、虚拟头结点，存储结点数量 ListNode dummy = new ListNode(0); // 尾结点 ListNode tail = dummy; public void add(int val) { // 向链表尾部添加结点 tail.next = new ListNode(val); tail = tail.next; dummy.val++; } public boolean remove() { // 删除链表尾结点 if (isEmpty()) return false; ListNode node = dummy; while (node.next != tail) node = node.next; node.next = null; tail = node; dummy.val--; return true; } public boolean isEmpty() { return tail == dummy; } public int size() { return dummy.val; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:1","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#11-单向链表"},{"categories":["算法"],"content":" 1.2 双向链表 class ListNode { int val; ListNode prev, next; public ListNode() {} public ListNode(int val) { this.val = val; } public ListNode(int val, ListNode prev, ListNode next) { this.val = val; this.prev = prev; this.next = next; } } class DoubleLinkedList { // 哨兵结点、虚拟头/尾结点，存储结点数量 ListNode dummy = new ListNode(0); public DoubleLinkedList() { // 初始化 dummy.prev = dummy; dummy.next = dummy; } public void add(int val) { // 向链表尾部添加结点 dummy.prev.next = new ListNode(val, dummy.prev, dummy); dummy.prev = dummy.prev.next; dummy.val++; } public boolean remove() { // 删除链表尾结点 if (isEmpty()) return false; dummy.prev.prev.next = dummy; dummy.prev = dummy.prev.prev; dummy.val--; return true; } public boolean isEmpty() { return dummy.next == dummy; } public int size() { return dummy.val; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#12-双向链表"},{"categories":["算法"],"content":" 1.3 链表遍历 递归 void traverse(TreeNode head) { if (head == null) return; // 前序 traverse(head.next); // 后序 } 迭代 ListNode p = head; while (p != null) { p = p.next; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:1:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#13-链表遍历"},{"categories":["算法"],"content":" 2.实战","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:0","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2实战"},{"categories":["算法"],"content":" 2.1 小技巧 虚拟头结点 快慢指针 二路归并 k路归并 递归 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:1","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#21-小技巧"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#22-简单"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#221-合并两个有序链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#222-有序链表去重"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#223-判断链表中是否有环"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#224-找出两个链表的交点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#225-删除所有满足条件的节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#226-反转链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#227-判断是否回文链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#228-删除给定节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#229-找出链表的中间节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2210-二进制链表转整数"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2211-删除-m-个节点之后的-n-个节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2212-逆序打印链表"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2213-删除第一个满足条件的节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2214-找出倒数第-k-个节点"},{"categories":["算法"],"content":" 2.2 简单 2.2.1 合并两个有序链表21. 合并两个有序链表 递归 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; } } } 二路归并 class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(); ListNode p = dummy; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } p.next = list1 == null ? list2 : list1; return dummy.next; } } 2.2.2 有序链表去重83. 删除排序链表中的重复元素 递归 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); if (head.val == head.next.val) head = head.next; return head; } } 迭代 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null) return head; ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) cur.next = cur.next.next; else cur = cur.next; } return head; } } 2.2.3 判断链表中是否有环141. 环形链表 快慢指针 public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 fast = fast.next.next; slow = slow.next; if (slow == fast) return true; // 快慢指针相遇，说明含有环 } return false; } } 2.2.4 找出两个链表的交点160. 相交链表 双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while (pA != pB) { // 消除长度差，pA 和 pB 只可能在 交点 或 null 处相等 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } } 2.2.5 删除所有满足条件的节点203. 移除链表元素 递归 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElement","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:2","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2215-未排序链表去重"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#23-中等"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#231-两数相加"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#232-删除倒数第-n-个结点"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#233-两两交换相邻节点"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#234-旋转链表"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#235-删除有序链表中重复的元素"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#236-按指定元素划分链表"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#237-反转从-left-到-right-的链表节点"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#238"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#239"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2310"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2311"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2312"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2313"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2314"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2315"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2316"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2317"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2318"},{"categories":["算法"],"content":" 2.3 中等 2.3.1 两数相加2. 两数相加 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode p = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int addition = carry; if (l1 != null) { addition += l1.val; l1 = l1.next; } if (l2 != null) { addition += l2.val; l2 = l2.next; } carry = addition / 10; p.next = new ListNode(addition % 10); p = p.next; } return dummy.next; } } 2.3.2 删除倒数第 N 个结点19. 删除链表的倒数第 N 个结点 递归 class Solution { int index = 1; // 后序，表示当前是倒数第 index 个结点 public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; head.next = removeNthFromEnd(head.next, n); if (n == index++) head = head.next; // 删除当前结点 return head; } } 前后指针 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (n \u003c= 0) return head; ListNode dummy = new ListNode(0, head); ListNode p1 = head; ListNode p2 = dummy; while (n-- \u003e 0 \u0026\u0026 p1 != null) p1 = p1.next; while (p1 != null) { p1 = p1.next; p2 = p2.next; } if (n \u003c 0) p2.next = p2.next.next; // 当 n 大于链表长度时什么也不做 return dummy.next; } } 2.3.3 两两交换相邻节点24. 两两交换链表中的节点 递归 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 迭代 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode prev = dummy; ListNode curr = head; while (curr != null \u0026\u0026 curr.next != null) { ListNode next = curr.next.next; prev.next = curr.next; // 当前组加入总链表 curr.next.next = curr; // 后结点指向前结点 curr.next = next; // 前结点指向下一组 prev = curr; curr = next; } return dummy.next; } } 2.3.4 旋转链表61. 旋转链表 class Solution { public ListNode rotateRight(ListNode head, int k) { if (head == null || k == 0) return head; // 1. 求链表长度，同时获取链表尾部结点 int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k %= len; if (k == 0) return head; // 2. 找到倒数第 k + 1 个结点 ListNode p = head; for (int i = 1; i \u003c ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:3","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#2319"},{"categories":["算法"],"content":" 2.4 困难 2.4.1","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:4","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#24-困难"},{"categories":["算法"],"content":" 2.4 困难 2.4.1","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/:2:4","series":null,"tags":["数据结构","链表"],"title":"数据结构-链表","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/#241"},{"categories":["数据结构","图"],"content":" 1.术语表图（graph） 边（edge）：连接两个顶点。 自环：起点和终点是同一个顶点的边。 平行边：连接同一对顶点的两条边。 边是否存在方向： 有向图：边有方向。 无向图：边无方向。 是否有环： 无环图：不存在环的图。 顶点（vertex） 度（degree）：顶点连接的边的数量。 入度（indegree）：终点是当前顶点的有向边的数量（到达当前顶点）。 出度（outdegree）：起点是当前顶点的有向边的数量（从当前顶点出发）。 路径（path）：由边连接的一系列顶点。 简单路径：无重复顶点的路径。 环（loop）：起点和终点相同的路径。 简单环：无重复顶点的环。 是否存在平行边： 简单图：无平行边的图。 多重图：存在平行边的图。 子图：边和连接的顶点的子集。 连通图：任意一个顶点都存在路径到达另一个任意顶点。 连通子图： 极大连通子图： 二分图：能将所有顶点分为两个部分的图，每条边的两个顶点分别属于不同的部分。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:1:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#1术语表"},{"categories":["数据结构","图"],"content":" 2.图的存储","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#2图的存储"},{"categories":["数据结构","图"],"content":" 2.1 邻接矩阵 // mat[u][v] == true 表示顶点 u 到顶点 v 存在一条有向边，u 是起点，v 是终点 boolean[][] mat = new boolean[n][n]; // mat[u][v] == w 表示顶点 u 到顶点 v 的有向边的边权 w // 可将 mat[u][v] 赋值为 0 或 Integer.MAX_VALUE 表示 u 和 v 之间无边 int[][] mat = new int[n][n]; 优点：可快速判断两个顶点是否相邻 缺点：占用空间大 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#21-邻接矩阵"},{"categories":["数据结构","图"],"content":" 2.2 邻接表 // graph[u] 存储从顶点 u 开始的所有边的终点集合 // graph[u].get(i) == v 表示顶点 u 开始的第 i 条边的终点 v List\u003cInteger\u003e[] graph = new ArrayList[n]; // graph[u].get(i)[0] == v, graph[u].get(i)[1] == w 表示顶点 u 开始的第 i 条边的终点 v，边权 w List\u003cint[]\u003e[] graph = new ArrayList[n]; for (int i = 0; i \u003c n; i++) graph[i] = new ArrayList\u003c\u003e(); // 快速判断两个顶点是否相邻 Set\u003cInteger\u003e[] graph = new HashSet[n]; Set\u003cint[]\u003e[] graph = new HashSet[n]; for (int i = 0; i \u003c n; i++) graph[i] = new HashSet\u003c\u003e(); // 快速判断两个顶点是否相邻，从顶点 u 开始的所有边的终点集合有序 Set\u003cInteger\u003e[] graph = new TreeSet[n]; Set\u003cint[]\u003e[] graph = new TreeSet[n]; for (int i = 0; i \u003c n; i++) graph[i] = new TreeSet\u003c\u003e(); 优点：占用空间小 缺点：无法快速判断两个顶点是否相邻（用 Set 存储可解决） ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#22-邻接表"},{"categories":["数据结构","图"],"content":" 2.3 其他 // 1.邻接表（无边权） // adjList1[u] 表示顶点 u 的相邻顶点 List\u003cInteger\u003e[] adjList1; // 2.邻接表 有边权 // adjList2[u] = { {v1, w1}, {v2, w2} ... } 表示顶点 u 的相邻顶点 List\u003cint[]\u003e[] adjList2; // 3.邻接表（无边权，可快速查询某顶点是否相邻） // adjSet[u] 表示顶点 u 的相邻顶点 TreeSet\u003cInteger\u003e[] adjSet; // 4.邻接矩阵 // adjMat[u][v] 表示顶点 u 到 顶点 v 的边的权值。 int[][] adjMat; // 5.边集数组 // edges[i] = { u, v, w } 表示第 i 条边，从顶点 u 到 顶点 v，权值为 w。 int[][] edges; 邻接表 优点：占用的空间少 缺点：无法快速判断两个节点是否相邻 适用于稀疏图 邻接矩阵 优点：占用的空间多 缺点：可以快速判断两个节点是否相邻 适用于稠密图 链式邻接表实现 // 边的定义 class Edge { // 起点，终点，边权 int u, v, w; } // 边集数组 // edges[j] 存储第 j 条边的 { 起点 u，终点 v，边权 w } Edge[] edges; // 或者 int[][] edges; // 表头数组 // adjEdges[u] 存储 u 点的所有出边的编号 List\u003cInteger\u003e[] adjEdges; 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 4, 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ 适用于各种图。 能够处理反向边，边的编号与 1 异或得到反向边。 链式前向星实现 // 边的定义 class Edge { // 终点，边权，下一条边的编号 int v, w, ne; } // 边集数组 // edges[j] 存储第 j 条边的 { 终点 v，边权 w，下一条边的编号 ne } Edge[] edges; // 或者 int[][] edges; // 表头数组 // firstEdge[u] 存储 u 点的第一条出边的编号 int[] firstEdge; // 添加边 void addEdge(int i, int u, int v, int w) { Edge e = new Edge(); e.v = v; e.w = w; // 头插法 e.ne = firstEdge[u]; edges[i] = e; firstEdge[u] = i; } 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#23-其他"},{"categories":["数据结构","图"],"content":" 2.3 其他 // 1.邻接表（无边权） // adjList1[u] 表示顶点 u 的相邻顶点 List[] adjList1; // 2.邻接表 有边权 // adjList2[u] = { {v1, w1}, {v2, w2} ... } 表示顶点 u 的相邻顶点 List[] adjList2; // 3.邻接表（无边权，可快速查询某顶点是否相邻） // adjSet[u] 表示顶点 u 的相邻顶点 TreeSet[] adjSet; // 4.邻接矩阵 // adjMat[u][v] 表示顶点 u 到 顶点 v 的边的权值。 int[][] adjMat; // 5.边集数组 // edges[i] = { u, v, w } 表示第 i 条边，从顶点 u 到 顶点 v，权值为 w。 int[][] edges; 邻接表 优点：占用的空间少 缺点：无法快速判断两个节点是否相邻 适用于稀疏图 邻接矩阵 优点：占用的空间多 缺点：可以快速判断两个节点是否相邻 适用于稠密图 链式邻接表实现 // 边的定义 class Edge { // 起点，终点，边权 int u, v, w; } // 边集数组 // edges[j] 存储第 j 条边的 { 起点 u，终点 v，边权 w } Edge[] edges; // 或者 int[][] edges; // 表头数组 // adjEdges[u] 存储 u 点的所有出边的编号 List[] adjEdges; 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 4, 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ 适用于各种图。 能够处理反向边，边的编号与 1 异或得到反向边。 链式前向星实现 // 边的定义 class Edge { // 终点，边权，下一条边的编号 int v, w, ne; } // 边集数组 // edges[j] 存储第 j 条边的 { 终点 v，边权 w，下一条边的编号 ne } Edge[] edges; // 或者 int[][] edges; // 表头数组 // firstEdge[u] 存储 u 点的第一条出边的编号 int[] firstEdge; // 添加边 void addEdge(int i, int u, int v, int w) { Edge e = new Edge(); e.v = v; e.w = w; // 头插法 e.ne = firstEdge[u]; edges[i] = e; firstEdge[u] = i; } 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#链式邻接表"},{"categories":["数据结构","图"],"content":" 2.3 其他 // 1.邻接表（无边权） // adjList1[u] 表示顶点 u 的相邻顶点 List[] adjList1; // 2.邻接表 有边权 // adjList2[u] = { {v1, w1}, {v2, w2} ... } 表示顶点 u 的相邻顶点 List[] adjList2; // 3.邻接表（无边权，可快速查询某顶点是否相邻） // adjSet[u] 表示顶点 u 的相邻顶点 TreeSet[] adjSet; // 4.邻接矩阵 // adjMat[u][v] 表示顶点 u 到 顶点 v 的边的权值。 int[][] adjMat; // 5.边集数组 // edges[i] = { u, v, w } 表示第 i 条边，从顶点 u 到 顶点 v，权值为 w。 int[][] edges; 邻接表 优点：占用的空间少 缺点：无法快速判断两个节点是否相邻 适用于稀疏图 邻接矩阵 优点：占用的空间多 缺点：可以快速判断两个节点是否相邻 适用于稠密图 链式邻接表实现 // 边的定义 class Edge { // 起点，终点，边权 int u, v, w; } // 边集数组 // edges[j] 存储第 j 条边的 { 起点 u，终点 v，边权 w } Edge[] edges; // 或者 int[][] edges; // 表头数组 // adjEdges[u] 存储 u 点的所有出边的编号 List[] adjEdges; 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 4, 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ 适用于各种图。 能够处理反向边，边的编号与 1 异或得到反向边。 链式前向星实现 // 边的定义 class Edge { // 终点，边权，下一条边的编号 int v, w, ne; } // 边集数组 // edges[j] 存储第 j 条边的 { 终点 v，边权 w，下一条边的编号 ne } Edge[] edges; // 或者 int[][] edges; // 表头数组 // firstEdge[u] 存储 u 点的第一条出边的编号 int[] firstEdge; // 添加边 void addEdge(int i, int u, int v, int w) { Edge e = new Edge(); e.v = v; e.w = w; // 头插法 e.ne = firstEdge[u]; edges[i] = e; firstEdge[u] = i; } 可视化 输入： 6 5 4 3 90 1 4 30 5 6 60 1 5 20 5 2 70 边集数组： 0 { 3, 90 } 1 { 3, 4, 90 } 2 { 1, 4, 30 } 3 { 4, 1, 30 } 4 { 5, 6, 60 } 5 { 6, 5, 60 } 6 { 1, 5, 20 } 7 { 5, 1, 20 } 8 { 5, 2, 70 } 9 { 2, 5, 70 } 表头数组： 1 { 2, 6 } 2 { 9 } 3 { 1 } 4 { 0, 3 } 5 { 4, 7, 8 } 6 { 5 } 特点 空间复杂度：$O(n+m)$ ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:2:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#链式前向星"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue\u003cInteger\u003e queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#3图的遍历"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#31-深度优先搜索dfs"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#32-广度优先搜索bfs"},{"categories":["数据结构","图"],"content":" 3.图的遍历 3.1 深度优先搜索（DFS）Depth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) dfs(graph, u, vis); } void dfs(Graph graph, int u, boolean[] vis) { vis[u] = true; // 前序 for (int v : graph[u]) { // 树枝 if (!vis[v]) dfs(graph, v, vis); } // 后序 } 3.2 广度优先搜索（BFS）Breadth First Search void traverse(Graph graph) { int n = graph.length; boolean[] vis = new boolean[n]; for (int u = 0; u \u003c n; u++) bfs(graph, u, vis); } void bfs(Graph graph, int start, boolean[] vis) { Queue queue = new Queue\u003c\u003e(); queue.offer(start); vis[start] = true; int step = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size-- \u003e 0) { int u = queue.poll(); for (int v : graph[u]) { // 此处可添加结束条件 if (!vis[v]) { vis[v] = true; queue.offer(v); } } } step++; } } 3.3 双向 BFS ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:3:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#33-双向-bfs"},{"categories":["数据结构","图"],"content":" 4.环检测","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:4:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#4环检测"},{"categories":["数据结构","图"],"content":" 4.1 有向图Detect cycle in a directed graph | Practice | GeeksforGeeks DFS class Solution { static boolean isCyclic(List\u003cList\u003cInteger\u003e\u003e graph) { // 判断有向图中是否存在环 int n = graph.size(); int[] vis = new int[n]; for (int u = 0; u \u003c n; u++) // 对每个连通分量都进行判断 if (vis[u] == 0 \u0026\u0026 dfs(graph, u, vis)) return true; return false; } static boolean dfs(List\u003cList\u003cInteger\u003e\u003e graph, int u, int[] vis) { // 判断有向图从顶点 u 开始是否存在环 vis[u] = 1; for (int v : graph.get(u)) { if (vis[v] == 1) return true; else if (vis[v] == 0 \u0026\u0026 dfs(graph, v, vis)) return true; } vis[u] = 2; return false; } } BFS class Solution { static boolean isCyclic(List\u003cList\u003cInteger\u003e\u003e graph) { // 判断有向图中是否存在环 int n = graph.size(); // 计算入度 int[] ind = new int[n]; for (List\u003cInteger\u003e uAdj : graph) for (int v : uAdj) ind[v]++; // 每次将入度为 0 的顶点加入队列，同时记录顶点数量 Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); int cnt = 0; for (int u = 0; u \u003c n; u++) { if (ind[u] == 0) { que.offer(u); cnt++; } } while (!que.isEmpty()) { int u = que.poll(); for (int v : graph.get(u)) { if (--ind[v] == 0) { que.offer(v); cnt++; } } } return cnt \u003c n; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:4:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#41-有向图"},{"categories":["数据结构","图"],"content":" 4.2 无向图Detect cycle in an undirected graph | Practice | GeeksforGeeks 并查集 class Solution { static boolean isCyclic(List\u003cList\u003cInteger\u003e\u003e graph) { // 判断无向图中是否存在环 UnionFind uf = new UnionFind(n); for (int u = 0; u \u003c graph.size(); u++) { for (int v : graph.get(u)) { if (u \u003c v) { if (uf.isConnected(u, v)) return true; uf.union(u, v); } } } return false; } } class UnionFind { public int[] parent; public int size; public UnionFind(int n) { this.parent = new int[n]; this.size = n; for (int i = 0; i \u003c n; i++) parent[i] = i; } public int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } public boolean isConnected(int x, int y) { return find(x) == find(y); } public void union(int x, int y) { int px = find(x); int py = find(y); if (px != py) size--; parent[py] = px; } } DFS class Solution { static boolean isCyclic(List\u003cList\u003cInteger\u003e\u003e graph) { // 判断无向图中是否存在环 int n = graph.size(); int[] vis = new int[n]; for (int u = 0; u \u003c n; u++) // 对每个连通分量都进行判断 if (vis[u] == 0 \u0026\u0026 dfs(graph, u, -1, vis)) return true; return false; } static boolean dfs(List\u003cList\u003cInteger\u003e\u003e graph, int u, int pre, int[] vis) { // 判断无向图从顶点 u 开始是否存在环 vis[u] = 1; for (int v : graph.get(u)) { if (v == pre) continue; else if (vis[v] == 1) return true; else if (vis[v] == 0 \u0026\u0026 dfs(graph, v, u, vis)) return true; } vis[u] = 2; return false; } } BFS class Solution { static boolean isCyclic(List\u003cList\u003cInteger\u003e\u003e graph) { // 判断无向图中是否存在环 int n = graph.size(); // 计算顶点的度数 int[] ind = new int[n]; for (List\u003cInteger\u003e uAdj : graph) for (int v : uAdj) ind[v]++; // 每次将度数为 1 的顶点加入队列，同时记录顶点数量 Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); int cnt = 0; for (int u = 0; u \u003c n; u++) { if (ind[u] \u003c= 1) { // 包含孤立顶点 que.offer(u); cnt++; } } while (!que.isEmpty()) { int u = que.poll(); for (int v : graph.get(u)) { if (--ind[v] == 1) { que.offer(v); cnt++; } } } return cnt \u003c n; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:4:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#42-无向图"},{"categories":["数据结构","图"],"content":" 5.拓扑排序拓扑排序（Topological Sort）：得到有向图 $G$ 的顶点的一个排列，满足任意一条有向边 $(u,v)$，$u$ 在排列中都在 $v$ 前面，即相对顺序不变。 DFS：后序添加顶点，然后逆序即可得到拓扑排序序列。（或者建图时颠倒每条边的起始顶点和结束顶点，则最后无需逆序） List\u003cInteger\u003e topoSort(List\u003cSet\u003cInteger\u003e\u003e graph) { // 存在环则返回 null int n = graph.size(); List\u003cInteger\u003e topo = new ArrayList\u003c\u003e(); int[] vis = new int[n]; for (int u = 0; u \u003c n; u++) if (vis[u] == 0 \u0026\u0026 dfs(graph, u, topo, vis)) return null; return topo; } boolean dfs(List\u003cSet\u003cInteger\u003e\u003e graph, int u, List\u003cInteger\u003e topo, int[] vis) { // 返回有向图中是否存在环 vis[u] = 1; for (int v : graph.get(u)) { if (vis[v] == 1) return true; if (vis[v] == 0 \u0026\u0026 dfs(graph, v, topo, vis)) return true; } topo.add(u); vis[u] = 2; return false; } BFS：每次添加入度为 0 的顶点 List\u003cInteger\u003e topoSort(List\u003cSet\u003cInteger\u003e\u003e graph) { // 存在环则返回 null int n = graph.size(); int[] ind = new int[n]; for (Set\u003cInteger\u003e u : graph) for (int v : u) ind[v]++; List\u003cInteger\u003e topo = new ArrayList\u003c\u003e(); Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); for (int u = 0; u \u003c n; u++) if (ind[u] == 0) que.offer(u); while (!que.isEmpty()) { int u = que.poll(); topo.add(u); for (int v : graph.get(u)) if (--ind[v] == 0) que.offer(v); } return topo.size() == n ? topo : null; } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:5:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#5拓扑排序"},{"categories":["数据结构","图"],"content":" 6.二分图二分图：一个图的顶点可分割为两个互不相交的子集，且每条边的两个顶点都分属于这两个子集。 可以用两种颜色给顶点染色使得相邻顶点的颜色均不相同。 785. 判断二分图 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:6:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#6二分图"},{"categories":["数据结构","图"],"content":" 6.1 DFS class Solution { public boolean isBipartite(int[][] graph) { int n = graph.length; int[] vis = new int[n]; for (int u = 0; u \u003c n; u++) // 非连通图 if (vis[u] == 0 \u0026\u0026 !dfs(graph, u, vis, 1)) return false; return true; } boolean dfs(int[][] graph, int u, int[] vis, int color) { vis[u] = color; for (int v : graph[u]) { if (vis[u] == vis[v]) return false; // 相邻结点颜色相同 if (vis[v] == 0 \u0026\u0026 !dfs(graph, v, vis, -color)) // 两种颜色 1 -1 return false; // 剪枝 } return true; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:6:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#61-dfs"},{"categories":["数据结构","图"],"content":" 6.2 BFS class Solution { public boolean isBipartite(int[][] graph) { int n = graph.length; int[] vis = new int[n]; for (int u = 0; u \u003c n; u++) // 非连通图 if (vis[u] == 0 \u0026\u0026 !bfs(graph, u, vis)) return false; return true; } boolean bfs(int[][] graph, int i, int[] vis) { Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); que.offer(i); vis[i] = 1; while (!que.isEmpty()) { int size = que.size(); while (size-- \u003e 0) { int u = que.poll(); for (int v : graph[u]) { if (vis[u] == vis[v]) return false; // 相邻结点颜色相同 if (vis[v] == 0) { vis[v] = -vis[u]; // 两种颜色 1 -1 que.offer(v); } } } } return true; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:6:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#62-bfs"},{"categories":["数据结构","图"],"content":" 7.Flood Fill 算法也称洪水扩散算法，从一个单元格向四周扩散。 200. 岛屿数量 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#7flood-fill-算法"},{"categories":["数据结构","图"],"content":" 7.1 DFS class Solution { public int numIslands(char[][] grid) { int ans = 0; for (int i = 0; i \u003c grid.length; i++) { for (int j = 0; j \u003c grid[0].length; j++) { if (grid[i][j] == '1') { ans++; dfs(grid, i, j, '1', '2'); } } } return ans; } void dfs(char[][] mat, int x, int y, char v1, char v2) { if (x \u003c 0 || x \u003e= mat.length || y \u003c 0 || y \u003e= mat[0].length || mat[x][y] != v1) return; mat[x][y] = v2; dfs(mat, x - 1, y, v1, v2); dfs(mat, x, y + 1, v1, v2); dfs(mat, x + 1, y, v1, v2); dfs(mat, x, y - 1, v1, v2); } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#71-dfs"},{"categories":["数据结构","图"],"content":" 7.2 BFS class Solution { int m, n; Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; int ans = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { ans++; bfs(grid, i, j, '1', '2'); } } } return ans; } void bfs(char[][] mat, int x, int y, char v1, char v2) { if (mat[x][y] != v1) return; que.offer(x); que.offer(y); mat[x][y] = v2; while (!que.isEmpty()) { x = que.poll(); y = que.poll(); for (int[] d : dir) { int xx = x + d[0]; int yy = y + d[1]; if (xx \u003e= 0 \u0026\u0026 xx \u003c m \u0026\u0026 yy \u003e= 0 \u0026\u0026 yy \u003c n \u0026\u0026 mat[xx][yy] == v1) { que.offer(xx); que.offer(yy); mat[xx][yy] = v2; } } } } } 保存坐标的几种方式 数组保存。 que.offer(new int[] { r, c }); int[] p = que.poll(); p[0]; p[1]; 分开保存。 que.offer(r); que.offer(c); int x = que.poll(); int y = que.poll(); 数学计算。注意防止溢出。 que.offer(r * n + c); // n 是列宽 int x = que.poll(); int y = x % n; x /= n; ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#72-bfs"},{"categories":["数据结构","图"],"content":" 7.2 BFS class Solution { int m, n; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; int ans = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { ans++; bfs(grid, i, j, '1', '2'); } } } return ans; } void bfs(char[][] mat, int x, int y, char v1, char v2) { if (mat[x][y] != v1) return; que.offer(x); que.offer(y); mat[x][y] = v2; while (!que.isEmpty()) { x = que.poll(); y = que.poll(); for (int[] d : dir) { int xx = x + d[0]; int yy = y + d[1]; if (xx \u003e= 0 \u0026\u0026 xx \u003c m \u0026\u0026 yy \u003e= 0 \u0026\u0026 yy \u003c n \u0026\u0026 mat[xx][yy] == v1) { que.offer(xx); que.offer(yy); mat[xx][yy] = v2; } } } } } 保存坐标的几种方式 数组保存。 que.offer(new int[] { r, c }); int[] p = que.poll(); p[0]; p[1]; 分开保存。 que.offer(r); que.offer(c); int x = que.poll(); int y = que.poll(); 数学计算。注意防止溢出。 que.offer(r * n + c); // n 是列宽 int x = que.poll(); int y = x % n; x /= n; ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:7:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#保存坐标的几种方式"},{"categories":["数据结构","图"],"content":" 8.最小生成树从一个 n 个顶点的连通图中生成包含 n 个顶点和 n - 1 条边，且边权之和最小的树。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:8:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#8最小生成树"},{"categories":["数据结构","图"],"content":" 8.1 Kruskal 算法步骤： 将图 $G=(V,E)$ 中的所有边按照长度由小到大进行排序，等长的边可以按任意顺序。 初始化图 $G’=(V,\\varnothing)$，从前向后扫描排序后的边，如果扫描到的边 $e$ 在 $G’$ 中连接了两个相异的连通块,则将它插入 $G’$ 中。 最后得到的图 $G’$ 就是图 $G$ 的最小生成树。 复杂度： 时间复杂度：$O(E \\log E)$ 空间复杂度：$O(E)$ int kruskal(Edge[] edges, int n) { Arrays.sort(edges, (a, b) -\u003e a.w - b.w); UnionFind uf = new UnionFind(n); int sum = 0; // 边权和 int count = 0; // 已选边的数量 for (Edge e : edges) { if (uf.isConnected(e.u, e.v)) continue; uf.union(e.u, e.v); sum += e.w; if (++count == n - 1) break; } return sum; } class Edge { int u, v, w; // 起点、终点、边权 public Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; } } class UnionFind { private int[] parent; // 指向父结点 private int size; // 连通块的数量 public UnionFind(int n) { parent = new int[n]; for (int i = 0; i \u003c n; i++) parent[i] = i; size = n; } public int find(int i) { // 寻找根结点 if (parent[i] != i) // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } public boolean isConnected(int i, int j) { // 判断是否连通 return find(i) == find(j); } public void union(int i, int j) { // 连通 if (find(i) != find(j)) size--; parent[find(j)] = find(i); // j 加入 i } public int size() { return size; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:8:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#81-kruskal-算法"},{"categories":["数据结构","图"],"content":" 8.2 Prim 算法步骤： 初始化图 $G’=(\\varnothing,\\varnothing)$，随机选择一个顶点加入，得到 $G’=(V’,\\varnothing)$。 选择 $G’$ 中顶点到其他顶点边权最小的边，将边及其对应顶点加入 $G’$。 重复步骤 2 直到全部顶点都加入 $G’$，即 $G$ 的最小生成树。 复杂度： 时间复杂度：$O(E \\log V)$ 空间复杂度：$O(E)$ int prim(List\u003cEdge\u003e[] graph) { int n = graph.length; boolean[] vis = new boolean[n]; // 顶点是否已选择 int sum = 0; // 最小边权和 int u = 0; // 随机选择一个顶点 int count = 1; // 已选择顶点数量 PriorityQueue\u003cEdge\u003e pq = new PriorityQueue\u003c\u003e((a, b) -\u003e a.w - b.w); // 按边权升序 vis[u] = true; for (Edge e : graph[u]) // 连接未选择顶点的边才会添加 if (!vis[e.v]) pq.offer(e); while (!pq.isEmpty()) { Edge edge = pq.poll(); if (vis[edge.v]) continue; // 跳过连接已选择顶点的边 u = edge.v; sum += edge.w; count++; vis[u] = true; for (Edge e : graph[u]) if (!vis[e.v]) pq.offer(e); if (count == n) break; } return sum; } class Edge { int u, v, w; // 起点、终点、边权 public Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:8:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#82-prim-算法"},{"categories":["数据结构","图"],"content":" 9.最短路径","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:9:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#9最短路径"},{"categories":["数据结构","图"],"content":" 9.1 Dijkstra 算法 单源最短路径 不能处理负边权 步骤： 从起点开始，将起点加入小根堆。 若从当前顶点到相邻顶点的距离小于“到相邻顶点的最短距离”，则更新到相邻顶点的最短距离，同时将相邻顶点加入小根堆。 重复步骤 2，直到没有顶点的最短距离得到更新。 复杂度： 时间复杂度：$ O(E \\log V) $ 空间复杂度：$ O(V+E) $ int[] dijkstra(List\u003cEdge\u003e[] graph, int start) { int n = graph.length; int[] dis = new int[n]; // start 到所有顶点的最短距离 Arrays.fill(dis, 0x3f3f3f3f); // 防止溢出 PriorityQueue\u003cVertex\u003e pq = new PriorityQueue\u003c\u003e((a, b) -\u003e a.dis - b.dis); dis[start] = 0; pq.offer(new Vertex(start, 0)); while (!pq.isEmpty()) { Vertex u = pq.poll(); if (dis[u.id] \u003c u.dis) continue; for (Edge e : graph[u.id]) { if (dis[e.v] \u003e dis[u.id] + e.w) { // 更新最短路径 dis[e.v] = dis[u.id] + e.w; pq.offer(new Vertex(e.v, dis[e.v])); } } } return dis; } class Edge { public int u, v, w; // 起点、终点、边权 public Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; } } class Vertex { public int id, dis; // 顶点编号、start 到该点的距离 public Vertex(int id, int dis) { this.id = id; this.dis = dis; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:9:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#91-dijkstra-算法"},{"categories":["数据结构","图"],"content":" 9.2 SPFA 算法 能够处理负边权 不能处理负环，能够判断负环 int[] spfa(List\u003cEdge\u003e[] graph, int start) { } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:9:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#92-spfa-算法"},{"categories":["数据结构","图"],"content":" 9.3 Bellman-Ford 算法 单源最短路径 能够处理负边权 能够检测负环 时间复杂度：$ O(V*E) $ int[] bellmanFord(List\u003cEdge\u003e[] graph, Edge[] edges, int start) { int n = graph.length; int[] dis = new int[n]; Arrays.fill(dis, 0x3f3f3f3f); dis[start] = 0; for (int k = 1; k \u003c n; k++) for (Edge e : edges) dis[e.v] = Math.min(dis[e.v], dis[e.u] + e.w); for (Edge e : edges) if (dis[e.v] \u003e dis[e.u] + e.w) // 存在负环 return null; return dis; } class Edge { public int u, v, w; // 起点、终点、边权 public Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:9:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#93-bellman-ford-算法"},{"categories":["数据结构","图"],"content":" 9.4 Floyd 算法 多源最短路径 可处理负边权 时间复杂度：$ O(V^3) $ void floyd(List\u003cEdge\u003e[] graph) { // 转为邻接矩阵 int n = graph.length; int[][] dis = new int[n][n]; for (int i = 0; i \u003c n; i++) for (Edge e : graph[u]) dis[e.u][e.v] = e.w; // 矩阵 n 次方，将每个顶点都作为中间顶点 for (int k = 0; k \u003c n; k++) for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c n; j++) dis[i][j] = Math.max(dis[i][k] + dis[k][j]); } class Edge { public int u, v, w; // 起点、终点、边权 public Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:9:4","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#94-floyd-算法"},{"categories":["数据结构","图"],"content":" 9.5 A* 算法","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:9:5","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#95-a-算法"},{"categories":["数据结构","图"],"content":" 实战","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#实战"},{"categories":["数据结构","图"],"content":" 环检测 🟨课程表207. 课程表 🟨以图判树261. 以图判树 DFS class Solution { public boolean validTree(int n, int[][] edges) { List\u003cList\u003cInteger\u003e\u003e graph = new ArrayList\u003c\u003e(n); for (int i = 0; i \u003c n; i++) graph.add(new ArrayList\u003c\u003e()); for (int[] e : edges) { graph.get(e[0]).add(e[1]); graph.get(e[1]).add(e[0]); } return !isCyclic(graph); } static boolean isCyclic(List\u003cList\u003cInteger\u003e\u003e graph) { int n = graph.size(); int[] vis = new int[n]; if (dfs(graph, 0, -1, vis)) return true; for (int x : vis) if (x == 0) return true; return false; } static boolean dfs(List\u003cList\u003cInteger\u003e\u003e graph, int u, int pre, int[] vis) { // 判断无向图从顶点 u 开始是否存在环 vis[u] = 1; for (int v : graph.get(u)) { if (v == pre) continue; else if (vis[v] == 1) return true; else if (vis[v] == 0 \u0026\u0026 dfs(graph, v, u, vis)) return true; } vis[u] = 2; return false; } } ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#环检测"},{"categories":["数据结构","图"],"content":" 环检测 🟨课程表207. 课程表 🟨以图判树261. 以图判树 DFS class Solution { public boolean validTree(int n, int[][] edges) { List","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#课程表"},{"categories":["数据结构","图"],"content":" 环检测 🟨课程表207. 课程表 🟨以图判树261. 以图判树 DFS class Solution { public boolean validTree(int n, int[][] edges) { List","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:1","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#以图判树"},{"categories":["数据结构","图"],"content":" 拓扑排序 🟨课程表 II210. 课程表 II DFS class Solution { List\u003cList\u003cInteger\u003e\u003e graph; int[] vis; int[] ans; int index; public int[] findOrder(int numCourses, int[][] prerequisites) { graph = new ArrayList\u003c\u003e(numCourses); for (int i = 0; i \u003c numCourses; i++) graph.add(new ArrayList\u003c\u003e()); for (int[] pre : prerequisites) graph.get(pre[0]).add(pre[1]); // 逆序建图 // graph.get(pre[1]).add(pre[0]); // 顺序建图 // index = numCourses - 1; // 顺序建图 vis = new int[numCourses]; ans = new int[numCourses]; for (int i = 0; i \u003c numCourses; i++) if (vis[i] == 0 \u0026\u0026 dfs(i)) // 存在环 return new int[0]; return ans; } boolean dfs(int u) { vis[u] = 1; for (int v : graph.get(u)) { if (vis[v] == 0 \u0026\u0026 dfs(v)) return true; // 剪枝 else if (vis[v] == 1) return true; // 存在环 } vis[u] = 2; ans[index++] = u; // ans[index--] = u; // 顺序建图 return false; } } BFS class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { List\u003cList\u003cInteger\u003e\u003e graph = new ArrayList\u003c\u003e(numCourses); for (int i = 0; i \u003c numCourses; i++) graph.add(new ArrayList\u003c\u003e()); int[] indegree = new int[numCourses]; for (int[] pre : prerequisites) { indegree[pre[0]]++; graph.get(pre[1]).add(pre[0]); } int[] ans = new int[numCourses]; int index = 0; Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); int count = 0; for (int i = 0; i \u003c numCourses; i++) if (indegree[i] == 0) { que.offer(i); ans[index++] = i; } while (!que.isEmpty()) { int u = que.poll(); count++; for (int v : graph.get(u)) { indegree[v]--; if (indegree[v] == 0) { que.offer(v); ans[index++] = v; } } } return count == numCourses ? ans : new int[0]; } } 🟥课程表 III630. 课程表 III 🟨课程表 IV1462. 课程表 IV ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#拓扑排序"},{"categories":["数据结构","图"],"content":" 拓扑排序 🟨课程表 II210. 课程表 II DFS class Solution { List","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#课程表-ii"},{"categories":["数据结构","图"],"content":" 拓扑排序 🟨课程表 II210. 课程表 II DFS class Solution { List","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#课程表-iii"},{"categories":["数据结构","图"],"content":" 拓扑排序 🟨课程表 II210. 课程表 II DFS class Solution { List","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#课程表-iv"},{"categories":["数据结构","图"],"content":" 拓扑排序 🟨课程表 II210. 课程表 II DFS class Solution { List","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#heading"},{"categories":["数据结构","图"],"content":" 拓扑排序 🟨课程表 II210. 课程表 II DFS class Solution { List","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:2","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#heading-1"},{"categories":["数据结构","图"],"content":" Flood Fill 图像渲染733. 图像渲染 DFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; dfs(image, sr, sc, image[sr][sc], color); return image; } void dfs(int[][] image, int x, int y, int v1, int v2) { if (x \u003c 0 || x \u003e= image.length || y \u003c 0 || y \u003e= image[0].length || image[x][y] != v1) return; image[x][y] = v2; dfs(image, x - 1, y, v1, v2); dfs(image, x, y + 1, v1, v2); dfs(image, x + 1, y, v1, v2); dfs(image, x, y - 1, v1, v2); } } BFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; int oldColor = image[sr][sc]; int m = image.length; int n = image[0].length; Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; que.offer(sr); que.offer(sc); while (!que.isEmpty()) { int r = que.poll(); int c = que.poll(); image[r][c] = color; for (int[] d : dir) { int rr = r + d[0]; int cc = c + d[1]; if (rr \u003e= 0 \u0026\u0026 rr \u003c m \u0026\u0026 cc \u003e= 0 \u0026\u0026 cc \u003c n \u0026\u0026 image[rr][cc] == oldColor) { que.offer(rr); que.offer(cc); } } } return image; } } 并查集 岛屿数量200. 岛屿数量 DFS class Solution { public int numIslands(char[][] grid) { int ans = 0; for (int i = 0; i \u003c grid.length; i++) { for (int j = 0; j \u003c grid[0].length; j++) { if (grid[i][j] == '1') { ans++; dfs(grid, i, j, '1', '2'); } } } return ans; } void dfs(char[][] grid, int x, int y, char v1, char v2) { if (x \u003c 0 || x \u003e= grid.length || y \u003c 0 || y \u003e= grid[0].length || grid[x][y] != v1) return; grid[x][y] = v2; dfs(grid, x - 1, y, v1, v2); dfs(grid, x, y + 1, v1, v2); dfs(grid, x + 1, y, v1, v2); dfs(grid, x, y - 1, v1, v2); } } BFS class Solution { int m, n; Queue\u003cInteger\u003e que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; int ans = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { ans++; bfs(grid, i, j, '1', '2'); } } } return ans; } void bfs(char[][] grid, in","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#flood-fill"},{"categories":["数据结构","图"],"content":" Flood Fill 图像渲染733. 图像渲染 DFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; dfs(image, sr, sc, image[sr][sc], color); return image; } void dfs(int[][] image, int x, int y, int v1, int v2) { if (x \u003c 0 || x \u003e= image.length || y \u003c 0 || y \u003e= image[0].length || image[x][y] != v1) return; image[x][y] = v2; dfs(image, x - 1, y, v1, v2); dfs(image, x, y + 1, v1, v2); dfs(image, x + 1, y, v1, v2); dfs(image, x, y - 1, v1, v2); } } BFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; int oldColor = image[sr][sc]; int m = image.length; int n = image[0].length; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; que.offer(sr); que.offer(sc); while (!que.isEmpty()) { int r = que.poll(); int c = que.poll(); image[r][c] = color; for (int[] d : dir) { int rr = r + d[0]; int cc = c + d[1]; if (rr \u003e= 0 \u0026\u0026 rr \u003c m \u0026\u0026 cc \u003e= 0 \u0026\u0026 cc \u003c n \u0026\u0026 image[rr][cc] == oldColor) { que.offer(rr); que.offer(cc); } } } return image; } } 并查集 岛屿数量200. 岛屿数量 DFS class Solution { public int numIslands(char[][] grid) { int ans = 0; for (int i = 0; i \u003c grid.length; i++) { for (int j = 0; j \u003c grid[0].length; j++) { if (grid[i][j] == '1') { ans++; dfs(grid, i, j, '1', '2'); } } } return ans; } void dfs(char[][] grid, int x, int y, char v1, char v2) { if (x \u003c 0 || x \u003e= grid.length || y \u003c 0 || y \u003e= grid[0].length || grid[x][y] != v1) return; grid[x][y] = v2; dfs(grid, x - 1, y, v1, v2); dfs(grid, x, y + 1, v1, v2); dfs(grid, x + 1, y, v1, v2); dfs(grid, x, y - 1, v1, v2); } } BFS class Solution { int m, n; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; int ans = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { ans++; bfs(grid, i, j, '1', '2'); } } } return ans; } void bfs(char[][] grid, in","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#图像渲染"},{"categories":["数据结构","图"],"content":" Flood Fill 图像渲染733. 图像渲染 DFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; dfs(image, sr, sc, image[sr][sc], color); return image; } void dfs(int[][] image, int x, int y, int v1, int v2) { if (x \u003c 0 || x \u003e= image.length || y \u003c 0 || y \u003e= image[0].length || image[x][y] != v1) return; image[x][y] = v2; dfs(image, x - 1, y, v1, v2); dfs(image, x, y + 1, v1, v2); dfs(image, x + 1, y, v1, v2); dfs(image, x, y - 1, v1, v2); } } BFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; int oldColor = image[sr][sc]; int m = image.length; int n = image[0].length; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; que.offer(sr); que.offer(sc); while (!que.isEmpty()) { int r = que.poll(); int c = que.poll(); image[r][c] = color; for (int[] d : dir) { int rr = r + d[0]; int cc = c + d[1]; if (rr \u003e= 0 \u0026\u0026 rr \u003c m \u0026\u0026 cc \u003e= 0 \u0026\u0026 cc \u003c n \u0026\u0026 image[rr][cc] == oldColor) { que.offer(rr); que.offer(cc); } } } return image; } } 并查集 岛屿数量200. 岛屿数量 DFS class Solution { public int numIslands(char[][] grid) { int ans = 0; for (int i = 0; i \u003c grid.length; i++) { for (int j = 0; j \u003c grid[0].length; j++) { if (grid[i][j] == '1') { ans++; dfs(grid, i, j, '1', '2'); } } } return ans; } void dfs(char[][] grid, int x, int y, char v1, char v2) { if (x \u003c 0 || x \u003e= grid.length || y \u003c 0 || y \u003e= grid[0].length || grid[x][y] != v1) return; grid[x][y] = v2; dfs(grid, x - 1, y, v1, v2); dfs(grid, x, y + 1, v1, v2); dfs(grid, x + 1, y, v1, v2); dfs(grid, x, y - 1, v1, v2); } } BFS class Solution { int m, n; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; int ans = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { ans++; bfs(grid, i, j, '1', '2'); } } } return ans; } void bfs(char[][] grid, in","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#岛屿数量"},{"categories":["数据结构","图"],"content":" Flood Fill 图像渲染733. 图像渲染 DFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; dfs(image, sr, sc, image[sr][sc], color); return image; } void dfs(int[][] image, int x, int y, int v1, int v2) { if (x \u003c 0 || x \u003e= image.length || y \u003c 0 || y \u003e= image[0].length || image[x][y] != v1) return; image[x][y] = v2; dfs(image, x - 1, y, v1, v2); dfs(image, x, y + 1, v1, v2); dfs(image, x + 1, y, v1, v2); dfs(image, x, y - 1, v1, v2); } } BFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; int oldColor = image[sr][sc]; int m = image.length; int n = image[0].length; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; que.offer(sr); que.offer(sc); while (!que.isEmpty()) { int r = que.poll(); int c = que.poll(); image[r][c] = color; for (int[] d : dir) { int rr = r + d[0]; int cc = c + d[1]; if (rr \u003e= 0 \u0026\u0026 rr \u003c m \u0026\u0026 cc \u003e= 0 \u0026\u0026 cc \u003c n \u0026\u0026 image[rr][cc] == oldColor) { que.offer(rr); que.offer(cc); } } } return image; } } 并查集 岛屿数量200. 岛屿数量 DFS class Solution { public int numIslands(char[][] grid) { int ans = 0; for (int i = 0; i \u003c grid.length; i++) { for (int j = 0; j \u003c grid[0].length; j++) { if (grid[i][j] == '1') { ans++; dfs(grid, i, j, '1', '2'); } } } return ans; } void dfs(char[][] grid, int x, int y, char v1, char v2) { if (x \u003c 0 || x \u003e= grid.length || y \u003c 0 || y \u003e= grid[0].length || grid[x][y] != v1) return; grid[x][y] = v2; dfs(grid, x - 1, y, v1, v2); dfs(grid, x, y + 1, v1, v2); dfs(grid, x + 1, y, v1, v2); dfs(grid, x, y - 1, v1, v2); } } BFS class Solution { int m, n; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; int ans = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { ans++; bfs(grid, i, j, '1', '2'); } } } return ans; } void bfs(char[][] grid, in","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#被围绕的区域"},{"categories":["数据结构","图"],"content":" Flood Fill 图像渲染733. 图像渲染 DFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; dfs(image, sr, sc, image[sr][sc], color); return image; } void dfs(int[][] image, int x, int y, int v1, int v2) { if (x \u003c 0 || x \u003e= image.length || y \u003c 0 || y \u003e= image[0].length || image[x][y] != v1) return; image[x][y] = v2; dfs(image, x - 1, y, v1, v2); dfs(image, x, y + 1, v1, v2); dfs(image, x + 1, y, v1, v2); dfs(image, x, y - 1, v1, v2); } } BFS class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if (image[sr][sc] == color) return image; int oldColor = image[sr][sc]; int m = image.length; int n = image[0].length; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; que.offer(sr); que.offer(sc); while (!que.isEmpty()) { int r = que.poll(); int c = que.poll(); image[r][c] = color; for (int[] d : dir) { int rr = r + d[0]; int cc = c + d[1]; if (rr \u003e= 0 \u0026\u0026 rr \u003c m \u0026\u0026 cc \u003e= 0 \u0026\u0026 cc \u003c n \u0026\u0026 image[rr][cc] == oldColor) { que.offer(rr); que.offer(cc); } } } return image; } } 并查集 岛屿数量200. 岛屿数量 DFS class Solution { public int numIslands(char[][] grid) { int ans = 0; for (int i = 0; i \u003c grid.length; i++) { for (int j = 0; j \u003c grid[0].length; j++) { if (grid[i][j] == '1') { ans++; dfs(grid, i, j, '1', '2'); } } } return ans; } void dfs(char[][] grid, int x, int y, char v1, char v2) { if (x \u003c 0 || x \u003e= grid.length || y \u003c 0 || y \u003e= grid[0].length || grid[x][y] != v1) return; grid[x][y] = v2; dfs(grid, x - 1, y, v1, v2); dfs(grid, x, y + 1, v1, v2); dfs(grid, x + 1, y, v1, v2); dfs(grid, x, y - 1, v1, v2); } } BFS class Solution { int m, n; Queue que = new ArrayDeque\u003c\u003e(); int[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public int numIslands(char[][] grid) { m = grid.length; n = grid[0].length; int ans = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { ans++; bfs(grid, i, j, '1', '2'); } } } return ans; } void bfs(char[][] grid, in","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:3","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#岛屿的最大面积"},{"categories":["数据结构","图"],"content":" 最小生成树 连接所有点的最小费用1584. 连接所有点的最小费用 Kruskal class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; Edge[] edges = new Edge[n * (n - 1) / 2]; int k = 0; for (int i = 0; i \u003c n; i++) for (int j = i + 1; j \u003c n; j++) edges[k++] = new Edge(i, j, manhattanDistance(points[i], points[j])); return kruskal(edges, n); } int kruskal(Edge[] edges, int n) { Arrays.sort(edges, (a, b) -\u003e a.w - b.w); UnionFind uf = new UnionFind(n); int sum = 0; // 边权和 int count = 0; // 已选边的数量 for (Edge e : edges) { if (uf.isConnected(e.u, e.v)) continue; uf.union(e.u, e.v); sum += e.w; if (++count == n - 1) break; } return sum; } int manhattanDistance(int[] x, int[] y) { return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); } } class Edge { int u, v, w; // 起点、终点、边权 public Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; } } class UnionFind { private int[] parent; // 指向父结点 private int size; // 连通块的数量 public UnionFind(int n) { parent = new int[n]; for (int i = 0; i \u003c n; i++) parent[i] = i; size = n; } public int find(int i) { // 寻找根结点 if (parent[i] != i) // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } public boolean isConnected(int i, int j) { // 判断是否连通 return find(i) == find(j); } public void union(int i, int j) { // 连通 if (find(i) != find(j)) size--; parent[find(j)] = find(i); // j 加入 i } public int size() { return size; } } Prim class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List\u003cEdge\u003e[] graph = new ArrayList[n]; for (int i = 0; i \u003c n; i++) graph[i] = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c n; i++) { for (int j = i + 1; j \u003c n; j++) { int dis = manhattanDistance(points[i], points[j]); graph[i].add(new Edge(i, j, dis)); graph[j].add(new Edge(j, i, dis)); } } return prim(graph); } int prim(List\u003cEdge\u003e[] graph) { int n = graph.length; boolean[] vis = new boolean[n]; // 顶点是否已选择 int sum = 0; // 最小边权和 int u = 0; // 随机选择一个顶点 int count = 1; // 已选择顶点数量 vis[u] = true; PriorityQueue\u003cEdge\u003e pq = new PriorityQueue\u003c\u003e((a, b) -\u003e a.w - b.w); // 按边权升序 while (count \u003c n)","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:4","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#最小生成树"},{"categories":["数据结构","图"],"content":" 最小生成树 连接所有点的最小费用1584. 连接所有点的最小费用 Kruskal class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; Edge[] edges = new Edge[n * (n - 1) / 2]; int k = 0; for (int i = 0; i \u003c n; i++) for (int j = i + 1; j \u003c n; j++) edges[k++] = new Edge(i, j, manhattanDistance(points[i], points[j])); return kruskal(edges, n); } int kruskal(Edge[] edges, int n) { Arrays.sort(edges, (a, b) -\u003e a.w - b.w); UnionFind uf = new UnionFind(n); int sum = 0; // 边权和 int count = 0; // 已选边的数量 for (Edge e : edges) { if (uf.isConnected(e.u, e.v)) continue; uf.union(e.u, e.v); sum += e.w; if (++count == n - 1) break; } return sum; } int manhattanDistance(int[] x, int[] y) { return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); } } class Edge { int u, v, w; // 起点、终点、边权 public Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; } } class UnionFind { private int[] parent; // 指向父结点 private int size; // 连通块的数量 public UnionFind(int n) { parent = new int[n]; for (int i = 0; i \u003c n; i++) parent[i] = i; size = n; } public int find(int i) { // 寻找根结点 if (parent[i] != i) // 路径压缩 parent[i] = find(parent[i]); return parent[i]; } public boolean isConnected(int i, int j) { // 判断是否连通 return find(i) == find(j); } public void union(int i, int j) { // 连通 if (find(i) != find(j)) size--; parent[find(j)] = find(i); // j 加入 i } public int size() { return size; } } Prim class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; List[] graph = new ArrayList[n]; for (int i = 0; i \u003c n; i++) graph[i] = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c n; i++) { for (int j = i + 1; j \u003c n; j++) { int dis = manhattanDistance(points[i], points[j]); graph[i].add(new Edge(i, j, dis)); graph[j].add(new Edge(j, i, dis)); } } return prim(graph); } int prim(List[] graph) { int n = graph.length; boolean[] vis = new boolean[n]; // 顶点是否已选择 int sum = 0; // 最小边权和 int u = 0; // 随机选择一个顶点 int count = 1; // 已选择顶点数量 vis[u] = true; PriorityQueue pq = new PriorityQueue\u003c\u003e((a, b) -\u003e a.w - b.w); // 按边权升序 while (count \u003c n)","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:4","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#连接所有点的最小费用"},{"categories":["数据结构","图"],"content":" 其他 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:5","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#其他"},{"categories":["数据结构","图"],"content":" 其他 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:5","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#封闭岛屿的数量"},{"categories":["数据结构","图"],"content":" 其他 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:5","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#1020-飞地的数量"},{"categories":["数据结构","图"],"content":" 其他 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:5","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#695-岛屿的最大面积"},{"categories":["数据结构","图"],"content":" 其他 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:5","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#1905-统计子岛屿"},{"categories":["数据结构","图"],"content":" 其他 封闭岛屿的数量将靠边的岛屿变为水，剩下的就是「封闭岛屿」。 void dfs(int[][] grid, int x, int y) { if (x \u003c 0 || x \u003e= m || y \u003c 0 || y \u003e= n || grid[x][y] == 0) { return; } grid[x][y] = 0; // 淹没 for (int i = 0; i \u003c 4; i++) { int nextX = x + dx[i]; int nextY = y + dy[i]; dfs(grid, nextX, nextY); } } 1020. 飞地的数量先把靠边的陆地淹掉，然后去数剩下的陆地数量。 695. 岛屿的最大面积淹没岛屿的同时，记录这个岛屿的面积。 1905. 统计子岛屿岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛。 694. 不同岛屿的数量对于形状相同的岛屿，如果从同一起点出发，dfs 函数遍历的顺序肯定是一样的。 分别用 1, 2, 3, 4 代表上下左右，用 -1, -2, -3, -4 代表上下左右的撤销。 把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:10:5","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#694-不同岛屿的数量"},{"categories":["数据结构","图"],"content":" 参考 《算法（第4版）》 ","date":"2022-06-08","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/:11:0","series":null,"tags":["数据结构","图"],"title":"数据结构-图","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#参考"},{"categories":["算法"],"content":" 1.前置知识","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#1前置知识"},{"categories":["算法"],"content":" 2.基本位运算","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#2基本位运算"},{"categories":["算法"],"content":" 2.1 与 \u0026：同 1 则 1，其余为 0。 // 6 0b0110 // 10 0b1010 // 2 0b0010 (6 \u0026 10) == 2; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:1","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#21-与"},{"categories":["算法"],"content":" 2.2 或 |：同 0 则 0，其余为 1。 // 6 0b0110 // 10 0b1010 // 15 0b1110 (6 | 10) == 14; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:2","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#22-或"},{"categories":["算法"],"content":" 2.3 非 ~：0 和 1 互换。 // 只考虑最后 4 位 // 6 0b0110 // 9 0b1001 (~6 \u0026 ((1 \u003c\u003c 4) - 1)) == 9; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:3","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#23-非"},{"categories":["算法"],"content":" 2.4 异或 ^：同 0 异 1。 // 6 0b0110 // 10 0b1010 // 12 0b1100 (6 ^ 10) == 12; x ^ x == 0; x ^ 0 == x; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:4","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#24-异或"},{"categories":["算法"],"content":" 2.5 左移 1 位 \u003c\u003c：右补 0。 // 6 0b0110 // 12 0b1100 (6 \u003c\u003c 1) == 12; // x *= 2; x \u003c\u003c= 1; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:5","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#25-左移-1-位"},{"categories":["算法"],"content":" 2.6 带符号右移 1 位 \u003e\u003e：正数左补 0，负数左补 1。 // -11 0xfffffff5 // -6 0xfffffffa (-11 \u003e\u003e 1) == -6; // x \u003e 0 \u0026\u0026 x /= 2; x \u003e\u003e= 1; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:6","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#26-带符号右移-1-位"},{"categories":["算法"],"content":" 2.7 无符号右移 1 位 \u003e\u003e\u003e：左补 0。 // -11 0xfffffff5 // 2147483642 0x7ffffffa (-11 \u003e\u003e\u003e 1) == 2147483642; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:7","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#27-无符号右移-1-位"},{"categories":["算法"],"content":" 3.常用操作","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#3常用操作"},{"categories":["算法"],"content":" 3.1 判断奇偶 // 奇数 x % 2 == 1 (x \u0026 1) == 1 // 偶数 x % 2 == 0 (x \u0026 1) == 0 ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:1","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#31-判断奇偶"},{"categories":["算法"],"content":" 3.2 判断是否 2 的次方 // 将最低位 1 置 0 x \u003e 0 \u0026\u0026 (x \u0026 (x - 1)) == 0 // 只保留最低位 1 x \u003e 0 \u0026\u0026 (x \u0026 -x) == x // 是否为因数 x \u003e 0 \u0026\u0026 (1 \u003c\u003c 31) % x == 0 ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:2","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#32-判断是否-2-的次方"},{"categories":["算法"],"content":" 3.3 小写大写转换 // 转大写 (char) (c - 'a' + 'A') c \u0026= 95 // 转小写 (char) (c - 'A' + 'a') c |= 32 // 大/小写互相转换 c ^= 32 ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:3","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#33-小写大写转换"},{"categories":["算法"],"content":" 3.4 交换两个数 // a' == a ^ b // b' == b ^ a' == b ^ a ^ b == a // a' == a' ^ b' == a ^ b ^ a == b a ^= b; b ^= a; a ^= b; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:4","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#34-交换两个数"},{"categories":["算法"],"content":" 3.5 判断符号是否相同 // 0b0... ^ 0b1... == 0b1... // 0b0... ^ 0b0... == 0b0... // 0b1... ^ 0b1... == 0b0... a ^ b \u003e 0; ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:5","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#35-判断符号是否相同"},{"categories":["算法"],"content":" 3.6 将最低位 1 置为 0 // n == 0b...10...0 // n - 1 == 0b...01...1 // n \u0026 (n - 1) == 0b...000000 n \u0026 (n - 1); ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:6","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#36-将最低位-1-置为-0"},{"categories":["算法"],"content":" 3.7 只保留最低位 1 // n == 0b.....10...0 // n - 1 == 0b.....01...1 // n \u0026 (n - 1) == 0b.....000000 // n -= n \u0026 (n - 1) == 0b0...010...0 n -= n \u0026 (n - 1); ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:7","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#37-只保留最低位-1"},{"categories":["算法"],"content":" 3.8 统计 1 的数量 int count = 0; while (n != 0) { count++; n = n \u0026 (n - 1); } ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:8","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#38-统计-1-的数量"},{"categories":["算法"],"content":" 3.9 加 1 // -n == (~n) + 1 // -(~n) == (~(~n)) + 1 // -(~n) == n + 1 n = -(~n); ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:9","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#39-加-1"},{"categories":["算法"],"content":" 3.10 减 1 // -n == (~n) + 1 // -(-n) == (~(-n)) + 1 // n == (~(-n)) + 1 // ~(-n) == n - 1 n = ~(-n); ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:10","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#310-减-1"},{"categories":["算法"],"content":" 4.高级操作","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:0","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#4高级操作"},{"categories":["算法"],"content":" 4.1 逆序 // 12345678 -\u003e 21436587 x = (x \u0026 0x55555555) \u003c\u003c 1 | (x \u003e\u003e\u003e 1) \u0026 0x55555555; // 21436587 -\u003e 43218765 x = (x \u0026 0x33333333) \u003c\u003c 2 | (x \u003e\u003e\u003e 2) \u0026 0x33333333; // 43218765 -\u003e 87654321 x = (x \u0026 0x0f0f0f0f) \u003c\u003c 4 | (x \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f; // 1B 2B 3B 4B -\u003e 4B 3B 2B 1B x = (x \u003c\u003c 24) | ((x \u0026 0xff00) \u003c\u003c 8) | (x \u003e\u003e 8) \u0026 0xff00 | (x \u003e\u003e\u003e 24); ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:1","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#41-逆序"},{"categories":["算法"],"content":" 4.2 获取右侧第 n 位 (x \u003e\u003e n) \u0026 1 ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:2","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#42-获取右侧第-n-位"},{"categories":["算法"],"content":" 4.3 将右侧第 n 位置 1 x | (1 \u003c\u003c n) ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:3","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#43-将右侧第-n-位置-1"},{"categories":["算法"],"content":" 4.4 将右侧第 n 位置 0 x \u0026 (~(1 \u003c\u003c n)) ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:4","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#44-将右侧第-n-位置-0"},{"categories":["算法"],"content":" 4.5 将右侧 n 位置 0 x \u0026 (~0 \u003c\u003c n) ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:5","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#45-将右侧-n-位置-0"},{"categories":["算法"],"content":" 4.6 将右侧 n 位置 1 x | ((1 \u003c\u003c (n + 1)) - 1) ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:6","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#46-将右侧-n-位置-1"},{"categories":["算法"],"content":" 4.7 获取左侧第 n 位 (x \u003e\u003e (32 - n)) \u0026 1 ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:7","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#47-获取左侧第-n-位"},{"categories":["算法"],"content":" 参考 位运算操作常见技巧_阿飞算法的博客-CSDN博客 ","date":"2022-05-14","objectID":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:5:0","series":null,"tags":["位运算","算法"],"title":"算法-位运算","uri":"/posts/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/#参考"},{"categories":null,"content":" 画布 plt.figure( figsize=(10, 8), # 画布大小。（宽，高） dpi=None, # 分辨率。300、600 tight_layout=None, # 紧凑布局。True ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#画布"},{"categories":null,"content":" 网格 plt.grid( visible=None, which='major', axis='both' ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#网格"},{"categories":null,"content":" 边框 获取边框 ax = plt.gca() ax.spines['top'] ax.spines['right'] ax.spines['bottom'] ax.spines['left'] 边框设置 ax.set_facecolor('white') ax.spines['top'].set_color('white') ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#边框"},{"categories":null,"content":" 轴 x轴 plt.xlabel( xlabel, loc='center', # 标签位置。'left'、'center'、'right' ) 刻度 # x轴刻度 plt.xticks( ticks=None, # 刻度。[0, 1, 2] labels=None, # 刻度值。['Jan', 'Feb', 'Mar'] rotation=None, # 旋转。'vertical'、45 ) # y轴刻度 plt.yticks( ticks=None, # 刻度。[0, 1, 2] labels=None, # 刻度值。['Jan', 'Feb', 'Mar'] rotation=None, # 旋转。'vertical'、45 ) 设置y轴刻度的最大/最小值 plt.ylim( bottom=bottom, # 最小值 top=top # 最大值 ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#轴"},{"categories":null,"content":" 其他 紧凑布局 plt.tight_layout() 保存图片 plt.savefig( fname, # 文件路径。image.png dpi='figure', # 图片分辨率。600、300 format=None, # 文件格式。'png'、'pdf'、'svg'、'eps' transparent=False, # 是否透明 ) ","date":"2022-05-13","objectID":"/posts/matplotlib-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Python","Matplotlib"],"title":"Matplotlib 教程","uri":"/posts/matplotlib-%E6%95%99%E7%A8%8B/#其他"},{"categories":["数据库"],"content":"结构化查询语言（Structured Query Language，SQL），读作S-Q-L或者sequel，是用来与数据库通信的语言。 SQL关键字不区分大小写。 ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#"},{"categories":["数据库"],"content":" 一、数据库 显示数据库 SHOW DATABASES; 选择数据库 USE db_name; 创建数据库 CREATE DATABASE db_name; CREATE DATABASE IF NOT EXISTS db_name; 删除数据库 DROP DATABASE db_name; 显示创建数据库的 SQL 语句 SHOW CREATE DATABASE db_name; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#一数据库"},{"categories":["数据库"],"content":" 二、表 显示表 SHOW TABLES; 描述表 DESCRIBE tb_name; SHOW COLUMNS FROM tb_name; 创建表 CREATE TABLE tb_name ( col_1 type_1 cons_1, col_2 type_2 cons_2, cons_3, cons_4 ); -- 使用旧表创建新表 CREATE TABLE tb_new LIKE tb_old; 显示创建表的 SQL 语句 SHOW CREATE TABLE tb_name; 删除表 DROP TABLE tb_name; 修改表名 ALTER TABLE tb_old RENAME TO tb_new; 添加列 ALTER TABLE tb_name ADD COLUMN col_ type_ cons_; 删除列 ALTER TABLE tb_name DROP COLUMN col_; 修改列名 ALTER TABLE tb_name RENAME col_old TO col_new; 添加约束 ALTER TABLE tb_name ADD cons; -- 添加主键 ALTER TABLE tb_name ADD PRIMARY KEY (col_); 删除约束 ALTER TABLE tb_name DROP cons; -- 删除主键 ALTER TABLE tb_name DROP PRIMARY KEY (col_); 创建索引 CREATE INDEX idx_name ON ta_name (col_1, col_2); -- 唯一索引 CREATE UNIQUE INDEX idx_name ON ta_name (col_1, col_2); 删除索引 DROP INDEX idx_name; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#二表"},{"categories":["数据库"],"content":" 三、修改数据 添加 -- 添加多条记录 INSERT INTO tb_name (col_1, col_2) VALUES (val_1_1, val_1_2), (val_2_1, val_2_2); -- 从其他表添加 INSERT INTO tb_name_1 (col_1, col_2) SELECT col_1, col_2 FROM tb_name_2; 删除 -- 删除指定记录 DELETE FROM tb_name WHERE cond_; -- 删除所有记录 DELETE FROM tb_name; TRUNCATE TABLE tb_name; 修改 UPDATE tb_name SET col_1=val_1, col_2=val_2 WHERE cond_; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#三修改数据"},{"categories":["数据库"],"content":" 四、查询","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#四查询"},{"categories":["数据库"],"content":" 4.1 单表查询 条件查询 -- 指定列 SELECT col_1, col_2 FROM tb_name WHERE cond_; -- 所有列 SELECT * FROM tb_name; 去重 SELECT DISTINCT col_ FROM tb_name; 分页：pos从 0 开始。 -- [0, len) SELECT col_ FROM tb_name LIMIT len_; -- [pos, pos + len) SELECT col_ FROM tb_name LIMIT pos_, len_; SELECT col_ FROM tb_name LIMIT len_ OFFSET pos_; 排序 -- 升序，ASC SELECT col_ FROM tb_name ORDER BY col_1; -- 降序 SELECT col_ FROM tb_name ORDER BY col_1 DESC; -- 复杂排序 SELECT col_ FROM tb_name ORDER BY col_1 DESC col_2 ASC; ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#41-单表查询"},{"categories":["数据库"],"content":" 4.2","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#42"},{"categories":["数据库"],"content":" 4.3 多表查询 -- 返回 tb_1 和 tb_2 的交集 SELECT col_ FROM tb_1 INNER JOIN tb_2 ON cond_; -- 返回 tb_1 减去 tb_1 和 tb_2 的交集 SELECT col_ FROM tb_1 LEFT JOIN tb_2 ON cond_; -- 返回 tb_2 减去 tb_1 和 tb_2 的交集 SELECT col_ FROM tb_1 RIGHT JOIN tb_2 ON cond_; -- 返回 tb_1 和 tb_2 的笛卡尔积 SELECT col_ FROM tb_1 CROSS JOIN tb_2 ON cond_; select * from test1; -- +------+------+ -- | r1 | r2 | -- +------+------+ -- | 1 | 1 | -- | 1 | 2 | -- +------+------+ select * from test2; -- +------+------+ -- | r1 | r2 | -- +------+------+ -- | 1 | 2 | -- | 2 | 2 | -- +------+------+ select * from test1, test2; -- +------+------+------+------+ -- | r1 | r2 | r1 | r2 | -- +------+------+------+------+ -- | 1 | 2 | 1 | 2 | -- | 1 | 1 | 1 | 2 | -- | 1 | 2 | 2 | 2 | -- | 1 | 1 | 2 | 2 | -- +------+------+------+------+ select * from test1, test2 where test1.r1 = test2.r1; -- +------+------+------+------+ -- | r1 | r2 | r1 | r2 | -- +------+------+------+------+ -- | 1 | 2 | 1 | 2 | -- | 1 | 1 | 1 | 2 | -- +------+------+------+------+ select * from test1 inner join test2 on test1.r1 = test2.r1; -- +------+------+------+------+ -- | r1 | r2 | r1 | r2 | -- +------+------+------+------+ -- | 1 | 2 | 1 | 2 | -- | 1 | 1 | 1 | 2 | -- +------+------+------+------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#43-多表查询"},{"categories":["数据库"],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between \u003ca\u003e and \u003cb\u003e [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (\u003ca\u003e, \u003cb\u003e, \u003cc\u003e) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select \u003ccolumns\u003e from \u003ctable\u003e where \u003ccolumn\u003e like \u003cpattern\u003e; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select \u003ccolumns\u003e from \u003ctable\u003e where \u003ccolumn\u003e regexp \u003cpattern\u003e; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat(\u003ccolumns\u003e) from \u003ctable\u003e; 计算： select \u003ccolumn1\u003e \u003cop\u003e \u003ccolumn2\u003e as \u003calias\u003e from \u003ctable\u003e; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#五条件"},{"categories":["数据库"],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between and [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (, , ) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select from where like ; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select from where regexp ; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat() from ; 计算： select as from ; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#551-通配符"},{"categories":["数据库"],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between and [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (, , ) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select from where like ; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select from where regexp ; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat() from ; 计算： select as from ; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#552-正则表达式"},{"categories":["数据库"],"content":" 五、条件 操作符 说明 = 等于 \u003c\u003e或!= 不等于 \u003c 小于 \u003c= 小于等于 \u003e 大于 \u003e= 大于等于 between and [a,b] is null 空 逻辑操作符 说明 and 与 or 或 not 非 in (, , ) 等于a或b或c 5.5.1 通配符 %表示任意字符任意次数（不能匹配NULL） _表示单个任意字符 select from where like ; 5.5.2 正则表达式 \\\\两个反斜杠转义字符。 select from where regexp ; 字符类 说明 [:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:upper:] [:print:] [:punct:] [:space:] [:xdigit:] 5.5.3 生成新列 拼接： select concat() from ; 计算： select as from ; 示例 -- demo -- +------+----------+ -- | id | name | -- +------+----------+ -- | 1 | zhangsan | -- | 1 | lisi | -- | 2 | zhangsan | -- | 2 | lisi | -- +------+----------+ select concat(id, ' ', name) as id_name from demo; -- +------------+ -- | id_name | -- +------------+ -- | 1 zhangsan | -- | 1 lisi | -- | 2 zhangsan | -- | 2 lisi | -- +------------+ select id * 2 as id_double from demo; -- +-----------+ -- | id_double | -- +-----------+ -- | 2 | -- | 2 | -- | 4 | -- | 4 | -- +-----------+ ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#553-生成新列"},{"categories":["数据库"],"content":" 六、约束","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#六约束"},{"categories":["数据库"],"content":" 函数流程控制： CASE val WHEN val1 THEN res1 [WHEN val2 THEN res2 ...] [ELSE res] END：switch 语句，无匹配返回 NULL。 CASE WHEN cond1 THEN res1 [WHEN cond2 THEN res2 ...] [ELSE res] END：多重 if 语句，无匹配返回 NULL。 IF(expr1, expr2, expr3)：若 expr1 为真返回 expr2 否则返回 expr3。 IFNULL(expr1, expr2)：若 expr1 为 NULL，则返回 expr2，否则返回 expr1。 NULLIF(expr1, expr2)：若 expr1 = expr2，返回 NULL，否则返回 expr1。 数值： ROUND(x) | ROUND(x, d)：四舍五入，保留 d 位小数，默认取整。 FLOOR(x)：去尾法，取整。 CEILING(x)：进一法，取整。同CEIL。 FORMAT(x, d)：保留 d 位小数，然后转为字符串。 统计量： COUNT(expr) | COUNT(DISTINCT expr)：行数（不包括 NULL），去重后行数（不包括 NULL）。 COUNT(*) | COUNT(1)：行数（包括 NULL）。 SUM(col_name)：求和。 AVG(col_name)：平均值。 MAX(col_name)：最大值。 MIN(col_name)：最小值。 字符串： LENGTH(str)：返回 str 长度。 CHAR_LENGTH(str)：返回非 ASCII 码字符串长度。比如’你好’返回 2。 LEFT(str, n)：返回 str 长度为 n 的前缀子串。 RIGHT(str, n)：返回 str 长度为 n 的后缀子串。 SUBSTRING(str, start)：返回 str 从第 start 个字符开始直到末尾的子串。同SUBSTR。 SUBSTRING(str, start, len)：返回 str 从第 start 个字符开始长度为 len 的子串。同SUBSTR。 CONCAT(s1, s2, ...)：返回拼接后的字符串，不限制参数数量。 CONCAT_WS(c, s1, s2, ...)：用分隔符 c 将字符串拼接起来。 LOWER(str)：转为小写。 UPPER(str)：转为大写。 TRIM(str)：去掉两侧空白字符。 REVERSE(str)：翻转字符串。 日期： DATEDIFF(date1, date2)：返回 date1 减去 date2 的天数。 ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#函数"},{"categories":["数据库"],"content":" 参考 MySQL :: MySQL 8.0 Reference Manual :: 12 Functions and Operators ","date":"2022-04-23","objectID":"/posts/sql-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["数据库","SQL"],"title":"SQL 教程","uri":"/posts/sql-%E6%95%99%E7%A8%8B/#参考"},{"categories":["Java"],"content":" 线程、程序和进程 程序：含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 进程：程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 线程：与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#线程程序和进程"},{"categories":["Java"],"content":" 线程","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#线程"},{"categories":["Java"],"content":" Java 线程的 6 个基本状态Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态： 创建（New）：还未start()的线程。 可运行（Runnable）：调用start()后的线程，可能正在运行，也可能在排队等待时间片。 阻塞（Blocked）：等待获取monitor锁，进入synchronized块或方法。 等待（Waiting）：等待被唤醒，在调用wait()、join()、LockSupport.park()后。 超时等待（Timed Waiting）：等待被唤醒，超时自动唤醒，在调用wait(long)、join(long)、LockSupport.parkNanos(long)、LockSupport.parkUntil(long)后。 终止（Terminated）：执行结束后。 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示： ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:2:1","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#java-线程的-6-个基本状态"},{"categories":["Java"],"content":" Runnable \u0026 Callable 实现Callable接口需要重写call()方法，实现Runnable接口需要重写run()方法。 Callable的任务有返回值，而Runnable的任务无返回值。 call()方法抛出异常，run()方法不抛出。 运行Callable任务可以拿到一个FutureTask对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过FutureTask对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:2:2","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#runnable--callable"},{"categories":["Java"],"content":" 创建线程 继承Thread类，实现run()方法，创建对象。 class Thread1 extends Thread { @Override public void run() { System.out.println(Thread.currentThread().getName()); } } Thread t1 = new Thread1(); t1.setName(\"t1\"); t1.start(); 实现Runnable接口，实现run()方法，传入Runnable对象。 class Thread2 implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()); } } Thread t2 = new Thread(new Thread2(), \"t2\"); t2.start(); // 等价于 Thread t22 = new Thread(() -\u003e { System.out.println(Thread.currentThread().getName()); }, \"t22\"); t22.start(); 实现Callable接口，实现call()方法，使用FutureTask进行包装，支持接收返回值。 class Thread3 implements Callable\u003cString\u003e { @Override public String call() throws Exception { return Thread.currentThread().getName(); } } FutureTask\u003cString\u003e ft = new FutureTask\u003c\u003e(new Thread3()); Thread t3 = new Thread(ft, \"t3\"); t3.start(); try { System.out.println(ft.get()); } catch (Exception e) { e.printStackTrace(); } ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:2:3","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#创建线程"},{"categories":["Java"],"content":" 线程池","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:3:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#线程池"},{"categories":["Java"],"content":" 线程池的优点 线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。 可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:3:1","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#线程池的优点"},{"categories":["Java"],"content":" 创建线程池 ThreadPoolExecutor​(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u003cRunnable\u003e workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：线程池核心线程数量 maximumPoolSize：线程池最大线程数量 keepAliveTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间 unit：存活时间的单位 workQueue：存放任务的队列 threadFactory：线程工厂 handler：超出线程范围和队列容量的任务的处理程序 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:3:2","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#创建线程池"},{"categories":["Java"],"content":" 线程池原理提交一个任务到线程池中，线程池的处理流程如下： 判断线程池里的核心线程是否都在执行任务。 如果核心线程空闲或者还有核心线程没有被创建，则创建一个新的工作线程来执行任务。 如果核心线程都在执行任务，则进入下个流程。 线程池判断工作队列是否已满。 如果工作队列未满，则将新提交的任务存储在这个工作队列里。 如果工作队列已满，则进入下个流程。 判断线程池里的线程是否都处于工作状态。 如果存在空闲线程，则创建一个新的工作线程来执行任务。 如果全部繁忙，则交给饱和策略来处理这个任务。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:3:3","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#线程池原理"},{"categories":["Java"],"content":" 线程池源码分析 ThreadPoolExecutor的execute()方法 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列 int c = ctl.get(); if (workerCountOf(c) \u003c corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // 线程池处于运行状态并且加入队列成功 if (isRunning(c) \u0026\u0026 workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) \u0026\u0026 remove(command)) reject(command); // 线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程） else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 创建线程失败，则采取阻塞处理的方式 else if (!addWorker(command, false)) reject(command); } ThreadPoolExecutor的addWorker()方法 private boolean addWorker(Runnable firstTask, boolean core) { retry: for (int c = ctl.get();;) { // Check if queue empty only if necessary. if (runStateAtLeast(c, SHUTDOWN) \u0026\u0026 (runStateAtLeast(c, STOP) || firstTask != null || workQueue.isEmpty())) return false; for (;;) { if (workerCountOf(c) \u003e= ((core ? corePoolSize : maximumPoolSize) \u0026 COUNT_MASK)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateAtLeast(c, SHUTDOWN)) continue retry; // else CAS failed due to workerCount change; retry inner loop } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int c = ctl.get(); if (isRunning(c) || (runStateLessThan(c, STOP) \u0026\u0026 firstTask == null)) { if (t.getState() != Thread.State.NEW) throw new IllegalThreadStateException(); workers.add(w); workerAdded = true; int s = workers.size(); if (s \u003e largestPoolSize) largestPoolSize = s; } } finally { mainLock.unlock(); } if (workerAdded) { t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; } ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:3:4","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#线程池源码分析"},{"categories":["Java"],"content":" 线程池饱和策略RejectedExecutionHandler 当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。Java 提供了 4 种策略： AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用所在的线程运行任务。 DiscardOldestPolicy：丢弃队列里最早的一个任务，并执行当前任务。 DiscardPolicy：不处理，直接丢弃。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:3:5","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#线程池饱和策略"},{"categories":["Java"],"content":" Executor 框架的两级调度模型在 HotSpot VM 的模型中，Java 线程被一对一映射为本地操作系统线程。Java 线程启动时会创建一个本地操作系统线程，当 Java 线程终止时，对应的操作系统线程也被销毁回收，而操作系统会调度所有线程并将它们分配给可用的 CPU。 在上层，Java 程序会将应用分解为多个任务，然后使用应用级的调度器（Executor）将这些任务映射成固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:3:6","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#executor-框架的两级调度模型"},{"categories":["Java"],"content":" JUC 基础通常所说的并发包（JUC）也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面： 提供了 CountDownLatch、CyclicBarrier、Semaphore 等 ， 比 synchronized 更加高级，可以实现更加丰富的多线程操作的同步结构。 提供了 ConcurrentHashMap、有序的 ConcunrrentSkipListMap，或者通过类似快照机制实现线程安全的动态数组 CopyOnWriteArrayList 等，各种线程安全的容器。 提供了 ArrayBlockingQueue、SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等，各种并发队列实现。 强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:4:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#juc-基础"},{"categories":["Java"],"content":" synchronized","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#synchronized"},{"categories":["Java"],"content":" synchronized 原理synchronized是由 JVM 实现的一种实现互斥同步的一种方式，查看被synchronized修饰过的程序块编译后的字节码，会发现，被synchronized修饰过的程序块，在编译前后被编译器生成了 monitorenter 和 monitorexit 两个字节码指令。 在虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁： 如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 +1；当执行 monitorexit 指令时将锁计数器 -1；当计数器为 0 时，锁就被释放了。 如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 synchronized通过在对象头设置标记，达到了获取锁和释放锁的目的。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:1","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#synchronized-原理"},{"categories":["Java"],"content":" 确定 synchronized 加锁对象“锁”的本质是 monitorenter 和 monitorexit 字节码指令的一个 Reference 类型的参数，即要锁定和解锁的对象。 如果指定了锁对象，即修饰类或代码块，如synchronized(obj)、synchronized(this)，说明加解锁对象为该对象。 如果没有明确指定对象，即修饰方法： 若修饰成员方法，表示此方法对应的对象为锁对象。 若修饰静态方法，表示此方法对应的类对象为锁对象。 当一个对象被锁住时，对象里面所有用synchronized修饰的方法都将产生阻塞，而对象里非synchronized修饰的方法可正常被调用，不受锁影响。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:2","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#确定-synchronized-加锁对象"},{"categories":["Java"],"content":" synchronized 是可重入锁可重入性是锁的一个基本要求，为了解决自己锁死自己的情况。 如下面的代码，一个类中的同步方法调用另一个同步方法，假如synchronized不支持重入，进入method2方法时当前线程获得锁，method2方法里面执行method1时当前线程又要去尝试获取锁，这时如果不支持重入，它就要等锁释放，把自己阻塞，导致自己锁死自己。 class SynchronizedTest { public synchronized void method1() {} public synchronized void method2() { method1(); } } 对synchronized来说，可重入性是显而易见的，在执行 monitorenter 指令时，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁（而不是已拥有了锁则不能继续获取），就把锁的计数器 +1，通过这种方式实现了可重入性。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:3","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#synchronized-是可重入锁"},{"categories":["Java"],"content":" Java 原生锁的优化在 Java 6 之前，Monitor 的实现完全依赖底层操作系统的互斥锁来实现。由于 Java 的线程与操作系统的原生线程有一一对应的关系，如果要将一个线程进行阻塞或唤醒都需要操作系统的协助，需要从用户态切换到内核态来执行，这种切换代价十分昂贵，很耗处理器时间。 现代 JDK 中做了大量的优化。一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等待一段时间（尝试获取锁多次），可能在等待期间其他线程已经释放了锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。 现代 JDK 中还提供了三种不同的 Monitor 实现，也就是三种不同的锁： 偏向锁（Biased Locking） 轻量级锁 重量级锁 当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级、降级。 当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作，在对象头的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。 如果有另一线程试图锁定某个被偏斜过的对象，JVM 就撤销偏向锁，升级到轻量级锁。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:4","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#java-原生锁的优化"},{"categories":["Java"],"content":" synchronized 是非公平锁非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:5","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#synchronized-是非公平锁"},{"categories":["Java"],"content":" 锁消除和锁粗化锁消除：指 JVM 即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除（这些锁很多不是程序员自己加入的）。主要根据逃逸分析。 锁粗化：原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。锁粗化就是增大锁的作用域。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:6","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#锁消除和锁粗化"},{"categories":["Java"],"content":" synchronized 是悲观锁synchronized显然是一个悲观锁，因为它的并发策略是悲观的：不管是否会产生竞争，任何的数据操作都必须要加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。 乐观锁的核心算法是 CAS（Compare and Swap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。 CAS 具有原子性，它的原子性由 CPU 硬件指令实现保证，即使用 JNI 调用native方法调用由 C++ 编写的硬件级别指令，JDK 中提供了Unsafe类执行这些操作。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:7","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#synchronized-是悲观锁"},{"categories":["Java"],"content":" 乐观锁的优点和缺点优点： 避免了悲观锁独占对象的现象，提高了并发性能。 缺点： 乐观锁只能保证一个共享变量的原子操作。如果有多个共享变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。 长时间自旋可能导致开销大。假如 CAS 长时间不成功而一直自旋，会给 CPU 带来很大的开销。 ABA 问题。CAS 的核心思想是通过比对内存值与预期值是否一致而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是 A，后来被改为 B，最后又被改成了 A，则 CAS 认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:5:8","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#乐观锁的优点和缺点"},{"categories":["Java"],"content":" volatile","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#volatile"},{"categories":["Java"],"content":" volatile 作用 volatile在指令之间插入内存屏障+缓存一致性协议，保证按照特定顺序执行和某些变量的可见性。 volatile通过内存屏障通知 CPU 和编译器阻止指令重排优化来维持有序性。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:6:1","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#volatile-作用"},{"categories":["Java"],"content":" Java 内存屏障 LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:6:2","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#java-内存屏障"},{"categories":["Java"],"content":" volatile 语义的内存屏障 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:6:3","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#volatile-语义的内存屏障"},{"categories":["Java"],"content":" 可重入锁 ReentrantLock","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:7:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#可重入锁-reentrantlock"},{"categories":["Java"],"content":" synchronized 和 ReentrantLock 简单对比锁的实现原理基本是为了达到一个目的：让所有的线程都能看到某种标记。 synchronized通过在对象头中设置标记实现了这一目的，是一种 JVM 原生的锁实现方式，而ReentrantLock以及所有的基于Lock接口的实现类，都是通过用一个volatile修饰的int类型变量，并保证每个线程都能拥有对该变量的可见性和修改的原子性，其本质基于 AQS 框架。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:7:1","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#synchronized-和-reentrantlock-简单对比"},{"categories":["Java"],"content":" AQS 框架AQS（Abstract Queued Synchronizer）是一个用来构建锁和同步器的框架，是一个抽象类，各种Lock包中的锁（常用的有ReentrantLock、ReadWriteLock），以及其他如Semaphore、CountDownLatch，甚至是早期的FutureTask等，都是基于 AQS 来构建的。 AQS 定义了一个volatile int state变量，表示同步状态，当线程调用lock()方法时， 如果state==0，说明没有任何线程占有共享资源的锁，可以获得锁并将state=1； 如果state==1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。 AQS 通过内部类 Node 构成的一个双向链表结构的同步队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。 Node 类是对要访问同步代码的线程的封装，用变量volatile int waitStatus表示其状态（五种不同状态：CONDITION是否被阻塞，SIGNAL是否等待唤醒，CANCELLED是否已经被取消、PROPAGATE需要传播信号、0不属于以上四种状态）。 Node 类有两个常量，static final Node SHARED = new Node()和static final Node EXCLUSIVE = null，分别代表共享模式和独占模式。所谓共享模式是一个锁允许多个线程同时操作（信号量Semaphore就基于 AQS 的共享模式实现），独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如ReentranLock）。 AQS 通过内部类 ConditionObject 构建等待队列（可有多个），当 Condition 调用wait()方法后，线程将会加入等待队列中，而当 Condition 调用signal()方法后，线程将从等待队列移到同步队列中进行锁竞争。 AQS 和 Condition 各自维护了不同的队列，在使用 Lock 和 Condition 的时候，其实就是两个队列的互相移动。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:7:2","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#aqs-框架"},{"categories":["Java"],"content":" synchronized 和 ReentrantLock 详细对比ReentrantLock 是 Lock 的实现类，是一个互斥的同步锁。 从功能角度，ReentrantLock 比 synchronized 的同步操作更精细（因为可以像普通对象一样使用），甚至实现 synchronized 没有的高级功能，如： 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用。 带超时的获取锁尝试：在指定的时间范围内获取锁，如果时间到了仍然无法获取则返回。 可以判断是否有线程在排队等待获取锁。 可以响应中断请求：与 synchronized 不同，当获取到锁的线程被中断时，能够响应中断，中断异常将会被抛出，同时锁会被释放。 可以实现公平锁。 从锁释放角度，synchronized 在 JVM 层面上实现，不但可以通过一些监控工具监控 synchronized 的锁定，而且在代码执行出现异常时，JVM 会自动释放锁；但是使用 Lock 则不行，Lock 是通过代码实现的，要保证锁一定会被释放，就必须将 unLock() 放到 finally 中。 从性能角度，synchronized 早期实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大。但是在 Java 6 中对其进行了非常多的改进，在竞争不激烈时，synchronized 的性能要优于 ReetrantLock；在高竞争情况下，synchronized 的性能会下降几十倍，但是 ReetrantLock 的性能能维持常态。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:7:3","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#synchronized-和-reentrantlock-详细对比"},{"categories":["Java"],"content":" ReentrantLock 是可重入锁ReentrantLock 内部自定义了同步器 Sync（Sync 既实现了 AQS，又实现了 AOS，而 AOS 提供了一种互斥锁持有的方式），其实就是加锁的时候通过 CAS 算法，将线程对象放到一个双向链表中，每次获取锁的时候，看下当前维护的那个线程 ID 和当前请求的线程 ID 是否一样，一样就可重入了。 ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:7:4","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#reentrantlock-是可重入锁"},{"categories":["Java"],"content":" ReadWriteLock 和 StampedLock 对比虽然 ReentrantLock 和 synchronized 简单实用，但是行为上有一定局限性，要么不占，要么独占。实际应用场景中，有时候不需要大量竞争的写操作，而是以并发读取为主，为了进一步优化并发操作的粒度，Java 提供了读写锁。 读写锁基于的原理是多个读操作不需要互斥，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对方操作结束，这样就可以自动保证不会读取到有争议的数据。 ReadWriteLock 代表了一对锁，下面是一个基于读写锁实现的数据结构，当数据量较大，并发读多、并发写少的时候，能够比纯同步版本凸显出优势： import java.util.Map; import java.util.TreeMap; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class RWSample { private final Map\u003cString, String\u003e m = new TreeMap\u003c\u003e(); private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); private final Lock r = rwl.readLock(); private final Lock w = rwl.writeLock(); public String get(String key) { r.lock(); System.out.println(\"读锁锁定\"); try { return m.get(key); } finally { r.unlock(); } } public String put(String key, String value) { w.lock(); System.out.println(\"写锁锁定\"); try { return m.put(key, value); } finally { w.unlock(); } } } 读写锁看起来比 synchronized 的粒度似乎细一些，但在实际应用中，其表现也并不尽如人意，主要还是因为相对比较大的开销。所以，JDK 在后期引入了 StampedLock，在提供类似读写锁的同时，还支持优化读模式。优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着修改，然后通过validate方法确认是否进入了写模式，如果没有进入，就成功避免了开销；如果进入，则尝试获取读锁。 import java.util.Map; import java.util.TreeMap; import java.util.concurrent.locks.StampedLock; public class Solution { private final Map\u003cString, String\u003e m = new TreeMap\u003c\u003e(); private final StampedLock sl = new StampedLock(); public String get(String key) { long stamp = sl.tryOptimisticRead(); String value = m.get(key); if (!sl.validate(stamp)) { stamp = sl.readLock(); System.out.println(\"读锁锁定\"); try { value = m.get(key); } finally { sl.unlockRead(stamp); } } return value; } public String put(String key, String value) { long stamp = sl.writeLock(); System.out.println(\"写锁锁定\"); try { return m.put(key, value); } finally { sl.unlockWrite(stamp); } } } ","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:7:5","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#readwritelock-和-stampedlock-对比"},{"categories":["Java"],"content":" AQS","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:8:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#aqs"},{"categories":["Java"],"content":" ThreadLocal 和 InheritableThreadLocal使资源不再共享，每个线程拥有一份拷贝的资源，实现了线程间隔离。 原理： 每个线程内部有threadLocals和inheritableThreadLocals两个属性，这是两个Map。其中threadLocals实现了线程间隔离，inheritableThreadLocals则可以将父线程中threadLocals的内容赋值给子线程，实现了父子线程数据传递。 当添加ThreadLocal属性时，将ThreadLocal对象作为 key，添加到了当前线程的threadLocals中。 当获取ThreadLocal属性时，实际上是从当前线程的threadLocals中获取。 public class ThreadLocal { public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { T result = (T) e.value; return result; } } return setInitialValue(); // null } public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } } public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) { m.remove(this); } } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) { return new ThreadLocalMap(parentMap); // 复制一份 } static class ThreadLocalMap { static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } private static final int INITIAL_CAPACITY = 16; private Entry[] table; // 开放寻址法解决哈希冲突 } } public class InheritableThreadLocal\u003cT\u003e extends ThreadLocal\u003cT\u003e { protected T childValue(T parentValue) { return parentValue; } ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; } void createMap(Thread t, T firstValue) { t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); } } public class Thread implements Runnable { private Thread(..., boolean inheritThreadLocals) { // true Thread parent = currentThread(); if (inheritThreadLocals \u0026\u0026 parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); } ThreadLocal.ThreadLocalMap threadLocal","date":"2022-04-20","objectID":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/:9:0","series":["面试"],"tags":["Java","多线程","JUC"],"title":"Java 多线程面试","uri":"/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/#threadlocal-和-inheritablethreadlocal"},{"categories":["Java"],"content":" JVM 主要组成部分JVM 包含两个子系统和两个组件： 两个子系统 Class loader（类装载）：根据给定的全限定类名（如：java.lang.Object）来装载 class 文件到 Runtime data area 中的method area。 Execution engine（执行引擎）：执行 classes 中的指令。 两个组件 Runtime data area（运行时数据区）：这就是我们常说的 JVM 的内存。 Native Interface（本地接口）：与 Native libraries 交互，是其它编程语言交互的接口。 首先通过编译器（javac）把 Java 代码编译成字节码（.class）。类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内。而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:1:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#jvm-主要组成部分"},{"categories":["Java"],"content":" JVM 运行时数据区JVM 在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， JVM 规范规定的区域分为以下 5 个部分： 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。 Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作 数栈、动态链接、方法出口等信息。 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。 Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享，几乎所有的对象实例都在这里分配内存。 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:2:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#jvm-运行时数据区"},{"categories":["Java"],"content":" 对象创建的主要流程虚拟机遇到一条 new 指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载（ClassLoader）。类加载通过后，接下来分配内存。若 Java 堆中内存是绝对规整的，使用指针碰撞方式分配内存；如果不是规整的，就从空闲列表中分配，叫做空闲列表方式。 划分内存时还需要考虑一个问题——并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。然后内存空间初始化操作，接着是做一些必要的对象设置（元信息、哈希码……），然后执行方法。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:3:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#对象创建的主要流程"},{"categories":["Java"],"content":" 为对象分配内存类加载完成后，接着会在 Java 堆中划分一块内存分配给对象。内存分配根据 Java 堆是否规整，有两种方式： 指针碰撞：如果 Java 堆的内存是规整，即所有用过的内存放在一边，而空闲的内存放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。 空闲列表：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。 选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理的功能决定。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:3:1","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#为对象分配内存"},{"categories":["Java"],"content":" 处理并发安全问题对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）； 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用 TLAB。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:3:2","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#处理并发安全问题"},{"categories":["Java"],"content":" 对象的访问定位Java 程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有句柄和直接指针两种方式。 直接指针：指向对象，代表一个对象在内存中的起始地址。 句柄：可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:4:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#对象的访问定位"},{"categories":["Java"],"content":" 句柄访问Java 堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。 优点：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:4:1","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#句柄访问"},{"categories":["Java"],"content":" 直接指针如果使用直接指针访问，引用中存储的直接就是对象地址，那么 Java 堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。 优点：速度更快，节省了一次指针定位的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 虚拟机中采用的就是这种方式。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:4:2","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#直接指针"},{"categories":["Java"],"content":" 内存溢出内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说， Java 是有 GC 垃圾回收机制的，也就是说，不再被使用的对象，会被 GC 自动回收掉，自动从内存中清除。但是，即使这样，Java 也还是存在着内存泄漏的情况，Java 导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为 长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:5:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#内存溢出"},{"categories":["Java"],"content":" 垃圾回收机制 GC 垃圾回收，顾名思义就是释放垃圾占用的空间，从而提升程序性能，防止内存泄露。当一个对象不再被需要时，该对象就需要被回收并释放空间。 Java 内存运行时数据区域包括程序计数器、虚拟机栈、本地方法栈、堆等区域。其中，程序计数器、虚拟机栈和本地方法栈都是线程私有的，当线程结束时，这些区域的生命周期也结束了，因此不需要过多考虑回收的问题。而堆是虚拟机管理的内存中最大的一块，堆中的内存的分配和回收是动态的，垃圾回收主要关注的是堆空间。 调用垃圾回收器的方法 调用垃圾回收器的方法是gc，该方法在System类和Runtime类中都存在。在Runtime类中，方法gc是实例方法，方法System.gc是调用该方法的一种传统而便捷的方法。在System类中，方法gc是静态方法，该方法会调用Runtime类中的gc方法。其实，java.lang.System.gc等价于java.lang.Runtime.getRuntime.gc的简写，都是调用垃圾回收器。方法gc的作用是提示Java虚拟机进行垃圾回收，该方法由系统自动调用，不需要人为调用。该方法被调用之后，由Java虚拟机决定是立即回收还是延迟回收。 finalize 方法 与垃圾回收有关的另一个方法是finalize方法。该方法在Object类中被定义，在释放对象占用的内存之前会调用该方法。该方法的默认实现不做任何事，如果必要，子类应该重写该方法，一般建议在该方法中释放对象持有的资源。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#垃圾回收机制"},{"categories":["Java"],"content":" 可回收对象判断垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器加 1，引用被释放时计数减 1，当计数器为 0 时就可以被回收。它有一个缺点是不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 在 Java 中，GC Roots 一般包含下面几种对象： 虚拟机栈中引用的对象 本地方法栈中的本地方法引用的对象 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:1","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#可回收对象判断"},{"categories":["Java"],"content":" 四种引用类型引用计数算法和根搜索算法都需要通过判断引用的方式判断对象是否可回收。 在 JDK 1.2 之后，Java 将引用分成四种，按照引用强度从高到低的顺序依次是： 强引用：在程序代码中普遍存在的引用。垃圾回收器永远不会回收被强引用关联的对象。 软引用：还有用但并非必需的对象。只有在系统将要发生内存溢出异常时，被软引用关联的对象才会被回收。在 JDK 1.2 之后，提供了SoftReference类实现软引用。 弱引用：非必需的对象，其强度低于软引用。被弱引用关联的对象只能存活到下一次垃圾回收发生之前，当垃圾回收器工作时，被弱引用关联的对象一定会被回收。在 JDK 1.2 之后，提供了WeakReference类实现弱引用。 虚引用：最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。在 JDK 1.2 之后，提供了PhantomReference类实现虚引用。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:2","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#四种引用类型"},{"categories":["Java"],"content":" 垃圾回收算法 标记-清除算法标记-清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 优点：不需要复制对象进行移动，仅对垃圾对象进行处理。 缺点： 标记和清除的效率都不高。 会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 复制算法复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将存活的对象标记并复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 优点： 标记和复制可以同时进行。 只需移动栈顶指针，按顺序分配内存。 不产生内存碎片。 缺点：内存使用率只有一半。 标记-整理算法标记过程与标记-清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向内存的一端移动，然后清理边界以外的内存。 优点：不产生内存碎片。 缺点：需要复制对象。 分代收集算法分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。 一般把 Java 堆内存空间分为新生代和老年代。 新生代（Young Generation）：新创建的对象都存放在新生代。 新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。 当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。 当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。 新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制 Eden 和 Survivor 的比例。 大对象直接进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。新生代使用的是复制算法，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。 长期存活对象将进入老年代。虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每经过一次 Minor GC 未被回收则年龄加 1，当年龄达到一个阈值（默认 15）就会被晋升到老年代。 动态对象年龄判定。为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor区中相同年龄的所有对象的空间总和大于Survivor区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 老年代（Old Generation）： 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。 一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。 永久代被移除，移入元空间（MetaSpace）。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:3","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#垃圾回收算法"},{"categories":["Java"],"content":" 垃圾回收算法 标记-清除算法标记-清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 优点：不需要复制对象进行移动，仅对垃圾对象进行处理。 缺点： 标记和清除的效率都不高。 会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 复制算法复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将存活的对象标记并复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 优点： 标记和复制可以同时进行。 只需移动栈顶指针，按顺序分配内存。 不产生内存碎片。 缺点：内存使用率只有一半。 标记-整理算法标记过程与标记-清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向内存的一端移动，然后清理边界以外的内存。 优点：不产生内存碎片。 缺点：需要复制对象。 分代收集算法分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。 一般把 Java 堆内存空间分为新生代和老年代。 新生代（Young Generation）：新创建的对象都存放在新生代。 新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。 当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。 当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。 新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制 Eden 和 Survivor 的比例。 大对象直接进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。新生代使用的是复制算法，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。 长期存活对象将进入老年代。虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每经过一次 Minor GC 未被回收则年龄加 1，当年龄达到一个阈值（默认 15）就会被晋升到老年代。 动态对象年龄判定。为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor区中相同年龄的所有对象的空间总和大于Survivor区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 老年代（Old Generation）： 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。 一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。 永久代被移除，移入元空间（MetaSpace）。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:3","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#标记-清除算法"},{"categories":["Java"],"content":" 垃圾回收算法 标记-清除算法标记-清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 优点：不需要复制对象进行移动，仅对垃圾对象进行处理。 缺点： 标记和清除的效率都不高。 会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 复制算法复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将存活的对象标记并复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 优点： 标记和复制可以同时进行。 只需移动栈顶指针，按顺序分配内存。 不产生内存碎片。 缺点：内存使用率只有一半。 标记-整理算法标记过程与标记-清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向内存的一端移动，然后清理边界以外的内存。 优点：不产生内存碎片。 缺点：需要复制对象。 分代收集算法分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。 一般把 Java 堆内存空间分为新生代和老年代。 新生代（Young Generation）：新创建的对象都存放在新生代。 新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。 当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。 当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。 新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制 Eden 和 Survivor 的比例。 大对象直接进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。新生代使用的是复制算法，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。 长期存活对象将进入老年代。虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每经过一次 Minor GC 未被回收则年龄加 1，当年龄达到一个阈值（默认 15）就会被晋升到老年代。 动态对象年龄判定。为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor区中相同年龄的所有对象的空间总和大于Survivor区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 老年代（Old Generation）： 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。 一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。 永久代被移除，移入元空间（MetaSpace）。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:3","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#复制算法"},{"categories":["Java"],"content":" 垃圾回收算法 标记-清除算法标记-清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 优点：不需要复制对象进行移动，仅对垃圾对象进行处理。 缺点： 标记和清除的效率都不高。 会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 复制算法复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将存活的对象标记并复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 优点： 标记和复制可以同时进行。 只需移动栈顶指针，按顺序分配内存。 不产生内存碎片。 缺点：内存使用率只有一半。 标记-整理算法标记过程与标记-清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向内存的一端移动，然后清理边界以外的内存。 优点：不产生内存碎片。 缺点：需要复制对象。 分代收集算法分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。 一般把 Java 堆内存空间分为新生代和老年代。 新生代（Young Generation）：新创建的对象都存放在新生代。 新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。 当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。 当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。 新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制 Eden 和 Survivor 的比例。 大对象直接进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。新生代使用的是复制算法，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。 长期存活对象将进入老年代。虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每经过一次 Minor GC 未被回收则年龄加 1，当年龄达到一个阈值（默认 15）就会被晋升到老年代。 动态对象年龄判定。为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor区中相同年龄的所有对象的空间总和大于Survivor区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 老年代（Old Generation）： 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。 一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。 永久代被移除，移入元空间（MetaSpace）。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:3","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#标记-整理算法"},{"categories":["Java"],"content":" 垃圾回收算法 标记-清除算法标记-清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 优点：不需要复制对象进行移动，仅对垃圾对象进行处理。 缺点： 标记和清除的效率都不高。 会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 复制算法复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将存活的对象标记并复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 优点： 标记和复制可以同时进行。 只需移动栈顶指针，按顺序分配内存。 不产生内存碎片。 缺点：内存使用率只有一半。 标记-整理算法标记过程与标记-清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向内存的一端移动，然后清理边界以外的内存。 优点：不产生内存碎片。 缺点：需要复制对象。 分代收集算法分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。 一般把 Java 堆内存空间分为新生代和老年代。 新生代（Young Generation）：新创建的对象都存放在新生代。 新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。 当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。 当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。 新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制 Eden 和 Survivor 的比例。 大对象直接进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。新生代使用的是复制算法，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。 长期存活对象将进入老年代。虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每经过一次 Minor GC 未被回收则年龄加 1，当年龄达到一个阈值（默认 15）就会被晋升到老年代。 动态对象年龄判定。为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor区中相同年龄的所有对象的空间总和大于Survivor区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 老年代（Old Generation）： 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。 一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。 永久代被移除，移入元空间（MetaSpace）。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:3","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#分代收集算法"},{"categories":["Java"],"content":" GC 的分类 新生代 GC（Minor GC / Scavenge GC）：发生在新生代的垃圾收集动作。因为 Java 对象大多都具有朝生夕灭的特性，因此 Minor GC 非常频繁（不一定等 Eden 区满了才触发），一般回收速度也比较快。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集。 老年代 GC（Major GC / Full GC）：发生在老年代的垃圾回收动作。Major GC 经常会伴随至少一次 Minor GC。由于老年代中的对象生命周期比较长，因此 Major GC 并不频繁，一般都是等待老年代满了后才进行 Full GC，而且其速度一般会比 Minor GC 慢10倍以上。另外，如果分配了 Direct Memory，在老年代中进行 Full GC 时，会顺便清理掉 Direct Memory 中的废弃对象。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”算法或“标记-整理”算法来进行回收。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:4","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#gc-的分类"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#垃圾回收器"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#serial-收集器"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#parnew-收集器"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#parallel-scavenge-收集器"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#serial-old-收集器"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#parallel-old-收集器"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#cms-收集器"},{"categories":["Java"],"content":" 垃圾回收器 Serial 收集器新生代单线程垃圾收集器，标记和清理都是单线程，优点是简单高效；复制算法 ParNew 收集器新生代并行垃圾收集器，是 Serial 的多线程 版本，在多核 CPU 环境下有着比 Serial 更好的表现；复制算法 Parallel Scavenge 收集器新生代并行垃圾收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间 / (用户线程时间 + GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；复制算法 Serial Old 收集器老年代单线程垃圾收集器，Serial 的老年代版本；标记-整理算法 Parallel Old 收集器老年代并行垃圾收集器，吞吐量优先，Parallel Scavenge 的老年代版本；标记-整理算法 CMS 收集器Concurrent Mark-Sweep 老年代并行垃圾收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。标记-清除算法 CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上-XX:+UseConcMarkSweepGC来指定使用 CMS 垃圾回收器。CMS 使用的是标记-清除算法，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 G1 收集器Garbage First Java 堆并行垃圾收集器，G1 收集器是 JDK 1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆（包括新生代和老年代）。标记-整理算法 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:5","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#g1-收集器"},{"categories":["Java"],"content":" Java 内存分配策略对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲（TLAB），将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配（大对象）。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则： 对象优先在 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。 Minor GC：发生在新生代中的 GC，因为 Java 对象大多都是朝生夕死，所以 Minor GC 非常频繁，一般回收速度也非常快； Major GC/Full GC：发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:6:6","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#java-内存分配策略"},{"categories":["Java"],"content":" 类加载机制虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:7:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#类加载机制"},{"categories":["Java"],"content":" JVM 加载 class 文件Java 中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也 是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时 候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。类装载方式，有两种： 隐式装载。程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用 类装载器加载对应的类到 JVM 中。 显式装载。通过Class.forName()等方法，显式加载需要的类。 Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到 JVM 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:7:1","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#jvm-加载-class-文件"},{"categories":["Java"],"content":" 类加载器实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有一下四种类加载器: 启动类加载器(Bootstrap ClassLoader)用来加载 Java 核心类库，无法被 java程序直接引用。 扩展类加载器(extensions class loader): 它用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径 （CLASSPATH ）来加载 Java 类。一般来说，Java 应用的类都是由它来 完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:7:2","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#类加载器"},{"categories":["Java"],"content":" 类装载的执行过程类装载分为以下 5个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 验证：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为 一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:7:3","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#类装载的执行过程"},{"categories":["Java"],"content":" 双亲委派模型在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一 个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:7:4","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#双亲委派模型"},{"categories":["Java"],"content":" 类初始化顺序Java 中的静态变量和静态代码块是在类加载的时候就执行的，实例化对象时，先声明并实例化变量再执行构造函数。如果子类继承父类，则先执行父类的静态变量和静态代码块，再执行子类的静态变量和静态代码块。同样，接着在执行父类和子类非静态代码块和构造函数。 未创建对象（只执行一次） 加载类信息。 父类的静态属性和静态代码块，按顺序执行。 子类的静态属性和静态代码块，按顺序执行。 创建对象（每创建一个对象，执行一次） 父类的非静态属性和构造代码块，按顺序执行。 父类的构造方法。 子类的非静态属性和构造代码块，按顺序执行。 子类的构造方法。 当访问static final修饰的属性时，若属性是常量（基本类型或字符串），则在编译阶段通过常量传播优化，将常量存到调用类的常量池中。所以，访问该属性时直接从常量池中访问，而无需加载对应类。 ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:8:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#类初始化顺序"},{"categories":["Java"],"content":" 参考 Javaer 面试必背系列！超高频八股之三色标记法 - 力扣（LeetCode） ","date":"2022-04-19","objectID":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/:9:0","series":["面试"],"tags":["Java","虚拟机","JVM"],"title":"Java 虚拟机面试","uri":"/posts/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95/#参考"},{"categories":[],"content":"import numpy as np ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 随机种子 np.random.seed(self, seed=None)：固定随机数的输出结果。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#随机种子"},{"categories":[],"content":" 创建数组","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#创建数组"},{"categories":[],"content":" 指定值填充 np.empty(shape, dtype=float, order='C', *, like=None)：返回给定形状和类型的新数组，而无需初始化条目。 np.empty_like(prototype, dtype=None, order='K', subok=True, shape=None)：返回形状和类型与给定数组相同的新数组。 np.eye(N, M=None, k=0, dtype=\u003cclass 'float'\u003e, order='C', *, like=None)：返回单位矩阵。 np.identity(n, dtype=None, *, like=None)：返回单位矩阵。 np.ones(shape, dtype=None, order='C', *, like=None)：返回给定形状和类型的新数组，并用1填充。 np.ones_like(a, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用1填充。 np.zeros(shape, dtype=float, order='C', *, like=None)：返回给定形状和类型的新数组，并用0填充。 np.zeros_like(a, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用0填充。 np.full(shape, fill_value, dtype=None, order='C', *, like=None)：返回给定形状和类型的新数组，并用fill_value填充。 np.full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None)：返回形状与类型与给定数组相同的数组，并用fill_value填充。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#指定值填充"},{"categories":[],"content":" 范围内填充 np.arange([start, ]stop, [step, ]dtype=None, *, like=None)：返回给定间隔内的均匀间隔的值。 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)：返回指定间隔内的等间隔数字。 np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)：返回数以对数刻度均匀分布。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#范围内填充"},{"categories":[],"content":" 随机值填充 np.random.rand(d0, d1, ..., dn)：返回服从[0,1)均匀分布的指定形状的浮点数数组。 np.random.uniform(low=0.0, high=1.0, size=None)：返回服从[low,high)均匀分布的指定形状的浮点数数组。 np.random.randint(low, high=None, size=None, dtype=int)：返回服从[low,high)均匀分布的指定形状的整数数组。 np.random.randn(d0, d1, ..., dn)：返回服从N(0,1)标准正态分布的指定形状的浮点数数组。 np.random.normal(loc=0.0, scale=1.0, size=None)：返回服从N(loc,scale)正态分布的指定形状的浮点数数组。 np.random.choice(a, size=None, replace=True, p=None)：从数组中随机有放回采样若干次。 np.random.permutation(x)：返回随机排列。 ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#随机值填充"},{"categories":[],"content":" 数组操作 ndarray.T：返回转置。 np.transpose(a, axes=None)：返回转置。 np.c_[tup]：左右合并。 np.column_stack(tup)：左右合并。 np.r_[tup]：行合并。 ``：行合并。 ``： ``： ``： ","date":"2021-12-22","objectID":"/posts/numpy-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Numpy 教程","uri":"/posts/numpy-%E6%95%99%E7%A8%8B/#数组操作"},{"categories":["力扣","摩尔投票法"],"content":"题目链接 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:0:0","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#"},{"categories":["力扣","摩尔投票法"],"content":" 摩尔投票法","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:0","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#摩尔投票法"},{"categories":["力扣","摩尔投票法"],"content":" 背景摩尔投票法的核心思想为对拼消耗。首先我们考虑最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数 $\\frac{1}{2}$ 的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。摩尔投票算法的核心思想是基于这个事实： 每次从序列里选择两个不相同的数字删除掉（或称为「抵消」），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个元素。假设我们当前数组中存在次数大于总数一半的元素为 x，数组的总长度为 n，则我们可以把数组分为两部分，一部分为相同的 k 个元素 x，另一部分为 $\\frac{n - k}{2}$ 对个不同的元素配对，此时我们假设还存在另外一个次数大于总数一半的元素 y，则此时 y 应该满足 y $\\gt \\frac{n}{2}$，但是按照我们之前的推理 y 应当满足 y $\\le \\frac{n - k}{2}$，二者自相矛盾。 论文地址：MJRTYA Fast Majority Vote Algorithm ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:1","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#背景"},{"categories":["力扣","摩尔投票法"],"content":" 步骤","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:2","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#步骤"},{"categories":["力扣","摩尔投票法"],"content":" 代码 class Solution { public: vector\u003cint\u003e majorityElement(vector\u003cint\u003e \u0026nums) { // 记录两个元素的值 int value1, value2; // 记录对应元素出现的次数 int count1 = 0, count2 = 0; // 第一次遍历：筛选出现次数最多元素（至少0个，至多2个）或者出现位置偏后的元素，用 value1 和 value2 记录 for (int \u0026v : nums) { if (count1 == 0 \u0026\u0026 count2 == 0 || count1 == 0 \u0026\u0026 v != value2) { value1 = v; count1++; } else if (count2 == 0 \u0026\u0026 v != value1) { value2 = v; count2++; } else if (v == value1) count1++; else if (v == value2) count2++; else { // 三个元素均不相等则消除 count1--; count2--; } } int total_count1 = 0; int total_count2 = 0; // 第二次遍历：记录筛选出的元素的出现次数，用来检验是否满足题意 for (int \u0026v : nums) { if (count1 \u003e 0 \u0026\u0026 v == value1) total_count1++; if (count2 \u003e 0 \u0026\u0026 v == value2) total_count2++; } vector\u003cint\u003e ans; int len = nums.size(); if (total_count1 \u003e len / 3) ans.push_back(value1); if (total_count2 \u003e len / 3) ans.push_back(value2); return ans; } }; ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:3","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#代码"},{"categories":["力扣","摩尔投票法"],"content":" 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/:1:4","series":null,"tags":["力扣","摩尔投票法"],"title":"力扣 0229 求众数II","uri":"/posts/%E5%8A%9B%E6%89%A3-0229-%E6%B1%82%E4%BC%97%E6%95%B0ii/#复杂度分析"},{"categories":["力扣","特殊算法"],"content":"题目链接 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:0:0","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#"},{"categories":["力扣","特殊算法"],"content":" 反对角线查找","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:0","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#反对角线查找"},{"categories":["力扣","特殊算法"],"content":" 步骤沿着反对角线进行查找，可以右上到左下，也可以反过来，以右上到左下为例： 如果当前元素与 target 相等，返回 true； 如果当前元素大于 target，由于每一列的元素都是升序排列的，那么当前元素所在列往下所有元素全都大于 target，因此考虑左侧的元素； 如果当前元素小于 target，由于每一行的元素都是升序排列的，那么当前元素所在行往左所有元素全都小于 target，因此考虑下方的元素。 ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:1","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#步骤"},{"categories":["力扣","特殊算法"],"content":" 代码 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); // 右上角 int x = 0, y = n - 1; while (x \u003c m \u0026\u0026 y \u003e= 0) { if (matrix[x][y] == target) return true; // 先左 else if (matrix[x][y] \u003e target) y--; // 后下 else x++; } return false; } }; ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:2","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#代码"},{"categories":["力扣","特殊算法"],"content":" 复杂度分析 时间复杂度：$O(m + n)$ 空间复杂度：$O(1)$ ","date":"2021-10-25","objectID":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/:1:3","series":null,"tags":["力扣","特殊算法"],"title":"力扣 0240 搜索二维矩阵II","uri":"/posts/%E5%8A%9B%E6%89%A3-0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/#复杂度分析"},{"categories":[],"content":"访问无公网地址的设备，如访问手机、平板、笔记本等。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" ZeroTierZeroTier官网 特点： 免费 多平台 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#zerotier"},{"categories":[],"content":" 使用 在ZeroTier官网创建一个账号。 登录后创建一个网络，得到网络ID。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#使用"},{"categories":[],"content":" 使用 从ZeroTier官网下载并安装适用于您的操作系统的 ZeroTier。 加入网络，填写网络ID。 在ZeroTier中心管理网络，对已加入网络的设备，勾选Auth?，在Managed IPs处会显示 IP，即可用此 IP 访问该设备。 ","date":"2021-10-24","objectID":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"内网穿透教程","uri":"/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%95%99%E7%A8%8B/#使用-1"},{"categories":[],"content":" 一般结构 // 包 package main // 导包 import ( \"fmt\" ) // 常量 const c = \"C\" // 变量 var v int = 5 // 自定义类型 type T struct { } // init() 函数，最先执行 func init() { } // main() 函数，其次执行 func main() { var a int Func1() // ... fmt.Println(a) } // 自定义可导出（公开）函数 func Func1() { //... } // 自定义不可导出（私有）函数 func func2() { } ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#一般结构"},{"categories":[],"content":" 规范 虽然不需要分号作为语句的结束，但实际上这一过程是由编译器自动完成 不存在隐式类型转换，所有类型转换必须显式说明，如a := int(b) 标识符的命名规则遵循骆驼命名法 \\作为多行连接符 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#规范"},{"categories":[],"content":" 注释 // 单行注释 /* 多行注释 */ 可通过godoc来导出注释，显示文档说明。 每一个包应该有相关注释。 在package语句之前的块注释将被默认认为是这个包的文档说明，称为包注释。 一个包可以有多个文件，只需要在其中一个文件中添加包注释。 所有全局的类型、常量、变量、函数和被导出的对象都应有注释。若出现在函数前面，称为文档注释，例如函数Abc()，则注释为// Abc ...。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#注释"},{"categories":[],"content":" 可见性 public：标识符以大写字母开头，如Name。 private：标识符以小写字母开头，如id。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#可见性"},{"categories":[],"content":" 包 import ( fm \"fmt\" // 别名 \"os\" \"./local_pkg\" // 本地包 ) 规范： 导入的包未使用报错。 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#包"},{"categories":[],"content":" 函数 func funcName(p1 int, p2 int) (add int, sub int) { return p1 + p2, p1 - p2 } // 函数很短，也可以放在同一行 func Sum(a, b int) int { return a + b } 规范： main()函数： main()函数是程序第一个执行的函数（如果有init()函数则会先执行init()） main包必须包含main()函数 main()函数既没有参数，也没有返回类型 ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#函数"},{"categories":[],"content":" 类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map\u003cstring, int\u003e或typedef map\u003cstring, int\u003e si; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) 每遇到一次const关键字，iota就重置为0 变量 var a, b int = 1, 2 var ( c int d bool e string ) 变量声明后，自动赋零值 int为0，float为0.0，bool为false，string为\"\"，指针为nil。 内层代码块中可使用与外部代码相同名称的变量，此时外部的同名变量将会暂时隐藏（内层不改变外部变量值） ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#类型"},{"categories":[],"content":" 类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map或typedef map si; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) 每遇到一次const关键字，iota就重置为0 变量 var a, b int = 1, 2 var ( c int d bool e string ) 变量声明后，自动赋零值 int为0，float为0.0，bool为false，string为\"\"，指针为nil。 内层代码块中可使用与外部代码相同名称的变量，此时外部的同名变量将会暂时隐藏（内层不改变外部变量值） ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#常量"},{"categories":[],"content":" 类型 基本类型 int、float、bool、string 复杂类型 struct、array、slice、map、channel、interface 空值：nil 类型别名 type si map[string]int类似#define si map或typedef map si; type ( IZ int FZ float64 STR string ) 常量 const Pi float = 3.14159265358979323846 const ( Unknown = 0 Female = 1 Male = 2 ) 类型包括：bool、int、float、complex、string 类型可省略 任何精度，不会溢出 // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) const ( Open = 1 \u003c\u003c iota // 0001 Close // 0010 Pending // 0100 ) 每遇到一次const关键字，iota就重置为0 变量 var a, b int = 1, 2 var ( c int d bool e string ) 变量声明后，自动赋零值 int为0，float为0.0，bool为false，string为\"\"，指针为nil。 内层代码块中可使用与外部代码相同名称的变量，此时外部的同名变量将会暂时隐藏（内层不改变外部变量值） ","date":"2021-10-11","objectID":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"Go 语言教程","uri":"/posts/go-%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/#变量"},{"categories":[],"content":" 英语 简称 中文 Accuracy 精度 Activation Function 激活函数 Adaptive Boosting AdaBoost AdaBoost Adaptive Gradient Algorithm AdaGrad AdaGrad Adaptive Moment Estimation Algorithm Adam Adam Affinity Matrix 亲和矩阵 Agent 智能体 Alpha-Beta Pruning α-β修剪法 Anomaly Detection 异常检测 Area Under ROC Curve AUC Artificial Intelligence AI 人工智能 Artificial Neural Network ANN 人工神经网络 Attention Mechanism 注意力机制 Autoencoder AE 自编码器 Automatic Differentiation AD 自动微分 Autoregressive AR 自回归 Back Propagation BP 反向传播 Bag of Words BOW 词袋 Bagging 装袋 Bandit 赌博机/老虎机 Baseline 基准 Batch Gradient Descent BGD 批量梯度下降法 Batch Normalization BN 批量规范化 Batch Size 批量大小 Bayes Classifier 贝叶斯分类器 Beam Search 束搜索 Benchmark 基准 Bi-Directional Long-Short Term Memory Bi-LSTM 双向长短期记忆 Bias 偏差/偏置 Bidirectional Recurrent Neural Network Bi-RNN 双向循环神经网络 Bigram 二元语法 Binary Sparse Coding 二值稀疏编码 Boosting Tree 提升树 Bootstrap Sampling 自助采样法 Bootstrapping 自助法/自举法 Bottom-Up 自下而上 Chebyshev Distance 切比雪夫距离 Classification And Regression Tree CART 分类与回归树 Computer Vision CV 计算机视觉 Conditional Random Field CRF 条件随机场 Confidence 置信度 Confusion Matrix 混淆矩阵 Conjugate Gradient 共轭梯度 Consistency Convergence 一致性收敛 Content-Addressable Memory CAM 基于内容寻址的存储 Context-Specific Independences 特定上下文独立 Contextual Bandit 上下文赌博机/上下文老虎机 Contextualized Representation 基于上下文的表示 Contractive Autoencoder 收缩自编码器 Contrastive Divergence 对比散度 Convergence 收敛 Convex Optimization 凸优化 Convex Quadratic Programming 凸二次规划 Convolutional Neural Network CNN 卷积神经网络 Correlation Coefficient 相关系数 Cost Function 代价函数 Covariance 协方差 Credit Assignment Problem CAP 贡献度分配问题 Cross Correlation 互相关 Cross Entropy 交叉熵 Cross Validation 交叉验证 Cross-Entropy Loss Function 交叉熵损失函数 Cumulative Distribution Function CDF 累积分布函数 Curvature 曲率 Curve-Fitting 曲线拟合 Data Mining 数据挖掘 Decision Tree 决策树 Deconvolution 反卷积 Deduction 演绎 Deep Convolutional Generative Adversarial Network DCGAN 深度卷积生成对抗网络 Denoising 去噪 Derivative 导数 Determinant 行列式 Diagonal Matrix 对角矩阵 Dimension Reduction 降维 Discriminative Model 判别式模型 Discriminator 判别器 Distance Measure 距离度量 Diverge 发散 Divergence 散度 Diversi","date":"2021-09-22","objectID":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/:0:0","series":null,"tags":[],"title":"翻译专业术语表","uri":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/#"},{"categories":[],"content":" 参考 Artificial-Intelligence-Terminology-Database ","date":"2021-09-22","objectID":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/:1:0","series":null,"tags":[],"title":"翻译专业术语表","uri":"/posts/%E7%BF%BB%E8%AF%91%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8/#参考"},{"categories":[],"content":"根据模型预测值和真实值的区别来评价模型。 ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#"},{"categories":[],"content":" 1.回归","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#1回归"},{"categories":[],"content":" 1.1 MAE平均绝对误差，MAE，Mean Absolute Error $$ MAE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i| $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:1","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#11-mae"},{"categories":[],"content":" 1.2 MAPE平均绝对百分比误差，MAPE，Mean Absolute Percentage Error $$ MAPE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n\\frac{|y_i-\\hat{y}_i|}{|y_i|} $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:2","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#12-mape"},{"categories":[],"content":" 1.3 MSE均方误差，MSE，Mean Squared Error $$ MSE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i|_2^2 $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:3","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#13-mse"},{"categories":[],"content":" 1.4 RMSE均方根误差，RMSE，Root Mean Squared Error $$ RMSE(y,\\hat{y})=\\sqrt{\\frac{1}{n}\\sum_{i=1}^n|y_i-\\hat{y}_i|_2^2} $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:4","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#14-rmse"},{"categories":[],"content":" 1.5 MSLE均方误差对数，MSLE，Mean Squared Log Error $$ MSLE(y,\\hat{y})=\\frac{1}{n}\\sum_{i=1}^n\\big(\\log{(1+y_i)}-\\log{(1+\\hat{y}_i)}\\big)^2 $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:5","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#15-msle"},{"categories":[],"content":" 1.6 MedAE中位绝对误差，MedAE，Median Absolute Error $$ MedAE(y,\\hat{y})=median(|y_1-\\hat{y}_1|,\\cdots,|y_n-\\hat{y}_n|) $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:6","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#16-medae"},{"categories":[],"content":" 1.7 $R^2$拟合优度/可决系数，$R^2$，R Squared $$ R^2(y,\\hat{y})=1-\\frac{ \\sum_{i=1}^n (y_i-\\hat{y_i})^2 }{ \\sum_{i=1}^n (y_i-\\bar{y})^2 } $$ ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:1:7","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#17-r2"},{"categories":[],"content":" 参考 回归模型的评价指标比较 - 知乎 ","date":"2021-09-01","objectID":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:2:0","series":null,"tags":[],"title":"评价指标","uri":"/posts/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/#参考"},{"categories":[],"content":"设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:0:0","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#"},{"categories":[],"content":" 1.介绍面向对象的特点是: 可维护 可复用 可扩展 灵活性好 设计模式的六大原则： 开闭原则（Open-Closed Principle，OCP）：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。 单一职责原则（Single Responsibility Principle，SRP）：一个类只做一件事，一个类应该只有一个引起它修改的原因。 里氏替换原则（Liskov Substitution Principle，LSP）：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。 依赖倒置原则（Dependence Inversion Principle，DIP）：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。 迪米特法则（Law of Demeter，LoD）：又名“最少知道原则”，一个类不应知道自己操作的类的细节，尽量降低类与类之间的耦合。 接口隔离原则（Interface Segregation Principle，ISP）：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:0","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#1介绍"},{"categories":[],"content":" 2.构建型模式Creational Patterns ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:0","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#2构建型模式"},{"categories":[],"content":" 2.1 工厂模式Factory Pattern 构建对象最常用的方式是 new 一个对象。然而每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。工厂模式便是用于封装对象构建过程的设计模式。 2.1.1 简单工厂模式Simple Factory Pattern 当我们需要创建一个对象时，不直接 new 这个对象，而是通过提供对象信息给对象工厂，然后由工厂提供创建的对象。这样调用者无需关心对象的创建细节，实现了解耦。 用户 class User { public void eat() { FruitFactory fruitFactory = new FruitFactory(); Fruit apple = fruitFactory.create(\"苹果\"); apple.eat(); Fruit pear = fruitFactory.create(\"梨\"); pear.eat(); } } 水果工厂 class FruitFactory { public Fruit create(String type) { switch (type) { case \"苹果\": return new Apple(); case \"梨\": return new Pear(); default: throw new IllegalArgumentException(\"暂时没有这种水果\"); } } } 水果 abstract class Fruit {} class Apple extends Fruit {} class Pear extends Fruit {} 优点： 封装了对象创建细节，调用者无需关心对象的创建细节，实现了解耦。 缺点： 如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因，违背了单一职责原则。 当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，违背了开闭原则。 2.1.2 工厂方法模式Factory Method Pattern 为了解决简单工厂的缺点，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。 用户 class User { public void eat() { Fruit apple = new AppleFactory().create(); apple.eat(); Fruit pear = new PearFactory().create(); pear.eat(); } } 苹果工厂 class AppleFactory { public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory { public Fruit create() { return new Pear(); } } 优点： 封装了对象创建细节。 缺点： 将调用者与创建对象解耦的同时，引入了调用者和对象工厂之间的耦合。 2.1.3 抽象工厂模式Abstract Factory Pattern 定义一个工厂接口，提供创建方法，然后由具体工厂去实现该方法。 用户 class User { public void eat() { FruitFactory fruitFactory = new AppleFactory(); Fruit apple = fruitFactory.create(); apple.eat(); fruitFactory = new PearFactory(); Fruit pear = fruitFactory.create(); pear.eat(); } } 工厂接口 interface FruitFactory { Fruit create(); } 苹果工厂 class AppleFactory implements FruitFactory { @Override public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory implements FruitFactory { @Override public Fruit create() { return new Pear(); } } 优点： 实现调用者与创建对象的解耦，也实现了调用者与具体对象工厂的解耦。 只需少量代码即可无缝切换创建对象的具体工厂类。 缺点： 当需要新增功能时，所有实现了工厂接口的具体工厂都必须实现新增的抽象方法，代码修改量巨大。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:1","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#21-工厂模式"},{"categories":[],"content":" 2.1 工厂模式Factory Pattern 构建对象最常用的方式是 new 一个对象。然而每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。工厂模式便是用于封装对象构建过程的设计模式。 2.1.1 简单工厂模式Simple Factory Pattern 当我们需要创建一个对象时，不直接 new 这个对象，而是通过提供对象信息给对象工厂，然后由工厂提供创建的对象。这样调用者无需关心对象的创建细节，实现了解耦。 用户 class User { public void eat() { FruitFactory fruitFactory = new FruitFactory(); Fruit apple = fruitFactory.create(\"苹果\"); apple.eat(); Fruit pear = fruitFactory.create(\"梨\"); pear.eat(); } } 水果工厂 class FruitFactory { public Fruit create(String type) { switch (type) { case \"苹果\": return new Apple(); case \"梨\": return new Pear(); default: throw new IllegalArgumentException(\"暂时没有这种水果\"); } } } 水果 abstract class Fruit {} class Apple extends Fruit {} class Pear extends Fruit {} 优点： 封装了对象创建细节，调用者无需关心对象的创建细节，实现了解耦。 缺点： 如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因，违背了单一职责原则。 当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，违背了开闭原则。 2.1.2 工厂方法模式Factory Method Pattern 为了解决简单工厂的缺点，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。 用户 class User { public void eat() { Fruit apple = new AppleFactory().create(); apple.eat(); Fruit pear = new PearFactory().create(); pear.eat(); } } 苹果工厂 class AppleFactory { public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory { public Fruit create() { return new Pear(); } } 优点： 封装了对象创建细节。 缺点： 将调用者与创建对象解耦的同时，引入了调用者和对象工厂之间的耦合。 2.1.3 抽象工厂模式Abstract Factory Pattern 定义一个工厂接口，提供创建方法，然后由具体工厂去实现该方法。 用户 class User { public void eat() { FruitFactory fruitFactory = new AppleFactory(); Fruit apple = fruitFactory.create(); apple.eat(); fruitFactory = new PearFactory(); Fruit pear = fruitFactory.create(); pear.eat(); } } 工厂接口 interface FruitFactory { Fruit create(); } 苹果工厂 class AppleFactory implements FruitFactory { @Override public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory implements FruitFactory { @Override public Fruit create() { return new Pear(); } } 优点： 实现调用者与创建对象的解耦，也实现了调用者与具体对象工厂的解耦。 只需少量代码即可无缝切换创建对象的具体工厂类。 缺点： 当需要新增功能时，所有实现了工厂接口的具体工厂都必须实现新增的抽象方法，代码修改量巨大。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:1","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#211-简单工厂模式"},{"categories":[],"content":" 2.1 工厂模式Factory Pattern 构建对象最常用的方式是 new 一个对象。然而每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。工厂模式便是用于封装对象构建过程的设计模式。 2.1.1 简单工厂模式Simple Factory Pattern 当我们需要创建一个对象时，不直接 new 这个对象，而是通过提供对象信息给对象工厂，然后由工厂提供创建的对象。这样调用者无需关心对象的创建细节，实现了解耦。 用户 class User { public void eat() { FruitFactory fruitFactory = new FruitFactory(); Fruit apple = fruitFactory.create(\"苹果\"); apple.eat(); Fruit pear = fruitFactory.create(\"梨\"); pear.eat(); } } 水果工厂 class FruitFactory { public Fruit create(String type) { switch (type) { case \"苹果\": return new Apple(); case \"梨\": return new Pear(); default: throw new IllegalArgumentException(\"暂时没有这种水果\"); } } } 水果 abstract class Fruit {} class Apple extends Fruit {} class Pear extends Fruit {} 优点： 封装了对象创建细节，调用者无需关心对象的创建细节，实现了解耦。 缺点： 如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因，违背了单一职责原则。 当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，违背了开闭原则。 2.1.2 工厂方法模式Factory Method Pattern 为了解决简单工厂的缺点，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。 用户 class User { public void eat() { Fruit apple = new AppleFactory().create(); apple.eat(); Fruit pear = new PearFactory().create(); pear.eat(); } } 苹果工厂 class AppleFactory { public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory { public Fruit create() { return new Pear(); } } 优点： 封装了对象创建细节。 缺点： 将调用者与创建对象解耦的同时，引入了调用者和对象工厂之间的耦合。 2.1.3 抽象工厂模式Abstract Factory Pattern 定义一个工厂接口，提供创建方法，然后由具体工厂去实现该方法。 用户 class User { public void eat() { FruitFactory fruitFactory = new AppleFactory(); Fruit apple = fruitFactory.create(); apple.eat(); fruitFactory = new PearFactory(); Fruit pear = fruitFactory.create(); pear.eat(); } } 工厂接口 interface FruitFactory { Fruit create(); } 苹果工厂 class AppleFactory implements FruitFactory { @Override public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory implements FruitFactory { @Override public Fruit create() { return new Pear(); } } 优点： 实现调用者与创建对象的解耦，也实现了调用者与具体对象工厂的解耦。 只需少量代码即可无缝切换创建对象的具体工厂类。 缺点： 当需要新增功能时，所有实现了工厂接口的具体工厂都必须实现新增的抽象方法，代码修改量巨大。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:1","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#212-工厂方法模式"},{"categories":[],"content":" 2.1 工厂模式Factory Pattern 构建对象最常用的方式是 new 一个对象。然而每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。工厂模式便是用于封装对象构建过程的设计模式。 2.1.1 简单工厂模式Simple Factory Pattern 当我们需要创建一个对象时，不直接 new 这个对象，而是通过提供对象信息给对象工厂，然后由工厂提供创建的对象。这样调用者无需关心对象的创建细节，实现了解耦。 用户 class User { public void eat() { FruitFactory fruitFactory = new FruitFactory(); Fruit apple = fruitFactory.create(\"苹果\"); apple.eat(); Fruit pear = fruitFactory.create(\"梨\"); pear.eat(); } } 水果工厂 class FruitFactory { public Fruit create(String type) { switch (type) { case \"苹果\": return new Apple(); case \"梨\": return new Pear(); default: throw new IllegalArgumentException(\"暂时没有这种水果\"); } } } 水果 abstract class Fruit {} class Apple extends Fruit {} class Pear extends Fruit {} 优点： 封装了对象创建细节，调用者无需关心对象的创建细节，实现了解耦。 缺点： 如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因，违背了单一职责原则。 当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，违背了开闭原则。 2.1.2 工厂方法模式Factory Method Pattern 为了解决简单工厂的缺点，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。 用户 class User { public void eat() { Fruit apple = new AppleFactory().create(); apple.eat(); Fruit pear = new PearFactory().create(); pear.eat(); } } 苹果工厂 class AppleFactory { public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory { public Fruit create() { return new Pear(); } } 优点： 封装了对象创建细节。 缺点： 将调用者与创建对象解耦的同时，引入了调用者和对象工厂之间的耦合。 2.1.3 抽象工厂模式Abstract Factory Pattern 定义一个工厂接口，提供创建方法，然后由具体工厂去实现该方法。 用户 class User { public void eat() { FruitFactory fruitFactory = new AppleFactory(); Fruit apple = fruitFactory.create(); apple.eat(); fruitFactory = new PearFactory(); Fruit pear = fruitFactory.create(); pear.eat(); } } 工厂接口 interface FruitFactory { Fruit create(); } 苹果工厂 class AppleFactory implements FruitFactory { @Override public Fruit create() { return new Apple(); } } 梨工厂 class PearFactory implements FruitFactory { @Override public Fruit create() { return new Pear(); } } 优点： 实现调用者与创建对象的解耦，也实现了调用者与具体对象工厂的解耦。 只需少量代码即可无缝切换创建对象的具体工厂类。 缺点： 当需要新增功能时，所有实现了工厂接口的具体工厂都必须实现新增的抽象方法，代码修改量巨大。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:1","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#213-抽象工厂模式"},{"categories":[],"content":" 2.2 单例模式Singleton Pattern 当一个类全局只需要一个实例时，即可使用单例模式。 不能自行创建，可通过指定方法获取该实例。 优点： 减少内存开销。 避免对资源的多重占用。 优化对共享资源的访问。 缺点： 单例模式一般没有接口，扩展困难。扩展必须修改代码，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 用户使用 Singleton instance = Singleton.getInstance(); 2.2.1 饿汉式实例在声明时便初始化，即使不使用。 class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 2.2.2 懒汉式：静态变量实例在第一次获取时才初始化，减少内存占用和减少类初始化时间。 class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 为什么使用 synchronized ？ 如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁。 为什么使用两次 if 判断？ 如果外面不做空检查，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步方法，这样会严重影响程序的执行效率。所以更好的做法是在同步之前，再加上一层检查。 如果里面不做空检查，可能会有两个线程同时通过了外面的空检查，然后在一个线程 new 出实例后，第二个线程进入锁中又 new 出一个实例，导致创建多个实例。 为什么使用 volatile ？ JVM 底层为了优化程序运行效率，可能会对我们的代码进行指令重排序，在一些特殊情况下会导致出现空指针，为了防止这个问题，更进一步的优化是给 instance 变量加上 volatile 关键字。 instance = new Singleton()实际上执行了三条重要的指令： 分配对象的内存空间。 初始化对象。 将变量 instance 指向刚分配的内存空间。 在这个过程中，如果第二条指令和第三条指令发生了重排序，可能导致 instance 还未初始化时，其他线程提前通过双检锁外层的 null 检查，获取到“不为 null，但还没有执行初始化”的 instance 对象，发生空指针异常。 2.2.3 懒汉式：静态内部类静态内部类实现。内部类会在使用时才被加载，并且 JVM 会保证内部类只会被加载一次。 class Singleton { private static class Inner { public static Singleton instance = new Singleton(); } private Singleton() {} public Singleton getInstance() { return Inner.instance; } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:2","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#22-单例模式"},{"categories":[],"content":" 2.2 单例模式Singleton Pattern 当一个类全局只需要一个实例时，即可使用单例模式。 不能自行创建，可通过指定方法获取该实例。 优点： 减少内存开销。 避免对资源的多重占用。 优化对共享资源的访问。 缺点： 单例模式一般没有接口，扩展困难。扩展必须修改代码，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 用户使用 Singleton instance = Singleton.getInstance(); 2.2.1 饿汉式实例在声明时便初始化，即使不使用。 class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 2.2.2 懒汉式：静态变量实例在第一次获取时才初始化，减少内存占用和减少类初始化时间。 class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 为什么使用 synchronized ？ 如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁。 为什么使用两次 if 判断？ 如果外面不做空检查，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步方法，这样会严重影响程序的执行效率。所以更好的做法是在同步之前，再加上一层检查。 如果里面不做空检查，可能会有两个线程同时通过了外面的空检查，然后在一个线程 new 出实例后，第二个线程进入锁中又 new 出一个实例，导致创建多个实例。 为什么使用 volatile ？ JVM 底层为了优化程序运行效率，可能会对我们的代码进行指令重排序，在一些特殊情况下会导致出现空指针，为了防止这个问题，更进一步的优化是给 instance 变量加上 volatile 关键字。 instance = new Singleton()实际上执行了三条重要的指令： 分配对象的内存空间。 初始化对象。 将变量 instance 指向刚分配的内存空间。 在这个过程中，如果第二条指令和第三条指令发生了重排序，可能导致 instance 还未初始化时，其他线程提前通过双检锁外层的 null 检查，获取到“不为 null，但还没有执行初始化”的 instance 对象，发生空指针异常。 2.2.3 懒汉式：静态内部类静态内部类实现。内部类会在使用时才被加载，并且 JVM 会保证内部类只会被加载一次。 class Singleton { private static class Inner { public static Singleton instance = new Singleton(); } private Singleton() {} public Singleton getInstance() { return Inner.instance; } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:2","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#221-饿汉式"},{"categories":[],"content":" 2.2 单例模式Singleton Pattern 当一个类全局只需要一个实例时，即可使用单例模式。 不能自行创建，可通过指定方法获取该实例。 优点： 减少内存开销。 避免对资源的多重占用。 优化对共享资源的访问。 缺点： 单例模式一般没有接口，扩展困难。扩展必须修改代码，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 用户使用 Singleton instance = Singleton.getInstance(); 2.2.1 饿汉式实例在声明时便初始化，即使不使用。 class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 2.2.2 懒汉式：静态变量实例在第一次获取时才初始化，减少内存占用和减少类初始化时间。 class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 为什么使用 synchronized ？ 如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁。 为什么使用两次 if 判断？ 如果外面不做空检查，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步方法，这样会严重影响程序的执行效率。所以更好的做法是在同步之前，再加上一层检查。 如果里面不做空检查，可能会有两个线程同时通过了外面的空检查，然后在一个线程 new 出实例后，第二个线程进入锁中又 new 出一个实例，导致创建多个实例。 为什么使用 volatile ？ JVM 底层为了优化程序运行效率，可能会对我们的代码进行指令重排序，在一些特殊情况下会导致出现空指针，为了防止这个问题，更进一步的优化是给 instance 变量加上 volatile 关键字。 instance = new Singleton()实际上执行了三条重要的指令： 分配对象的内存空间。 初始化对象。 将变量 instance 指向刚分配的内存空间。 在这个过程中，如果第二条指令和第三条指令发生了重排序，可能导致 instance 还未初始化时，其他线程提前通过双检锁外层的 null 检查，获取到“不为 null，但还没有执行初始化”的 instance 对象，发生空指针异常。 2.2.3 懒汉式：静态内部类静态内部类实现。内部类会在使用时才被加载，并且 JVM 会保证内部类只会被加载一次。 class Singleton { private static class Inner { public static Singleton instance = new Singleton(); } private Singleton() {} public Singleton getInstance() { return Inner.instance; } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:2","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#222-懒汉式静态变量"},{"categories":[],"content":" 2.2 单例模式Singleton Pattern 当一个类全局只需要一个实例时，即可使用单例模式。 不能自行创建，可通过指定方法获取该实例。 优点： 减少内存开销。 避免对资源的多重占用。 优化对共享资源的访问。 缺点： 单例模式一般没有接口，扩展困难。扩展必须修改代码，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 用户使用 Singleton instance = Singleton.getInstance(); 2.2.1 饿汉式实例在声明时便初始化，即使不使用。 class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 2.2.2 懒汉式：静态变量实例在第一次获取时才初始化，减少内存占用和减少类初始化时间。 class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 为什么使用 synchronized ？ 如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁。 为什么使用两次 if 判断？ 如果外面不做空检查，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步方法，这样会严重影响程序的执行效率。所以更好的做法是在同步之前，再加上一层检查。 如果里面不做空检查，可能会有两个线程同时通过了外面的空检查，然后在一个线程 new 出实例后，第二个线程进入锁中又 new 出一个实例，导致创建多个实例。 为什么使用 volatile ？ JVM 底层为了优化程序运行效率，可能会对我们的代码进行指令重排序，在一些特殊情况下会导致出现空指针，为了防止这个问题，更进一步的优化是给 instance 变量加上 volatile 关键字。 instance = new Singleton()实际上执行了三条重要的指令： 分配对象的内存空间。 初始化对象。 将变量 instance 指向刚分配的内存空间。 在这个过程中，如果第二条指令和第三条指令发生了重排序，可能导致 instance 还未初始化时，其他线程提前通过双检锁外层的 null 检查，获取到“不为 null，但还没有执行初始化”的 instance 对象，发生空指针异常。 2.2.3 懒汉式：静态内部类静态内部类实现。内部类会在使用时才被加载，并且 JVM 会保证内部类只会被加载一次。 class Singleton { private static class Inner { public static Singleton instance = new Singleton(); } private Singleton() {} public Singleton getInstance() { return Inner.instance; } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:2","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#223-懒汉式静态内部类"},{"categories":[],"content":" 2.3 建造者模式Builder Pattern 建造者模式用于创建过程稳定，但配置多变的对象。 用户不能通过 new 创建对象，只能通过 Builder 构建。对于必须配置的属性，通过 Builder 的构造方法传入，可选的属性通过 Builder 的链式调用方法传入，如果不配置，将使用默认配置。 使用建造者模式的好处是不用担心忘了指定某个配置，保证了构建过程是稳定的。 用户 class User { public void buyMilkTea() { MilkTea milkTea = new MilkTea().Builder(\"原味奶茶\").build(); MilkTea mongoMilkTea = new MilkTea.Builder(\"杨枝甘露\").size(2).ice(true).build(); } } 对象 class MikeTea { private String type; private int size; private boolean ice; private MikeTea() {} private MikeTea(Builder builder) { type = builder.type; size = builder.size; ice = builder.ice; } public static class Builder { private String type; private int size = 1; private boolean ice = true; public Builder(String type) { this.type = type; } public Builder size(int size) { this.size = size; return this; } public Builder ice(boolean ice) { this.ice = ice; return this; } public MikeTea create() { return new MikeTea(this); } } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:3","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#23-建造者模式"},{"categories":[],"content":" 2.4 原型模式Prototype Pattern 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 简单来说就是深拷贝复制对象。 用户 class User { public void buyMilkTea() throws CloneNotSupportedException { // 两杯一样的 MilkTea milkTea1 = new MilkTea(\"蜂蜜柚子茶\", true); MilkTea milkTea2 = milkTea1.clone(); } } 对象 class MilkTea implements Cloneable { private String type; private boolean ice; public MilkTea(String type, boolean ice) { this.type = type; this.ice = ice; } @Override public MilkTea clone() throws CloneNotSupportedException { return (MilkTea) super.clone(); } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:4","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#24-原型模式"},{"categories":[],"content":" 3.结构型模式Structural Patterns ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:0","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#3结构型模式"},{"categories":[],"content":" 3.1 适配器模式Adapter Pattern 将一个类的接口转换成用户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 适配器模式适用于有相关性但不兼容的结构，源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。 只有在遇到接口无法修改时才应该考虑适配器模式。如果接口可以修改，那么将接口改为一致的方式会让程序结构更加良好。 Lightning class Lightning { public void transmit() { System.out.println(\"正在使用 Lightning 传输数据\"); } } USB-C class USBC { public void transmit() { System.out.println(\"正在使用 USB-C 传输数据\"); } } 电脑 class PC { // 电脑只有 USB-C 接口 public void connect(USBC plug) { plug.transmit(); } } Lightning 转 USB-C 适配器 class LightningToUSBCAdapter extends USBC { private Lightning plug; public LightningToUSBCAdapter(Lightning plug) { this.plug = plug; } @Override public void transmit() { plug.transmit(); } } 用户 class User { public void transmitData() { PC pc = new PC(); pc.connect(new USBC()); pc.connect(new LightningToUSBCAdapter(new Lightning())); } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:1","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#31-适配器模式"},{"categories":[],"content":" 3.2 桥接模式Bridge Pattern 将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。 图形 interface Shape { void draw(); } 矩形 class Rectangle implements Shape { @Override public void draw() { System.out.println(\"画矩形\"); } } 三角形 class Triangle implements Shape { @Override public void draw() { System.out.println(\"画三角形\"); } } 圆形 class Circle implements Shape { @Override public void draw() { System.out.println(\"画圆\"); } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:2","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#32-桥接模式"},{"categories":[],"content":" 3.3 组合模式Composite Pattern 组合模式：又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 组合模式用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。 透明方式：在 Component 中声明所有管理子对象的方法，包括 add 、remove 等，这样继承自 Component 的子类都具备了 add、remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口。 安全方式：在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。 安全方式和透明方式各有好处，在使用组合模式时，需要根据实际情况决定。但大多数使用组合模式的场景都是采用的透明方式，虽然它有点不安全，但是客户端无需做任何判断来区分是叶子结点还是枝节点。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:3","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#33-组合模式"},{"categories":[],"content":" 3.4 装饰模式Decorator Pattern 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。 增强一个类原有的功能。 为一个类添加新的功能。 不会改变原有的类功能。 没有修改原有的功能，只是扩展了新的功能，这种模式在装饰模式中称之为半透明装饰模式。 这个装饰类对客户端来说是可见的、不透明的。而被装饰者可以是实现了指定接口的任意对象，所以被装饰者对客户端是不可见的、透明的。由于一半透明，一半不透明，所以称之为半透明装饰模式。 半透明装饰模式中，我们无法多次装饰。 Java I/O 的设计框架便是使用的装饰者模式。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:4","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#34-装饰模式"},{"categories":[],"content":" 3.5 外观模式Facade Pattern 外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式。 外观模式就是这么简单，它使得两种不同的类不用直接交互，而是通过一个中间件——也就是外观类——间接交互。外观类中只需要暴露简洁的接口，隐藏内部的细节，所以说白了就是封装的思想。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:5","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#35-外观模式"},{"categories":[],"content":" 3.6 享元模式Flyweight Pattern 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。FlyWeightFactory 负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:6","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#36-享元模式"},{"categories":[],"content":" 3.7 代理模式Proxy Pattern 代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 静态代理：包装方法 interface Shape { void draw(String color); void erase(); } class Circle implements Shape { @Override public void draw(String color) { System.out.println(\"画\" + color + \"圆\"); } @Override public void erase() { System.out.println(\"擦除图形\"); } } class CircleProxy implements Shape { private final Circle circle; public CircleProxy(Circle circle) { this.circle = circle; } @Override public void draw(String color) { System.out.println(\"准备作画\"); circle.draw(color); System.out.println(\"结束作画\"); } @Override public void erase() { System.out.println(\"准备擦除\"); circle.erase(); System.out.println(\"擦除完毕\"); } } class User { public void drawing() { Circle circle = new Circle(); circle.draw(\"红色\"); circle.erase(); CircleProxy proxy = new CircleProxy(circle); proxy.draw(\"红色\"); proxy.erase(); } } 动态代理：反射 interface Shape { void draw(String color); void erase(); } class Circle implements Shape { @Override public void draw(String color) { System.out.println(\"画\" + color + \"圆\"); } @Override public void erase() { System.out.println(\"擦除图形\"); } } class CircleProxy implements InvocationHandler { private Circle circle; public Shape getInstance(Circle circle) { this.circle = circle; return (Shape) Proxy.newProxyInstance(circle.getClass().getClassLoader(), circle.getClass().getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; if (method.getName().equals(\"draw\")) { System.out.println(\"开始作画\"); method.invoke(circle, args); System.out.println(\"结束作画\"); } else if (method.getName().equals(\"erase\")) { System.out.println(\"开始擦除\"); method.invoke(circle, args); System.out.println(\"擦除完毕\"); } return result; } } class User { public void drawing() { Circle circle = new Circle(); circle.draw(\"红色\"); circle.erase(); Shape proxy = new CircleProxy().getInstance(circle); proxy.draw(\"红色\"); proxy.erase(); } } ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:7","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#37-代理模式"},{"categories":[],"content":" 4.行为型模式Behavioral Patterns ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:0","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#4行为型模式"},{"categories":[],"content":" 参考 图说设计模式 — Graphic Design Patterns 设计模式 - 菜鸟教程 ","date":"2021-08-22","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:5:0","series":["面试"],"tags":["设计模式"],"title":"设计模式","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#参考"},{"categories":[],"content":"类图是 UML 中面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 1.类图表示classDiagram class Person { -name : String -age : int +getName() String +setName(name : String) void +getAge() int +setAge(age : int) void +work() void } 一个类的 UML 图表示为一个矩形框，分为三层： 类名 粗体居中 若为抽象类，类名和抽象方法用斜体表示 若为接口，类名上加\u003c\u003cinterface\u003e\u003e，一般无属性 属性 可见性 + 属性名 + 类型 方法 可见性 + 方法名 + ( + 参数名 + 参数类型 + ) + 返回类型 可见性： -表示private #表示protected 空表示package/default +表示public ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#1类图表示"},{"categories":[],"content":" 2.关系表示","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#2关系表示"},{"categories":[],"content":" 2.1 泛化（Generalization）classDiagram Person \u003c|-- Student 关系：继承非抽象类 表示：子类指向父类的实线空心三角箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#21-泛化generalization"},{"categories":[],"content":" 2.2 实现（Realize）classDiagram class Vehicle \u003c\u003e Vehicle Vehicle \u003c|.. Car 关系：继承抽象类 表示：子类指向父类的虚线空心三角箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#22-实现realize"},{"categories":[],"content":" 2.3 聚合（Aggregation）classDiagram Car o-- Wheel 关系：成员对象是整体对象的属性，部分可独立存在，且可属于多个整体 表示：部分指向整体的实线空心菱形箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#23-聚合aggregation"},{"categories":[],"content":" 2.4 组合（Composition）classDiagram Face *-- Eye 关系：成员对象是整体对象的属性，整体与部分密不可分 表示：部分指向整体的实线实心菱形箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#24-组合composition"},{"categories":[],"content":" 2.5 关联（Association）classDiagram Class \u003c-- Student 关系：成员对象是整体对象的属性，一般表示一种平等关系 表示：部分指向整体的实线箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#25-关联association"},{"categories":[],"content":" 2.6 依赖（Dependency）classDiagram Car \u003c.. Driver 关系：依赖对象一般作为参数传入另一个对象 表示：对象指向依赖对象的虚线箭头 ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#26-依赖dependency"},{"categories":[],"content":" 参考 看懂UML类图和时序图 — Graphic Design Patterns 30分钟学会UML类图 - 知乎 Class diagrams - Mermaid ","date":"2021-08-22","objectID":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"UML 类图教程","uri":"/posts/uml-%E7%B1%BB%E5%9B%BE%E6%95%99%E7%A8%8B/#参考"},{"categories":null,"content":" 1.数组","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#1数组"},{"categories":null,"content":" 打印数组 import java.utils.Arrays; int[] arr1; System.out.println(Arrays.toString()); int[][] arr2; System.out.println(Arrays.deepToString()); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#打印数组"},{"categories":null,"content":" 类型转换 // int[] 转 List\u003cInteger\u003e // 不可添加、删除、修改 int[] arr; List\u003cInteger\u003e list = List.of(arr); // int[] 转 Integer[] int[] arr; Integer[] arr2 = IntStream.of(arr).boxed() // Integer[] 转 List\u003cInteger\u003e // 不可添加、删除、修改 Integer[] arr; List\u003cInteger\u003e list = List.of(arr); // List\u003cInteger\u003e 转 Integer[] List\u003cInteger\u003e list; int[] arr2 = list.stream().mapToInt().toArray(Integer::new); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#类型转换"},{"categories":null,"content":" 2.Collection","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#2collection"},{"categories":null,"content":" 2.1 方法 int size()：返回容器大小 boolean isEmpty()：容器是否为空 boolean contains(Object element)：是否包含指定元素 boolean add(E element)：添加元素；未添加成功返回 false boolean remove(Object element)：删除指定元素；未删除成功返回 false Iterator\u003cE\u003e iterator()：返回迭代器 boolean containsAll(Collection\u003c?\u003e c)：$A \\supset B$；当前容器是否包含了容器 c 中的所有元素 boolean addAll(Collection\u003c? extends E\u003e c)：$A \\cup B$；添加容器 c 中的所有元素到当前容器 boolean removeAll(Collection\u003c?\u003e c)：$A-B$；从当前容器中删除同时包含于容器 c 中的所有元素 boolean retainAll(Collection\u003c?\u003e c)：$A \\cap B$；从当前容器中删除不包含于容器 c 中的所有元素 void clear()：清空容器 Object[] toArray()：容器转 Object 数组 \u003cT\u003e T[] toArray(T[] a)：容器转数组 `` ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#21-方法"},{"categories":null,"content":" 2.2 遍历（1）聚合操作（Stream + Lambda）：只能访问，不能修改。 myColl.stream() .filter(e -\u003e e.getAttribute() == \"Attribute\") .forEach(e -\u003e System.out.println(e.toString())); myColl.forEach(System.out::println); （2）for-each：只能访问，不能修改。 for (Object o : myColl) { System.out.println(o); } （3）Iterator：可修改。 // 定义 public interface Iterator\u003cE\u003e { boolean hasNext(); // 是否存在下个元素 E next(); // 迭代器后移，同时返回下个元素 void remove(); // 删除当前元素 } for (Iterator\u003cE\u003e it = myColl.iterator(); it.hasNext();) { System.out.println(it.next()); } for (Iterator\u003cE\u003e it = myColl.iterator(); it.hasNext();) { E e = it.next(); if (judge(e)) { it.remove(); } } （4）for：可修改。 for (int i = 0; i \u003c myColl.size(); i++) { System.out.println(myColl.get(i)); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#22-遍历"},{"categories":null,"content":" List import java.util.List; ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator\u003cInteger\u003e it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List\u003cInteger\u003e list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List\u003cInteger\u003e list4 = List.of(1, 2, 3); // 初始化5，推荐 List\u003cInteger\u003e list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List\u003cInteger\u003e list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet\u003cInteger\u003e deDuplicator = new LinkedHashSet\u003c\u003e(list1); List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List\u003cInteger\u003e list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List\u003cInteger\u003e list4 = new ArrayList\u003c\u003e(); HashSet\u003cInteger\u003e hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { // AbstractList\u003cE\u003e protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#arraylist"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#api"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#初始化"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#去重"},{"categories":null,"content":" ArrayList import java.util.ArrayList; API构造函数 ArrayList() ArrayList(int initialCapacity) ArrayList(Collection\u003c? extends E\u003e c) 增 void add(int index, E element) boolean add(E e) boolean addAll(int index, Collection\u003c? extends E\u003e c) boolean addAll(Collection\u003c? extends E\u003e c) 删 E remove(int index) boolean remove(Object o)：删除第一个出现的 boolean removeAll(Collection\u003c?\u003e c) void clear() for (int i = 0; i \u003c list.size(); i++) { if (list.get(i) == target) { list.remove(i); i--; // 集合删除元素后，后面元素整体前移一位。 } } for (Iterator it = list.iterator(); it.hasNext();) { int val = it.next(); if (val == target) { it.remove(); } } 改 E set(int index, E element) 查 E get(int index) boolean contains(Object o) 大小 int size() boolean isEmpty() 初始化 // 初始化1 List list1 = new ArrayList\u003c\u003e(); list1.add(1); // 初始化2，推荐 List list2 = new ArrayList\u003c\u003e() {{ add(1); }}; // 初始化3，不能修改 List list3 = Arrays.asList(1, 2, 3); // 初始化4，不能修改 List list4 = List.of(1, 2, 3); // 初始化5，推荐 List list5 = Stream.of(1, 2, 3).collect(Collectors.toList()); // 初始化6，推荐 List list6 = new ArrayList\u003c\u003e(List.of(1, 2, 3)); 去重 List list1 = new ArrayList\u003c\u003e(List.of(1, 2, 2, 3, 2)); // 去重1 LinkedHashSet deDuplicator = new LinkedHashSet\u003c\u003e(list1); List list2 = new ArrayList\u003c\u003e(deDuplicator); // 去重2 List list3 = list1.stream().distinct().collect(Collectors.toList()); // 去重3 List list4 = new ArrayList\u003c\u003e(); HashSet hashset = new HashSet\u003c\u003e(); for (int x : list1) { if (hashset.add(x)) { list4.add(x); } } 源码 源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { // AbstractList protected transient int modCount = 0; // 默认容量 private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#源码"},{"categories":null,"content":" LinkedList import java.util.LinkedList; API构造方法 增 // 尾部添加 boolean add​(E e) // 一般 List 使用 boolean offer​(E e) // 一般 Queue 使用 void addLast​(E e) // 一般 LinkedList 使用 boolean offerLast​(E e) // 一般 Deque 使用 // 首部添加 void addFirst​(E e) // 一般 LinkedList 使用 boolean offerFirst​(E e) // 一般 Deque 使用 void push​(E e) // 一般 栈 使用 // 指定位置添加 void add​(int index, E element) // 添加集合 boolean addAll​(Collection\u003c? extends E\u003e c) boolean addAll​(int index, Collection\u003c? extends E\u003e c) 删 // 尾部删除 E removeLast() // 一般 LinkedList 使用 E pollLast() // 一般 Deque 使用 // 首部删除 E remove() // 一般 List 使用 E poll() // 一般 Queue 使用 E removeFirst() // 一般 LinkedList 使用 E pollFirst() // 一般 Deque 使用 E pop() // 一般 栈 使用 // 指定位置删除 E remove​(int index) // 指定元素删除 boolean remove​(Object o) boolean removeFirstOccurrence​(Object o) boolean removeLastOccurrence​(Object o) // 清空 void clear() 改 E set​(int index, E element) 查 // 尾部 E getLast() // 一般 List 使用 E peekLast() // 一般 List 使用 // 指定位置 E get​(int index) // 首部 E getFirst() // 一般 List 使用 E peekFirst() // 一般 List 使用 E peek() // 一般 Queue 使用 boolean contains​(Object o) int indexOf​(Object o) int lastIndexOf​(Object o) 其他 ListIterator\u003cE\u003e listIterator​(int index) Iterator\u003cE\u003e descendingIterator() ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#linkedlist"},{"categories":null,"content":" LinkedList import java.util.LinkedList; API构造方法 增 // 尾部添加 boolean add​(E e) // 一般 List 使用 boolean offer​(E e) // 一般 Queue 使用 void addLast​(E e) // 一般 LinkedList 使用 boolean offerLast​(E e) // 一般 Deque 使用 // 首部添加 void addFirst​(E e) // 一般 LinkedList 使用 boolean offerFirst​(E e) // 一般 Deque 使用 void push​(E e) // 一般 栈 使用 // 指定位置添加 void add​(int index, E element) // 添加集合 boolean addAll​(Collection\u003c? extends E\u003e c) boolean addAll​(int index, Collection\u003c? extends E\u003e c) 删 // 尾部删除 E removeLast() // 一般 LinkedList 使用 E pollLast() // 一般 Deque 使用 // 首部删除 E remove() // 一般 List 使用 E poll() // 一般 Queue 使用 E removeFirst() // 一般 LinkedList 使用 E pollFirst() // 一般 Deque 使用 E pop() // 一般 栈 使用 // 指定位置删除 E remove​(int index) // 指定元素删除 boolean remove​(Object o) boolean removeFirstOccurrence​(Object o) boolean removeLastOccurrence​(Object o) // 清空 void clear() 改 E set​(int index, E element) 查 // 尾部 E getLast() // 一般 List 使用 E peekLast() // 一般 List 使用 // 指定位置 E get​(int index) // 首部 E getFirst() // 一般 List 使用 E peekFirst() // 一般 List 使用 E peek() // 一般 Queue 使用 boolean contains​(Object o) int indexOf​(Object o) int lastIndexOf​(Object o) 其他 ListIterator listIterator​(int index) Iterator descendingIterator() ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#api-1"},{"categories":null,"content":" 4.4 遍历ListIterator：可修改，双向迭代。 // 列表迭代器定义 public interface ListIterator\u003cE\u003e extends Iterator\u003cE\u003e { boolean hasNext(); E next(); int nextIndex(); // 返回下个元素下标 boolean hasPrevious(); E previous(); int previousIndex(); void remove(); void set(E e); // 修改当前迭代器指向元素 void add(E e); // 添加到当前迭代器指向元素之前（next 之前，previous 之后），能被 } 迭代器总是位于元素之间，它并不指向某个元素，而是指向元素之间的间隔。 所以，listIterator(int index)可以接受的参数范围为[0, myList.size()] listIterator()返回的迭代器初始位于第一个元素之前。 listIterator()返回的迭代器初始位于第一个元素之前。 // 正向 for (ListIterator\u003cE\u003e it = myList.listIterator(); it.hasNext();) { E e = it.next(); } // 逆向 for (ListIterator\u003cE\u003e it = myList.listIterator(myList.size()); it.hasPrevious();) { E e = it.previous(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#44-遍历"},{"categories":null,"content":" List 和数组转换 List 转数组 List\u003cInteger\u003e list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List\u003cInteger\u003e list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list-和数组转换"},{"categories":null,"content":" List 和数组转换 List 转数组 List list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#list-转数组"},{"categories":null,"content":" List 和数组转换 List 转数组 List list = List.of(1, 2, 3); // 方法1 Integer[] array1 = list.toArray(new Integer[0]); // 方法2 Integer[] array2 = list.toArray(Integer[]::new); // 不能转为 int[] 数组转 List // int[] 不能转换 Integer[] array = { 1, 2, 3 }; List list = List.of(array); // 转换后的 list 只读，不能增删或修改 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#数组转-list"},{"categories":null,"content":" Queue // 定义 Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); // 向队尾添加元素 queue.offer(1); // 删除队首元素并返回 int first1 = queue.poll(); // 取队首元素 int first2 = queue.peek(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#queue"},{"categories":null,"content":" Deque // 定义 Deque\u003cInteger\u003e deque = new LinkedList\u003c\u003e(); // 队尾添加 deque.offerLast(1); // 队首添加 deque.offerFirst(1); // 队尾删除并返回 int last1 = deque.pollLast(); // 队首删除并返回 int first1 = deque.pollFirst(); // 取队尾元素 int last2 = deque.peekLast(); // 取队首元素 int first2 = deque.peekFirst(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#deque"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue\u003cInteger\u003e q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue\u003cInteger\u003e q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable\u003cA\u003e { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator\u003cA\u003e { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue\u003cStu\u003e q1 = new PriorityQueue\u003c\u003e(new StuComp\u003cStu\u003e()); // 显式定义排序类 class StuComp implements Comparator\u003cStu\u003e { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue\u003cStu\u003e q1 = new PriorityQueue\u003c\u003e(new Comparator\u003cStu\u003e() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator\u003cStu\u003e { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#priorityqueue"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#基本用法"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#自定义类"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#模板"},{"categories":null,"content":" PriorityQueue优先队列，使用堆实现。 基本用法 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; // 默认最小堆，元素值小的优先 Queue q = new PriorityQueue\u003c\u003e(); // 自定义最大堆，元素值大的优先 Queue q1 = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); q.offer(1); int top = q.peek(); while (!q.isEmpty()) { int x = q.poll(); } q.clear(); q.size(); 自定义类 // 自定义类 class Stu { String name; int score; } 模板 class A implements Comparable { @Override public int compareTo(A a) { // ... } } import java.util.Comparator; class A implements Comparator { @Override public int compare(A a, A b) { // ... } } 具体实现 import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; 方法1 // 定义1 Queue q1 = new PriorityQueue\u003c\u003e(new StuComp()); // 显式定义排序类 class StuComp implements Comparator { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } 方法2 // 定义2: 匿名类隐式定义排序类 Queue q1 = new PriorityQueue\u003c\u003e(new Comparator() { @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } }); 方法3 // 定义3: 修改类定义 class Stu implements Comparator { String name; int score; @Override public int compare(Stu s1, Stu s2) { if (s1.score != s2.score) { // 成绩高的优先 return s2.score - s1.score; } else { // 再按名字字母排序 return s1.name.compareTo(s2.name); } } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#具体实现"},{"categories":null,"content":" Set","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#set"},{"categories":null,"content":" HashSet 元素唯一，不可重复 元素乱序 数组+哈希函数实现，性能最优 import java.util.HashSet; HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(1); set.contains(1); set.remove(1); set.clear(); set.size(); set.isEmpty(); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#hashset"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); TreeSet\u003cInteger\u003e set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set\u003cInteger\u003e set1 = set.subSet(1, 2); // [1] Set\u003cInteger\u003e set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set\u003cInteger\u003e set3 = set.tailSet(2); // [1] Set\u003cInteger\u003e set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set\u003cInteger\u003e set3 = set.tailSet(2); // [2, 3] Set\u003cInteger\u003e set4 = set.tailSet(2, false); // [3] // 逆序 Set\u003cInteger\u003e set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator\u003cInteger\u003e it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator\u003cInteger\u003e it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#treeset"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#增"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#查"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#删"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#子集"},{"categories":null,"content":" TreeSet 元素唯一，不可重复 元素有序（默认升序） 红黑树实现，性能最差 import java.util.TreeSet; TreeSet set = new TreeSet\u003c\u003e(); TreeSet set2 = new TreeSet\u003c\u003e(); set2.addAll(Set.of(1, 3, 5)); 增 set.add(1); // [1] set.addAll(set2); // [1, 3, 5] 查 set.contains(1); // true set.first(); // 1 set.last(); // 5 // 第一个大于等于指定值的元素，不存在返回 null Integer a1 = set.ceiling(0); // 1 Integer a2 = set.ceiling(1); // 1 Integer a3 = set.ceiling(4); // 5 Integer a4 = set.ceiling(7); // null // 第一个大于指定值的元素，不存在返回 null Integer a5 = set.higher(0); // 1 Integer a6 = set.higher(1); // 3 Integer a7 = set.higher(4); // 5 Integer a8 = set.higher(7); // null // 第一个小于等于指定值的元素，不存在返回 null Integer a9 = set.floor(0); // null Integer a10 = set.floor(1); // 1 Integer a11 = set.floor(4); // 3 Integer a12 = set.floor(7); // 5 // 第一个小于指定值的元素，不存在返回 null Integer a13 = set.lower(0); // null Integer a14 = set.lower(1); // null Integer a15 = set.lower(4); // 3 Integer a16 = set.lower(7); // 5 删 set.pollFirst(); // 1 set.pollLast(); // 5 set.remove(3); // true set.remove(4); // false set.clear(); set.size(); set.isEmpty(); 子集 TreeSet set = new TreeSet\u003c\u003e(); set.addAll(Set.of(1, 2, 3)); // [1, 2, 3] // 范围子集 Set set1 = set.subSet(1, 2); // [1] Set set2 = set.subSet(1, false, 2, true); // [2] // 首部子集 Set set3 = set.tailSet(2); // [1] Set set4 = set.tailSet(2, true); // [1, 2] // 尾部子集 Set set3 = set.tailSet(2); // [2, 3] Set set4 = set.tailSet(2, false); // [3] // 逆序 Set set7 = set.descendingSet(); // [3, 2, 1] 遍历 // foreach for (int x : set) { // } // foreach 逆序 for (int x : set.descendingSet()) { // } // iterator for (Iterator it = set.iterator(); it.hasNext();) { it.next(); } // iterator 逆序 for (Iterator it = set.descendingIterator(); it.hasNext();) { it.next(); } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#遍历"},{"categories":null,"content":" Map ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#map"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); Map\u003cString, Integer\u003e otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry\u003cString, Integer\u003e ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#hashmap"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#增改"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#查-1"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#删-1"},{"categories":null,"content":" HashMap 无序键值对，键不重复。 import java.util.HashMap; import java.util.Map; // 定义 Map map = new HashMap\u003c\u003e(); Map otherMap = new HashMap\u003c\u003e(); 增/改 // 添加元素，始终覆盖原值 map.put(\"Alice\", 80); // 存在返回原值，否则添加该元素，返回 null map.putIfAbsent(\"Alice\", 60); // 80 // 添加所有元素，始终覆盖原值 map.putAll(otherMap); // 自增 map[key]++ map.put(\"Alice\", map.getOrDefault(\"Alice\", 0) + 1); // 81 查 // 根据键查询值，不存在返回 null map.get(\"Alice\"); // 81 // 存在返回原值，否则返回指定值 map.getOrDefault(\"Bob\", 0); // 存在返回原值，否则添加该元素，并返回新值 map.computeIfAbsent(\"Alice\", key -\u003e 90); // 81 map.computeIfAbsent(\"Bob\", key -\u003e 90); // 90 // 修改已存在的值，并返回新值 map.computeIfPresent(\"Alice\", (key, value) -\u003e value + 10); // 91 // 查询键 map.containsKey(\"Bob\"); // true 删 // 删除 map.remove(\"Alice\"); // 清空 map.clear(); // 是否为空 map.isEmpty(); // 大小 map.size(); 遍历 // 遍历1 for (String key : map.keySet()) { int value = map.get(key); } // 遍历2 for (Map.Entry ent : map.entrySet()) { String key = ent.getKey(); int value = ent.getValue(); } // 只遍历 value for (int value : map.values()) { } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#遍历-1"},{"categories":null,"content":" TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable\u003cStu\u003e { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) \u003c 0 等价于 x \u003c y if (score != s.score) { return s.score - score; } else { return name.compareTo(s.name); } } } Map\u003cStu, Integer\u003e map = new TreeMap\u003c\u003e(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Map\u003cStu, Integer\u003e map1 = new TreeMap\u003c\u003e(new Comparator\u003cStu\u003e() { @Override public int compare(Stu a, Stu b) { // compare(x, y) \u003c 0 等价于 x \u003c y if (a.score != b.score) { return b.score - a.score; } else { return a.name.compareTo(b.name); } } }); // 实现2 lambda 表达式 Comparator\u003cStu\u003e cmp = (Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Map\u003cStu, Integer\u003e map2 = new TreeMap\u003c\u003e(cmp); // 实现3 lambda 表达式 Map\u003cStu, Integer\u003e map3 = new TreeMap\u003c\u003e((Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name)); // 实现4 Comparator 类方法 Map\u003cStu, Integer\u003e map4 = new TreeMap\u003c\u003e(Comparator.comparing(Stu::getScore).reversed().thenComparing(Stu::getName)); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#treemap"},{"categories":null,"content":" TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) \u003c 0 等价于 x \u003c y if (score != s.score) { return s.score - score; } else { return name.compareTo(s.name); } } } Map map = new TreeMap\u003c\u003e(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Map map1 = new TreeMap\u003c\u003e(new Comparator() { @Override public int compare(Stu a, Stu b) { // compare(x, y) \u003c 0 等价于 x \u003c y if (a.score != b.score) { return b.score - a.score; } else { return a.name.compareTo(b.name); } } }); // 实现2 lambda 表达式 Comparator cmp = (Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Map map2 = new TreeMap\u003c\u003e(cmp); // 实现3 lambda 表达式 Map map3 = new TreeMap\u003c\u003e((Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name)); // 实现4 Comparator 类方法 Map map4 = new TreeMap\u003c\u003e(Comparator.comparing(Stu::getScore).reversed().thenComparing(Stu::getName)); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#类实现-comparable-接口"},{"categories":null,"content":" TreeMap 有序键值对，键不重复。 放入的 Key 必须实现Comparable接口。 import java.util.Map; import java.util.TreeMap; 类实现 Comparable 接口 class Stu implements Comparable { String name; int score; @Override public int compareTo(Stu s) { // x.compareTo(y) \u003c 0 等价于 x \u003c y if (score != s.score) { return s.score - score; } else { return name.compareTo(s.name); } } } Map map = new TreeMap\u003c\u003e(); 自定义 Comparator 比较器 import java.util.Comparator; class Stu { String name; int score; String getName() { return name; } int getScore() { return score; } } // 实现1 匿名类 Map map1 = new TreeMap\u003c\u003e(new Comparator() { @Override public int compare(Stu a, Stu b) { // compare(x, y) \u003c 0 等价于 x \u003c y if (a.score != b.score) { return b.score - a.score; } else { return a.name.compareTo(b.name); } } }); // 实现2 lambda 表达式 Comparator cmp = (Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); Map map2 = new TreeMap\u003c\u003e(cmp); // 实现3 lambda 表达式 Map map3 = new TreeMap\u003c\u003e((Stu a, Stu b) -\u003e a.score != b.score ? b.score - a.score : a.name.compareTo(b.name)); // 实现4 Comparator 类方法 Map map4 = new TreeMap\u003c\u003e(Comparator.comparing(Stu::getScore).reversed().thenComparing(Stu::getName)); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#自定义-comparator-比较器"},{"categories":null,"content":" Arrays import java.util.Arrays; ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#arrays"},{"categories":null,"content":" 二分查找查找指定值，返回下标，若未找到则返回应该插入的下标的相反数减一。需要数组升序且元素无重复。 static \u003cT\u003e int binarySearch(T[] a, T key) static \u003cT\u003e int binarySearch(T[] a, int fromIndex, int toIndex, T key) static \u003cT\u003e int binarySearch​(T[] a, T key, Comparator\u003c? super T\u003e c) static \u003cT\u003e int binarySearch​(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c) int[] arr = {1, 3, 5}; Arrays.binarySearch(arr, -1); // -1 Arrays.binarySearch(arr, 0); // -1 Arrays.binarySearch(arr, 1); // 0 Arrays.binarySearch(arr, 2); // -2 Arrays.binarySearch(arr, -4); // -1 Arrays.binarySearch(arr, 8); // -4 ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#二分查找"},{"categories":null,"content":" 比较a 小于 b 返回 -1，等于返回 0，大于返回 1。 static \u003cT\u003e int compare(T[] a, T[] b) static \u003cT\u003e int compare​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e int compare​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e int compare​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) 相等 true，不相等 false。 static \u003cT\u003e boolean equals​(T[] a, T[] b) static \u003cT\u003e boolean equals​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e boolean equals​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e boolean equals​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) 比较多维数组 static boolean deepEquals​(Object[] a1, Object[] a2) int[][] a = { { 1, 2 }, { 3, 4 } }; int[][] b = { { 1, 2 }, { 3, 4 } }; System.out.println(a == b); // false System.out.println(a.equals(b)); // false System.out.println(Arrays.deepEquals(a, b)); // true 返回第一个不相等的下标，若全相等，返回 -1。 static \u003cT\u003e int mismatch​(T[] a, T[] b) static \u003cT\u003e int mismatch​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex) static \u003cT\u003e int mismatch​(T[] a, T[] b, Comparator\u003c? super T\u003e cmp) static \u003cT\u003e int mismatch​(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#比较"},{"categories":null,"content":" 复制新数组长度小于原数组则截断，大于则多余元素为 null/0。 static \u003cT\u003e T[] copyOf​(T[] original, int newLength) static \u003cT,​U\u003e T[] copyOf​(U[] original, int newLength, Class\u003c? extends T[]\u003e newType) static \u003cT\u003e T[] copyOfRange​(T[] original, int from, int to) static \u003cT,​U\u003e T[] copyOfRange​(U[] original, int from, int to, Class\u003c? extends T[]\u003e newType) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:3","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#复制"},{"categories":null,"content":" 赋值 static \u003cT\u003e void fill(T[] a, T val) static \u003cT\u003e void fill(T[] a, int fromIndex, int toIndex, T val) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:4","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#赋值"},{"categories":null,"content":" 前缀操作 static \u003cT\u003e void parallelPrefix​(T[] array, BinaryOperator\u003cT\u003e op) static \u003cT\u003e void parallelPrefix​(T[] array, int fromIndex, int toIndex, BinaryOperator\u003cT\u003e op) int[] a = { 1, 2, 3 }; // 前缀和 Arrays.parallelPrefix(a, (x, y) -\u003e x + y); // [1, 3, 6] ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:5","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#前缀操作"},{"categories":null,"content":" 排序 static \u003cT\u003e void sort​(T[] a) static \u003cT\u003e void sort​(T[] a, Comparator\u003c? super T\u003e c) static \u003cT\u003e void sort​(T[] a, int fromIndex, int toIndex) static \u003cT\u003e void sort​(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:6","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#排序"},{"categories":null,"content":" 流 static \u003cT\u003e Stream\u003cT\u003e stream​(T[] array) static \u003cT\u003e Stream\u003cT\u003e stream​(T[] array, int startInclusive, int endExclusive) ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:7","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#流"},{"categories":null,"content":" 转为字符串 static \u003cT\u003e String toString(T[] a) static String deepToString​(Object[] a)：可用于打印多维数组。 int[][] a = { { 1, 2 }, { 3, 4 } }; int[][] b = { { 1, 2 }, { 3, 4 } }; System.out.println(a); // [[I@36aa7bc2 System.out.println(Arrays.toString(a)); // [[I@76ccd017, [I@182decdb] System.out.println(Arrays.toString(a[0])); // [1, 2] System.out.println(Arrays.deepToString(a)); // [[1, 2], [3, 4]] ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:7:8","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#转为字符串"},{"categories":null,"content":" Collections import java.util.Collections; // 创建空集合 // 返回的集合是不可变集合，无法向其中添加或删除元素。 List\u003cString\u003e list1 = Collections.emptyList(); List\u003cString\u003e list2 = List.of(); Map\u003cString, Integer\u003e map1 = Collections.emptyMap(); Map\u003cString, Integer\u003e map2 = Map.of(); Set\u003cString\u003e set1 = Collections.emptySet(); Set\u003cString\u003e set2 = Set.of(); // 创建单元素集合 // 返回的集合是不可变集合，无法向其中添加或删除元素。 List\u003cString\u003e list1 = Collections.singletonList(\"one\"); List\u003cString\u003e list2 = List.of(\"one\"); Map\u003cString, Integer\u003e map1 = Collections.singletonMap(\"one\", 1); Map\u003cString, Integer\u003e map2 = Map.of(\"one\", 1); Set\u003cString\u003e set1 = Collections.singleton(\"one\"); Set\u003cString\u003e set2 = Set.of(\"one\"); // 排序 // 必须传入可变 List Collections.sort(list); // 洗牌 // 必须传入可变 List Collections.shuffle(list); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#collections"},{"categories":null,"content":" 10.代码片段 // 数组转 List // 1.重新分配空间 List\u003cInteger\u003e myList = new ArrayList\u003c\u003e(Arrays.asList(1, 2, 3)); // 2.使用同一片空间 List\u003cInteger\u003e myList = Arrays.asList(1, 2, 3); // 禁止调整大小，若 add 或 remove // 则抛出 UnsupportedOperationException 异常 // 转换为字符串 String str = myColl.stream() .map(Object::toString) .collect(Collectors.joining(\", \")); // 求和 int sum = myColl.stream() .collect(Collectors.summingInt(E::getValue)); // 删除容器中所有指定元素 myColl.removeAll(Collections.singleton(e)); myColl.removeAll(Collections.singleton(mull)); // 容器转数组，要求容器中元素类型统一 String[] arrStr = myColl.toArray(new String[0]); Integer[] arrInt = myColl.toArray(new Integer[0]); // 1.容器去重 Collection\u003cE\u003e noDups = new HashSet\u003c\u003e(myColl); Collection\u003cE\u003e noDups = myColl.stream().collect(Collectors.toSet()); // 2.容器去重，且保持原来顺序 Collection\u003cE\u003e noDups = new LinkedHashSet\u003c\u003e(myColl); public static \u003cE\u003e Set\u003cE\u003e removeDups(Collection\u003cE\u003e myColl) { return new LinkedHashSet\u003cE\u003e(myColl); } // 取出属性值，创建集合 Set\u003cString\u003e set = people.stream() .map(Person::getName) .collect(Collectors.toCollection(TreeSet::new)); // 交换元素 public static \u003cE\u003e void swap(List\u003cE\u003e a, int i, int j) { E tmp = a.get(i); a.set(i, a.get(j)); a.set(j, tmp); } // 洗牌算法，打乱顺序 public static void shuffle(List\u003cE\u003e list, Random rnd) { for (int i = list.size(); i \u003e 1; i--) { swap(list, i - 1, rnd.nextInt(i)); } } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#10代码片段"},{"categories":null,"content":" char[] 转 Character[] char[] charArray = { 'a', 'b', 'c' }; Character[] charObjectArray = ArrayUtils.toObject(charArray); ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:9:1","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#char-转-character"},{"categories":null,"content":" 11.聚合操作","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#11聚合操作"},{"categories":null,"content":" 重写 equals 方法 对引用类型用Objects.equals()比较（避免判断null），对基本类型直接用==比较。 import java.util.Objects; public boolean equals(Object o) { if (o instanceof E) { E e = (E) o; // } return false; } ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#重写-equals-方法"},{"categories":null,"content":" 重写 hashCode 方法 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 import java.util.Objects; class Stu { String name; int score, age; public int hashCode() { return Objects.hash(name, score, age); } } 参考： Aggregate Operations - Java Tutorials ","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#重写-hashcode-方法"},{"categories":null,"content":" StreamsJava 8 中引入。 import java.util.stream.Collectors; import java.util.stream.Stream; // 获取流方法1 int[] array = { 1, 2, 3 }; Stream\u003cInteger\u003e s1 = Stream.of(array); // 获取流方法2 List\u003cInteger\u003e list = List.of(1, 2, 3); Stream\u003cInteger\u003e s2 = list.stream(); // 获取流方法3 Stream\u003cInteger\u003e s3 = Stream.of(1, 2, 3); // forEach 终端操作 List\u003cInteger\u003e list = List.of(1, 2, 3); list.stream().forEach(e -\u003e System.out.println(e)); list.stream().forEach(System.out::println); // map 中间操作 List\u003cString\u003e list = list.stream().map(e -\u003e e.toString()).collect(Collectors.toList()); // collect 终端操作 List\u003cInteger\u003e list = Stream.of(1, 2, 3).collect(Collectors.toList()); String str = list.stream().map(e -\u003e e.toString()).collect(Collectors.joining(\", \")); Set\u003cInteger\u003e set = list.stream().collect(Collectors.toSet()); // filter 中间操作 List\u003cInteger\u003e list = Stream.of(1, 2, 3).filter(e -\u003e e \u003c 2).collect(Collectors.toList()); // findFirst Integer x = Stream.of(1, 2, 3).filter(e -\u003e e % 2 == 1).findFirst().orElse(null); // toArray Integer[] array = list.stream().toArray(Integer[]::new); // flatMap 中间操作 List\u003cList\u003cString\u003e\u003e namesNested = Arrays.asList( Arrays.asList(\"Jeff\", \"Bezos\"), Arrays.asList(\"Bill\", \"Gates\"), Arrays.asList(\"Mark\", \"Zuckerberg\")); List\u003cString\u003e namesFlatStream = namesNested.stream() .flatMap(Collection::stream) .collect(Collectors.toList()); // count 终端操作 long a = list.stream().count(); // Stream\u003cInteger\u003e infiniteStream = Stream.iterate(2, i -\u003e i * 2); List\u003cInteger\u003e collect = infiniteStream .skip(3) // 跳过前 3 个元素 .limit(5) // 长度为 5 .collect(Collectors.toList()); // sorted list.stream().sorted((a, b) -\u003e b - a); // min max Integer x = list.stream().min((a, b) -\u003e a - b).orElse(null); Integer x = list.stream().max((a, b) -\u003e a - b).orElse(null); // distinct List\u003cInteger\u003e newList = list.stream().distinct().collect(Collectors.toList()); // allMatch anyMatch noneMatch boolean allEven = list.stream().allMatch(i -\u003e i % 2 == 0); boolean oneEven = list.stream().anyMatch(i -\u003e i % 2 == 0); boolean noneMultipleOfThree = list.stream().noneMatch(i -\u003e i % 3 == 0); // I","date":"2021-08-20","objectID":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/:13:0","series":null,"tags":["Java"],"title":"Java Collections Framework 教程","uri":"/posts/java-collections-framework-%E6%95%99%E7%A8%8B/#streams"},{"categories":["Python"],"content":"常用 Python 第三方库。 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:0:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#"},{"categories":["Python"],"content":" 机器学习 scikit-learn: machine learning in Python. 🌟48.1k XGBoost: Scalable, Portable and Distributed Gradient Boosting (GBDT, GBRT or GBM) Library, for Python, R, Java, Scala, C++ and more. Runs on single machine, Hadoop, Spark, Dask, Flink and DataFlow. 🌟21.9k LightGBM: A fast, distributed, high performance gradient boosting (GBT, GBDT, GBRT, GBM or MART) framework based on decision tree algorithms, used for ranking, classification and many other machine learning tasks. 🌟13.2k CatBoost: A fast, scalable, high performance Gradient Boosting on Decision Trees library, used for ranking, classification, regression and other machine learning tasks for Python, R, Java, C++. Supports computation on CPU and GPU. 🌟6.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:1:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#机器学习"},{"categories":["Python"],"content":" 深度学习 TensorFlow: TensorFlow is an end-to-end open source platform for machine learning. 🌟161k Pytorch: Tensors and Dynamic neural networks in Python with strong GPU acceleration. 🌟52.4k MXNet: Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Scala, Go, Javascript and more. 🌟19.8k PaddlePaddle: PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice. 🌟17.1k JAX: Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more. 🌟15.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:2:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#深度学习"},{"categories":["Python"],"content":" 超参数优化 Optuna: A hyperparameter optimization framework. 🌟5,642 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:3:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#超参数优化"},{"categories":["Python"],"content":" 自动化机器学习 auto-sklearn: Automated Machine Learning with scikit-learn. 🌟5,907 PyCaret: An open-source, low-code machine learning library in Python. 🌟4,541 Auto-PyTorch: Automatic architecture search and hyperparameter optimization for PyTorch. 🌟1,464 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:4:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#自动化机器学习"},{"categories":["Python"],"content":" 时间序列分析 Prophet: Tool for producing high quality forecasts for time series data that has multiple seasonality with linear or non-linear growth. 🌟13,809 tsfresh: The package provides systematic time-series feature extraction by combining established algorithms from statistics, time-series analysis, signal processing, and nonlinear dynamics with a robust feature selection algorithm. 🌟6,074 sktime: A unified framework for machine learning with time series. 🌟4,721 Kats: Kats, a kit to analyze time series data, a lightweight, easy-to-use, generalizable, and extendable framework to perform time series analysis, from understanding the key statistics and characteristics, detecting change points and anomalies, to forecasting future trends. 🌟3,308 Darts: A python library for easy manipulation and forecasting of time series. 🌟3,208 GluonTS: Probabilistic time series modeling in Python. 🌟2,351 Merlion: A Machine Learning Framework for Time Series Intelligence. 🌟2,275 tslearn: A machine learning toolkit dedicated to time-series data. 🌟1,904 tsai: tsai is an open-source deep learning package built on top of Pytorch \u0026 fastai focused on state-of-the-art techniques for time series tasks like classification, regression, forecasting, imputation… 🌟1,443 Greykite: The Greykite library provides flexible, intuitive and fast forecasts through its flagship algorithm, Silverkite. 🌟1,358 mcfly: A deep learning tool for time series classification. 🌟337 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:5:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#时间序列分析"},{"categories":["Python"],"content":" 计算机视觉 Face Recognition: The world’s simplest facial recognition api for Python and the command line. 🌟42.3k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:6:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#计算机视觉"},{"categories":["Python"],"content":" 自然语言处理 Transformers: State-of-the-art Natural Language Processing for Pytorch, TensorFlow, and JAX. 🌟54.9k jieba: “结巴”中文分词：做最好的 Python 中文分词组件。 🌟27.4k HanLP: 中文分词 词性标注 命名实体识别 依存句法分析 成分句法分析 语义依存分析 语义角色标注 指代消解 风格转换 语义相似度 新词发现 关键词短语提取 自动摘要 文本分类聚类 拼音简繁转换 自然语言处理。 🌟24.5k spaCy: Industrial-strength Natural Language Processing (NLP) in Python. 🌟21.9k AllenNLP: An open-source NLP research library, built on PyTorch. 🌟10.7k NLTK: NLTK – the Natural Language Toolkit – is a suite of open source Python modules, data sets, and tutorials supporting research and development in Natural Language Processing. 🌟10.3k TextBlob: Simple, Pythonic, text processing–Sentiment analysis, part-of-speech tagging, noun phrase extraction, translation, and more. 🌟8k fastNLP: fastNLP 是一款面向自然语言处理（NLP）的轻量级框架，目标是快速实现NLP任务以及构建复杂模型。 🌟2.4k textacy: NLP, before and after spaCy. 🌟1.8k xmnlp: 提供中文分词, 词性标注, 命名体识别，情感分析，文本纠错，文本转拼音，文本摘要，偏旁部首等功能。 🌟736 ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:7:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#自然语言处理"},{"categories":["Python"],"content":" 科学计算 NumPy: The fundamental package for scientific computing with Python. 🌟18.9k SciPy: SciPy is an open-source software for mathematics, science, and engineering. It includes modules for statistics, optimization, integration, linear algebra, Fourier transforms, signal and image processing, ODE solvers, and more. 🌟8.9k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:8:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#科学计算"},{"categories":["Python"],"content":" 处理数据 pandas: Flexible and powerful data analysis / manipulation library for Python, providing labeled data structures similar to R data.frame objects, statistical functions, and much more. 🌟31.8k pdfminer.six: It is a tool for extracting information from PDF documents. 🌟3.2k openpyxl: openpyxl is a Python library to read/write Excel 2010 xlsx/xlsm/xltx/xltm files. ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:9:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#处理数据"},{"categories":["Python"],"content":" 可视化 Matplotlib: Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. 🌟14.6k seaborn: Seaborn is a Python visualization library based on matplotlib. It provides a high-level interface for drawing attractive statistical graphics. 🌟9k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:10:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#可视化"},{"categories":["Python"],"content":" 爬虫 Requests: A simple, yet elegant, HTTP library. 🌟46.5k Scrapy: Scrapy, a fast high-level web crawling \u0026 scraping framework for Python. 🌟42.2k ","date":"2021-08-15","objectID":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:11:0","series":null,"tags":["Python"],"title":"Python 第三方库","uri":"/posts/python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/#爬虫"},{"categories":[],"content":"Pandas 是一个优秀的数据处理库。 import pandas as pd ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#"},{"categories":[],"content":" 数据结构","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#数据结构"},{"categories":[],"content":" DataFrame df = pd.DataFrame({\"c1\": [11, 21, 31], \"c2\": [12, 22, 32], \"c3\": [13, 23, 33]}, index=[\"r1\", \"r2\", \"r3\"]) df = pd.DataFrame([[11, 12, 13], [21, 22, 23], [31, 32, 33]], index=['r1', 'r2', 'r3'], columns=['c1', 'c2', 'c3']) ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#dataframe"},{"categories":[],"content":" Series","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#series"},{"categories":[],"content":" 读取数据 pd.read_csv() ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#读取数据"},{"categories":[],"content":" 处理缺失数据 df.dropna() df.fillna(value) ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#处理缺失数据"},{"categories":[],"content":" 参考 User Guide — pandas documentation ","date":"2021-08-09","objectID":"/posts/pandas-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":[],"title":"Pandas 教程","uri":"/posts/pandas-%E6%95%99%E7%A8%8B/#参考"},{"categories":[],"content":"阿里云盘相关小技巧。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:0:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#"},{"categories":[],"content":" 1）阿里云盘转存115资源 下载 Chrome 或 Edge 或 Firefox 浏览器，并安装 Tampermonkey 插件。 安装脚本。 打开阿里云盘网页版。 点击右上角多文件提取，导入 sha1 链接文件。 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:1:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#1阿里云盘转存115资源"},{"categories":[],"content":" 参考 如何使用第三方脚本实现阿里云盘分享文件 - 太空堡垒麦克罗斯 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:1:1","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#参考"},{"categories":[],"content":" 2）绕过阿里云分享限制目前阿里云盘只能分享 txt、mp4、jpg 等特定类型的文件, 而不能分享 zip、rar、7z 等压缩文件。 下载十六进制编辑器，修改前四个数值就可以改变文件种类。 macOS：brew install hex-fiend 示例：将zip文件伪装成png文件。 打开文件，将前四个数值改为89504E47。 修改文件后缀为png。 上传阿里云盘，此时可以分享。 下载文件后打开，将前四个数值改回504B0304。 文件后缀改回zip，然后解压。 文件类型 前四个值 png 89504E47 jpg/jpeg FFD8FFE0 gif 47494638 webp 52494646 svg 3C737667 mp4 00000020 zip 504B0304 7z 377ABCAF ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:2:0","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#2绕过阿里云分享限制"},{"categories":[],"content":" 参考 如何绕过阿里云盘文件分享种类限制 - 哔哩哔哩 ","date":"2021-07-21","objectID":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/:2:1","series":null,"tags":[],"title":"阿里云盘","uri":"/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/#参考-1"},{"categories":["位运算","力扣"],"content":"题目链接 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#"},{"categories":["位运算","力扣"],"content":" 方法一：模拟","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#方法一模拟"},{"categories":["位运算","力扣"],"content":" 代码 class Solution { public: int xorOperation(int n, int start) { int ans = start; for (int i = 1; i \u003c n; ++i) { ans ^= (start + i * 2); } return ans; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:1","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#代码"},{"categories":["位运算","力扣"],"content":" 复杂度分析 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:1:2","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#复杂度分析"},{"categories":["位运算","力扣"],"content":" 方法二：数学","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#方法二数学"},{"categories":["位运算","力扣"],"content":" 思路首先介绍异或运算： 对于单个比特的异或，相同为0，相异为1，即： $ 0 \\oplus 0 = 0 $ $ 0 \\oplus 1 = 1 $ $ 1 \\oplus 0 = 1 $ $ 1 \\oplus 1 = 0 $ 对于整数的异或，按最低位对齐，相同位置的比特进行异或运算，如： $ \\ \\ \\ \\ 0001 \\ (1) $ $ \\underline{\\oplus \\ 0011 \\ (3)} $ $ \\ \\ \\ \\ 0010 \\ (2) $ 异或运算满足以下基本性质： $ a \\oplus a = 0 $ $ a \\oplus 0 = a $ $ a \\oplus b = b \\oplus a $ $ (a \\oplus b) \\oplus c = a \\oplus (b \\oplus c) $ 可以推导出如下性质： $ a \\oplus b \\oplus b = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i+1个a} = a $ $ \\forall i \\in \\mathbb{Z}, 有 \\underbrace{a \\oplus 0 \\oplus a \\oplus a \\oplus \\cdots \\oplus 0 \\oplus a}_{2i个a} = 0 $ $ \\forall i \\in \\mathbb{Z}, 有 4i \\oplus (4i+1) \\oplus (4i+2) \\oplus (4i+3) = 0 $ 回到本题，我们需要计算 $ start \\oplus (start+2) \\oplus (start+4) \\oplus \\cdots \\oplus (start+2(n-1)) $，观察公式可以知道每一项奇偶性相同，因此它们的二进制表示中的最低位或者均为1或均为0。 于是我们可以把参与运算的数的二进制位的最低位提取出来单独处理。当且仅当start为奇数且n也为奇数时，结果才为奇数，即最低位为1。令 $ e = n \\oplus start \\oplus 1 $。 此时不考虑start的最后一位，我们将start右移一位，令 $ s = \\lfloor \\frac{start}{2} \\rfloor $，公式转化为 $ s \\oplus (s+1) \\oplus (s+2) \\oplus \\cdots \\oplus (s+n-1) + e $。 这样我们可以自定义函数sumXor(x)来计算 $ 0 \\oplus 1 \\oplus 2 \\oplus \\cdots \\oplus x $，根据上面异或运算的推导性质第4条，可以得出如下结论： $ 当x=4i + 0,i \\in \\mathbb{Z}时，sumXor(x) = x $ $ 当x=4i + 1,i \\in \\mathbb{Z}时，sumXor(x) = (x-1) \\oplus x = 1 $ $ 当x=4i + 2,i \\in \\mathbb{Z}时，sumXor(x) = (x-2) \\oplus (x-1) \\oplus x = x + 1 $ $ 当x=4i + 3,i \\in \\mathbb{Z}时，sumXor(x) = 0 $ 所以，最终结果为 $ [(sumXor(s+n-1) \\oplus sumXor(s-1)) \\times 2] \\oplus e $。 ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:1","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#思路"},{"categories":["位运算","力扣"],"content":" 代码 class Solution { public: int xorOperation(int n, int start) { int s = start \u003e\u003e 1; int e = n \u0026 start \u0026 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return (ret \u003c\u003c 1) | e; } int sumXor(int x) { if (x % 4 == 0) return x; else if (x % 4 == 1) return 1; else if (x % 4 == 2) return x + 1; return 0; } }; ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:2","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#代码-1"},{"categories":["位运算","力扣"],"content":" 复杂度分析 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-05-07","objectID":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/:2:3","series":null,"tags":["位运算","力扣"],"title":"力扣 1486 数组异或操作","uri":"/posts/%E5%8A%9B%E6%89%A3-1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/#复杂度分析-1"},{"categories":["软件"],"content":"适用于各种平台的一些好用软件。 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:0:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#"},{"categories":["软件"],"content":" 跨平台 Mark Text：简洁美观的 Markdown 编辑器。开源 免费 Visual Studio Code：代码编辑器。开源 免费 JetBrains Toolbox App：JetBrains IDE 管理器。 学生免费 PDF Reader Pro：阅读、编辑、注释、转换和签署 PDF 的最佳 PDF 软件。 付费 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:1:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#跨平台"},{"categories":["软件"],"content":" macOS Homebrew：适用于 macOS（或 Linux）缺失的软件包的管理器。 开源 免费 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Hex Fiend：适用于 macOS 的快速且智能的开源十六进制编辑器。 开源 免费 brew install --cask hex-fiend Mounty for NTFS：在 macOS 下以读写模式重新挂载写保护的 NTFS 卷的小工具。 免费 brew install --cask mounty Android File Transfer：在 Mac 计算机和 Android 设备之间浏览和传输文件。 免费 brew install --cask android-file-transfer IINA：适用于 macOS 的现代媒体播放器。 开源 免费 brew install --cask iina OpenInTerminal-Lite：适用于 macOS 的 Finder 工具栏应用程序，用于在终端、iTerm、Hyper 或 Alacritty 中打开当前目录。 开源 免费 brew install --cask openinterminal-lite brew install --cask openineditor-lite MacZip：专为 macOS 而设计的压缩软件. 免费 brew install --cask maczip CheatSheet：适用于 macOS 的列出当前应用程序所有快捷键的工具。 免费 brew install --cask cheatsheet 腾讯柠檬清理：适用于 macOS 的磁盘清理工具。 免费 QSpace：一款简洁高效的多视图文件管理器。 付费 Alfred：通过自定义操作控制你的 Mac 电脑，提高工作效率。 付费 Downie：适用于 macOS 的视频下载工具。 付费 Dash：API 文档浏览器和代码片段管理器。 付费 shottr：截图、滚动截图、抠图、测距、OCR、取色。 免费 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:2:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#macos"},{"categories":["软件"],"content":" macOS 破解软件下载 MacWk ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:2:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#macos-破解软件下载"},{"categories":["软件"],"content":" Windows Bandizip：压缩文件管理工具。 Everything：基于名称快速定位文件和文件夹。 Potplayer：多媒体播放器。 Revo Uninstaller：软件卸载和清除管理器。 MobaXterm：远程连接管理器。 Visual Studio：C++、C# 开发IDE。 Microsoft Store Windows Terminal QuickLook Files ModernFlyouts (Preview) IrfanView64 TranslucentTB ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:3:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#windows"},{"categories":["软件"],"content":" 浏览器插件","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:0","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#浏览器插件"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#chrome-网上应用店需要科学上网"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#沙拉查词"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#mac-沙拉查词--alfred"},{"categories":["软件"],"content":" Chrome 网上应用店（需要科学上网） uBlock Origin：广告过滤 沙拉查词 官网 Github Chrome 网上应用店 Edge 外接程序 Firefox 扩展 Mac: 沙拉查词 + Alfred 沙拉查词 + Alfred，打造最佳文献翻译体验！ - 知乎 浏览器外划词 | Saladict 沙拉查词 test Imagus：鼠标悬停在图片上自动放大图片 Chrono下载管理器：可嗅探网页资源 Free Download Manager：配合 FDM 使用 Tampermonkey：油猴，脚本下载：Greasy Fork Bitwarden - 免费密码管理器：全平台同步密码管理器 Augmented Steam：查看 Steam 各区价格及史低价格 TabFloater: Picture-in-Picture for any tab!：让标签页变为“画中画”模式 ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:1","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#test"},{"categories":["软件"],"content":" Edge 外接程序 BETA uBlock Origin 沙拉查词-聚合词典划词翻译 Tampermonkey Bitwarden - 免费密码管理器 Augmented Steam Edge 浏览器也可到 Chrome 网上应用店安装扩展。 https://github.com/beekeeper-studio/beekeeper-studio ","date":"2021-04-27","objectID":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:4:2","series":null,"tags":["软件"],"title":"常用软件","uri":"/posts/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/#edge-外接程序-betahttpsmicrosoftedgemicrosoftcomaddonsmicrosoft-edge-extensions-homehlzh-cn"},{"categories":["Hugo"],"content":" 1.网站配置","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#1网站配置"},{"categories":["Hugo"],"content":" 1.1 基础配置 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#11-基础配置"},{"categories":["Hugo"],"content":" 1.2 完整配置 [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#12-完整配置"},{"categories":["Hugo"],"content":" 2.网站图标，浏览器配置，网站清单强烈建议你把： apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在/static目录，利用 RealFaviconGenerator 可以很容易地生成这些文件。 可以自定义browserconfig.xml和site.webmanifest文件来设置 theme-color 和 background-color。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#2网站图标浏览器配置网站清单"},{"categories":["Hugo"],"content":" 3.自定义样式 需使用 Hugo extended 版本 通过自定义.scss样式文件，LoveIt 主题支持自定义的样式。 包含自定义.scss样式文件的路径为assets/css。 在assets/css/_override.scss中，你可以覆盖themes/LoveIt/assets/css/_variables.scss中的变量以自定义样式。 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在assets/css/_custom.scss中，你可以添加一些 CSS 样式代码以自定义样式。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#3自定义样式"},{"categories":["Hugo"],"content":" 4.多语言和 i18nHugo 配置多语言支持 一个支持英语和中文的网站配置： # [en, zh-cn, fr, pl, ...] 默认语言 defaultContentLanguage = \"zh-cn\" [languages] # 英语 [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 # 中文 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 然后，对于每个新页面，将语言代码附加到文件名中。 单个文件my-page.md需要分为三个文件： 英语：my-page.en.md 中文：my-page.zh-cn.md 也可使用 文章前置参数 来翻译文章。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#4多语言和-i18n"},{"categories":["Hugo"],"content":" 修改默认的翻译字符串翻译字符串用于在主题中使用的常见默认值。 目前提供一些语言的翻译，但你可能自定义其他语言或覆盖默认值。 要覆盖默认值，请在你项目的 i18n 目录i18n/\u003clanguageCode\u003e.toml中创建一个新文件，并从themes/LoveIt/i18n/en.toml中获得提示。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#修改默认的翻译字符串"},{"categories":["Hugo"],"content":" 5.搜索基于 Lunr.js 或 algolia，LoveIt 主题支持搜索功能。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#5搜索"},{"categories":["Hugo"],"content":" 5.1 输出配置为了生成搜索功能所需要的index.json，请在你的网站配置中添加JSON输出文件类型到outputs部分的home字段中。 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#51-输出配置"},{"categories":["Hugo"],"content":" 5.2 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:2","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#52-搜索配置"},{"categories":["Hugo"],"content":" 5.3 比较 lunr：简单，无需同步index.json，没有contentLength的限制，但占用带宽大且性能低（特别是中文需要一个较大的分词依赖库） algolia：高性能并且占用带宽低，但需要同步index.json且有contentLength的限制 文章内容被h2和h3HTML 标签切分来提高查询效果并且基本实现全文搜索。contentLength用来限制h2和h3HTML 标签开头的内容部分的最大长度。 algolia：你需要上传index.json到 algolia 来激活搜索功能，你可以使用浏览器来上传index.json文件。但是一个自动化的脚本可能效果更好，Algolia Atomic 是一个不错的选择。为了兼容 Hugo 的多语言模式，你需要上传不同语言的index.json文件到对应的 algolia index，例如zh-cn/index.json或en/index.json…… ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:5:3","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#53-比较"},{"categories":["Hugo"],"content":" 6.内容文本内容组织 保持博客文章存放在content/posts目录，例如：content/posts/我的第一篇文章.md 保持简单的静态页面存放在content目录，例如：content/about.md 本地媒体资源引用 使用页面包中的页面资源。你可以使用适用于Resources.GetMatch的值或者直接使用相对于当前页面目录的文件路径来引用页面资源。 将本地资源放在assets目录中，默认路径是/assets。引用资源的文件路径是相对于assets目录的。 将本地资源放在static目录中，默认路径是/static。引用资源的文件路径是相对于static目录的。 引用的优先级符合以上的顺序。 在这个主题中的很多地方可以使用上面的本地资源引用，例如：链接、图片、image shortcode、music shortcode、和前置参数中的部分参数. 页面资源或者assets目录中的图片处理会在未来的版本中得到支持。 ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#6内容"},{"categories":["Hugo"],"content":" 7.前置参数 只有在文章的参数和你的网站设置中的page部分不一致时才有必要显式设置。 --- title: \"My first blog\" # 标题 subtitle: \"\" # 副标题 date: 2020-03-04T15:58:26+08:00 # 创建日期 lastmod: 2020-03-04T15:58:26+08:00 # 修改日期 draft: true # 是否草稿 author: \"\" # 作者 authorLink: \"\" # 作者链接 description: \"\" # 内容描述 license: \"\" # 文章许可 images: [] # 页面图片,用于 Open Graph 和 Twitter Cards tags: [] # 标签 categories: [] # 分类 featuredImage: \"\" # 特色图片 featuredImagePreview: \"\" # 主页预览的图片 hiddenFromHomePage: false # 是否从主页上隐藏 hiddenFromSearch: false # 是否从搜索中隐藏 twemoji: false # 是否使用 twemoji lightgallery: true # 图片是否按照画廊形式呈现 ruby: true # 是否使用上标注释扩展语法 fraction: true # 是否使用分数扩展语法 fontawesome: true # 是否使用 Font Awesome 扩展语法 linkToMarkdown: true # 页脚是否显示指向原始 Markdown 文件的链接 rssFullText: false # RSS 中是否显示全文内容 toc: # 和 params.page.toc 部分相同 enable: true auto: true code: # 和 params.page.code 部分相同 copy: true # ... math: # 和 params.page.math 部分相同 enable: true # ... mapbox: # 和 params.page.mapbox 部分相同 accessToken: \"\" # ... share: # 和 params.page.share 部分相同 enable: true # ... comment: # 和 params.page.comment 部分相同 enable: true # ... library: # 和 params.page.library 部分相同 css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: # 和 params.page.seo 部分相同 images: [] # ... --- ","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:7:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#7前置参数"},{"categories":["Hugo"],"content":" 8.内容摘要","date":"2021-04-12","objectID":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/:8:0","series":null,"tags":["Hugo"],"title":"Hugo DoIt 主题介绍和配置","uri":"/posts/hugo-doit-%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/#8内容摘要"},{"categories":null,"content":"FFmpeg 是视频/音频处理最常用的开源软件。 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#"},{"categories":null,"content":" 常用参数 -c：指定编码器。-c copy：直接复制，不重新编码，加快生成速度 -c:v或-vcodec：指定视频编码器。-c:v copy或-vcodec copy：不改变视频编码，直接拷贝 -c:a或-acodec：指定音频编码器。-c:a copy或-acodec copy：不改变音频编码，直接拷贝 -i：指定输入文件 -an：去除音频流 -vn：去除视频流 -preset：指定输出的视频质量，会影响生成速度。可用值：ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow -y：不经过确认，输出时直接覆盖同名文件 -hwaccel cuvid：指定使用 cuvid 硬件加速 举例： ffmpeg -y -c:a libfdk_aac -c:v libx264 -i input.mp4 -c:a libvorbis -c:v libvpx-vp9 output.webm ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#常用参数"},{"categories":null,"content":" 格式转换 ffmpeg -i input.webm output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#格式转换"},{"categories":null,"content":" 提取视频中的音频 ffmpeg -i input.mp4 -vn -acodec copy output.aac ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#提取视频中的音频"},{"categories":null,"content":" 去除视频中的音频 ffmpeg -i input.mp4 -an -vcodec copy output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#去除视频中的音频"},{"categories":null,"content":" 合并音频和视频视频不包含音频： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental output.mp4 视频包含音频，需要被替换： ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy -strict experimental -map 0:v:0 -map 1:a:0 output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#合并音频和视频"},{"categories":null,"content":" 视频截图在第 4.5s 截取一帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 1 output.png 在第 4.5s 截取 10 帧图片 ffmpeg -i input.mp4 -ss 4.5 -vframes 10 output%d.png ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#视频截图"},{"categories":null,"content":" 压缩视频改变帧率，设置为 20fps ffmpeg -i input.mp4 -r 20 output.mp4 指定文件大小，设置最大值为 15MB ffmpeg -i input.mp4 -fs 15MB output.mp4 改变分辨率，设置为 1280x720 ffmpeg -i input.mp4 -vf scale=1280:720 output.mp4 改变码率，设置为 1.5Mb/s ffmpeg -i input.mp4 -b:v 1.5M output.mp4 ","date":"2021-04-10","objectID":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["FFmpeg"],"title":"FFmpeg 使用教程","uri":"/posts/ffmpeg-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#压缩视频"},{"categories":null,"content":" C++ #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; void solve() { int n; cin \u003e\u003e n; cout \u003c\u003c n \u003c\u003c endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); int t; cin \u003e\u003e t; while (t--) solve(); return 0; } #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef long double ld; typedef complex\u003cld\u003e cd; typedef pair\u003cint, int\u003e pi; typedef pair\u003cll,ll\u003e pl; typedef pair\u003cld,ld\u003e pd; typedef vector\u003cint\u003e vi; typedef vector\u003cld\u003e vd; typedef vector\u003cll\u003e vl; typedef vector\u003cpi\u003e vpi; typedef vector\u003cpl\u003e vpl; typedef vector\u003ccd\u003e vcd; template\u003cclass T\u003e using pq = priority_queue\u003cT\u003e; template\u003cclass T\u003e using pqg = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e; #define FOR(i, a, b) for (int i=a; i\u003c(b); i++) #define F0R(i, a) for (int i=0; i\u003c(a); i++) #define FORd(i,a,b) for (int i = (b)-1; i \u003e= a; i--) #define F0Rd(i,a) for (int i = (a)-1; i \u003e= 0; i--) #define trav(a,x) for (auto\u0026 a : x) #define uid(a, b) uniform_int_distribution\u003cint\u003e(a, b)(rng) #define sz(x) (int)(x).size() #define mp make_pair #define pb push_back #define f first #define s second #define lb lower_bound #define ub upper_bound #define all(x) x.begin(), x.end() #define ins insert template\u003cclass T\u003e bool ckmin(T\u0026 a, const T\u0026 b) { return b \u003c a ? a = b, 1 : 0; } template\u003cclass T\u003e bool ckmax(T\u0026 a, const T\u0026 b) { return a \u003c b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); void __print(int x) {cerr \u003c\u003c x;} void __print(long x) {cerr \u003c\u003c x;} void __print(long long x) {cerr \u003c\u003c x;} void __print(unsigned x) {cerr \u003c\u003c x;} void __print(unsigned long x) {cerr \u003c\u003c x;} void __print(unsigned long long x) {cerr \u003c\u003c x;} void __print(float x) {cerr \u003c\u003c x;} void __print(double x) {cerr \u003c\u003c x;} void __print(long double x) {cerr \u003c\u003c x;} void __print(char x) {cerr \u003c\u003c '\\'' \u003c\u003c x \u003c\u003c '\\'';} void __print(const char *x) {cerr \u003c\u003c '\\\"' \u003c\u003c x \u003c\u003c '\\\"';} void __print(const string \u0026x) {cerr \u003c\u003c '\\\"' \u003c\u003c x \u003c\u003c '\\\"';} void __print(bool x) {cerr \u003c\u003c (x ? \"true\" : \"false\");} template\u003ctypename T, typename V\u003e void __print(const pair\u003cT, V\u003e \u0026x) {cerr \u003c\u003c '{","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:1:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#c"},{"categories":null,"content":" 输入","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:2:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#输入"},{"categories":null,"content":" 输出","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#输出"},{"categories":null,"content":" 格式化 ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:3:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#格式化"},{"categories":null,"content":" 排序排序模板 public class SortTemplate { public static void sort(Comparable[] array) {} private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } private static void show(Comparable[] array) { for (Comparable elem : array) { System.out.print(elem + \" \"); } System.out.println(); } private static boolean isSorted(Comparable[] array) { for (int i = 1; i \u003c array.length; i++) { if (less(array[i], array[i - 1])) { return false; } } return true; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#排序"},{"categories":null,"content":" 1 选择排序 public class SelectionSort { public static void sort(Comparable[] array) { int len = array.length; for (int i = 0; i \u003c len; i++) { int minIdx = i; for (int j = i + 1; j \u003c len; j++) { if (less(array[j], array[minIdx])) { minIdx = j; } } exchange(array, i, minIdx); } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#1-选择排序"},{"categories":null,"content":" 2 插入排序 public class InsertionSort { public static void sort(Comparable[] array) { int len = array.length; for (int i = 1; i \u003c len; i++) { for (int j = i; j \u003e 0 \u0026\u0026 less(array[j], array[j - 1]); j--) { exchange(array, j, j - 1); } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:2","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#2-插入排序"},{"categories":null,"content":" 3 希尔排序 public class ShellSort { public static void sort(Comparable[] array) { int len = array.length; int step = 1; while (step \u003c len / 3) { // 1, 4, 13, 40, 121, 364, 1093, ... step = step * 3 + 1; } while (step \u003e= 1) { for (int i = step; i \u003c len; i++) { for (int j = i; j \u003e= step \u0026\u0026 less(array[j], array[j - step]); j -= step) { exchange(array, j, j - step); } } step /= 3; } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:3","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#3-希尔排序"},{"categories":null,"content":" 4 归并排序自顶向下 public class MergeSort { private static Comparable[] copy; public static void sort(Comparable[] array) { int len = array.length; copy = new Comparable[len]; sort(array, 0, len - 1); } private static void sort(Comparable[] array, int low, int high) { // [low, high] if (low \u003e= high) return; int mid = low + (high - low) / 2; sort(array, low, mid); sort(array, mid + 1, high); merge(array, low, mid, high); } private static void merge(Comparable[] array, int low, int mid, int high) { // [low, high] int i = low; int j = mid + 1; if (high + 1 - low \u003e= 0) System.arraycopy(array, low, copy, low, high + 1 - low); for (int k = low; k \u003c= high; k++) { if (i \u003e mid) { array[k] = copy[j++]; } else if (j \u003e high) { array[k] = copy[i++]; } else if (less(copy[j], copy[i])) { array[k] = copy[j++]; } else { array[k] = copy[i++]; } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } } 自底向上 public class MergeSort { private static Comparable[] copy; public static void sort(Comparable[] array) { int len = array.length; copy = new Comparable[len]; for (int step = 1; step \u003c len; step *= 2) { for (int low = 0; low \u003c len - step; low += 2 * step) { merge(array, low, low + step - 1, Math.min(low + 2 * step - 1, len - 1)); } } } private static void merge(Comparable[] array, int low, int mid, int high) { // [low, high] int i = low; int j = mid + 1; if (high + 1 - low \u003e= 0) System.arraycopy(array, low, copy, low, high + 1 - low); for (int k = low; k \u003c= high; k++) { if (i \u003e mid) { array[k] = copy[j++]; } else if (j \u003e high) { array[k] = copy[i++]; } else if (less(copy[j], copy[i])) { array[k] = copy[j++]; } else { array[k] = copy[i++]; } } } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:4","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#4-归并排序"},{"categories":null,"content":" 5 快速排序 public class QuickSort { public static void sort(Comparable[] array) { sort(array, 0, array.length - 1); } public static void sort(Comparable[] array, int low, int high) { // [low, high] if (low \u003e= high) return; int i = partition(array, low, high); sort(array, low, i - 1); sort(array, i + 1, high); } private static int partition(Comparable[] array, int low, int high) { // [low, high] int i = low; int j = high + 1; Comparable copy = array[low]; while (true) { while (less(array[++i], copy)) { if (i == high) break; } while (less(copy, array[--j])) { if (j == low) break; } if (i \u003e= j) break; exchange(array, i, j); } exchange(array, low, j); return j; } private static boolean less(Comparable a, Comparable b) { return a.compareTo(b) \u003c 0; } private static void exchange(Comparable[] array, int i, int j) { Comparable temp = array[i]; array[i] = array[j]; array[j] = temp; } } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:4:5","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#5-快速排序"},{"categories":null,"content":" 算法","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:5:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#算法"},{"categories":null,"content":" 滑动窗口","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:5:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#滑动窗口"},{"categories":null,"content":" 二分查找 int binarySearch(vector\u003cint\u003e arr, const int target) { // 升序数组 // [low, high] int low = 0, high = arr.size() - 1, mid; while (low \u003c= high) { mid = low + (high - low) / 2; if (target == arr[mid]) { return mid; } else if (target \u003e arr[mid]) { low = mid + 1; } else { high = mid - 1; } } return -1; } ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:5:2","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#二分查找"},{"categories":null,"content":" 小技巧头文件 #include\u003cbits/stdc++.h\u003e 判断奇偶 if (x \u0026 1) // 奇数，等价于 x % 2 else // 偶数 快速乘除2 x \u003c\u003c= 1; // 乘2，等价于 x *= 2; x \u003e\u003e= 1; // 除2，等价于 x /= 2; 快速交换 a ^= b; // a1 = a ^ b b ^= a; // b1 = b ^ a1 = b ^ a ^ b = a a ^= b; // a2 = a1 ^ b1 = a ^ b ^ a = b 遍历字符串 for (int i = 0; s[i]; i++) 使用 emplace_back() 代替 push_back() 内置求最大公约数函数：__gcd(x, y); 使用 inline 函数 全局数组最大 $ 10^7 $，函数内数组最大 $ 10^6 $ 得到最高有效位数字 double k = log(n, 10); k -= floor(k); x = pow(10, k); 得到数字的有效位数 n = floor(log(n, 10)) + 1; 判断是否是 2 的幂（Brian Kernighan’s Algorithm） // log(n) n \u0026\u0026 (!(n \u0026 (n - 1))) C++11 内置 STL 函数 // 是否全是正数？ all_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否存在正数 any_of(first, first + n, [](int x) { return x \u003e 0; }); // 是否全不是正数？ none_of(first, first + n, [](int x) { return x \u003e 0; }); // 复制 int source[5] = {0, 12, 34, 50, 80}; int target[5]; copy_n(source, 5, target); // 迭代 int a[5] = {0}; char c[3] = {0}; iota(a, a + 5, 10); // {10, 11, 12, 13, 14} iota(c, c + 3, 'a'); // {'a', 'b', 'c'} 二进制表示 auto number = 0b011; cout \u003c\u003c number; // 3 Using Range based for loop ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:6:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#小技巧"},{"categories":null,"content":" C++ 实用技巧","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:7:0","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#c-实用技巧"},{"categories":null,"content":" STL 常用库 /*** 函数 ***/ #include\u003calgorithm\u003e #include\u003cfunctional\u003e // hash #include\u003cclimits\u003e // 常量 #include\u003ccmath\u003e #include\u003ccstdio\u003e #include\u003ccstdlib\u003e // random #include\u003cctime\u003e #include\u003ciostream\u003e #include\u003csstream\u003e #include\u003ciomanip\u003e // 右对齐 std::right 设置宽度 std::setw(width) /*** 数据结构 ***/ #include\u003cdeque\u003e #include\u003clist\u003e #include\u003cqueue\u003e // 包括 priority_queue #include\u003cstack\u003e #include\u003cstring\u003e #include\u003cvector\u003e ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:7:1","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#stl-常用库"},{"categories":null,"content":" I/O #include\u003ciostream\u003e // cin cout #include\u003ccstdio\u003e // scanf printf // cin does not concern with ’\\n’ at end of each line // however scanf or getline does concern with ’\\n’ at end of each line // ’\\n’ will be ignored when you use cin to read char. // 读取数值数据后在读取字符串 cin \u003e\u003e n; getline(cin, str) // wasted getline getline(cin, str) // real input string ","date":"2021-03-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/:7:2","series":null,"tags":["数据结构","算法"],"title":"算法模板库","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%BA%93/#io"},{"categories":["二分查找","力扣"],"content":"题目链接 ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:0:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#"},{"categories":["二分查找","力扣"],"content":" 方法一：两次二分查找易知： 每行升序 每列升序 所以，我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。 class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e matrix, int target) { auto row = upper_bound(matrix.begin(), matrix.end(), target, [](const int b, const vector\u003cint\u003e \u0026a) { return b \u003c a[0]; }); if (row == matrix.begin()) { return false; } --row; return binary_search(row-\u003ebegin(), row-\u003eend(), target); } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int rowIndex = binarySearchFirstColumn(matrix, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], target); } public int binarySearchFirstColumn(int[][] matrix, int target) { int low = -1, high = matrix.length - 1; while (low \u003c high) { int mid = (high - low + 1) / 2 + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } public boolean binarySearchRow(int[] row, int target) { int low = 0, high = row.length - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; if (row[mid] == target) { return true; } else if (row[mid] \u003e target) { high = mid - 1; } else { low = mid + 1; } } return false; } } int binarySearchFirstColumn(int** matrix, int matrixSize, int target) { int low = -1, high = matrixSize - 1; while (low \u003c high) { int mid = (high - low + 1) / 2 + low; if (matrix[mid][0] \u003c= target) { low = mid; } else { high = mid - 1; } } return low; } bool binarySearchRow(int* row, int rowSize, int target) { int low = 0, high = rowSize - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; if (row[mid] == target) { return true; } else if (row[mid] \u003e target) { high = mid - 1; } else { low = mid + 1; } } return false; } bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) { int rowIndex = binarySearchFirstColumn(matrix, matrixSize, target); if (rowIndex \u003c 0) { return false; } return binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target); } var searchMatrix = function(matrix, target) { const rowIndex = binarySearchFirstColumn(matrix, ta","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:1:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#方法一两次二分查找"},{"categories":["二分查找","力扣"],"content":" 方法二：一次二分查找根据特性可将二维数组看作一维的升序数组，再使用二分搜索查找。（要求二维数组每行元素个数相等） class Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; // 中位数映射到行和列 if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } }; class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } } bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) { int m = matrixSize, n = matrixColSize[0]; int low = 0, high = m * n - 1; while (low \u003c= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; } var searchMatrix = function(matrix, target) { const m = matrix.length, n = matrix[0].length; let low = 0, high = m * n - 1; while (low \u003c= high) { const mid = Math.floor((high - low) / 2) + low; const x = matrix[Math.floor(mid / n)][mid % n]; if (x \u003c target) { low = mid + 1; } else if (x \u003e target) { high = mid - 1; } else { return true; } } return false; }; func searchMatrix(matrix [][]int, target int) bool { m, n := len(matrix), len(matrix[0]) i := sort.Search(m*n, func(i int) bool { return matrix[i/n][i%n] \u003e= target }) return i \u003c m*n \u0026\u0026 matrix[i/n][i%n] == target } 时间复杂度：$ O(\\log mn) $ ","date":"2021-03-30","objectID":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/:2:0","series":null,"tags":["二分查找","力扣"],"title":"力扣 0074 搜索二维矩阵","uri":"/posts/%E5%8A%9B%E6%89%A3-0074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/#方法二一次二分查找"},{"categories":["Java"],"content":" 路线图 MCA JAVA后端架构师 八股文： CS-Notes JavaGuide Java 全栈知识体系 进击的java菜鸟 算法： labuladong 的算法小抄 代码随想录 数据库： DB-TUTORIAL ","date":"2021-03-30","objectID":"/posts/java-%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/:1:0","series":null,"tags":["Java"],"title":"Java 后端面试","uri":"/posts/java-%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/#路线图"},{"categories":["正则表达式"],"content":"用来描述字符串模式匹配规则的表达式。 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#"},{"categories":["正则表达式"],"content":" 1.规则","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#1规则"},{"categories":["正则表达式"],"content":" 1.1 单个字符匹配 正则表达式 意义 等价 a 单个指定字母 0 单个指定数字 \\\\ \\ \\* * \\. . \\n 换行符 \\f 换页符 \\t 制表符 . 单个除了换行符之外的任何字符 \\d 单个数字 [0-9] \\D 单个非数字字符 [^0-9] 、 [^\\d] \\w 单个字母或数字或下划线 [a-zA-Z0-9_] \\W 单个非字母非数字非下划线字符 [^a-zA-Z0-9_]、[^\\w] \\s 单个空白字符（空格、换行符、换页符、制表符） [ \\n\\f\\t] \\S 单个非空白字符 [^ \\n\\f\\t]、[^\\s] ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#11-单个字符匹配"},{"categories":["正则表达式"],"content":" 1.2 匹配次数 正则表达式 意义 ? 匹配0或1次 * 匹配任意次（大于等于0） + 至少匹配一次（大于等于1） {a} 匹配a次 {a,b} 至少匹配a次，至多匹配b次（[a,b]） {a,} 至少匹配a次（大于等于a） {0,b} 至多匹配b次（[0,b]） ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#12-匹配次数"},{"categories":["正则表达式"],"content":" 1.3 边界匹配 正则表达式 意义 \\b 单词边界 \\B 非单词边界 ^ 字符串开头 $ 字符串结尾 /规则/m 多行模式 /规则/i 忽略大小写 /规则/g 全局模式 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#13-边界匹配"},{"categories":["正则表达式"],"content":" 1.4 逻辑关系 正则表达式 意义 ` ` [^] 逻辑非 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:1:4","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#14-逻辑关系"},{"categories":["正则表达式"],"content":" 2.高级用法 回溯引用 前向查找 后向查找 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#2高级用法"},{"categories":["正则表达式"],"content":" 3.代码中使用","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#3代码中使用"},{"categories":["正则表达式"],"content":" 3.1 C++ #include \u003cregex\u003e // 转义字符 regex reg1(\"^[\\\\w-]+(\\\\.[\\\\w-]+)*@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); regex_match(\"google@gmail.com\", reg1); // 1 // 原生字符串 R\"(...)\" regex reg2(R\"(^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$)\"); regex_match(\"google@gmail.com\", reg2); // 1 // ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#31-c"},{"categories":["正则表达式"],"content":" 3.2 Java","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#32-java"},{"categories":["正则表达式"],"content":" 3.3 Python","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#33-python"},{"categories":["正则表达式"],"content":" 4.常用正则表达式 整数：^-?\\d+$ 自然数（非负整数）：^\\d+$ 正整数：^[0-9]*[1-9][0-9]*$ 非正整数：^((-\\d+) ?(0+))$ 负整数：^-[0-9]*[1-9][0-9]*$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 非负浮点数：^\\d+(\\.\\d+)?$ 正浮点数：^(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*))$ 非正浮点数：^((-\\d+(\\.\\d+)?) ?(0+(\\.0+)?))$ 负浮点数：^(-(([0-9]+\\.[0-9]*[1-9][0-9]*) ?([0-9]*[1-9][0-9]*\\.[0-9]+) ?([0-9]*[1-9][0-9]*)))$ 下划线、数字和大小写字母：^\\w+$ 数字和大小写字母：^[A-Za-z0-9]+$ 大小写字母：^[A-Za-z]+$ 大写字母：^[A-Z]+$ 小写字母：^[a-z]+$ 中文字符：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff]，可以用来计算字符串的长度 空行：\\n[\\s ? ]*\\r，可以用来删除空白行 HTML标记：/ \u003c(.*)\u003e.* \u003c\\/\\1\u003e ? \u003c(.*) \\/\u003e/，仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 首尾空格：(^\\s*) ?(\\s*$) ^\\s* ?\\s*$，可以用来删除行首行尾的空白字符 电子邮件：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 网址（URL）：(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$ [a-zA-z]+://[^\\s]* 命名规则（字母开头，长度5-16，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 中国座机号码：\\d{3}-\\d{8} ?\\d{4}-\\d{7} QQ号：[1-9][0-9]{4,} 中国邮政编码：[1-9]\\d{5}(?!\\d) 中国身份证：\\d{15} ?\\d{18} IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#4常用正则表达式"},{"categories":["正则表达式"],"content":" 5.辅助网站 Regexper：正则表达式规则可视化。 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#5辅助网站"},{"categories":["正则表达式"],"content":" 参考资料 正则表达式不要背 - 掘金 C++正则表达式 - cpluspluser - 博客园 ","date":"2021-03-30","objectID":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["正则表达式"],"title":"正则表达式教程","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/#参考资料"},{"categories":["位运算","分治法","力扣"],"content":"题目链接 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:0:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#"},{"categories":["位运算","分治法","力扣"],"content":" 方法一：逐位颠倒","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#方法一逐位颠倒"},{"categories":["位运算","分治法","力扣"],"content":" 思路将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。 代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:1","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#思路"},{"categories":["位运算","分治法","力扣"],"content":" 代码 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } }; public class Solution { public int reverseBits(int n) { int rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n != 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev; } } uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e= 1; } return rev; } var reverseBits = function(n) { let rev = 0; for (let i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; ++i) { rev |= (n \u0026 1) \u003c\u003c (31 - i); n \u003e\u003e\u003e= 1; } return rev \u003e\u003e\u003e 0; }; func reverseBits(n uint32) (rev uint32) { for i := 0; i \u003c 32 \u0026\u0026 n \u003e 0; i++ { rev |= n \u0026 1 \u003c\u003c (31 - i) n \u003e\u003e= 1 } return } ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:2","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#代码"},{"categories":["位运算","分治法","力扣"],"content":" 复杂度 时间复杂度：$ O(\\log n) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:1:3","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#复杂度"},{"categories":["位运算","分治法","力扣"],"content":" 方法二：位运算分治","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:0","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#方法二位运算分治"},{"categories":["位运算","分治法","力扣"],"content":" 思路若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。 由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。 对于递归的最底层，我们需要交换所有奇偶位： 取出所有奇数位和偶数位； 将奇数位移到偶数位上，偶数位移到奇数位上。 类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。 ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:1","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#思路-1"},{"categories":["位运算","分治法","力扣"],"content":" 代码 class Solution { private: const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 public: uint32_t reverseBits(uint32_t n) { n = n \u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e 16 | n \u003c\u003c 16; } }; public class Solution { private static final int M1 = 0x55555555; // 01010101010101010101010101010101 private static final int M2 = 0x33333333; // 00110011001100110011001100110011 private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111 public int reverseBits(int n) { n = n \u003e\u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e\u003e 16 | n \u003c\u003c 16; } } const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 uint32_t reverseBits(uint32_t n) { n = n \u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return n \u003e\u003e 16 | n \u003c\u003c 16; } var reverseBits = function(n) { const M1 = 0x55555555; // 01010101010101010101010101010101 const M2 = 0x33333333; // 00110011001100110011001100110011 const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const M8 = 0x00ff00ff; // 00000000111111110000000011111111 n = n \u003e\u003e\u003e 1 \u0026 M1 | (n \u0026 M1) \u003c\u003c 1; n = n \u003e\u003e\u003e 2 \u0026 M2 | (n \u0026 M2) \u003c\u003c 2; n = n \u003e\u003e\u003e 4 \u0026 M4 | (n \u0026 M4) \u003c\u003c 4; n = n \u003e\u003e\u003e 8 \u0026 M8 | (n \u0026 M8) \u003c\u003c 8; return (n \u003e\u003e\u003e 16 | n \u003c\u003c 16) \u003e\u003e\u003e 0; }; const ( m1 = 0x55555555 // 01010101010101010101010101010101 m2 = 0x33333333 // 00110011001100110","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:2","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#代码-1"},{"categories":["位运算","分治法","力扣"],"content":" 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-03-29","objectID":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:2:3","series":null,"tags":["位运算","分治法","力扣"],"title":"力扣 0190 颠倒二进制位","uri":"/posts/%E5%8A%9B%E6%89%A3-0190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/#复杂度-1"},{"categories":["黑苹果","MacOS"],"content":" 一、工具 U盘（≥16G） Mac OS镜像（.dmg） 适合你的电脑的EFI文件 balenaEtcher（刻录工具） DiskGenius（分区工具） ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#一工具"},{"categories":["黑苹果","MacOS"],"content":" 二、制作U盘启动盘 插入U盘，然后打开balenaEtcher软件。 点击Select image选择Mac OS镜像。 软件会自动识别出你的U盘，最后点击Flash!。 等待刻录完成（20min左右），之后会有一个完整性检测（15min左右）。 当软件显示Flash Complete!时表示刻录成功。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#二制作u盘启动盘"},{"categories":["黑苹果","MacOS"],"content":" 三、配置Clover引导驱动 打开DiskGenius，找到U盘上的ESP分区，删除EFI文件夹。 把适合自己电脑EFI文件夹复制进去。（这里只能用快捷键复制粘贴） 保存更改。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#三配置clover引导驱动"},{"categories":["黑苹果","MacOS"],"content":" 四、制作黑苹果系统盘","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#四制作黑苹果系统盘"},{"categories":["黑苹果","MacOS"],"content":" 硬盘分区安装压缩卷（≥25G）。 选中压缩出的空闲分区，右键新建简单卷，一直点击下一步但选择不要格式化这个卷。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#硬盘分区安装"},{"categories":["黑苹果","MacOS"],"content":" 整块硬盘安装删除磁盘所有分区即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#整块硬盘安装"},{"categories":["黑苹果","MacOS"],"content":" 五、BIOS设置以技嘉（Gigabyte）主板为例： BIOS-\u003eFastBoot-\u003eDisable BIOS-\u003eWindows 8/10 Features-\u003eWindows 8/10 将操作系统类型设置为其他操作系统。从不支持Microsoft签名安全启动的第三方操作系统启动时，将“操作系统类型”设置为“其他操作系统”以获取优化的功能。 BIOS-\u003eCSM Support-\u003eDisabled 禁用CSM。兼容性支持模块（CSM）是UEFI固件的组件，该组件通过模拟BIOS环境来提供旧版BIOS兼容性，从而允许仍使用旧版操作系统和某些不支持UEFI的选件ROM。Clover和OpenCore引导都支持UEFI引导。禁用CSM使BIOS可以轻松发现Bootloader。 BIOS-\u003eLAN PXE Boot Option ROM-\u003eDisabled BIOS-\u003eStorage Boot Option Control-\u003eUEFI BIOS-\u003eOther PCI devices-\u003eUEFI Peripherals-\u003eInitial Display Output-\u003ePCIe Slot(独显)/IGFX(核显) Peripherals-\u003eAbove 4G Decoding-\u003eDisabled Peripherals-\u003eTrusted Computing-\u003eSecurity Device Support-\u003eDisable Peripherals-\u003eUSB Configuration-\u003eLegacy USB Support-\u003eDisabled 禁用旧版USB支持。 Peripherals-\u003eUSB Configuration-\u003eXHCI Hand-off-\u003eEnabled 启用XHCI切换。 Peripherals-\u003eNetwork Stack Configuration-\u003eDisabled Peripherals-\u003eSATA and RST Configuration-\u003eSATA Mode Selection-\u003eAHCI 将SATA设置为AHCI。通过高级主机控制器接口（AHCI）模式，可以在SATA驱动器上使用高级功能，例如热插拔和本机命令队列（NCQ）。AHCI还允许硬盘以比传统IDE模式更高的速度运行。 Chipset-\u003eVT-d-\u003eDisabled 禁用VT-D。VT-d特别是IOMMU规范。扩展允许您访问虚拟机下的物理硬件（例如，运行Linux的系统可以在虚拟机上运行Windows。如果没有VT-d，则视频卡会被仿真，并且游戏速度会很慢。视频卡可以进入直通模式，并且可以在Windows下作为真实硬件（可以安装nvidia驱动程序）进行访问，并且视频卡的性能类似于运行本机Windows实时预览的情况。但是对于许多黑苹果用户，VT-D不会造成任何问题，但是如果您是新手，则尝试安装和配置Hackintosh禁用VT-D并安装。您可以在安装后根据需要启用VT-D。 Chipset-\u003eIOAPIC 24-119 Entries-\u003eEnabled ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#五bios设置"},{"categories":["黑苹果","MacOS"],"content":" 六、黑苹果安装","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#六黑苹果安装"},{"categories":["黑苹果","MacOS"],"content":" 七、更改硬盘启动","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#七更改硬盘启动"},{"categories":["黑苹果","MacOS"],"content":" 八、其他问题","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#八其他问题"},{"categories":["黑苹果","MacOS"],"content":" EFI分区扩容 分出合适空间大小，可使用Windows自带的磁盘管理或者DiskGenius。 打开DiskGenius。 找到ESP分区，右键选择备份分区到镜像文件，选择合适的文件路径并保存（选择热备份）。 删除ESP分区。 在任意分区上右键选择建立ESP/MSR分区，调整合适的分区大小并确认。 保存更改。 找到ESP分区，右键选择从镜像文件还原分区，选择刚才备份的镜像文件即可。 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#efi分区扩容"},{"categories":["黑苹果","MacOS"],"content":" 九、参考 黑果小兵的部落阁 黑苹果MacOS Big Sur 11.0 安装教程及驱动工具 主流电脑配置的通用引导文件，包含CLOVER与OpenCorer双引导 ","date":"2021-03-28","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["黑苹果","MacOS"],"title":"黑苹果安装教程","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#九参考"},{"categories":["饥荒"],"content":" 等级25级后开启制造减半后制造 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:1:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#等级"},{"categories":["饥荒"],"content":" 食谱 名称 代码 时间 保质期 饥饿、san、生命 制作 效果 百奇 sorapocky 0s ∞ 37.5、20、20 浆果×6+鸡蛋×0/1/2+蜂蜜×0/1/4 速食拉面 sora_tongmian 1.6s 20d 100/70/40、10、-5 （肉度+菜度）≥2.5 喷香蛋包饭 sora_danbaofan 16s 15d 80/56/32、10、40 蛋≥1+菜度≥0.5+肉度≥0.5 可2怪物肉 默认不放树枝。 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:2:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#食谱"},{"categories":["饥荒"],"content":" 药剂 名称 代码 制作 效果 公正 sora2gz 暖石×2+灰烬×40 恒定温度（15min） 诚实 sora2cs 荧光果×40+草×40+树枝×40 持续发光（15min） 谦卑 sora2qb 蜘蛛腺体×40 生命+40、生命+5/s（5min） 灵魂 sora2lh 灰烬×40+金块×20+莎草纸×10 san+40、san+5/s（5min） 荣誉 sora2ry 蜘蛛网×10+黑色羽毛×3+红色羽毛×3 移动速度+100%（5min） 英勇 sora2yy 蜂刺×40+燧石×40 攻击+50%（5min） 牺牲 sora2xs 狗牙×40+木炭×20+格罗姆的粘液×5 攻击+200%、防御-50%、生命-5/s（1min） 怜悯 sora2lm 治疗药膏×10+蜂蜜药膏×10+强心针×5 怪物生命+500/s（3min） 默认一次制作10个药剂 药剂同时只能生效一个，叠加使用会只有最后使用的产生效果 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:3:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#药剂"},{"categories":["饥荒"],"content":" 装备","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#装备"},{"categories":["饥荒"],"content":" 奇妙法杖 属性 属性值 代码 sora2sword 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+10% 功能 斧头、鹤嘴锄、铲子（右键开关）、锤子（右键开关）、捕虫网、鱼竿 队友能否使用 能 要求 穹10级 制作 黄金铲子×2/4/6+锤子×2/4/6+紫宝石×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#奇妙法杖"},{"categories":["饥荒"],"content":" 神奇法杖 属性 属性值 代码 sora2prop 位置 手 效果 无耐久、攻击+0、攻击距离+0、移动速度+50% 功能 只能攻击队友，将其击飞，掉落其手部装备和身上的金子 队友能否使用 能 要求 穹10级 制作 活木×10/20/30+锤子×0/4/6 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#神奇法杖"},{"categories":["饥荒"],"content":" 银白の锋 属性 属性值 代码 sora3sword 位置 手 效果 无耐久、攻击+59.5、攻击距离+1.25、移动速度+10% 功能 每次攻击回复0.5血量 队友能否使用 能 要求 穹10级 制作 影刀×1/3/5+触手尖刺×2/4/6+蝙蝠棒×1/1/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の锋"},{"categories":["饥荒"],"content":" 银白の甲 属性 属性值 代码 sora2armor 位置 身 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 木甲×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の甲"},{"categories":["饥荒"],"content":" 银白の盔 属性 属性值 代码 sora2hat 位置 头 效果 耐久2000（缝纫包可修复、归零消失）、防御+85%、移动速度+10% 功能 防水+30%、回san+3/min、作祟可复活（物品消失） 队友能否使用 能 要求 穹10级 制作 猪皮帽×2/4/6+紫宝石×3/5/10+噩梦燃料×5/10/50 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の盔"},{"categories":["饥荒"],"content":" 银白の翼 属性 属性值 代码 sora2bag 位置 包 效果 14格背包、移动速度+10% 功能 保鲜+50%、回san+3/min 队友能否使用 能 要求 穹10级 制作 冰块×80/200/400+电子元件×10/20/80 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#银白の翼"},{"categories":["饥荒"],"content":" 荣誉勋章 属性 属性值 代码 sora2amulet 位置 符 效果 移动速度+20%、攻击+20%（穹无效）、防御+20%（穹无效） 功能 防水+30%、回san+3/min、发光（多档调节，不同消耗速度，自动关闭）、 修复 关闭时自动修复0.1/s，也可用荧光果、蜗牛粘液、小发光浆果、发光浆果修复 队友能否使用 能 队友增幅 使用穹的便携烹饪锅、制作穹专属料理、快速采集、快速制作 要求 穹10级 制作 重生护符×1/2/3+寒冰护符×1/2/3+噩梦护符×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#荣誉勋章"},{"categories":["饥荒"],"content":" 穹の采 属性 属性值 代码 sorapick 位置 手 效果 无耐久、攻击+10、攻击距离+8、移动速度+25% 功能 灭火、批量采集，CD60s→0s 队友能否使用 不能 要求 穹20级 制作 懒人护符×1/2/4+活木×10/20/40+橙宝石×3/6/10+燧石×40/80/400 升级（冷却时间） 每1/2/3紫宝石，CD-12s，最高提升到0s 升级（采集范围） 每1/2/3橙宝石，范围+1，最高提升到7格 升级（灭火范围） 每10/20/30e，范围+0.5，最高提升到7格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の采"},{"categories":["饥荒"],"content":" 穹の愈 属性 属性值 代码 sorahealing 位置 手 效果 无耐久、攻击+15→35、攻击距离+8、移动速度+25% 功能 右键切换群体治疗或冰冻（消耗饱食度），CD60s，治疗效果30 队友能否使用 不能 要求 穹20级 制作 分解法杖×1/2/4+蜂蜜药膏×10/20/40+绿宝石×3/6/10+花瓣×40/80/400 升级（攻击） 每1/2/3紫宝石，攻击+4，最高提升到35 升级（冷却时间） 每1/2/3黄宝石，CD-10s，最高提升到10s 升级（治疗、冰冻） 每1/2/3绿宝石，治疗+10，最高提升到80（到55后可复活自己或队友） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の愈"},{"categories":["饥荒"],"content":" 穹の瞬 属性 属性值 代码 soratele 位置 手 效果 无耐久、攻击+17、攻击距离+12、移动速度+50% 功能 右键瞬移（CD20s，消耗40san），斧、锄、铲、锤、捕虫网、鱼竿（立刻上钩） 队友能否使用 不能 要求 穹20级 制作 瞬移法杖×1/2/4+月石×5/10/40+紫宝石×4/4/10+红色羽毛×4/10/40 升级（冷却时间） 每1/2/3紫宝石，CD-4s，最高提升到0s 升级（施法消耗） 每10/20/30噩梦燃料，消耗san-3，最高提升到10san ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:10","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の瞬"},{"categories":["饥荒"],"content":" 穹の空 属性 属性值 代码 soramagic 位置 手 效果 无耐久、攻击+20→45、攻击距离+5→10、移动速度+25% 功能 右键流星群伤技能，伤害20→120，CD30s，攻击有概率触发技能 队友能否使用 不能 要求 穹20级 制作 火焰法杖×1/2+金块×10/20+红宝石×2/6+噩梦燃料×10/20 制作（困难） 火焰法杖4+电子元件×20+红宝石×10+龙鳞×4 升级（攻击） 每5/10/15金块，攻击+0.5，最高提升到45 升级（攻击距离） 每1/2/3金丝雀羽毛，攻击距离+0.2，最高提升到10 升级（技能伤害） 每1/2/3红宝石，伤害+4，最高提升到120 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:11","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の空"},{"categories":["饥荒"],"content":" 穹の护 属性 属性值 代码 soraclothes 位置 身 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 保暖+0→240、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（保暖） 每1/2/3熊皮，保暖+48，最高提升到240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:12","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の护"},{"categories":["饥荒"],"content":" 穹の冠 属性 属性值 代码 sorahat 位置 头 效果 防御+75%→85%、耐久500→2000、移动速度+10% 功能 防雨+0→100%（满级防水）、回san+4.5/min、每10秒回复1%耐久、满级后免疫火焰伤害 队友能否使用 不能 要求 穹20级 制作 升级（防御） 每1/2/3龙鳞，防御+2%，耐久+300，最高提升到防御+85%，耐久+2000 升级（防雨） 每1/2/3巨鹿眼球，防雨+40%，最高提升到100% ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:13","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の冠"},{"categories":["饥荒"],"content":" 穹の包 属性 属性值 代码 sorabag 位置 包 效果 14格背包、出生自带、移动速度+10% 功能 保鲜（默认50%）、回san、隔热 队友能否使用 不能 要求 穹20级 制作 鸭毛×5/10+牛毛×6/20+蜘蛛网×8/20 制作（困难） 鸭毛×40+黑色羽毛×20+红色羽毛×20+紫宝石×4 升级（保鲜） 每5/10/15金块，保鲜度+10%，最高提升500% 升级（回san） 每5/10/15蜂蜜，回san+1/min，最高提升到20/min 升级（隔热） 每5/10/15冰块，隔热+4，最高提升240 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:14","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の包"},{"categories":["饥荒"],"content":" 穹の二次元蝴蝶结 属性 属性值 代码 sorabowkno 位置 符 效果 攻击+20%、防御+20%、移动速度+20% 功能 防水+30%、回san+4.5/min、发光、消耗经验打包物品作礼物 队友能否使用 不能 要求 穹20级 制作 蝴蝶×10/20/20+格罗姆翅膀×3/5/10+彩虹宝石×1/2/4 升级（发光） 每5/10/15荧光果/萤火虫/发光浆果，发光范围+0.5格，最高提升5格 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:4:15","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の二次元蝴蝶结"},{"categories":["饥荒"],"content":" 物品","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#物品"},{"categories":["饥荒"],"content":" 穹の缝纫包 属性 属性值 代码 sorarepairer 功能 重置食物新鲜度、修复装备（除了分解法杖） 制作 蜘蛛网×4/6/10+金块×1/2/3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の缝纫包"},{"categories":["饥荒"],"content":" 穹の打包纸 属性 属性值 代码 sora2pack 功能 一次制作6个（一般难度），打包建筑、植物、物品等。 要求 穹10级 制作 莎草纸×4/6/10+紫宝石×1+花瓣×10/20/60 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:5:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の打包纸"},{"categories":["饥荒"],"content":" 魔法","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#魔法"},{"categories":["饥荒"],"content":" 全部魔法 名称 代码 消耗san 效果 鸽子还没到 sora_birds 20/30/40 召唤一群鸟（20-30只） 未闻花名 sora_gardening 20/30/40 催生附近作物（包括大理石树） 提醒睡觉小助手 sora_sleep 40/50/60 催眠附近生物 都是时辰的错 sora_raining 70/90/110 下雨或天晴 空白永不败北 sora_magics 120/140/160 附近物品变化，按物品12或123循环变化 超电磁炮永世长存 sora_lighting 30/40/50 附近召唤闪电 伪典-弑君者 sora_tentacles 50/70/90 附近召唤三只触手 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#全部魔法"},{"categories":["饥荒"],"content":" 空白永不败北 物品1 物品2 物品3 浆果 蜜汁浆果 蝴蝶翅膀 黄油 青蛙腿 鸟腿 花瓣 恶魔花瓣 肥料 鸟粪 石头 燧石 硝石 冰 木炭 金子 金元宝 骨片 化石碎片 月石 月亮碎片 红宝石 蓝宝石 紫宝石 绿宝石 黄宝石 橙宝石 蓝色羽毛 黑色羽毛 红色羽毛 兔毛 猪皮 触手皮 蜘蛛腺体 蚊子血袋 蜂刺 狗牙 牛毛 蜘蛛网 牛角 海象牙 羊角 龙鳞 蛤蟆皮 蝴蝶 月娥 常青树 粗壮常青树 石化树 胡萝卜（地里） 胡萝卜鼠（地里） 曼德拉草（地里） 浆果丛 浆果灌木丛 蜜汁浆果丛 树苗根 月岛树苗根 红蘑菇（树） 蓝蘑菇（树） 绿蘑菇（树） 洋葱 辣椒 大蒜 蒜粉 辣椒面 月相盘 月台 棋盘地板 卵石路 地毯地板 贝壳地板 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:6:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#空白永不败北"},{"categories":["饥荒"],"content":" 建筑","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:0","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#建筑"},{"categories":["饥荒"],"content":" 穹の圣诞树 属性 属性值 代码 sora2tree 要求 穹5级 功能 每天可随机领取物品 制作 木板×1/5/20+松果×1/10/40+桦木果×1/10/40 升级机制：往圣诞树里放东西，点击献祭（手柄关闭后就会自动献祭），献祭会增加经验值，达到一定经验值后树就会升级，不同的物品经验值也不同，但是不需要太在意升级因为献祭获得的经验和获得礼物而扣除的经验不成正比（一根草每天白嫖不香吗），所以应该把他当做垃圾桶更合适（小声bb） ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:1","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#穹の圣诞树"},{"categories":["饥荒"],"content":" 薇诺娜的投石机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:2","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的投石机"},{"categories":["饥荒"],"content":" 薇诺娜的聚光灯 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+树枝×3+石砖×3 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:3","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的聚光灯"},{"categories":["饥荒"],"content":" 薇诺娜的发电机 属性 属性值 代码 功能 敲除掉落1个可靠的胶带 要求 穹10级 制作 穹の缝纫包×2+木头×2+硝石×2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:4","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#薇诺娜的发电机"},{"categories":["饥荒"],"content":" 秘法祭坛 属性 属性值 代码 sora2base 要求 制作（简单） 红月之眼+蓝月之眼+月石×6 制作（一般） 紫月之眼×2+黄月之眼×2+月石×20 制作（困难） 绿月之眼×3+橙月之眼×3+月石×40 火魔杖 自动攻击 冰魔杖 灭火器 传送魔杖 作为传送石的目的地 瞬移魔杖 消耗饥饿回san 解构魔杖 消耗饥饿回血 唤星者 大范围升温 访月者 大范围降温 魔杖放置在祭坛的第一格 若第二格不是噩梦燃料，则会提供大范围光源 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:5","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#秘法祭坛"},{"categories":["饥荒"],"content":" 传送石 属性 属性值 代码 sora2stone 要求 制作 金块×2+沙漠石头×0/1/1+月石×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:6","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#传送石"},{"categories":["饥荒"],"content":" 强迫の箱子 属性 属性值 代码 sora2chest 功能 25格容器，关闭时自动收集附近与第一格相同的物品，其他物品掉落（打包除外） 要求 穹10级 制作 木板×3/3/5+石砖×0/3/5+噩梦燃料×0/0/2 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:7","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#强迫の箱子"},{"categories":["饥荒"],"content":" 寒冰の箱子 属性 属性值 代码 sora2ice 功能 25格容器，永久保鲜 要求 穹10级 制作（简单） 冰块×80+木板×10+石砖×10 制作 蓝宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:8","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#寒冰の箱子"},{"categories":["饥荒"],"content":" 烈焰の箱子 属性 属性值 代码 sora2fire 功能 25格容器，烤熟食物，木头变木炭，可燃物变灰烬 要求 穹10级 制作（简单） 木炭×80+木板×10+石砖×10 制作 红宝石×6/20+木板×20/40+石砖×20/40 ","date":"2021-03-28","objectID":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/:7:9","series":null,"tags":["饥荒"],"title":"饥荒MOD小穹","uri":"/posts/%E9%A5%A5%E8%8D%92mod%E5%B0%8F%E7%A9%B9/#烈焰の箱子"},{"categories":["环境配置"],"content":" Windows 添加环境变量","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#windows-添加环境变量"},{"categories":["环境配置"],"content":" 窗口化操作 按Win + R，并输入sysdm.cpl。 选择高级，然后点击环境变量。 在系统变量区中选择Path，点击编辑。 点击新建，输入程序的执行路径（绝对路径）。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#窗口化操作"},{"categories":["环境配置"],"content":" 误删系统环境变量的补救措施 若未关闭当前CMD。输入echo %PATH%会显示原来的 PATH 值。 若已关闭当前CMD。每个正在运行的 Windows 程序都会有自己已加载的 PATH，可以使用Process Explorer来查看当前正在运行的程序的环境变量。例如：如果你之前打开了 Chrome，且一直未关闭，按Ctrl+O打开C:\\Windows\\System32\\cmd.exe，然后输入echo %PATH%会显示原来的 PATH 值。恢复之后删除C:\\Program Files\\Google\\Chrome\\Application和用户变量中的PATH值即可。 若已重启电脑。手动恢复 PATH 到默认值%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0，其他值已丢失。 参考：如何恢复我删除的Path环境变量？ ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:2","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#误删系统环境变量的补救措施"},{"categories":["环境配置"],"content":" VS CodeVisual Studio Code 官网 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#vs-code"},{"categories":["环境配置"],"content":" 1. C++ 安装编译器 Windows（二选一） 安装 Visual Studio 安装 MinGW-w64，推荐从 SourceForge 下载安装。 Linux: sudo apt install gcc g++ gdb build-essential Mac OS: xcode-select --install 安装 VS Code C/C++ 扩展ms-vscode.cpptools。 asd 解决头文件找不到 修改c_cpp_properties.json Linux：gcc -v -E -x c++ - Windows 10 + Visual Studio 2019 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/include/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64/cl.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"windows-msvc-x64\" } ], \"version\": 4 } Windows 10 + Mingw-w64 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/**\", \"C:/Portable/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Portable/mingw64/bin/g++.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\" } ], \"version\": 4 } 打开设置。 C_Cpp: Clang_format_fallback Style设为{BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4} C_Cpp › Default: Cpp Standard设为`` C_Cpp › Default: C Standard设为`` 参考 关闭 Windows Defender “首次看到时阻止”： 问题描述： 编译运行程序的时候总是弹出一个 Microsoft Defender 防病毒程序窗口，提示“需要扫描当前程序”。 解决方法： 按Win+R，输入gpedit.msc，打开本地组策略编辑器。 左侧选择计算机配置-\u003e管理模板-\u003eWindows 组件-Microsoft Defender 防病毒-\u003eMAPS。 右侧双击配置“首次看到时阻止”功能，选择已禁用，然后点击确定，保存退出。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#1-c"},{"categories":["环境配置"],"content":" Python Python官网 Miniconda官网 Anaconda官网 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#python"},{"categories":["环境配置"],"content":" pip 设置代理 Windows：%APPDATA%\\pip\\pip.ini [global] proxy = http://user:password@proxy_name:port ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#pip-设置代理"},{"categories":["环境配置"],"content":" Conda 常用命令更新：conda update 查看环境：conda env list或conda info -e 创建环境：conda create -n \u003cENVNAME\u003e python=3.X -y 删除环境：conda remove -n \u003cENVNAME\u003e --all -y 设置代理：conda config --set proxy_servers.http http://127.0.0.1:10809 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#conda-常用命令"},{"categories":["环境配置"],"content":" PyTorchPyTorch 官网 CPU： Anaconda: conda install pytorch torchvision torchaudio cpuonly -c pytorch Pip: pip install torch==1.8.1+cpu torchvision==0.9.1+cpu torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html GPU (CUDA 11.0)： Anaconda: conda install pytorch torchvision torchaudio cudatoolkit=11.0 -c pytorch Pip: pip install torch==1.7.1+cu110 torchvision==0.8.2+cu110 torchaudio===0.7.2 -f https://download.pytorch.org/whl/torch_stable.html 检查是否安装成功： import torch # 检查 pytorch 是否安装成功 print(torch.__version__) # 检查 CUDA 是否可用 print(torch.cuda.is_available()) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#pytorch"},{"categories":["环境配置"],"content":" TensorFlowTensorFlow 官网 Pip: CPU and GPU: pip install tensorflow Wheel: # https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow_cpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_cpu-2.4.1-cp38-cp38-win_amd64.whl # CPU # https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl # GPU 检查是否安装成功： import tensorflow as tf # 检查 tensorflow 是否安装成功 print(tf.__version__) # 检查 CUDA 是否可用 # 输出最后一行显示 [PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')] print(tf.config.experimental.list_physical_devices('GPU')) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#tensorflow"},{"categories":["环境配置"],"content":" Q\u0026A问题描述： 安装 CUDA 11.1 + cuDNN 8.1，tensorflow 2.4.1 检查 GPU 时报错： Could not load dynamic library 'cusolver64_10.dll'; dlerror: cusolver64_10.dll not found 解决方案： 卸载重新安装 CUDA 11.0 + cuDNN 8.0，参考 Windows 经过测试的构建配置。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#qa"},{"categories":["环境配置"],"content":" CUDA \u0026 cuDNN CUDA 和 cuDNN 版本：Windows 经过测试的构建配置 以笔记本 RTX2060 显卡为例 NVIDIA 驱动程序下载，选择对应版本，下载安装。 CUDA 工具包下载，下载对应版本安装。 在CMD输入nvcc -V，出现如下输出表示安装成功。 nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Tue_Sep_15_19:12:04_Pacific_Daylight_Time_2020 Cuda compilation tools, release 11.1, V11.1.74 Build cuda_11.1.relgpu_drvr455TC455_06.29069683_0 cuDNN 下载，需要登陆账号，登陆后下载对应版本，解压将bin、include和lib三个文件夹的内容复制到 CUDA 安装目录下。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["环境配置"],"title":"环境配置","uri":"/posts/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#cuda--cudnn"},{"categories":["Git","教程"],"content":"Git 是一个开源的分布式版本控制系统。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#"},{"categories":["Git","教程"],"content":" 1 Git 基本工作流程","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#1-git-基本工作流程"},{"categories":["Git","教程"],"content":" 1.1 本地仓库 本地历史仓库（Repository）：存放不同版本的代码。 暂存区（Index）：代码提交前的临时存储区。 工作目录（Working Tree）：修改代码的区域。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#11-本地仓库"},{"categories":["Git","教程"],"content":" 1.2 远程仓库 克隆（Clone）：将远程仓库中的内容复制到本地仓库。 推送（Push）：将本地仓库中的内容推送到远程仓库。 拉取（Pull）：更新远程仓库中的改动到本地仓库。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#12-远程仓库"},{"categories":["Git","教程"],"content":" 2 Git 常用命令 # 查看 git 状态 git status # 查看日志 git log # 查看简短日志 git reflog ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#2-git-常用命令"},{"categories":["Git","教程"],"content":" 2.1 本地仓库 # 初始化，创建 git 仓库 git init # 添加文件到暂存区 git add \u003cfile\u003e # 将暂存区文件提交到本地历史仓库 git commit -m \u003cmessage\u003e # 将所有修改或删除的文件提交到本地历史仓库（不包括新建文件） git commit -a -m \u003cmessage\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#21-本地仓库"},{"categories":["Git","教程"],"content":" 2.2 版本切换 # git reset --hard a3a9cf1 git reset --hard \u003ccommit\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#22-版本切换"},{"categories":["Git","教程"],"content":" 2.3 分支管理 切换：将HEAD指向别的分支。 合并：将main指向该分支，然后将HEAD指向main分支。 # 查看所有分支 git branch # 创建新分支 git branch \u003cbranch-name\u003e # 删除指定分支 git branch -d \u003cbranch-name\u003e # 切换到其他分支 git checkout \u003cbranch\u003e # 创建新分支，并立即切换过去 git checkout -b \u003cbranch\u003e # 将指定分支合并到当前分支 git merge \u003cbranch-name\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#23-分支管理"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add \u003cname\u003e \u003curl\u003e # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u \u003crepository\u003e \u003crefspec\u003e 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone \u003crepo\u003e # 拉取远端仓库，更新本地仓库 # git pull origin master git pull \u003crepository\u003e \u003crefspec\u003e ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#24-远程仓库"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#241-远程仓库创建"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#242-ssh-配置"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#243-本地仓库同步到远程仓库"},{"categories":["Git","教程"],"content":" 2.4 远程仓库 2.4.1 远程仓库创建 Github：全球最大。 Gitlab：国外网站。 Gitee：国内最大。 2.4.2 SSH 配置 配置用户名和邮箱，然后生成密钥（公钥和私钥）。 # 配置用户名和邮箱 git config --global user.name \"backtraxe\" git config --global user.email \"backtraxe@gmail.com\" # 生成密钥 ssh-keygen -t rsa -C \"backtraxe@gmail.com\" 进入$HOME/.ssh文件夹，复制公钥id_rsa.pub文件中的内容。 回到网页进行配置，点击右上角头像。 Github：Settings-\u003eSSH and GPG keys-\u003eNew SSH key。Title随便填，Key粘贴公钥内容。 Gitee：设置-\u003eSSH公钥。标题随便填，公钥粘贴公钥内容。 输入如下指令测试是否配置成功。 # Github ssh -T git@github.com # Gitlab ssh -T git@gitlab.com # Gitee ssh -T git@gitee.com 2.4.3 本地仓库同步到远程仓库 添加或修改文件。 添加到暂存区。 提交到本地仓库。 推送到远程仓库。 # 添加远程仓库，起一个别名 # git remote add origin https://github.com/backtraxe/backtraxe.github.io.git git remote add # 推送到远程仓库，更新远程仓库 # git push -u origin master git push -u 2.4.4 远程仓库同步到本地仓库 # 克隆远程仓库 # git clone https://github.com/backtraxe/backtraxe.github.io.git git clone # 拉取远端仓库，更新本地仓库 # git pull origin master git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#244-远程仓库同步到本地仓库"},{"categories":["Git","教程"],"content":" 2.5 代码冲突同一文件存在多个新版本，如下所示。需要先拉取远程仓库，手动修改冲突文件后，再次推送即可。 ! [rejected] master -\u003e master (fetch first) error: failed to push some refs to 'https://github.com/backtraxe/repo_for_test.git' 2.5.1 替换本地改动 # 丢弃当前文件修改内容 git checkout -- \u003cfile\u003e # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#25-代码冲突"},{"categories":["Git","教程"],"content":" 2.5 代码冲突同一文件存在多个新版本，如下所示。需要先拉取远程仓库，手动修改冲突文件后，再次推送即可。 ! [rejected] master -\u003e master (fetch first) error: failed to push some refs to 'https://github.com/backtraxe/repo_for_test.git' 2.5.1 替换本地改动 # 丢弃当前文件修改内容 git checkout -- # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#251-替换本地改动"},{"categories":["Git","教程"],"content":" 2.6 子模块 # 将一个 Git 仓库添加为当前仓库的子模块 git submodule add https://github.com/USERNAME/REPONAME.git # git clone 含有子模块的项目 # 1.项目已经克隆到了本地 git submodule init git sunmodule update # 或者 git submodule update --init # 2.项目还未克隆到本地 git clone --recurse-submodules https://github.com/USERNAME/REPONAME.git # 或者 git clone --recursive https://github.com/USERNAME/REPONAME.git ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#26-子模块"},{"categories":["Git","教程"],"content":" 2.7 .gitignore工作目录中需要 git 忽略的文件目录。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#27-gitignore"},{"categories":["Git","教程"],"content":" Q\u0026A","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#qa"},{"categories":["Git","教程"],"content":" 1. 无法连接服务器，报错443问： git clone或git push等操作时无法连接至服务器，报错内容如下： SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 答： 该问题由开启代理软件导致。设置-\u003e网络和Internet-\u003e代理，查看地址和端口，通过如下命令进行配置。 # git config --global http.proxy 127.0.0.1:10809 git config --global http.proxy IP_ADDRESS:PORT ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#1-无法连接服务器报错443"},{"categories":["Git","教程"],"content":" 参考 Git Cheat Sheets ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Git","教程"],"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/#参考"},{"categories":["饥荒"],"content":"饥荒 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#"},{"categories":["饥荒"],"content":" 科普 食物可通过觅食，陷阱，种植或者猎捕动物和怪兽获得。 不同的食物可以恢复不同的饥饿和一些生命以及理智。 但是如果吃下一些像是怪物肉或是榴梿之类的食物，可能反而会对玩家的生命值造成伤害，甚至是降低玩家的理智。 不同颜色的蘑菇针对生命值和理智值也都会对玩家产生不同的效果。 另外有些比较特殊的食物，比如发光莓，在吃下去后会给予玩家特别的效果。 大部分食物都可以通过在营火上烹饪来增加恢复的饥饿与生命或是减少（抵消）生吃对玩家造成的负面影响。 有些生的食物（通常为肉类）可以挂在干肉架上晒干来取得可以长久保存并能回复玩家饥饿/生命/理智的食物。 烹饪锅可以用来取得一些特殊料理，让玩家可以从食物中得到额外的好处（大部分的料理都有回复理智的效果，但直接食用大部分的食物都无法得到）。 肉类可以作为诱饵，可以招募猪人，可以进贡给猪王换取金块。 一个可以不断取得蛋的方法就是通过将肉喂给鸟笼中的鸟，肉类还可以制作复活肖像。 当玩家在物品栏中持有肉时会被兔人视为攻击目标。 蔬菜和水果可以当作草食动物的诱饵（像是兔子）或是喂给猪人来换取粪便。种子可以当作捕鸟陷阱的诱饵。 被视为游戏中最重要的物品之一，根据地图生成的不同，食物可以从很丰富到十分短缺都有可能。 食物受到季节的影响非常大，这鼓励玩家去根据季节挑选适合的食物（译注：像是冬天农田几乎不会生长、春天兔子不会跑出洞、只有夏天才有仙人掌花…等等例子）。 大多数的食物都会慢慢的腐烂，最后变成腐烂食物。 当食物的腐坏度为50%时，食物将会变为**不新鲜（黄色）**状态。可恢复2/3的饥饿，1/3的生命，不能恢复理智。 当食物的腐坏度为20%时，食物将会变为**变质（红色）**状态。可恢复1/2的饥饿，不能恢复生命，降低10点理智。 地面上的食物腐坏率为150%，冰箱中的腐坏率为50%，冬天食物的腐坏率为75%。 不新鲜和变质的食物对**WX-78（机器人）**没有影响。 堆叠的食物具有相同的腐烂程度，将腐烂程度不同的食物堆叠起来腐烂值取平均值。在游戏中可以利用这个设定来\"拯救\"快要腐烂的食物：将快腐烂的食物与新鲜的食物堆叠起来，然后ctrl+点击分开食物。 烹饪中的食物和在烹饪锅中的食物降低一般的腐坏度。 高脚鸟蛋，曼德拉草和巨鹿眼球是不会腐坏的。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#科普"},{"categories":["饥荒"],"content":" 食谱 类别 详细 肉类 怪物肉 鱼类 蔬菜 胡萝卜、各种蘑菇、 水果 浆果、多汁浆果、香蕉、西瓜、火龙果、石榴、榴莲 烹饪 其他 桦树果、蝴蝶翅膀、黄油、牛奶、冰、蜂蜜、腐烂食物、各种种子、齿轮、树枝、噩梦燃料、骨头碎片、花瓣 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#食谱"},{"categories":["饥荒"],"content":" 肉丸 肉度×0.5，1肉3填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 62.5 5 3 15秒 10天 食材1 食材2 食材3 食材4 怪物肉、大肉、小肉、鸡腿 浆果、冰 浆果、冰 浆果、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#肉丸"},{"categories":["饥荒"],"content":" 炖肉 肉度×3，3肉1填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 150 5 12 15秒 10天 食材1 食材2 食材3 食材4 怪物肉 大肉 大肉 浆果、冰 怪物肉 大肉 小肉 小肉 大肉 大肉 鸡腿 蛙腿 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#炖肉"},{"categories":["饥荒"],"content":" 火鸡大餐 鸡腿×2+肉度×0.5，2鸡腿1肉1填充物，两个鸡腿必须是生的。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 60秒 6天 食材1 食材2 食材3 食材4 鸡腿 鸡腿 怪物肉、大肉、小肉 浆果、蘑菇、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#火鸡大餐"},{"categories":["饥荒"],"content":" 培根煎蛋 蛋度×2+肉度×1.5，禁蔬菜、水果。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 40秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉、大肉 大肉、小肉 高脚鸟蛋 怪物肉、大肉、小肉 怪物肉、大肉、小肉 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:4","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#培根煎蛋"},{"categories":["饥荒"],"content":" 蜜汁火腿 蜂蜜×1+肉度×2，禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 30 40秒 20天 食材1 食材2 食材3 食材4 蜂蜜 怪物肉 大肉、小肉 大肉、小肉 蜂蜜 怪物肉 大肉 浆果 蜂蜜 蜂蜜 怪物肉 大肉 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:5","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#蜜汁火腿"},{"categories":["饥荒"],"content":" 果仁杂烩 烤桦树果+水果×1.5，禁冰、蔬菜。 饥饿 精神 生命 烹饪时间 腐烂时间 12.5 5 30 40秒 15天 食材1 食材2 食材3 食材4 烤桦树果 浆果 浆果 浆果 烤桦树果 烤桦树果 浆果 浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:6","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#果仁杂烩"},{"categories":["饥荒"],"content":" 波兰水饺 禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 20秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉 蘑菇 高脚鸟蛋 浆果 怪物肉 蘑菇 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:7","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#波兰水饺"},{"categories":["饥荒"],"content":" 火龙果派 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 40 40秒 15天 食材1 食材2 食材3 食材4 火龙果 树枝、浆果 树枝、浆果 树枝、浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:8","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#火龙果派"},{"categories":["饥荒"],"content":" 华夫饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 60 10秒 6天 食材1 食材2 食材3 食材4 黄油 鸡蛋、高脚鸟蛋 浆果 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:9","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#华夫饼"},{"categories":["饥荒"],"content":" 炸鱼条 鱼+树枝 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 40秒 10天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:10","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#炸鱼条"},{"categories":["饥荒"],"content":" 太妃糖 蜂蜜×3 饥饿 精神 生命 烹饪时间 腐烂时间 25 15 -3 40秒 15天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:11","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#太妃糖"},{"categories":["饥荒"],"content":" 蝴蝶松饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 20 40秒 15天 食材1 食材2 食材3 食材4 蝴蝶翅膀 蘑菇 树枝 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:12","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#蝴蝶松饼"},{"categories":["饥荒"],"content":" 粉末蛋糕 玉米+蜂蜜，腐烂时间很久。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:13","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#粉末蛋糕"},{"categories":["饥荒"],"content":" 人物 mod","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#人物-mod"},{"categories":["饥荒"],"content":" 宝石萝莉宝石萝莉完整攻略 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#宝石萝莉"},{"categories":["饥荒"],"content":" 参考资料 Don’t Starve 中文维基 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["饥荒"],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/#参考资料"},{"categories":null,"content":" 1.准备工作 VPS：CN2 GIA-E \u003e CN2 GIA \u003e CN2 GT \u003e CN2 \u003e KVM BandwagonHost Vultr 域名 免费：Freenom 付费：NameSilo DNS \u0026 CDN： Cloudflare ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#1准备工作"},{"categories":null,"content":" 2.服务端","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#2服务端"},{"categories":null,"content":" 2.1 Xray_onekeyGithub 安装： wget -N --no-check-certificate -q -O install.sh \"https://raw.githubusercontent.com/wulabing/Xray_onekey/main/install.sh\" \u0026\u0026 chmod +x install.sh \u0026\u0026 bash install.sh 查看配置： ~/install.sh ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#21-xray_onekey"},{"categories":null,"content":" 2.2 x-uiGithub 安装： bash \u003c(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) 查看配置： x-ui ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#22-x-ui"},{"categories":null,"content":" 3.客户端","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#3客户端"},{"categories":null,"content":" 3.1 Windows v2rayNGithub Clash for WindowsGithub ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#31-windows"},{"categories":null,"content":" 3.1 Windows v2rayNGithub Clash for WindowsGithub ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#v2rayn"},{"categories":null,"content":" 3.1 Windows v2rayNGithub Clash for WindowsGithub ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#clash-for-windows"},{"categories":null,"content":" 3.2 安卓 v2rayNG Github Google Play Clash for Android Github Google Play ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#32-安卓"},{"categories":null,"content":" 3.2 安卓 v2rayNG Github Google Play Clash for Android Github Google Play ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#v2rayng"},{"categories":null,"content":" 3.2 安卓 v2rayNG Github Google Play Clash for Android Github Google Play ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#clash-for-android"},{"categories":null,"content":" 3.3 iOS Shadowrocket","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#33-ios"},{"categories":null,"content":" 3.3 iOS Shadowrocket","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#shadowrocket"},{"categories":null,"content":" 3.4 macOS Clash for Windows","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#34-macos"},{"categories":null,"content":" 3.4 macOS Clash for Windows","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#clash-for-windows-1"},{"categories":null,"content":" 参考 在 WSL 2 中访问主机代理 - Geek 成长录 WSL2内使用windows的v2ray代理配置方式。 - 知乎 ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["科学上网"],"title":"科学上网教程","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/#参考"},{"categories":["C++","数据结构","算法"],"content":"竞赛算法集合。 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:0:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#"},{"categories":["C++","数据结构","算法"],"content":" 1 STL 小技巧","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#1-stl-小技巧"},{"categories":["C++","数据结构","算法"],"content":" 1.1 头文件 /*** 函数 ***/ #include\u003calgorithm\u003e #include\u003cfunctional\u003e // hash #include\u003cclimits\u003e // 常量 #include\u003ccmath\u003e #include\u003ccstdio\u003e #include\u003ccstdlib\u003e // 随机数生成 random #include\u003cctime\u003e #include\u003ciostream\u003e #include\u003csstream\u003e #include\u003ciomanip\u003e // 格式化 right 和 setw(width) /*** 数据结构 ***/ #include\u003cdeque\u003e // 双端队列 #include\u003clist\u003e #include\u003cqueue\u003e // 包含 priority_queue #include\u003cstack\u003e #include\u003cstring\u003e #include\u003cvector\u003e ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#11-头文件"},{"categories":["C++","数据结构","算法"],"content":" 1.2 I/O cin \u003e\u003e n; getline(cin, str); // 接收换行符 getline(cin, str); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#12-io"},{"categories":["C++","数据结构","算法"],"content":" 1.3 常量 #include\u003cclimits\u003e INT_MIN INT_MAX LONG_MIN LONG_MAX LLONG_MIN LLONG_MAX (~0u) // 无穷大 (for long and long long) (~0u)\u003e\u003e2 // 无穷大 (for int) ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#13-常量"},{"categories":["C++","数据结构","算法"],"content":" 1.4 数学 // 当数字很大时，用 powl 代替 pow powl(a, b); // p 的 n 方根 (int)round(p, (1.0/n)); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#14-数学"},{"categories":["C++","数据结构","算法"],"content":" 1.5 初始化数组 // 一维数组 fill(arr, arr + sizeof(arr), value); fill_n(arr, sizeof(arr), value); // 二维数组，只能填充 0 或 -1 memset(arr, 0, sizeof(arr)); for (int i = 0; i \u003c row; i++) fill(a[i], a[i] + sizeof(a[i]), value); ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:5","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#15-初始化数组"},{"categories":["C++","数据结构","算法"],"content":" 1.6 修改序列 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:6","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#16-修改序列"},{"categories":["C++","数据结构","算法"],"content":" 动态规划","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#动态规划"},{"categories":["C++","数据结构","算法"],"content":" 凸包技巧https://codeforces.com/contest/319/problem/C #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; typedef long long ll; const int MAXN = 105000; int n; ll height[MAXN], tax[MAXN]; ll dp[MAXN]; vector\u003cll\u003e mvals, bvals; int cur = 0; // Suppose the last 3 lines added are : (l1, l2, l3) // Line l2 becomes irrelevant, if l1/l3 x-intersection is to the left of l1/l2 x-intersection bool bad(ll m1, ll b1, ll m2, ll b2, ll m3, ll b3) { // 转为 double 避免溢出 return 1.0 * (b1 - b3) * (m2 - m1) \u003c 1.0 * (b1 - b2) * (m3 - m1); } void add(ll m, ll b) { while ( (int) mvals.size() \u003e= 2 \u0026\u0026 bad(mvals[mvals.size() - 2], bvals[bvals.size() - 2], mvals[mvals.size() - 1], bvals[bvals.size() - 1], m, b)) { mvals.pop_back(); bvals.pop_back(); } mvals.push_back(m); bvals.push_back(b); } void setCur(ll x) { if (cur \u003e (int) mvals.size() - 1) cur = (int) mvals.size() - 1; // Best-line pointer goes to the right only when queries are non-decreasing (x argument grows) while (cur \u003c (int) mvals.size() - 1 \u0026\u0026 1.0 * mvals[cur + 1] * x + bvals[cur + 1] \u003c= 1.0 * mvals[cur] * x + bvals[cur]) cur++; } int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026height[i]); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026tax[i]); // Formula is dp[i] = min(tax[j] * height[i] + dp[j] | j = 1 .. i - 1) // Here tax[j] is considered as m value, and dp[j] as b value in line equation y = m * x + b for (int i = 1; i \u003c= n; i++) { if (i == 1) { dp[i] = 0; } else { setCur(height[i]); dp[i] = mvals[cur] * height[i] + bvals[cur]; } add(tax[i], dp[i]); } cout \u003c\u003c dp[n]; return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#凸包技巧"},{"categories":["C++","数据结构","算法"],"content":" 最长递增序列https://informatics.msk.ru/mod/statements/view3.php?id=766\u0026chapterid=1794 $O(N \\log N)$ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = 1000 * 1000 * 1000; int n; int k, b, m; int a[MAXN]; int d[MAXN]; int ind[MAXN], pr[MAXN]; vector \u003cint\u003e ansv; int ans = 1; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); scanf(\"%d %d %d %d\", \u0026a[1], \u0026k, \u0026b, \u0026m); for (int i = 2; i \u003c= n; i++) a[i] = (k * a[i - 1] + b) % m; d[0] = -INF; for (int i = 1; i \u003c= n; i++) d[i] = INF; for (int i = 1; i \u003c= n; i++) { int pos = upper_bound(d + 1, d + n + 1, a[i]) - d; if (d[pos - 1] \u003c a[i] \u0026\u0026 a[i] \u003c d[pos]) { d[pos] = a[i]; ind[pos] = i; pr[i] = ind[pos - 1]; if (pos \u003e ans) { ans = pos; } } } if (ans == 1) { printf(\"%d\", a[1]); } else { int cur = ind[ans]; while (cur != 0) { ansv.push_back(a[cur]); cur = pr[cur]; } for (int i = (int) ansv.size() - 1; i \u003e= 0; i--) printf(\"%d \", ansv[i]); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最长递增序列"},{"categories":["C++","数据结构","算法"],"content":" 数据结构","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#数据结构"},{"categories":["C++","数据结构","算法"],"content":" 笛卡尔树Balanced Binary Search Tree https://informatics.msk.ru/mod/statements/view3.php?chapterid=2782 $O(\\log N)$ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int mod = 1000 * 1000 * 1000; struct node { int x, y; node *l, *r; node(int new_x, int new_y) { x = new_x; y = new_y; l = NULL; r = NULL; } }; typedef node * pnode; void merge(pnode \u0026t, pnode l, pnode r) { if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } } void split(pnode t, int x, pnode \u0026l, pnode \u0026r) { if (t == NULL) l = r = NULL; else if (t-\u003ex \u003e x) { split(t-\u003el, x, l, t-\u003el); r = t; } else { split(t-\u003er, x, t-\u003er, r); l = t; } } void add(pnode \u0026t, pnode a) { if (t == NULL) t = a; else if (a-\u003ey \u003e t-\u003ey) { split(t, a-\u003ex, a-\u003el, a-\u003er); t = a; } else { if (t-\u003ex \u003c a-\u003ex) add(t-\u003er, a); else add(t-\u003el, a); } } int next(pnode t, int x) { int ans = -1; while (t != NULL) { if (t-\u003ex \u003c x) t = t-\u003er; else { if (ans == -1 || ans \u003e t-\u003ex) ans = t-\u003ex; t = t-\u003el; } } return ans; } int n, ans, x; char qt, prev_qt; pnode root = NULL, num; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\\n\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%c %d\\n\", \u0026qt, \u0026x); if (qt == '+') { if (prev_qt == '?') x = (x + ans) % mod; num = new node(x, rand()); add(root, num); } else { ans = next(root, x); printf(\"%d\\n\", ans); } prev_qt = qt; } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#笛卡尔树"},{"categories":["C++","数据结构","算法"],"content":" 带有隐式键的笛卡尔树https://informatics.msk.ru/mod/statements/view3.php?chapterid=111240 $O(\\log N)$ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003cutility\u003e #include \u003ccstring\u003e #include \u003ciomanip\u003e using namespace std; const int INF = 2 * 1000 * 1000 * 1000; struct node { int y, val; int sz, mn; bool rev; node *l, *r; node (int new_val, int new_y) { y = new_y; val = new_val; sz = 1; mn = val; rev = false; l = NULL; r = NULL; } }; typedef node * pnode; int getsize(pnode t) { if (t == NULL) return 0; return t-\u003esz; } int getmin(pnode t) { if (t == NULL) return INF; return t-\u003emn; } void update(pnode t) { if (t == NULL) return; t-\u003esz = getsize(t-\u003el) + 1 + getsize(t-\u003er); t-\u003emn = min(t-\u003eval, min(getmin(t-\u003er), getmin(t-\u003el))); } void push(pnode t) { if (t \u0026\u0026 t-\u003erev) { swap(t-\u003el, t-\u003er); if (t-\u003el) t-\u003el-\u003erev ^= true; if (t-\u003er) t-\u003er-\u003erev ^= true; t-\u003erev = false; } } void merge(pnode \u0026t, pnode l, pnode r) { push(l); push(r); if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } update(t); } void split(pnode t, pnode \u0026l, pnode \u0026r, int x, int add = 0) { push(t); if (t == NULL) { l = r = NULL; return; } int key = getsize(t-\u003el) + 1 + add; if (x \u003c= key) { split(t-\u003el, l, t-\u003el, x, add); r = t; } else { split(t-\u003er, t-\u003er, r, x, add + getsize(t-\u003el) + 1); l = t; } update(t); } void reverse(pnode t, int l, int r) { pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); a-\u003erev ^= true; merge(t, t, a); merge(t, t, b); } int getmin(pnode t, int l, int r) { int ans; pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); ans = getmin(a); merge(t, t, a); merge(t, t, b); return ans; } int n, m; int qt, l, r; pnode root = NULL, add; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int x; sca","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#带有隐式键的笛卡尔树"},{"categories":["C++","数据结构","算法"],"content":" 树状数组$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3317 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; int a[MAXN]; long long f[MAXN]; char q; int l, r; void update(int pos, int delta) { for (; pos \u003c= n; pos = (pos | (pos + 1))) f[pos] += delta; } long long sum(int pos) { long long res = 0; for (; pos \u003e 0; pos = (pos \u0026 (pos + 1)) - 1) res += f[pos]; return res; } long long sum(int l, int r) { return sum(r) - sum(l - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026a[i]); update(i, a[i]); } scanf(\"%d\\n\", \u0026m); for (int i = 1; i \u003c= m; i++) { scanf(\"%c %d %d\\n\", \u0026q, \u0026l, \u0026r); if (q == 's') { cout \u003c\u003c sum(l, r) \u003c\u003c \" \"; } else { int delta = r - a[l]; a[l] = r; update(l, delta); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#树状数组"},{"categories":["C++","数据结构","算法"],"content":" 二维树状数组$O((\\log N)^2)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3013 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 1050; int n, m; int qn; char q[10]; int f[MAXN][MAXN]; void update(int x, int y, int delta) { for (int i = x; i \u003c= n; i = i | (i + 1)) for (int j = y; j \u003c= m; j = j | (j + 1)) f[i][j] += delta; } int getSum(int x, int y) { int res = 0; for (int i = x; i \u003e 0; i = (i \u0026 (i + 1)) - 1) for (int j = y; j \u003e 0; j = (j \u0026 (j + 1)) - 1) res += f[i][j]; return res; } int getSum(int xFrom, int xTo, int yFrom, int yTo) { return getSum(xTo, yTo) - getSum(xTo, yFrom - 1) - getSum(xFrom - 1, yTo) + getSum(xFrom - 1, yFrom - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026qn); m = n; for (int i = 1; i \u003c= qn; i++) { scanf(\"%s\", \u0026q); if (q[0] == 'A') { int x, y; scanf(\"%d %d\\n\", \u0026x, \u0026y); update(x, y, 1); } else { int xFrom, xTo, yFrom, yTo; scanf(\"%d %d %d %d\\n\", \u0026xFrom, \u0026yFrom, \u0026xTo, \u0026yTo); if (xFrom \u003e xTo) swap(xFrom, xTo); if (yFrom \u003e yTo) swap(yFrom, yTo); printf(\"%d\\n\", getSum(xFrom, xTo, yFrom, yTo)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#二维树状数组"},{"categories":["C++","数据结构","算法"],"content":" 隐式的线段树 时间复杂度：$O(\\log N)$ 空间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3327 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstdlib\u003e using namespace std; typedef long long ll; struct Node { ll sum; Node *l, *r; Node() : sum(0), l(NULL), r(NULL) { } }; void add(Node *v, int l, int r, int q_l, int q_r, ll val) { if (l \u003e r || q_r \u003c l || q_l \u003e r) return; if (q_l \u003c= l \u0026\u0026 r \u003c= q_r) { v -\u003e sum += val; return; } int mid = (l + r) \u003e\u003e 1; if (v -\u003e l == NULL) v -\u003e l = new Node(); if (v -\u003e r == NULL) v -\u003e r = new Node(); add(v -\u003e l, l, mid, q_l, q_r, val); add(v -\u003e r, mid + 1, r, q_l, q_r, val); } ll get(Node *v, int l, int r, int pos) { if (!v || l \u003e r || pos \u003c l || pos \u003e r) return 0; if (l == r) return v -\u003e sum; int mid = (l + r) \u003e\u003e 1; return v -\u003e sum + get(v -\u003e l, l, mid, pos) + get(v -\u003e r, mid + 1, r, pos); } int n, m, t, x, y, val; char c; int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); Node *root = new Node(); scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026x); add(root, 0, n - 1, i, i, x); } scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"\\n%c\", \u0026c); if (c == 'a') { scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026val); add(root, 0, n - 1, --x, --y, val); } else { scanf(\"%d\", \u0026x); printf(\"%I64d \", get(root, 0, n - 1, --x)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:5","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#隐式的线段树"},{"categories":["C++","数据结构","算法"],"content":" 最小队列 时间复杂度：$O(1)$ https://informatics.msk.ru//mod/statements/view.php?chapterid=756 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 205000; int n, m; deque \u003c pair \u003cint, int\u003e \u003e d; int a[MAXN]; void enqueue(int x) { int num = 1; while (!d.empty() \u0026\u0026 d.back().first \u003e x) { num += d.back().second; d.pop_back(); } d.push_back(make_pair(x, num)); } void dequeue() { if (d.front().second == 1) { d.pop_front(); } else { d.front().second--; } } int getMin() { return d.front().first; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); for (int i = 1; i \u003c= m; i++) { enqueue(a[i]); } printf(\"%d\\n\", getMin()); for (int i = m + 1; i \u003c= n; i++) { dequeue(); enqueue(a[i]); printf(\"%d\\n\", getMin()); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:6","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最小队列"},{"categories":["C++","数据结构","算法"],"content":" 线段树（加法-最小间隔-最大间隔）https://codeforces.com/contest/1263/problem/E #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 1000 * 1000 + 100; const int INF = (int) 1e9; struct node { int mx, mn; int add; }; int n; int val[MAXN]; string s; int pos; node tree[4 * MAXN]; void add(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; if (L == l \u0026\u0026 R == r) { tree[v].add += val; } else { int mid = L + (R - L) / 2; add(2 * v + 1, L, mid, l, min(mid, r), val); add(2 * v + 2, mid + 1, R, max(mid + 1, l), r, val); tree[v].mx = max(tree[2 * v + 1].mx + tree[2 * v + 1].add, tree[2 * v + 2].mx + tree[2 * v + 2].add); tree[v].mn = min(tree[2 * v + 1].mn + tree[2 * v + 1].add, tree[2 * v + 2].mn + tree[2 * v + 2].add); } } int getMin(int v, int L, int R, int l, int r) { if (l \u003e r) { return INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mn + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + min(getMin(2 * v + 1, L, mid, l, min(mid, r)), getMin(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int getMax(int v, int L, int R, int l, int r) { if (l \u003e r) { return -INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mx + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + max(getMax(2 * v + 1, L, mid, l, min(mid, r)), getMax(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\\n\", \u0026n); getline(cin, s); pos = 0; for (int i = 0; i \u003c (int) s.length(); i++) { if (s[i] == 'L') { if (pos \u003e 0) pos--; } else if (s[i] == 'R') { pos++; } else { int newVal = 0; if (s[i] == '(') { newVal = 1; } else if (s[i] == ')') { newVal = -1; } int delta = newVal - val[pos]; val[pos] = newVal; add(0, 0, n - 1, pos, n - 1, delta); } int mn = getMin(0, 0, n - 1, 0, n - ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:7","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树加法-最小间隔-最大间隔"},{"categories":["C++","数据结构","算法"],"content":" 线段树（分配-求和）https://codeforces.com/gym/100093 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int zero = -1; struct node { long long sum; int val; int size; }; int n, m; char qt; int x, l, r; int a[MAXN]; vector \u003cnode\u003e tree; void build (int v, int L, int R, int a[]) { if (L == R) { tree[v].sum = tree[v].val = a[L]; tree[v].size = 1; } else { int mid = L + (R - L) / 2; build(2 * v, L, mid, a); build(2 * v + 1, mid + 1, R, a); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; tree[v].val = zero; tree[v].size = tree[2 * v + 1].size + tree[2 * v].size; } } void push(int v) { if (tree[v].val == zero) return; if (tree[v].size != 1) { tree[2 * v].val = tree[v].val; tree[2 * v + 1].val = tree[v].val; } tree[v].sum = 1ll * tree[v].size * tree[v].val; tree[v].val = zero; } void assign(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; push(v); if (L == l \u0026\u0026 R == r) { tree[v].val = val; tree[v].sum = 1ll * val * tree[v].size; } else { int mid = L + (R - L) / 2; assign(2 * v, L, mid, l, min(mid, r), val); assign(2 * v + 1, mid + 1, R, max(mid + 1, l), r, val); push(2 * v); push(2 * v + 1); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; } push(v); } long long getsum(int v, int L, int R, int l, int r) { if (l \u003e r) return 0; push(v); if (l == L \u0026\u0026 r == R) return tree[v].sum; int mid = L + (R - L) / 2; long long res = getsum(2 * v, L, mid, l, min(mid, r)) + getsum(2 * v + 1, mid + 1, R, max(l, mid + 1), r); return res; } int main() { assert(freopen(\"sum.in\",\"r\",stdin)); assert(freopen(\"sum.out\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026m); tree.resize(4 * n); build(1, 1, n, a); for (int i = 1; i \u003c= m; i++) { scanf(\"%c\", \u0026qt); if (qt == 'A') { scanf(\"%d %d %d\\n\", \u0026l, \u0026r, \u0026x); assign(1, 1, n, l, r, x); } else { scanf(\"%d %d\\n\"","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:8","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树分配-求和"},{"categories":["C++","数据结构","算法"],"content":" 线段树（最小值-值更新） 预先计算：$O(N \\log N)$ 查询：$O(1)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = (int) 1e9; int n, num, qn; int a[MAXN]; int tree[4 * MAXN]; int l, r; int getMax(int l, int r) { l = num + l - 1; r = num + r - 1; int res = -INF; while (l \u003c= r) { if (l \u0026 1) { res = max(res, tree[l]); l++; } if (r % 2 == 0) { res = max(res, tree[r]); r--; } l /= 2; r /= 2; } return res; } void update(int pos, int val) { pos = num + pos - 1; tree[pos] = val; pos /= 2; while (pos \u003e= 1) { tree[pos] = max(tree[pos * 2], tree[pos * 2 + 1]); pos /= 2; } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); num = 1; while (num \u003c n) num *= 2; for (int i = num; i \u003c 2 * num; i++) { if (i - num + 1 \u003c= n) tree[i] = a[i - num + 1]; else tree[i] = -INF; } for (int i = num - 1; i \u003e= 1; i--) { tree[i] = max(tree[i * 2], tree[i * 2 + 1]); } scanf(\"%d\", \u0026qn); for (int i = 1; i \u003c= qn; i++) { scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:9","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#线段树最小值-值更新"},{"categories":["C++","数据结构","算法"],"content":" 稀疏表 预先计算：$O(N)$ 查询：$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 2 * 105000; const int MAXLOG = 20; int n, m; int a[MAXN]; int table[MAXLOG][MAXN]; int numlog[MAXN]; void buildTable() { numlog[1] = 0; for (int i = 2; i \u003c= n; i++) numlog[i] = numlog[i / 2] + 1; for (int i = 0; i \u003c= numlog[n]; i++) { int curlen = 1 \u003c\u003c i; for (int j = 1; j \u003c= n; j++) { if (i == 0) { table[i][j] = a[j]; continue; } table[i][j] = max(table[i - 1][j], table[i - 1][j + curlen / 2]); } } } int getMax(int l, int r) { int curlog = numlog[r - l + 1]; return max(table[curlog][l], table[curlog][r - (1 \u003c\u003c curlog) + 1]); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); buildTable(); scanf(\"%d\", \u0026m); for (int i = 1; i \u003c= m; i++) { int l, r; scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:10","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#稀疏表"},{"categories":["C++","数据结构","算法"],"content":" 几何","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#几何"},{"categories":["C++","数据结构","算法"],"content":" 最近点对 时间复杂度：$O(N \\log N)$ https://www.spoj.com/problems/CLOPPAIR/ #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; #define sqr(x) ((x) * (x)) const double inf = 1e100; const int MAXN = 105000; struct point { double x, y; int ind; }; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } int n; int a[MAXN]; point p[MAXN], tmp[MAXN]; double ans = inf; int p1, p2; void updateAnswer(point a, point b) { double d = dist(a, b); if (d \u003c ans) { ans = d; p1 = a.ind; p2 = b.ind; } } void closestPair(int l, int r) { if (l \u003e= r) return; if (r - l == 1) { if (p[l].y \u003e p[r].y) swap(p[l], p[r]); updateAnswer(p[l], p[r]); return; } int m = (l + r) / 2; double mx = p[m].x; closestPair(l, m); closestPair(m + 1, r); int lp = l, rp = m + 1, sz = 1; while (lp \u003c= m || rp \u003c= r) { if (lp \u003e m || ((rp \u003c= r \u0026\u0026 p[rp].y \u003c p[lp].y))) { tmp[sz] = p[rp]; rp++; } else { tmp[sz] = p[lp]; lp++; } sz++; } for (int i = l; i \u003c= r; i++) p[i] = tmp[i - l + 1]; sz = 0; for (int i = l; i \u003c= r; i++) if (abs(p[i].x - mx) \u003c ans) { sz++; tmp[sz] = p[i]; } for (int i = 1; i \u003c= sz; i++) { for (int j = i - 1; j \u003e= 1; j--) { if (tmp[i].y - tmp[j].y \u003e= ans) break; updateAnswer(tmp[i], tmp[j]); } } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%lf %lf\", \u0026p[i].x, \u0026p[i].y); p[i].ind = i - 1; } sort(p + 1, p + n + 1, cmp); closestPair(1, n); printf(\"%d %d %.6lf\\n\", min(p1, p2), max(p1, p2), ans); return 0; } #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003calgorithm\u003e #include \u003ccmath\u003e using namespace std; #define sqr(a) ((a)*(a)) const double inf = 1e100; const int MAXN = 55000; stru","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#最近点对"},{"categories":["C++","数据结构","算法"],"content":" 凸包Graham-Andrew 方法 时间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view3.php?chapterid=638 https://informatics.msk.ru/mod/statements/view3.php?id=\u0026chapterid=290 #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003ccmath\u003e using namespace std; #define sqr(x) ((x) * (x)) const double pi = acos(-1.0); struct point { double x, y; }; int n; vector \u003cpoint\u003e p, hull; double ans; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } bool eq(point a, point b) { return (a.x == b.x \u0026\u0026 a.y == b.y); } bool isCCW(point a, point b, point c) { return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) \u003e 0; } void setConvexHull(vector \u003cpoint\u003e p, vector \u003cpoint\u003e \u0026h) { sort(p.begin(), p.end(), cmp); p.erase(unique(p.begin(), p.end(), eq), p.end()); vector \u003cpoint\u003e up, down; point head = p[0], tail = p.back(); up.push_back(head); down.push_back(head); for (int i = 1; i \u003c (int) p.size(); i++) { if (i == (int) p.size() - 1 || !isCCW(tail, head, p[i])) { while ( (int) up.size() \u003e= 2 \u0026\u0026 isCCW(up[up.size() - 2], up.back(), p[i]) ) up.pop_back(); up.push_back(p[i]); } if (i == (int) p.size() - 1 || isCCW(tail, head, p[i])) { while ( (int) down.size() \u003e= 2 \u0026\u0026 !isCCW(down[down.size() - 2], down.back(), p[i]) ) down.pop_back(); down.push_back(p[i]); } } h.clear(); for (int i = 0; i \u003c (int) up.size(); i++) h.push_back(up[i]); for (int i = (int) down.size() - 2; i \u003e 0; i--) h.push_back(down[i]); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } double getPerimeter(vector \u003cpoint\u003e p) { double per = 0; for (int i = 1; i \u003c (int) p.size(); i++) per += dist(p[i - 1], p[i]); per += dist(p.back(), p[0]); return per; } int main() { freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { point tmp; scanf(\"%lf %lf\", \u0026tmp.x, \u0026tmp.y); p.push_back(tmp); } setConvexHull(p, hull); ans = getPerimeter(hull); printf(\"%.1lf\", ans); return 0; } 时间复杂度：$O(sort) + O(N)$ #include \u003ccstd","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#凸包"},{"categories":["C++","数据结构","算法"],"content":" 图","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#图"},{"categories":["C++","数据结构","算法"],"content":" Bellman-Ford 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view3.php?id=260\u0026chapterid=178 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105; const int INF = 30000; struct edge { int from, to; int w; }; int n, m; int dist[MAXN]; vector \u003cedge\u003e e; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { edge curEdge; scanf(\"%d %d %d\", \u0026curEdge.from, \u0026curEdge.to, \u0026curEdge.w); e.push_back(curEdge); } for (int i = 1; i \u003c= n; i++) dist[i] = INF; dist[1] = 0; for (int i = 1; i \u003c= n; i++) { bool changed = false; for (int j = 0; j \u003c m; j++) { int from = e[j].from, to = e[j].to, w = e[j].w; if (dist[from] != INF \u0026\u0026 dist[from] + w \u003c dist[to]) { dist[to] = dist[from] + w; changed = true; } } if (!changed) break; } for (int i = 1; i \u003c= n; i++) printf(\"%d \", dist[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:1","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#bellman-ford-算法"},{"categories":["C++","数据结构","算法"],"content":" 二部图匹配Kuhn 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=1683 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105; int n, m; vector \u003cint\u003e g[MAXN]; bool used[MAXN]; int mt[MAXN]; int ans; bool kuhn(int v) { if (used[v]) return false; used[v] = true; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (mt[to] == 0 || kuhn(mt[to])) { mt[to] = v; return true; } } return false; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int can; scanf(\"%d\", \u0026can); if (can) g[i].push_back(j); } } for (int i = 1; i \u003c= n; i++) { memset(used, 0, sizeof(used)); if (kuhn(i)) ans++; } printf(\"%d\\n\", ans); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:2","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#二部图匹配"},{"categories":["C++","数据结构","算法"],"content":" 桥搜索 时间复杂度：$O(M)$ https://codeforces.com/gym/100083 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cstack\u003e #include \u003cqueue\u003e #include \u003ccstdlib\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #include \u003ccassert\u003e #include \u003cutility\u003e #include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; vector \u003cint\u003e g[MAXN]; vector \u003cint\u003e ind[MAXN]; int tin[MAXN], mn[MAXN]; bool used[MAXN]; vector \u003cint\u003e bridges; int timer; void dfs(int v, int par = -1) { used[v] = true; timer++; tin[v] = timer; mn[v] = tin[v]; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { dfs(to, v); if (mn[to] == tin[to]) { bridges.push_back(ind[v][i]); } mn[v] = min(mn[v], mn[to]); } else if (to != par) { mn[v] = min(mn[v], mn[to]); } } } int main() { assert(freopen(\"bridges.in\",\"r\",stdin)); assert(freopen(\"bridges.out\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { int from, to; scanf(\"%d %d\", \u0026from, \u0026to); g[from].push_back(to); ind[from].push_back(i); g[to].push_back(from); ind[to].push_back(i); } for (int i = 1; i \u003c= n; i++) if (!used[i]) dfs(i); sort(bridges.begin(), bridges.end()); printf(\"%d\\n\", (int) bridges.size()); for (int i = 0; i \u003c (int) bridges.size(); i++) printf(\"%d\\n\", bridges[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:3","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#桥搜索"},{"categories":["C++","数据结构","算法"],"content":" 拓扑排序 #include\u003ciostream\u003e using namespace std; int n = 100; int f[100]={0}, ans[100]={0}; bool g[100][100]={0} ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:4","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#拓扑排序"},{"categories":["C++","数据结构","算法"],"content":" 参考资料 ADJA/algos: Competitive programming algorithms in C++ - GitHub ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:6:0","series":null,"tags":["C++","数据结构","算法"],"title":"竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/#参考资料"},{"categories":["Linux"],"content":" 快捷键 Tab 补全命令 Ctrl + C 停止当前运行中的程序 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#快捷键"},{"categories":["Linux"],"content":" ls显示目录内容。 # 指定目录，默认当前目录 ls \u003cpath\u003e # 列出详细信息 # 权限、用户、用户组、大小、修改时间、名称 ls -l # 文件大小显示更直观 ls -lh # 列出所有文件（包括隐藏） ls -a # 按修改时间从近到远排序 ls -t # 按文件大小从大到小排序 ls -S # 逆序排序 ls -r # 纵向显示（一行一个） ls -1 # 横向显示（逗号分隔） ls -m drwxrwxrwx 第1位，d，文件类型。 d：目录。 -：一般文件。 第2-4位，rwx，文件创建者的权限。 第5-7位，rwx，文件创建者同用户组成员的权限。 第8-10位，rwx，其他成员的权限。 rwx r，读取权限。二进制为100，十进制即4。 w，写入权限。二进制为010，十进制即2。 x，执行权限。二进制为001，十进制即1。 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ls"},{"categories":["Linux"],"content":" ssh远程登录。 # 默认端口 22 ssh \u003cuser\u003e@\u003cip\u003e # 指定端口 ssh \u003cuser\u003e@\u003cip\u003e -p \u003cport\u003e # ssh 免密登录 # 为当前用户生成 ssh 公钥 + 私钥。 # 默认保存在 $home/.ssh/ 文件夹中。 # id_rsa 是私钥，id_rsa.pub 是公钥。 ssh-keygen # 将当前用户的公钥复制到服务器的 ~/.ssh/authorized_keys 文件 ssh-copy-id \u003cuser\u003e@\u003cip\u003e:\u003cport\u003e # 或者手动将公钥添加到服务器的 ~/.ssh/authorized_keys 文件 ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ssh"},{"categories":["Linux"],"content":" scp在本地主机和远程主机之间传输文件。 # 本地主机的文件上传到远程主机 # 单个文件 scp \u003cfile\u003e \u003cuser\u003e@\u003cip\u003e:\u003cpath\u003e -P \u003cssh_port\u003e # 目录 scp -r \u003cfolder\u003e \u003cuser\u003e@\u003cip\u003e:\u003cpath\u003e -P \u003cssh_port\u003e # 远程主机的文件下载到本地主机 # 单个文件 scp \u003cuser\u003e@\u003cip\u003e:\u003cfile\u003e \u003cpath\u003e -P \u003cssh_port\u003e # 目录 scp -r \u003cuser\u003e@\u003cip\u003e:\u003cfolder\u003e \u003cpath\u003e -P \u003cssh_port\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#scp"},{"categories":["Linux"],"content":" grepGlobal search REgular expression and Print out the line 打印指定模式匹配到的所有行，支持多文件、正则表达式。 grep [OPTION]... PATTERNS [FILE]... 默认支持正则表达式语法：^ $ . * [] 参数 含义 --color=auto 高亮匹配内容 -E 使用扩展正则表达式，支持：+ ? | () {} -i 忽略大小写 -w 只匹配整个单词 -x 只匹配整行 -v 打印未匹配的所有行 -m NUM 指定打印行数 -H 打印文件名 -n 打印行号 -c 打印行数 -o 只打印匹配到的内容，而不是整行 -r 递归匹配 -l 打印有匹配行的文件名 -L 打印无匹配行的文件名 正则表达式教程 # 匹配空行 grep \"^$\" \u003cFILE\u003e # 匹配非空行 grep -v \"^$\" \u003cFILE\u003e # 统计匹配行数 grep -c \u003cPATTERN\u003e \u003cFILE\u003e # 统计匹配次数 grep -o \u003cPATTERN\u003e \u003cFILE\u003e | wc -l # 打印注释行 grep \"^#.*\" \u003cFILE\u003e ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#grep"},{"categories":["Linux"],"content":" sedStream EDitor 对文件内容进行增删改查，支持正则表达式。 sed [OPTION]... {script-only-if-no-other-script} [input-file]... 默认支持正则表达式语法：^ $ . * [] 参数 含义 --color=auto 高亮匹配内容 -E 使用扩展正则表达式，支持：+ ? | () {} -n 只输出匹配内容 -i 输出同时修改文件内容 -e 多个规则依次匹配 内置命令符 含义 a append，指定行后面追加 d delete，删除 i insert，指定行前面插入 p print，打印 /模式/操作 匹配模式，然后进行操作 s/替换前/替换后/g 替换，支持正则表达式，g表示全局匹配 指定行号 # 打印第二行和第三行 sed -n \"2,3p\" \u003cFILE\u003e # 删除第二行和第三行 sed -i \"2,3d\" \u003cFILE\u003e # 打印第二行开始的三行 sed -n \"2,+3p\" \u003cFILE\u003e # 删除第二行开始的三行 sed -i \"2,+3d\" \u003cFILE\u003e # 打印第二行到最后一行 sed -n \"2,$p\" \u003cFILE\u003e # 删除第二行到最后一行 sed -i \"2,$d\" \u003cFILE\u003e 指定内容 # 打印匹配到的行 sed -n \"/\u003cPATTERN\u003e/p\" \u003cFILE\u003e # 删除匹配到的行 sed -i \"/\u003cPATTERN\u003e/d\" \u003cFILE\u003e # ","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#sed"},{"categories":["Linux"],"content":" awk","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:7:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#awk"},{"categories":["Linux"],"content":" ps","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:8:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#ps"},{"categories":["Linux"],"content":" 参考","date":"2021-02-20","objectID":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:9:0","series":null,"tags":["Linux"],"title":"Linux 命令大全","uri":"/posts/linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#参考"},{"categories":["LaTeX","Cheatsheet"],"content":"标量 - 斜体小写 - $a$ 向量 - 粗体小写 - $a$ 矩阵 - 粗体大写 - $A$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:0:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#"},{"categories":["LaTeX","Cheatsheet"],"content":" 希腊字母 大写字母 代码 小写字母 代码 变量形式 代码 $\\alpha$ \\alpha $\\beta$ \\beta $\\Gamma$ \\Gamma $\\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $\\epsilon$ \\epsilon $\\Theta$ \\Theta $\\theta$ \\theta $\\Lambda$ \\Lambda $\\lambda$ \\lambda $\\mu$ \\mu $\\Pi$ \\Pi $\\pi$ \\pi $\\rho$ \\rho $\\Sigma$ \\Sigma $\\sigma$ \\sigma $\\Phi$ \\Phi $\\phi$ \\phi $\\varphi$ \\varphi $\\Psi$ \\Psi $\\psi$ \\psi $\\Omega$ \\Omega $\\omega$ \\omega ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:1:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#希腊字母"},{"categories":["LaTeX","Cheatsheet"],"content":" 字体$\\mathcal{L}、\\mathbf{L}、\\mathbb{L}、\\ell、\\mathrm{L}、\\mathsf{L}、\\mathtt{L}、\\mathit{L}、\\mathfrak{L}、\\mathscr{L}$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:2:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#字体"},{"categories":["LaTeX","Cheatsheet"],"content":" 特殊符号 符号 代码 解释 $\\partial$ \\partial 偏导数 $\\nabla$ \\nabla 梯度 $\\ell$ \\ell $\\Complex$ \\Complex \\cnums 复数集 $\\R$ \\Reals \\reals \\R 实数集 $\\Z$ \\Z 整数集 $\\natnums$ \\natnums \\N 自然数集 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:3:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#特殊符号"},{"categories":["LaTeX","Cheatsheet"],"content":" 垂直布局 符号 代码 解释 $x_n$ x_n 下标 $e^x$ e^x 上标 $_u^o$ _u^o 上下标 $\\overset{N}{\\sum}$ \\overset{N}{\\sum} 正上标 $\\underset{i=1}{\\sum}$ \\underset{i=1}{\\sum} 正下标 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:4:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#垂直布局"},{"categories":["LaTeX","Cheatsheet"],"content":" 逻辑符与集合论 符号 代码 解释 $\\forall$ \\forall 所有 $\\exist$ \\exists \\exist 存在 $\\in$ \\in \\isin 属于 $\\notin$ \\notin 不属于 $\\subset$ \\subset 包含于 $\\supset$ \\supset 包含 $\\emptyset$ \\emptyset \\empty 空集 $\\varnothing$ \\varnothing 空集 $\\implies$ \\implies 充分 $\\impliedby$ \\impliedby 必要 $\\iff$ \\iff 充分必要 $\\neg$ \\neg \\lnot 非 $\\lor$ \\lor 或 $\\land$ \\land 与 $\\because$ \\because 因为 $\\therefore$ \\therefore 所以 $\\ne$ \\ne \\neq 不等于 $\\approx$ \\approx 约等于 $\\coloneqq$ \\coloneqq 赋值 $\\gt$ \\gt 大于 $\\ge$ \\ge \\geq 大于等于 $\\lt$ \\lt 小于 $\\le$ \\le \\leq 小于等于 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:5:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#逻辑符与集合论"},{"categories":["LaTeX","Cheatsheet"],"content":" 多元运算符 符号 代码 解释 $\\sum$ \\sum 累加 $\\prod$ \\prod 累乘 $\\bigcap$ \\bigcap 累交 $\\bigcup$ \\bigcup 类并 $\\int$ \\int 一重积分 $\\iint$ \\iint 二重积分 $\\iiint$ \\iiint 三重积分 $\\oint$ \\oint 一重环路积分 $\\oiint$ \\oiint 二重环路积分 $\\oiiint$ \\oiiint 三重环路积分 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:6:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#多元运算符"},{"categories":["LaTeX","Cheatsheet"],"content":" 二元运算符 符号 代码 解释 $\\bmod$ \\bmod $x \\pmod a$ x \\pmod a $\\div$ \\div $\\pm$ \\pm \\plusmn $\\oplus$ \\oplus $\\otimes$ \\otimes $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:7:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#二元运算符"},{"categories":["LaTeX","Cheatsheet"],"content":" 常用数学符号 符号 代码 解释 $\\lim$ \\lim $\\ln$ \\ln $\\log$ \\log $\\exp$ \\exp $\\max$ \\max $\\min$ \\min $\\argmax$ \\argmax $\\argmin$ \\argmin $\\sin$ \\sin $\\cos$ \\cos $\\tan$ \\tan $\\sqrt{x}$ \\sqrt{x} 平方根 $\\sqrt[3]{x}$ \\sqrt[3]{x} 三次方根 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:8:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#常用数学符号"},{"categories":["LaTeX","Cheatsheet"],"content":" 矩阵","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:9:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#矩阵"},{"categories":["LaTeX","Cheatsheet"],"content":" 一行多个公式$$ \\begin{align} x\u0026=t \u0026 x\u0026=\\cos t \u0026 x\u0026=t \\notag y\u0026=2t \u0026 y\u0026=\\sin(t+1) \u0026 y\u0026=\\sin t \\end{align} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#一行多个公式"},{"categories":["LaTeX","Cheatsheet"],"content":" 大括号多行公式$$ f(x)=\\begin{cases} 2x+1, \u0026 \\text{if} \u0026 x \\lt 0; \\ 0, \u0026 \\text{if} \u0026 x = 0; \\ x^2-1, \u0026 \\text{if} \u0026 x \\gt 0. \\end{cases} $$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:11:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#大括号多行公式"},{"categories":["LaTeX","Cheatsheet"],"content":" 参考 Supported Functions - KaTeX ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:12:0","series":null,"tags":["LaTeX","Cheatsheet"],"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/#参考"},{"categories":null,"content":" 1.基础","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:0","series":["面试"],"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#1基础"},{"categories":null,"content":" 1.1 存储结构 数组： 数据连续存储 支持随机访问，通过索引快速找到对应元素，时间复杂度 $O(1)$ 数组满时需要扩容，重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 $O(n)$ 在数组中间进行插入和删除时需要对后面的所有数据进行移位，平均时间复杂度 $O(n)$ 链表： 数据不连续存储，而是靠指针指向其他元素的位置 不支持随机访问，平均时间复杂度 $O(n)$ 无需扩容 插入和删除时无需移位，时间复杂度 $O(1)$（前驱结点已知），$O(n)$（前驱结点未知） 指针域会占用储存空间，降低空间利用率 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:1","series":["面试"],"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#11-存储结构"},{"categories":null,"content":" 1.2 逻辑结构 栈（stack）：后进先出（LIFO）。 队列（queue）：先进先出（FIFO）。 树（tree）：子结点也是一棵树，子结点之间相互独立。 图（graph）：任意两个结点间可以连接。 每种逻辑结构均可使用不同存储结构实现，一般具体情况进行选择。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:2","series":["面试"],"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#12-逻辑结构"},{"categories":null,"content":" 1.3 复杂度 常见时间复杂度：$O(1)$、$O(\\log n)$、$O(n)$、$O(n\\log n)$、$O(n^2)$、$O(n^3)$ 常见空间复杂度：$O(1)$、$O(n)$、$O(n^2)$、$O(n^3)$ 复杂度一般去掉常数项，并将系数置为1，$O$ 表示上界。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:3","series":["面试"],"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#13-复杂度"},{"categories":null,"content":" 1.4 可视化 数据结构和算法动态可视化 Data Structure Visualizations ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:4","series":["面试"],"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#14-可视化"},{"categories":null,"content":" 排序算法-排序 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:0","series":["面试"],"tags":["数据结构","算法"],"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#排序"},{"categories":null,"content":"谷歌三件套包括 Google Play 商店（Google Play Store）、Google Play 服务（Google Play Services）和Google 服务框架（Google Services Framework），只有正确安装了这三件套才能访问 Google Play 商店和使用需要 Google Play 服务的 APP。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#"},{"categories":null,"content":" 安装","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#安装"},{"categories":null,"content":" 一键安装","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#一键安装"},{"categories":null,"content":" 手动安装 访问 APKMirror。 搜索Google Services Framework，根据安卓版本选择对应的版本下载并安装。（示例：Google Services Framework 10） 搜索Google Play Services，选择最新版并进入，选择arm64-v8a + armeabi-v7a、对应的安卓版本、nodpi，下载并安装。 搜索Google Play Store，选择最新版下载并安装。 若三件套都安装完，并且正确科学上网后还是打不开Google Play 商店，尝试下载旧版本Google Play Services安装。 不推荐使用beta版本。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#手动安装"},{"categories":null,"content":" Google Play Services 版本号版本号示例：20.50.66 (100400-351698872)，其中100400说明： 第 1、2 位表示安卓版本 00 - Android 4.1 02 - Android 5.0 04 - Android 6.0 05 - Wear OS 08 - Android TV 10 - Android 9.0 12 - Android 10 15 - Android 11 第 3、4 位表示CPU架构 03 - armeabi-v7a 04 - armeabi-v7a + arm64-v8a 07 - x86 08 - x86 + x86_64 第 5、6 位表示屏幕 DPI 00 - nodpi 02 - 160dpi 04 - 240dpi 06 - 320dpi 08 - 480dpi 则100400指Android 9.0、arm64-v8a和nodpi。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:3","series":null,"tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#google-play-services-版本号"},{"categories":["Java"],"content":" 0 名词解释 JVM：Java Virtual Machine，Java 虚拟机。 JRE：Java Runtime Environment，Java 运行环境，包含 JVM 和 Java 核心类库。 JDK：Java Development Kit，Java 开发工具包，包含 JRE，编译工具和运行工具。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#0-名词解释"},{"categories":["Java"],"content":" 1 准备","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#1-准备"},{"categories":["Java"],"content":" 1.1 JDK 下载 Oracle JDK Oracle OpenJDK Windows 可通过 Chocolatey 安装。 MacOS 可通过 Homebrew 安装。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#11-jdk-下载"},{"categories":["Java"],"content":" 1.2 环境变量配置Windows： 设置→系统→关于→高级系统设置→环境变量。 在下方的系统变量中找到Path，点击编辑。 点击新建，将JDK的路径下的bin目录粘贴进去。（示例：C:\\Users\\backs\\Downloads\\jdk-11.0.10\\bin\\） 连续点击确定，保存退出。 打开cmd，输入java -version，若有如下所示输出即为配置成功。 java version \"11.0.10\" 2021-01-19 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.10+8-LTS-162) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.10+8-LTS-162, mixed mode) 在任意位置创建 test.java，写入以下内容。 public class test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 在该文件夹下打开命令行，输入以下内容，输出应该为 Hello World!。 javac test.java java test ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#12-环境变量配置"},{"categories":["Java"],"content":" 1.3 IDE Download IntelliJ IDEA: 最好用，Community版免费，Ultimate版收费，学生可白嫖，推荐。 psvm public static void main(String[] args) {} sout System.out.println(); arr.fori for (int i = 0; i \u003c arr.length; i++) {} arr.forr for (int i = arr.length - 1; i \u003e= 0; i--) {} alt + 1 开/关左侧目录结构 alt + 4 开/关底部控制台 ctrl + alt + L 格式化代码 ctrl + / 单行注释 ctrl + shift + / 多行注释 shift + alt + ↑ 上移 shift + alt + ↓ 下移 ctrl + x 剪切当前行 ctrl + d 下方复制当前行 shift + enter 下方新建空行 ctrl + alt + enter 上方新建空行 ctrl + alt + v 自动定义变量来接收当前值 ctrl + alt + m 将选中代码生成独立方法 Eclipse: 开源，免费。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#13-ide-download"},{"categories":["Java"],"content":" 2 基础语法","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2-基础语法"},{"categories":["Java"],"content":" 2.1 注释 // 单行注释 /* 多行注释 */ /** 文档注释 */ ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#21-注释"},{"categories":["Java"],"content":" 2.2 常量 字符串常量：\"helloworld\"，\"程序员\" 整数常量：12，-3 浮点数常量：1.2，-3.4 字符常量：'a'，'\\n'，'我' 布尔常量：true，false 空常量：null ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#22-常量"},{"categories":["Java"],"content":" 2.3 数据类型 数据类型 关键字 内存占用（字节） 取值范围 整数 byte 1 -128~127 short 2 -32,768~32,767 int 4 -2,147,483,648~2,147,483,647 long 8 $$-2^{63} \\sim 2^{63} - 1$$ 浮点数 float 4 小数点后6位 double 8 小数点后15位 字符 char 2 0~65,535 布尔 boolean 1 true,false graph TB; A(数据类型) --\u003e B(基本数据类型) A --\u003e C(引用数据类型) B --\u003e D(数值型) B --\u003e E(非数值型) C --\u003e F(类) C --\u003e G(接口) C --\u003e H(数组) D --\u003e I(整数) D --\u003e J(浮点数) D --\u003e K(字符) E --\u003e L(布尔) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#23-数据类型"},{"categories":["Java"],"content":" 2.4 变量定义和使用 float a = 3.14F; // float b = 3.14f; long c = 100L; // long d = 100l; ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#24-变量定义和使用"},{"categories":["Java"],"content":" 2.5 读取输入 import java.util.Scanner; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); String s1 = sc.nextLine(); // 遇到换行结束，接收换行符，并丢弃。 String s2 = sc.next(); // 遇到空格或换行结束，不接收。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#25-读取输入"},{"categories":["Java"],"content":" 2.6 标识符定义必须： 由数字、字母、下划线、美元符号组成 不能以数字开头 不能是关键字 区分大小写 建议： 小驼峰命名法：backTraxe，常用于定义方法、变量。 大驼峰命名法：BackTraxe，常用于定义类。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#26-标识符定义"},{"categories":["Java"],"content":" 2.7 类型转换 隐式转换 graph LR; A(byte) --\u003e B(short) B --\u003e D(int) C(char) --\u003e D D --\u003e E(long) E --\u003e F(float) F --\u003e G(double) 占用空间小的数据类型会先转换为占用空间大的数据类型，然后进行运算。 byte、short和char三种数据类型在运算时会转换为int，然后进行运算。 byte a = 1, b = 2; // 错误 byte c = a + b; // 正确 int d = a + b; 显式（强制）转换 有可能产生精度损失。 byte a = 1, b = 2; byte e = (byte) (a + b); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#27-类型转换"},{"categories":["Java"],"content":" 2.8 运算符 单目算术运算符：自增++、自减-- 只能作用于变量。 int a = 1; int b = a++; // a = 2, b = 1 int c = ++a; // a = 3, c = 3 int d = a--; // a = 2, d = 3 int e = --a; // a = 1, e = 1 双目算术运算符：加+、减-、乘*、除/、取余% 加+：出现字符串则为连接运算符，否则为算术运算。从左到右执行。 System.out.println(1 + 2); // 3 System.out.println(2 + 1); // 3 System.out.println(1 + 'a'); // 98 System.out.println('a' + 2); // 99 System.out.println(1 + \"abc\"); // 1abc System.out.println(\"abc\" + 2); // abc2 System.out.println(true + \"abc\"); // trueabc System.out.println(\"abc\" + true); // abctrue System.out.println(\"abc\" + 1 + 2); // abc12 System.out.println(1 + 2 + \"abc\"); // 3abc System.out.println(1 + \"\" + 2 + \"abc\"); // 12abc 除/：整数除整数得整数。 System.out.println(10 / 3); // 3 System.out.println(10 / 3.0); // 3.3333333333333335 System.out.println(10.0 / 3); // 3.3333333333333335 赋值运算符：赋值=、加后赋值+=、减后赋值-=、乘后赋值*=、除后赋值/=、取余后赋值%= a 操作符= b等价于a = (a的类型) (a 操作符 (b))，隐含了强制类型转换，从右往左运算。 int a = 10; a /= 2 + 3; // 2 等价于 a = a / (2 + 3) short b = 1; b = b + 1; // 报错 b += 1; // 2 等价于 b = (short) (b + 1) 比较运算符：相等==、不等!=、大于\u003e、大于等于\u003e=、小于\u003c、小于等于\u003c= // 基本数据类型比较值 int a = 1, b = 1; System.out.println(a == b); // true // 引用数据类型比较地址 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); System.out.println(s1 == s2); // false System.out.println(s1.equals(s2)); // true 逻辑运算符：与\u0026,\u0026\u0026、或|,||、非!、异或^ int a = 1, b = 1; // 非短路与 \u0026，每个条件都进行判断 a \u003e 2 \u0026 b++ \u003e 0; // false, a = 1, b = 2 // 短路与 \u0026\u0026，当某个条件为 false 时，后面不再进行判断 a \u003e 2 \u0026\u0026 b++ \u003e 0; // false, a = 1, b = 1 // 非短路或 |，每个条件都进行判断 a \u003e 0 | b++ \u003e 0; // true, a = 1, b = 2 // 短路或 ||，当某个条件为 true 时，后面不再进行判断 a \u003e 0 || b++ \u003e 0; // true, a = 1, b = 1 位运算符：与\u0026、或|、非~、异或^、左移\u003c\u003c、右移\u003e\u003e、无符号右移\u003e\u003e\u003e a ^ a == 0 a ^ 0 == a a \u003c\u003c 1 == a * 2 三目运算符：a ? b : c // 等价于 if (a) { b; } else { c; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#28-运算符"},{"categories":["Java"],"content":" 2.9 分支语句 if (A) { B; } if (A) { B; } else { C; } if (A) { B; } else if (C) { D; } else { E; } // case 表达式不能重复，且不能为变量。 String rank = \"First\"; switch (rank) { case \"First\": System.out.println(\"第一\"); break; case \"Second\": case \"Third\": System.out.println(\"前三\"); break; default: System.out.println(\"再接再厉\"); break; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:9","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#29-分支语句"},{"categories":["Java"],"content":" 2.10 循环语句 for (初始化语句; 继续循环条件判断语句; 每轮循环后执行语句) { 循环体; } while (继续循环条件判断语句) { 循环体; } // 至少执行一次 do { 循环体; } while (继续循环条件判断语句); 跳转控制语句 continue：中断本次循环，直接开始下一次循环。 break：退出循环。 // 中断多重循环 outer: for (int i = 0; i \u003c 10; i++) { for (int j = 0; j \u003c 10; j++) { if (i == 5 \u0026\u0026 j == 7) { System.out.println(i + \"\\n\" + j); break outer; } } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:10","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#210-循环语句"},{"categories":["Java"],"content":" 2.11 格式化输出 System.out.print(); System.out.printf(); System.out.println(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:11","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#211-格式化输出"},{"categories":["Java"],"content":" 2.12 随机数生成 import java.util.Random; Random r = new Random(); int a = r.nextInt(10); // [0, 10) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:12","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#212-随机数生成"},{"categories":["Java"],"content":" 2.13 数组 // 动态初始化。不指定元素，指定长度。默认初始化为 0 int[] arr1 = new int[3]; int[][] arr2 = new int[2][3]; // 静态初始化。指定元素，不指定长度。 int[] arr3 = new int[]{1, 2, 3}; int[][] arr4 = new int[][]{{1, 2}, {3, 4}}; int[] arr5 = {1, 2, 3}; int[][] arr6 = {{1, 2}, {3, 4}}; // 长度 arr1.length; // 3 arr2[0].length; // 3 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:13","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#213-数组"},{"categories":["Java"],"content":" 2.14 方法 方法不能嵌套定义 方法重载（overload）：方法名相同，参数数量或者类型不同。与返回值类型无关。 // 返回匿名数组 return new int[]{1, 2}; ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:14","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#214-方法"},{"categories":["Java"],"content":" 2.15 进制 二进制：以0b, 0B开头 八进制：以0开头 十六进制：以0x, 0X开头 System.out.println(10); // 10 System.out.println(0b10); // 2 System.out.println(010); // 8 System.out.println(0x10); // 16 // 10 进制转 x 进制 public static String ten2x(int num, int x) { StringBuilder str = new StringBuilder(); while (0 != num) { str.append((char) (num % x + '0')); num /= x; } str.reverse(); return str.toString(); } // x 进制转 10 进制 public static int x2ten(String str, int x) { int res = 0; for (int i = 0; i \u003c str.length(); i++) { res = res * x + str.charAt(i) - '0'; } return res; } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:15","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#215-进制"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#216-字符串"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2161-字符串构造"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2162-字符串比较"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2163-字符串遍历"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2164-子串"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2165-其他操作"},{"categories":["Java"],"content":" 2.16 字符串不可修改，当字符串拼接时，系统自动转为StringBuilder进行拼接，然后转为字符串。 String s = \"abc\"; s.length(); // 3 2.16.1 字符串构造 String s1 = \"abc\"; String s2 = new String(new char[]{'a', 'b', 'c'}); String s3 = new String(\"abc\"); 2.16.2 字符串比较 String s1 = \"abc\"; String s2 = new String(\"abc\"); String s3 = \"Abc\"; // 比较地址 System.out.println(s1 == s2); // false // 比较值 System.out.println(s1.equals(s2)); // true // 不区分大小写 System.out.println(s1.equalsIgnoreCase(s3)); // true 2.16.3 字符串遍历 String s = \"abc\"; // 1 for (int i = 0; i \u003c s.length(); i++) { s.charAt(i); } // 2 char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { chars[i]; } 2.16.4 子串 String substring(int beginIndex) String substring(int beginIndex, int endIndex): [beginIndex, endIndex) Char[] subSequence(int beginIndex, int endIndex): [beginIndex, endIndex) String s = \"abcde\"; s.substring(1); // bcde s.substring(2, 4); // cd 2.16.5 其他操作格式化 static String format(String format) String strip() String stripLeading() String stripTrailing() String toUpperCase() String toLowerCase() 查找 boolean startsWith(String prefix) boolean endsWith(String suffix) boolean matches(String regex) int indexOf(int ch) int indexOf(int ch, int fromIndex) int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换 String replace(char oldChar, char newChar) String replace(CharSequence target, CharSequence replacement) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分/合并 String[] split(String regex) static String join(CharSequence delimiter, CharSequence... elements) static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements) String s = \"Java-is-cool\"; s.split(\"-\"); // {\"Java\", \"is\", \"cool\"} String.join(\"-\", \"Java\", \"is\", \"cool\"); // Java-is-cool String.join(\"-\", List.of(\"Java\", \"is\", \"cool\")); // Java-is-cool 2.16.6 字符串常量池 当使用双引号创建字符串对象的时候，系统会在常量池中检查是否已存在该字符串，若不存在，则创建，若存在，则直接使用。","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:16","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2166-字符串常量池"},{"categories":["Java"],"content":" 2.17 可变字符串 2.17.1 StringBuilder插入 StringBuilder append(X x) StringBuilder insert(int offset, X x) 修改 void setCharAt(int index, char ch) StringBuilder replace(int start, int end, String str) StringBuilder delete(int start, int end) StringBuilder deleteCharAt(int index) StringBuilder reverse() 索引查找 char charAt(int index) 值查找 int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 比较 int compareTo(StringBuilder another) 子串 CharSequence subSequence(int start, int end) String substring(int start) String substring(int start, int end) 转换 StringBuilder(String str) String toString() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:17","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#217-可变字符串"},{"categories":["Java"],"content":" 2.17 可变字符串 2.17.1 StringBuilder插入 StringBuilder append(X x) StringBuilder insert(int offset, X x) 修改 void setCharAt(int index, char ch) StringBuilder replace(int start, int end, String str) StringBuilder delete(int start, int end) StringBuilder deleteCharAt(int index) StringBuilder reverse() 索引查找 char charAt(int index) 值查找 int indexOf(String str) int indexOf(String str, int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 比较 int compareTo(StringBuilder another) 子串 CharSequence subSequence(int start, int end) String substring(int start) String substring(int start, int end) 转换 StringBuilder(String str) String toString() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:17","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#2171-stringbuilder"},{"categories":["Java"],"content":" 2.18 复杂度分析程序耗时 long start = System.currentTimeMillis(); // 执行代码 long end = System.currentTimeMillis(); System.out.println(end - start); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:18","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#218-复杂度分析"},{"categories":["Java"],"content":" 2.19 static静态修饰符，可修饰变量和方法。 - 静态变量 1. 被所有实例化的对象共享。 2. 随类的加载而加载。 3. 不需要创建对象即可调用（使用类名）。 - 静态方法 1. 只能访问静态变量或静态方法。 2. 不能使用this。 3. 不需要创建对象即可调用（使用类名）。 public class Student { public static int age = 18; public static int getAge() { return age; } } Student.age; // 18 Student.getAge(); // 18 Student stu1 = new Student(); stu1.age; // 18 stu1.age = 20; Student stu2 = new Student(); stu2.age; // 20 Student.age; // 20 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:19","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#219-static"},{"categories":["Java"],"content":" 3 面向对象编程面向对象编程（Object Oriented Programming，OOP），是一种程序设计思想，把类作为程序的基本单元，一个类包含了变量和方法。 可以提高代码的维护性、可读性、复用性。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#3-面向对象编程"},{"categories":["Java"],"content":" 3.1 为什么要面向对象 3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#31-为什么要面向对象"},{"categories":["Java"],"content":" 3.1 为什么要面向对象 3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#311-分类思想"},{"categories":["Java"],"content":" 3.1 为什么要面向对象 3.1.1 分类思想例如：学生信息管理系统。 Student类：标准学生类，封装学生信息（学号、姓名、性别、年级等）。 StudentDao类：DAO，Data Access Object，访问存储数据的数组或集合。 StudentService类：业务逻辑处理。例如添加学生、查询学生。 StudentController类：用户交互相关。例如处理用户输入、给予用户反馈信息。 3.1.2 分包思想 本质文件夹。 多级包使用.分割，一般用逆序网址（去掉www），如 io.github.backtraxe。 全小写字母。 必须在文件开头（注释不算）。 不同包下类的访问：1.先导包。2.包名+类名（重名类使用）。 package io.github.backtraxe; // 1. 导包 import io.github.backsided.Student; // 2. 包名+类名 io.github.backsided.Student stu = new io.github.backsided.Student(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#312-分包思想"},{"categories":["Java"],"content":" 怎样面向对象","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#怎样面向对象"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#31-类"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#311-构造方法"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#312-构造代码块"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#313-静态代码块"},{"categories":["Java"],"content":" 3.1 类执行顺序： 静态代码块 构造代码块 构造方法 3.1.1 构造方法 名称与类名相同。 无返回值。 实现类时自动调用。 若无自定义构造方法，则系统提供空构造方法。 若自定义构造方法，则系统不再提供。 public class Circle { public Circle() { // 系统默认提供的构造函数 } } 3.1.2 构造代码块 public class Circle { { // 每次创建对象时在构造方法之前执行。 } } 3.1.3 静态代码块 public class Circle { static { // 类加载时执行一次。 } } 3.1.4 内部类 内部类可以使用外部类中所有成员和方法（包括私有）。 class Outer { class Inner { // 成员内部类 } } Outer.Inner oi = new Outer().new Inner(); class Outer { static class Inner { // 静态内部类 } } Outer.Inner oi = new Outer.Inner(); class Outer { void method() { class Inner { // 局部内部类，外界无法访问。 } } } class Outer { Inner inner = new Inner() { // 匿名内部类 @Override public void method() {} }; inner.method(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#314-内部类"},{"categories":["Java"],"content":" 3.2 封装隐藏实现细节，仅对外暴露公共的访问方式。可以提高代码的安全性和复用性。 针对private修饰的成员变量，如果需要被其他类使用，需要提供getXxx()和setXxx()方法。Idea 可自动生成。 public class Student { private String name; // 类外无法访问 public String getName() { return name; } public void setName(String name) { this.name = name; } public static void main(String[] args) { Student stu = new Student(); stu.setName(\"张三\"); System.out.println(stu.getName()); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#32-封装"},{"categories":["Java"],"content":" 3.3 继承","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#33-继承"},{"categories":["Java"],"content":" 3.4 多态 子类继承父类，或者子类实现接口。 子类进行方法重写。 父类引用指向子类对象，调用父类中定义的方法，子类完成动作。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#34-多态"},{"categories":["Java"],"content":" 3.5 接口 无构造方法。 所有变量都是常量public static final。 所有方法都是抽象方法public abstract(JDK 7)。 public default方法，可以有方法体（JDK 8）。若子类实现的多个接口存在相同的default方法，则子类必须重写该方法。 public static方法，可以有方法体（JDK 8）。该方法只能通过接口名调用，不能通过子类调用。 private方法，可以有方法体（JDK 9）。仅允许接口内使用。 子类implements接口，实现接口中所有抽象方法。 子类可实现多接口。 public interface Shape { double area(); double perimeter(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:4:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#35-接口"},{"categories":["Java"],"content":" 字符串 String 转 byte 数组 // 使用平台的默认字符集 byte[] getBytes() // 指定字符集。UTF-8（中文3字节）、GBK（中文2字节）等 byte[] getBytes​(String charsetName) byte[] getBytes​(Charset charset) byte 数组转 String String​(byte[] bytes) String​(byte[] bytes, String charsetName) String​(byte[] bytes, Charset charset) String​(byte[] bytes, int offset, int length) String​(byte[] bytes, int offset, int length, String charsetName) String​(byte[] bytes, int offset, int length, Charset charset) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#字符串"},{"categories":["Java"],"content":" 常用库","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#常用库"},{"categories":["Java"],"content":" Math static double E static double PI static T abs​(T a) static T max​(T a, T b) static T min​(T a, T b) static double ceil​(double a) // 向上取整 static double floor​(double a) // 向下取整 static double exp​(double a) static double pow​(double a, double b) static double log​(double a) static double log10​(double a) static double sin​(double a) static double cos​(double a) static double tan​(double a) static double random() // [0.0, 1.0) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#math"},{"categories":["Java"],"content":" System static PrintStream err static InputStream in static PrintStream out // System.setIn​(new InputStream(\"input\")); static void setIn​(InputStream in) // System.setOut(new PrintStream(\"output\")); static void setOut​(PrintStream out) // System.exit(0); static void exit​(int status) static void gc() static long currentTimeMillis() // 毫秒 static void arraycopy​(Object src, int srcPos, Object dest, int destPos, int length) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#system"},{"categories":["Java"],"content":" Object protected Object clone() boolean equals​(Object obj) { return (this == obj); } // Deprecated protected void finalize() Class\u003c?\u003e getClass() int hashCode() void notify() void notifyAll() String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } void wait() void wait​(long timeoutMillis) void wait​(long timeoutMillis, int nanos) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#object"},{"categories":["Java"],"content":" Class String getName() boolean isArray() boolean isInstance​(Object obj) boolean isInterface() Constructor\u003cT\u003e getDeclaredConstructor​(Class\u003c?\u003e... parameterTypes) Constructor\u003c?\u003e[] getDeclaredConstructors() Field getDeclaredField​(String name) Field[] getDeclaredFields() Method getDeclaredMethod​(String name, Class\u003c?\u003e... parameterTypes) Method[] getDeclaredMethods() T newInstance() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#classt"},{"categories":["Java"],"content":" BigDecimal import java.math.BigDecimal; BigDecimal​(char[] in) BigDecimal​(char[] in, int offset, int len) BigDecimal​(double val) BigDecimal​(int val) BigDecimal​(long val) BigDecimal​(String val) // 推荐 BigDecimal​(BigInteger val) BigDecimal abs() BigDecimal max​(BigDecimal val) BigDecimal min​(BigDecimal val) BigDecimal pow​(int n) int compareTo​(BigDecimal val) boolean equals​(Object x) BigDecimal add​(BigDecimal augend) BigDecimal subtract​(BigDecimal subtrahend) BigDecimal multiply​(BigDecimal multiplicand) BigDecimal divide​(BigDecimal divisor) // RoundingMode.UP 进一法 // RoundingMode.DOWN 去尾法 // RoundingMode.HALF_UP 四舍五入 BigDecimal divide​(BigDecimal divisor, int scale, RoundingMode roundingMode) BigDecimal remainder​(BigDecimal divisor) BigDecimal[] divideAndRemainder​(BigDecimal divisor) int intValue() long longValue() double doubleValue() BigInteger toBigInteger() String toString() static BigDecimal valueOf​(double val) static BigDecimal valueOf​(long val) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bigdecimal"},{"categories":["Java"],"content":" Integer static int BYTES // 4 static int MAX_VALUE // 0x7fffffff 2147483647 static int MIN_VALUE // 0x80000000 -2147483648 static int SIZE // 32 static Class\u003cInteger\u003e TYPE // int static int compare​(int x, int y) static int compareUnsigned​(int x, int y) int compareTo​(Integer anotherInteger) static int bitCount​(int i) // 返回1的数量 static int highestOneBit​(int i) // 保留最高位1 static int lowestOneBit​(int i) // 保留最低位1 static int numberOfLeadingZeros​(int i) // 前缀0数量 static int numberOfTrailingZeros​(int i) // 后缀0数量 static int reverse​(int i) static int reverseBytes​(int i) static int parseInt​(CharSequence s, int beginIndex, int endIndex, int radix) static int parseInt​(String s) static int parseInt​(String s, int radix) static String toString​(int i) static String toString​(int i, int radix) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#integer"},{"categories":["Java"],"content":" Date \u0026 SimpleDateFormat import java.util.Date; import java.text.SimpleDateFormat; // Date 类中的方法 Date() Date​(long date) Date​(String s) long getTime() void setTime​(long time) int compareTo​(Date anotherDate) // Date 转 String Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 E HH:mm:ss\"); sdf.format(date1); // 2022年05月27日 周五 13:57:41 // String 转 Date String str = \"2022年05月27日 周五 13:57:41\"; Date date2 = sdf.parse(str); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#date--simpledateformat"},{"categories":["Java"],"content":" Calendar import java.util.Calendar; Date getTime() void setTime​(Date date) long getTimeInMillis() void setTimeInMillis​(long millis) void add​(int field, int amount) int get​(int field) void set​(int field, int value) void set​(int year, int month, int date) void set​(int year, int month, int date, int hourOfDay, int minute) void set​(int year, int month, int date, int hourOfDay, int minute, int second) void setFirstDayOfWeek​(int value) Calendar calendar = Calendar.getInstance(); calendar.get(Calendar.YEAR); // 年 calendar.get(Calendar.MONTH) + 1; // 月 calendar.get(Calendar.DAY_OF_MONTH); // 日 (calendar.get(Calendar.DAY_OF_WEEK) - 1) % 7; // 周 calendar.get(Calendar.HOUR_OF_DAY); // 时 calendar.get(Calendar.MINUTE); // 分 calendar.get(Calendar.SECOND); // 秒 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#calendar"},{"categories":["Java"],"content":" DateTimeFormatter \u0026 LocalDateTime import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 E HH:mm:ss\"); LocalDateTime time = LocalDateTime.parse(str, formatter); // LocalDateTime 类中的方法 String format​(DateTimeFormatter formatter) int getYear() int getMonthValue() // [1, 12] Month getMonth() // May int getDayOfMonth() // [1, 31] int getDayOfYear() // [1, 366] DayOfWeek getDayOfWeek() // FRIDAY int getHour() // [0, 23] int getMinute() int getSecond() int getNano() static LocalDateTime of​(int year, int month, int dayOfMonth, int hour, int minute) static LocalDateTime of​(int year, int month, int dayOfMonth, int hour, int minute, int second) static LocalDateTime parse​(CharSequence text) static LocalDateTime parse​(CharSequence text, DateTimeFormatter formatter) LocalDateTime plusYears​(long years) LocalDateTime plusMonths​(long months) LocalDateTime plusDays​(long days) LocalDateTime plusHours​(long hours) LocalDateTime plusMinutes​(long minutes) LocalDateTime plusSeconds​(long seconds) LocalDateTime plusWeeks​(long weeks) LocalDateTime minusYears​(long years) LocalDateTime minusMonths​(long months) LocalDateTime minusDays​(long days) LocalDateTime minusHours​(long hours) LocalDateTime minusMinutes​(long minutes) LocalDateTime minusSeconds​(long seconds) LocalDateTime minusWeeks​(long weeks) LocalDateTime withYear​(int year) LocalDateTime withMonth​(int month) LocalDateTime withDayOfMonth​(int dayOfMonth) LocalDateTime withHour​(int hour) LocalDateTime withMinute​(int minute) LocalDateTime withSecond​(int second) LocalDateTime withDayOfYear​(int dayOfYear) LocalDate toLocalDate() LocalTime toLocalTime() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:9","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#datetimeformatter--localdatetime"},{"categories":["Java"],"content":" Period \u0026 LocalDate startDate = LocalDate.of(2022, 2, 1); LocalDate endDate = LocalDate.of(2025, 11, 18); Period period = Period.between(startDate, endDate); period.getYears(); period.getMonths(); period.getDays(); LocalDateTime startTime = LocalDateTime.of(2022, 2, 4, 5, 18, 23); LocalDateTime endTime = LocalDateTime.of(2030, 1, 30, 17, 24, 12); Duration duration = Duration.between(startTime, endTime); duration.toSeconds(); ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:6:10","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#period-"},{"categories":["Java"],"content":" 文件","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#文件"},{"categories":["Java"],"content":" 构造方法 File​(File parent, String child) File​(String pathname) File​(String parent, String child) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#构造方法"},{"categories":["Java"],"content":" 判断路径 // 是否目录 boolean isDirectory() // 是否文件 boolean isFile() // 是否存在 boolean exists() // 是否绝对路径 boolean isAbsolute() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#判断路径"},{"categories":["Java"],"content":" 获取路径 // 文件名加后缀 String getName() // 父目录 String getParent() new File(\"demo\").getParent(); // null new File(\"folder/demo\").getParent(); // folder // 返回传入的路径 String getPath() // 绝对路径 String getAbsolutePath() // 获取路径下所有路径（包括隐藏） String[] list() // 只返回文件名 File[] listFiles() // 文件名加路径（非绝对路径） ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#获取路径"},{"categories":["Java"],"content":" 创建文件或文件夹 // 创建单个文件 boolean createNewFile() throws IOException // 创建单个文件夹 boolean mkdir() // 递归创建文件夹 boolean mkdirs() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#创建文件或文件夹"},{"categories":["Java"],"content":" 删除文件或文件夹 // 删除空目录或文件 boolean delete() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:7:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#删除文件或文件夹"},{"categories":["Java"],"content":" I/O","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#io"},{"categories":["Java"],"content":" 分类流向 输入流 输出流 类型 字节流：所有文件。 字符流：文本文件。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#分类"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#文件字节流"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#fileinputstream"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#fileoutputstream"},{"categories":["Java"],"content":" 文件字节流 FileInputStream​ 构造方法 FileInputStream​(String name) throws FileNotFoundException FileInputStream​(File file) throws FileNotFoundException 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } long skip​(long n) throws IOException 关闭 void close() throws IOException FileOutputStream​ 构造方法 FileOutputStream​(String name) throws FileNotFoundException FileOutputStream​(String name, boolean append) throws FileNotFoundException FileOutputStream​(File file) throws FileNotFoundException FileOutputStream​(File file, boolean append) throws FileNotFoundException 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows 关闭 void close() throws IOException 实战 文件复制 try (FileInputStream fis = new FileInputStream(\"input\"); FileOutputStream fos = new FileOutputStream(\"output\");) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#实战"},{"categories":["Java"],"content":" 缓冲字节流 BufferedInputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedInputStream​(InputStream in) BufferedInputStream​(InputStream in, int size) 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } void reset() throws IOException long skip​(long n) throws IOException 关闭 void close() throws IOException BufferedOutputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out, int size) 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows void flush() throws IOException 关闭 void close() throws IOException ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#缓冲字节流"},{"categories":["Java"],"content":" 缓冲字节流 BufferedInputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedInputStream​(InputStream in) BufferedInputStream​(InputStream in, int size) 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } void reset() throws IOException long skip​(long n) throws IOException 关闭 void close() throws IOException BufferedOutputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out, int size) 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows void flush() throws IOException 关闭 void close() throws IOException ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedinputstream"},{"categories":["Java"],"content":" 缓冲字节流 BufferedInputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedInputStream​(InputStream in) BufferedInputStream​(InputStream in, int size) 读 int read() throws IOException // 读1个字节 int read​(byte[] b) throws IOException int read​(byte[] b, int off, int len) throws IOException // 读取整个文件 while ((b = fis.read()) != -1) { read(); } void reset() throws IOException long skip​(long n) throws IOException 关闭 void close() throws IOException BufferedOutputStream 构造方法 // DEFAULT_BUFFER_SIZE = 8192 BufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out, int size) 写 void write​(int b) throws IOException // 写入对应字符 void write​(byte[] b) throws IOException void write​(byte[] b, int off, int len) throws IOException // 写入换行 fos.write(\"\\r\\n\".getBytes()); // windows void flush() throws IOException 关闭 void close() throws IOException ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedoutputstream"},{"categories":["Java"],"content":" 对象操作流 ObjectInputStream ObjectInputStream​(InputStream in) Object readObject() ObjectOutputStream 需要对象实现java.io.Serializable接口 private static final long serialVersionUID = 1L; ObjectOutputStream​(OutputStream out) void writeObject​(Object obj) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#对象操作流"},{"categories":["Java"],"content":" 对象操作流 ObjectInputStream ObjectInputStream​(InputStream in) Object readObject() ObjectOutputStream 需要对象实现java.io.Serializable接口 private static final long serialVersionUID = 1L; ObjectOutputStream​(OutputStream out) void writeObject​(Object obj) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#objectinputstream"},{"categories":["Java"],"content":" 对象操作流 ObjectInputStream ObjectInputStream​(InputStream in) Object readObject() ObjectOutputStream 需要对象实现java.io.Serializable接口 private static final long serialVersionUID = 1L; ObjectOutputStream​(OutputStream out) void writeObject​(Object obj) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:4","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#objectoutputstream"},{"categories":["Java"],"content":" 字符流 Reader int read() int read​(char[] cbuf) int read​(char[] cbuf, int off, int len) int read​(CharBuffer target) void mark​(int readAheadLimit) boolean markSupported() long transferTo​(Writer out) long skip​(long n) void reset() void close() Writer Writer append​(char c) Writer append​(CharSequence csq) Writer append​(CharSequence csq, int start, int end) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#字符流"},{"categories":["Java"],"content":" 字符流 Reader int read() int read​(char[] cbuf) int read​(char[] cbuf, int off, int len) int read​(CharBuffer target) void mark​(int readAheadLimit) boolean markSupported() long transferTo​(Writer out) long skip​(long n) void reset() void close() Writer Writer append​(char c) Writer append​(CharSequence csq) Writer append​(CharSequence csq, int start, int end) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#reader"},{"categories":["Java"],"content":" 字符流 Reader int read() int read​(char[] cbuf) int read​(char[] cbuf, int off, int len) int read​(CharBuffer target) void mark​(int readAheadLimit) boolean markSupported() long transferTo​(Writer out) long skip​(long n) void reset() void close() Writer Writer append​(char c) Writer append​(CharSequence csq) Writer append​(CharSequence csq, int start, int end) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:5","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#writer"},{"categories":["Java"],"content":" 文件字符流 FileReader 构造方法 FileReader​(String fileName) FileReader​(String fileName, Charset charset) FileReader​(File file) FileReader​(File file, Charset charset) FileWriter 构造方法 FileWriter​(String fileName) FileWriter​(String fileName, boolean append) FileWriter​(String fileName, Charset charset) FileWriter​(String fileName, Charset charset, boolean append) FileWriter​(File file) FileWriter​(File file, boolean append) FileWriter​(File file, Charset charset) FileWriter​(File file, Charset charset, boolean append) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#文件字符流"},{"categories":["Java"],"content":" 文件字符流 FileReader 构造方法 FileReader​(String fileName) FileReader​(String fileName, Charset charset) FileReader​(File file) FileReader​(File file, Charset charset) FileWriter 构造方法 FileWriter​(String fileName) FileWriter​(String fileName, boolean append) FileWriter​(String fileName, Charset charset) FileWriter​(String fileName, Charset charset, boolean append) FileWriter​(File file) FileWriter​(File file, boolean append) FileWriter​(File file, Charset charset) FileWriter​(File file, Charset charset, boolean append) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#filereader"},{"categories":["Java"],"content":" 文件字符流 FileReader 构造方法 FileReader​(String fileName) FileReader​(String fileName, Charset charset) FileReader​(File file) FileReader​(File file, Charset charset) FileWriter 构造方法 FileWriter​(String fileName) FileWriter​(String fileName, boolean append) FileWriter​(String fileName, Charset charset) FileWriter​(String fileName, Charset charset, boolean append) FileWriter​(File file) FileWriter​(File file, boolean append) FileWriter​(File file, Charset charset) FileWriter​(File file, Charset charset, boolean append) ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:6","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#filewriter"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream\u003cString\u003e lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#缓冲字符流"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedreader"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#bufferedwriter"},{"categories":["Java"],"content":" 缓冲字符流 BufferedReader BufferedReader​(Reader in) BufferedReader​(Reader in, int sz) int read() int read​(char[] cbuf, int off, int len) String readLine() Stream lines() void reset() long skip​(long n) void close() BufferedWriter BufferedWriter​(Writer out) BufferedWriter​(Writer out, int sz) void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String s) void write​(String s, int off, int len) void newLine() void flush() void close() 实战 文件复制 try (BufferedReader br = new BufferedReader(new FileReader(\"input\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output\"));) { String line; while ((line = br.readLine()) != null) { bw.write(line); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:7","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#实战-1"},{"categories":["Java"],"content":" 转换流 InputStreamReader字节流 -\u003e 字符流 InputStreamReader​(InputStream in) InputStreamReader​(InputStream in, String charsetName) InputStreamReader​(InputStream in, Charset cs) InputStreamReader​(InputStream in, CharsetDecoder dec) String getEncoding() int read() int read​(char[] cbuf, int offset, int length) OutputStreamWriter字符流 -\u003e 字节流 OutputStreamWriter​(OutputStream out) OutputStreamWriter​(OutputStream out, String charsetName) OutputStreamWriter​(OutputStream out, Charset cs) OutputStreamWriter​(OutputStream out, CharsetEncoder enc) String getEncoding() void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#转换流"},{"categories":["Java"],"content":" 转换流 InputStreamReader字节流 -\u003e 字符流 InputStreamReader​(InputStream in) InputStreamReader​(InputStream in, String charsetName) InputStreamReader​(InputStream in, Charset cs) InputStreamReader​(InputStream in, CharsetDecoder dec) String getEncoding() int read() int read​(char[] cbuf, int offset, int length) OutputStreamWriter字符流 -\u003e 字节流 OutputStreamWriter​(OutputStream out) OutputStreamWriter​(OutputStream out, String charsetName) OutputStreamWriter​(OutputStream out, Charset cs) OutputStreamWriter​(OutputStream out, CharsetEncoder enc) String getEncoding() void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#inputstreamreader"},{"categories":["Java"],"content":" 转换流 InputStreamReader字节流 -\u003e 字符流 InputStreamReader​(InputStream in) InputStreamReader​(InputStream in, String charsetName) InputStreamReader​(InputStream in, Charset cs) InputStreamReader​(InputStream in, CharsetDecoder dec) String getEncoding() int read() int read​(char[] cbuf, int offset, int length) OutputStreamWriter字符流 -\u003e 字节流 OutputStreamWriter​(OutputStream out) OutputStreamWriter​(OutputStream out, String charsetName) OutputStreamWriter​(OutputStream out, Charset cs) OutputStreamWriter​(OutputStream out, CharsetEncoder enc) String getEncoding() void write​(int c) void write​(char[] cbuf) void write​(char[] cbuf, int off, int len) void write​(String str) void write​(String str, int off, int len) void flush() void close() ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:8:8","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#outputstreamwriter"},{"categories":["Java"],"content":" Propertieskey和value都是String的Hashtable 构造方法 Properties() Properties​(int initialCapacity) Properties​(Properties defaults) 添加/修改 Object setProperty​(String key, String value) Object put(String key, String value) 删除 V remove(Object key) 查询 Set\u003cString\u003e stringPropertyNames() Set\u003cObject\u003e keySet() Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() boolean containsKey(Object key) String getProperty​(String key) String getProperty​(String key, String defaultValue) Object get(Object key) Object getOrDefault(Object key, Object defaultValue) 序列化 void load​(InputStream inStream) void load​(Reader reader) void loadFromXML​(InputStream in) void store​(OutputStream out, String comments) void store​(Writer writer, String comments) void storeToXML​(OutputStream os, String comment) void storeToXML​(OutputStream os, String comment, String encoding) void storeToXML​(OutputStream os, String comment, Charset charset) # properties key1=value1 key2=value2 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u003e \u003cproperties\u003e \u003centry key=\"key1\"\u003evalue1\u003c/entry\u003e \u003centry key=\"key2\"\u003evalue2\u003c/entry\u003e \u003c/properties\u003e ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#properties"},{"categories":["Java"],"content":" Lambda 表达式 方法传入参数为接口。 接口有且只有一个抽象方法。 不产生.class文件。 // 无参数 () -\u003e { // return } // 一个参数 a -\u003e { // return } // 多个参数 (a, b) -\u003e { // return } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#lambda-表达式"},{"categories":["Java"],"content":" 异常","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#异常"},{"categories":["Java"],"content":" 分类 java.lang.Throwable java.lang.Error：严重错误 java.lang.Exception java.lang.RuntimeException：运行时异常 编译时异常：编译器能够检查出的异常，需要进行异常处理 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#分类-1"},{"categories":["Java"],"content":" 异常处理 try { } catch (Exception e) { } finally { // 一定会执行，就算没有出现异常 // 即使 try 程序块中有 return 语句，也是在执行了 finally 语句块后再返回 } // 不处理，向上继续抛出 void func() throws Exception {} void func() { // 主动抛出异常 throw new Exception(); } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:2","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#异常处理"},{"categories":["Java"],"content":" 自定义异常 class DIYException extends Exception { public DIYException() { super(); } public DIYException(String message) { super(message); } } ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:11:3","series":null,"tags":["Java"],"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/#自定义异常"},{"categories":["Python","教程"],"content":"Python 是现在最受欢迎的语言。 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#"},{"categories":["Python","教程"],"content":" 运算符 # 位运算 # 按位与 \u0026 a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a \u0026 b # 00 00 00 01 : 1 # 按位或 | a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a | b # 00 00 01 11 : 7 # 按位取反 ~ a = 3 # 00 00 00 11 ~a # 11 11 11 00 # 按位异或 ^ （相同为0，不同为1） a = 3 # 00 00 00 11 b = 5 # 00 00 01 01 a ^ b # 00 00 01 10 : 6 # 任何值与自身异或为0 a ^ a # 00 00 00 00 : 0 # 任何值与0异或不变 a ^ 0 # 00 00 00 11 : 3 # 按位左移 \u003c\u003c # 三元运算符 smaller = x if x \u003c y else y # 其他运算符 'A' in ['A', 'B', 'C'] 'D' not in ['A', 'B', 'C'] \"hello\" is \"hello\" \"Hello\" is not \"hello\" # is 对比的是两个变量的内存地址 # == 对比的是两个变量的值 # 地址不可变的类型（str 等），那么 is 和 == 完全等价 # 地址可变的类型（list，dict，tuple 等），两者不等价 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#运算符"},{"categories":["Python","教程"],"content":" 异常处理 # 异常处理 try: a = 1 / 0 except ZeroDivisionError: print('除数不能为0') # 指定精度 from decimal import Decimal decimal.getcontext().prec = 4 c = Decimal(1) / Decimal(3) # 0.3333 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#异常处理"},{"categories":["Python","教程"],"content":" 内置函数 # 获取类型信息 isinstance(1, int) # type() 不会认为子类是一种父类类型，不考虑继承关系 # isinstance() 会认为子类是一种父类类型，考虑继承关系 # 类型转换 int('520') # 520 float('520.52') # 520.52 str(520) # '520' # print # print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False) # sep 分隔符 # end 结束符 # file 输出的文件 # flush 立即输出，不作缓存 abs(x) # 返回绝对值。若参数为复数，则返回复数的模。 divmod(a, b) # 返回 tuple(a // b, a % b) input(words) # 打印 words，读取用户输入，返回 str 类型 ord(c) # 返回字符对应的 ASCII 数值，或者 Unicode 数值 chr(i) # 返回整数（0～255，10进制或16进制）对应的 ASCII 字符。 bin(i) # 返回一个整数（int 或 long int）的二进制表示，str 类型。 any() # 是否存在大于0 all() # 是否全大于0 complex(real=0, image=0) # 复数 7.bit_length() # 3 0.25.as_integer_ratio() # (1, 4) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#内置函数"},{"categories":["Python","教程"],"content":" 数据结构","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#数据结构"},{"categories":["Python","教程"],"content":" 列表 a = [1] a.append(2) # [1, 2] a.pop() # 2 a.index(1) # 0 找不到报错 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#列表"},{"categories":["Python","教程"],"content":" 复数 c = 12 + 3j print(c.real) # 12.0 print(c.imag) # 3.0 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#复数"},{"categories":["Python","教程"],"content":" 字符串 pluto_mass = 1.303 * 10**22 earth_mass = 5.9722 * 10**24 population = 52910390 # {:.2} 2位有效数字 # {:.3%} 3位有效数字，百分数形式表示 # {:,} 数字每隔3位用逗号隔开 \"{} weighs about {:.2} kilograms ({:.3%} of Earth's mass). It is home to {:,} Plutonians.\".format( planet, pluto_mass, pluto_mass / earth_mass, population ) # Pluto weighs about 1.3e+22 kilograms (0.218% of Earth's mass). It is home to 52,910,390 Plutonians. # 根据位置使用变量 s = \"\"\"Pluto's a {0}. No, it's a {1}. {0}! {1}!\"\"\".format('planet', 'dwarf planet') # Pluto's a planet. # No, it's a dwarf planet. # planet! # dwarf planet! '123'.isdigit() # True 参考： PyFormat ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#字符串"},{"categories":["Python","教程"],"content":" 字典 dict() # {} dict(a=1, b=2, c=3) # {'a': 1, 'b': 2, 'c': 3} dict(zip(['a', 'b', 'c'], [1, 2, 3])) # {'a': 1, 'b': 2, 'c': 3} dict([('a', 1), ('b', 2), ('c', 3)]) # {'a': 1, 'b': 2, 'c': 3} ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:4","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#字典"},{"categories":["Python","教程"],"content":" staticmethod声明静态方法，即可以不实例化类而直接调用该方法。类中类也可以。 class C(object): @staticmethod def f(arg1, arg2, ...): ... ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:5","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#staticmethod"},{"categories":["Python","教程"],"content":" enumerate将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和下标，一般用在 for 循环中。 enumerate(sequence, start=0) list(enumerate([1, 2, 3])) # [(0, 1), (1, 2), (2, 3)] list(enumerate((1, 2, 3))) # [(0, 1), (1, 2), (2, 3)] list(enumerate('abc')) # [(0, 'a'), (1, 'b'), (2, 'c')] list(enumerate('abc', start=1)) # [(1, 'a'), (2, 'b'), (3, 'c')] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:6","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#enumerate"},{"categories":["Python","教程"],"content":" int 若 x 为数字，返回整数部分。（不能有 base 参数，否则报错） 若 x 为字符串，则将 x 视为 base 进制的数，返回转换为 10 进制后的数。（x 不能为小数或不存在的数，否则报错） int(x, base=10) int() # 0 int(3.9) # 3 int(-3.9) # -3 int('10', 2) # 2 int('0xA', 16) # 10 int('aB', 16) # 171 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:7","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#int"},{"categories":["Python","教程"],"content":" 常用内置库","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#常用内置库"},{"categories":["Python","教程"],"content":" randomrandom库 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#random"},{"categories":["Python","教程"],"content":" osos模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.pathos.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' -\u003e 'A' # 'A' -\u003e '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' -\u003e ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' -\u003e ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#os"},{"categories":["Python","教程"],"content":" osos模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.pathos.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' -\u003e 'A' # 'A' -\u003e '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' -\u003e ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' -\u003e ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#ospath"},{"categories":["Python","教程"],"content":" 文件操作 open() ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#文件操作"},{"categories":["Python","教程"],"content":" 技巧","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#技巧"},{"categories":["Python","教程"],"content":" 数字编号前置 0 s1 = \"12\" s1.zfill(4) # \"0012\" s2 = \"-12\" s2.zfill(4) # \"-0012\" a = 12 '%04d' % a # \"0012\" ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#数字编号前置-0"},{"categories":["Python","教程"],"content":" 列表推导式 [i * 2 for i in range(3)] # [0, 2, 4] [str(a) + b for a in range(2) for b in 'ab'] # ['0a', '0b', '1a', '1b'] [i * 2 if i % 2 else i for i in range(4)] # [0, 2, 2, 6] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#列表推导式"},{"categories":["Python","教程"],"content":" 匿名函数 + map list(map(lambda x: 2 * x, range(3))) # [0, 2, 4] list(map(lambda x, y: str(x) + y, range(3), 'abc')) # ['0a', '1b', '2c'] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:3","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#匿名函数--map"},{"categories":["Python","教程"],"content":" zip list(zip('01', 'ab')) # [('0', 'a'), ('1', 'b')] dict(zip('01', 'ab')) # {'0': 'a', '1': 'b'} for x, y in zip('ab', 'xy'): print(x, y) # a x # b y ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:4","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#zip"},{"categories":["Python","教程"],"content":" enumerate list(enumerate('ab')) # [(0, 'a'), (1, 'b')] for i, x in enumerate('ab'): print(i, x) # 0 a # 1 b ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:6:5","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#enumerate-1"},{"categories":["Python","教程"],"content":" Q\u0026A","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#qa"},{"categories":["Python","教程"],"content":" UnicodeDecodeError问题描述: UnicodeDecodeError: 'gbk' codec can't decode byte 0xad in position 7: illegal multibyte sequence 解决方案: 将open(filename, 'r')改为open(filename, 'r', encoding='utf-8') ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#unicodedecodeerror"},{"categories":["Python","教程"],"content":" Python 风格规范 不要在行尾加分号，也不要用分号将两条命令放在同一行。 每行不超过80个字符。（导入和注释例外） 不要使用反斜杠连接行。（Python 会将括号中的行隐式连接起来） foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 文本字符串在一行放不下，可以使用括号来实现隐式行连接。 s = ('This will build a very long long ' 'long long long long long long string') 除非是用于实现行连接，否则不要在返回语句或条件语句中使用括号。 用4个空格来缩进代码 # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = { long_dictionary_key: value1 + value2, ... } # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... } 顶级定义之间空两行（全局类、全局函数、全局变量），方法定义之间空一行（类内函数之间、类与第一个函数之间）。 括号内表达式两端不要有空格。 在逗号、分号、冒号后面加空格，前面不加。（行尾除外） 参数列表、索引或切片的左括号前不加空格。 二元操作符两边都加上一个空格。 ‘=‘用于指示参数值或默认值时，不在其两侧使用空格。 不要用空格来垂直对齐多行间的标记。（如’#’、’=’、’:‘等） 类注释和函数注释规范 class SampleClass(object): \"\"\"Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. \"\"\" def __init__(self, likes_spam=False): \"\"\"Inits SampleClass with blah.\"\"\" self.likes_spam = likes_spam self.eggs = 0 def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): \"\"\"Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: {'Serak': ('Rigel VII', 'Pr","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["Python","教程"],"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/#python-风格规范"},{"categories":["C++","教程"],"content":"标准模板库（Standard Template Library，STL）是一组 C++ 模板类，提供常见的数据结构和函数，如列表、堆栈、数组等。它是由容器类、算法和迭代器构成的一个通用库，它的组件是参数化的。 STL 包含以下四个组件： 算法（Algorithms）：头文件\u003calgorithm\u003e定义了一组函数，作用于容器，并为容器中的内容提供各种操作方法。 容器（Containers）：用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，如 deque、list、vector、map、set、bitset 等。 函数（Functions）： 迭代器（Iterators）：遍历容器。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#"},{"categories":["C++","教程"],"content":" \u003cvector\u003evector是一个动态数组，需要#include \u003cvector\u003e。 数组大小动态改变 可以进行逻辑操作（是否相等、比较大小） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vector"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u003cint\u003e v1; // {} vector\u003cint\u003e v2 = {1, 2, 3}; // {1, 2, 3} vector\u003cint\u003e v3({1, 2, 3}); // {1, 2, 3} vector\u003cint\u003e v4 = v3; // {1, 2, 3} vector\u003cint\u003e v5(v3); // {1, 2, 3} vector\u003cint\u003e v6(3); // {0, 0, 0} vector\u003cint\u003e v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector\u003cint\u003e v8(arr, arr + 1); // {1} vector\u003cint\u003e v9(v4.begin(), v4.begin() + 2); // {1, 2} vector\u003cvector\u003cint\u003e\u003e v10(2, vector\u003cint\u003e(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定位置构造并插入元素 iterator insert(const_iterator position, const value_type\u0026 val) 在指定位置插入元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 在指定位置插入 n 个 val iterator insert(const_iterator position, InputIterator first, InputIterator last) 在指定位置插入数组或迭代器 [first, last) 区间内的元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) 在指定位置插入指定列表中的元素 vector\u003cpair\u003cstring, int\u003e\u003e v; v.push_back(make_pair(\"Mike\", 1)); v.emplace_back(\"John\", 2); // 隐式地构造了 pair 并插入末尾 1.3 删除 void pop_back() 删除最后一个元素 iterator erase(const_iterator position) 删除指定位置的元素 iterator erase(const_iterator first, const_iterator last) 删除迭代器 [first, last) 区间内的元素 void clear() noexcept 清空 1.4 容量 bool empty() const 判断容器是否为空 size_type size() const 返回元素个数 size_type capacity() const noexcept 返回已分配存储容量的大小 void resize(size_type n) 改变大小，变小截断，变大补 0 void resize(size_type n, const value_type\u0026 val) 改变大小，变小截断，变大补 val 1.5 其他操作 void assign(size_type n, const value_type\u0026 val) 赋值为 n 个 val void assign(InputIterator first, InputIterator last) 赋值为数组或迭代器 [firs","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vector-1"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#11-初始化"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#12-添加"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#13-删除"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#14-容量"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#15-其他操作"},{"categories":["C++","教程"],"content":" vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list il) 复制指定列表中的元素 vector v1; // {} vector v2 = {1, 2, 3}; // {1, 2, 3} vector v3({1, 2, 3}); // {1, 2, 3} vector v4 = v3; // {1, 2, 3} vector v5(v3); // {1, 2, 3} vector v6(3); // {0, 0, 0} vector v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector v8(arr, arr + 1); // {1} vector v9(v4.begin(), v4.begin() + 2); // {1, 2} vector","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#16-遍历"},{"categories":["C++","教程"],"content":" vector\u003cbool\u003e基本操作同 vector。 特殊操作： void flip() noexcept 所有位都翻转 static void swap(reference ref1, reference ref2) noexcept 交换两个位置的值 vector\u003cbool\u003e mask; mask.push_back(true); mask.push_back(false); // {1 0} mask.flip(); // {0 1} mask.swap(mask[0], mask[1]); // {1 0} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#vectorbool"},{"categories":["C++","教程"],"content":" \u003cstack\u003estack是一个栈，需要#include \u003cstack\u003e。 后进先出（LIFO） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#stack"},{"categories":["C++","教程"],"content":" 2.1 初始化 默认底层容器是 deque 可以显式设置底层容器为 vector stack\u003cint\u003e st1; stack\u003cint\u003e st2(st1); stack\u003cint\u003e st3({1, 2, 3}); // st3.top() == 3 deque\u003cint\u003e dq(2, 3); stack\u003cint\u003e st4(dq); // 默认底层容器是 deque vector\u003cint\u003e v({1, 2, 3}); stack\u003cint, vector\u003cint\u003e\u003e st5(v); // 设置底层容器为 vector ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#21-初始化"},{"categories":["C++","教程"],"content":" 2.2 操作 void push(const value_type\u0026 val) 栈顶添加元素 void emplace(Args\u0026\u0026... args) 栈顶添加元素 void pop() 栈顶弹出元素 reference\u0026 top() 返回栈顶元素 bool empty() const 判断栈是否为空 size_type size() const 返回元素个数 void swap(stack\u0026 x) noexcept 交换两个栈 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#22-操作"},{"categories":["C++","教程"],"content":" \u003clist\u003elist是一个双向链表，需要#include \u003clist\u003e。 无法按索引访问元素 插入删除元素效率高 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#list"},{"categories":["C++","教程"],"content":" 3.1 基本操作基本操作同 vector。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#31-基本操作"},{"categories":["C++","教程"],"content":" 3.2 特殊操作添加： void push_front(const value_type\u0026 val) 在开头插入元素 void emplace_front(Args\u0026\u0026... args) 在开头构造并插入元素 void splice(const_iterator position, list\u0026 x) 将 x 中的元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator i) 将 x 中的位置为 i 元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator first, const_iterator last) 将 x 中的 [first, last) 区间内的元素转移到指定位置 void merge(list\u0026 x) void merge(list\u0026 x, Compare comp) 删除： void pop_front() 删除第一个元素 void remove(const value_type\u0026 val) 删除值为 val 的所有元素 void remove_if(Predicate pred) 删除满足自定义一元函数的元素 void unique() 删除连续重复元素，只保留一个 void unique(BinaryPredicate binary_pred) 删除满足自定义二元函数的元素 其他： void sort() 按升序排序 void sort(Compare comp) 按自定义二元函数排序 void reverse() noexcept 逆序 list\u003cint\u003e l = {1, 1, 1, 2, 1, 2}; l.unique(); // {1, 2, 1, 2} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#32-特殊操作"},{"categories":["C++","教程"],"content":" \u003cqueue\u003equeue是一个单向队列容器，需要#include \u003clist\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#queue"},{"categories":["C++","教程"],"content":" queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue\u003cint\u003e q1; // 空 queue queue\u003cint\u003e q2(5, 2); // 大小为 5 的 queue，值均为 2 queue\u003cint\u003e q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue\u003cint\u003e q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; queue\u003cint\u003e q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue\u003cint\u003e q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#queue-1"},{"categories":["C++","教程"],"content":" queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue q1; // 空 queue queue q2(5, 2); // 大小为 5 的 queue，值均为 2 queue q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; queue q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#411-初始化"},{"categories":["C++","教程"],"content":" queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue q1; // 空 queue queue q2(5, 2); // 大小为 5 的 queue，值均为 2 queue q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; queue q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#412-操作"},{"categories":["C++","教程"],"content":" priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue\u003cint\u003e pq1; // 空 priority_queue priority_queue\u003cint\u003e pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue\u003cint\u003e pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue\u003cint\u003e pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; priority_queue\u003cint\u003e pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue\u003cint\u003e pq6(v); // 复制 vector priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e pq7; // 最大优先队列（最大堆） priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq8; // 最小优先队列（最小堆） 4.2.2 操作 void push(const value_type\u0026 val) 添加元素 void emplace(Args\u0026\u0026... args) 添加元素 void pop() 删除队首（堆顶）元素 const_reference top() const 返回队首（堆顶）元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(priority_queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#priority_queue"},{"categories":["C++","教程"],"content":" priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue pq1; // 空 priority_queue priority_queue pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; priority_queue pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue pq6(v); // 复制 vector priority_queue","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#421-初始化"},{"categories":["C++","教程"],"content":" priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue pq1; // 空 priority_queue priority_queue pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector v = {1, 2, 3}; priority_queue pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue pq6(v); // 复制 vector priority_queue","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#422-操作"},{"categories":["C++","教程"],"content":" \u003cdeque\u003edeque是一个双端队列容器，需要#include \u003cdeque\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#deque"},{"categories":["C++","教程"],"content":" 5.1 初始化 deque\u003cint\u003e dq1; // 空 deque deque\u003cint\u003e dq2(5, 2); // 大小为 5 的 deque，值均为 2 deque\u003cint\u003e dq3(dq2); // 复制 deque deque\u003cint\u003e dq4(dq2.begin(), dq2.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 int arr[] = {1, 2, 3}; deque\u003cint\u003e dq5(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; deque\u003cint\u003e dq6(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 deque\u003cint\u003e dq7 = dq6; deque\u003cint\u003e dq8 = {1, 2, 3}; ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#51-初始化"},{"categories":["C++","教程"],"content":" 5.2 修改 void push_back(const value_type\u0026 val) 队尾添加元素 void push_front(const value_type\u0026 val) 队首添加元素 void emplace_back(Args\u0026\u0026... args) 队尾添加元素 void emplace_front(Args\u0026\u0026... args) 队首添加元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, const value_type\u0026 val) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 迭代器指定位置前面添加 n 个相同元素 iterator insert(const_iterator position, InputIterator first, InputIterator last) 迭代器指定位置前面添加 [first, last) 区间内元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) void pop_back() 删除队尾 void pop_front() 删除队首 iterator erase(iterator position) 删除迭代器指向元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 区间内元素 void clear() noexcept 清空 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#52-修改"},{"categories":["C++","教程"],"content":" 5.3 遍历 deque\u003cint\u003e dq; for (auto it = dq.begin(); it != dq.end(); it++) {*it;} for (auto it = dq.rbegin(); it != dq.rend(); it++) {*it;} for (int e : dq) {e;} for (int\u0026 e : dq) {e;} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#53-遍历"},{"categories":["C++","教程"],"content":" 5.4 操作 size_type size() const noexcept 返回大小 void resize(size_type n) 调整大小为 n，调大补 0，调小末尾截断 void resize(size_type n, const value_type\u0026 val) 调整大小为 n，调大补 val，调小末尾截断 bool empty() const noexcept 判断是否为空 reference operator[](size_type n) 访问指定位置元素，越界报错 reference at(size_type n) 访问指定位置元素，越界抛出 out_of_range 异常 const_reference back() const 返回队尾元素 const_reference front() const 返回队首元素 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:4","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#54-操作"},{"categories":["C++","教程"],"content":" \u003cmap\u003emap是一个有序键值对容器，每个元素由关键字（key）和该关键字对应的值（value）组合而成。需要#include \u003cmap\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#map"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map\u003cchar, int\u003e m1; map\u003cchar, int\u003e m2(m1); map\u003cchar, int\u003e m3(m1.begin(), m1.end()); map\u003cchar, int, less\u003cchar\u003e\u003e m4; // 按 key 升序排列，相当于 map\u003cchar, int\u003e map\u003cchar, int, greater\u003cchar\u003e\u003e m5; // 按 key 降序排列 6.2 添加 map\u003cchar, int\u003e m1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair\u003cchar, int\u003e('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 map\u003cchar, int\u003e m; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-\u003efirst; it-\u003esecond; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-\u003efirst; it-\u003esecond; } for (auto \u0026p : m) { p.first; p.second; } for (auto \u0026[k, v] : m) { k; v; } for (auto \u0026[_, v] : m) { k; v; } for (auto \u0026[k, _] : m) { k; v; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() const noexcept 判断是否为空 void swap(map\u0026 x) 交换两个 map iterator find(const key_type\u0026 k) 查找 key 值为 k 的元素，未找到返回 map::end() size_type count(const key_type\u0026 k) const 返回 key 值为 k 的元素的数量，由于 key 唯一，则存在返回 1，不存在返回 0 iterator lower_bound(const key_type\u0026 k) 返回指向第一个 key 大于等于 k 的元素的迭代器 iterator upper_bound(const key_type\u0026 k) 返回指向第一个 key 大于 k 的元素的迭代器 pair\u003citerator, iterator\u003e equal_range(const key_type\u0026 k) 返回指向 key 等于 k 的所有元素的范围的边界元素的迭代器 [first, second) map\u003cchar, int\u003e m; m['a'] = 0; m.find('b'); // m.end() m.count('a'); // 1 m.count('b'); // 0 6.6 排序 map没有随机迭代器，只有顺序迭代器，所以不能用sort 6.6.1 按 key 排序key 升序，value 随机 默认情况，map\u003cint, char\u003e，相当于map\u003cint, char, less\u003cint\u003e\u003e。 当 key 为自定义类时： typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; return a.two \u003c b.two; } }; map\u003cGrade, int, Cmp\u003e m; typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; ret","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#map-1"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#61-初始化"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#62-添加"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#63-删除"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#64-遍历"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#65-其他操作"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#66-排序"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#661-按-key-排序"},{"categories":["C++","教程"],"content":" map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map m1; map m2(m1); map m3(m1.begin(), m1.end()); map","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#662-按-value-排序"},{"categories":["C++","教程"],"content":" multimap key允许重复 默认按key升序排列 底层二叉搜索树实现，速度比unordered_multimap慢 基本使用方法同 map。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#multimap"},{"categories":["C++","教程"],"content":" \u003cunordered_map\u003e","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_map"},{"categories":["C++","教程"],"content":" unordered_map key唯一且不能修改，可以添加或删除 无序 速度比map快 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_map-1"},{"categories":["C++","教程"],"content":" unordered_multimap","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_multimap"},{"categories":["C++","教程"],"content":" \u003cset\u003eset是一个有序集合容器。需要#include \u003cset\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#set"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set\u003cint\u003e s1; // {} set\u003cint\u003e s2 = {1, 2, 3}; // { 1 2 3 } set\u003cint\u003e s3 = s2; // { 1 2 3 } set\u003cint\u003e s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set\u003cint\u003e s5(arr, arr + 3); // { 1 2 3 } set\u003cint\u003e s6(arr, arr + 1); // { 1 } set\u003cint\u003e s7(s4); // { 1 2 3 } set\u003cint\u003e s8(s4.begin(), s4.end()); // { 1 2 3 } set\u003cint\u003e s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set\u003cint, CompClass\u003e s10; // { 1 2 3 } 修改 pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args) 添加一个元素 pair\u003citerator, bool\u003e insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list\u003cvalue_type\u003e il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair\u003citerator, iterator\u003e equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#set-1"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#初始化"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#修改"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#容量"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#遍历"},{"categories":["C++","教程"],"content":" set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set s1; // {} set s2 = {1, 2, 3}; // { 1 2 3 } set s3 = s2; // { 1 2 3 } set s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set s5(arr, arr + 3); // { 1 2 3 } set s6(arr, arr + 1); // { 1 } set s7(s4); // { 1 2 3 } set s8(s4.begin(), s4.end()); // { 1 2 3 } set s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set s10; // { 1 2 3 } 修改 pair emplace(Args\u0026\u0026... args) 添加一个元素 pair insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#操作"},{"categories":["C++","教程"],"content":" multiset 允许重复元素 元素默认升序 速度比unordered_set慢 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#multiset"},{"categories":["C++","教程"],"content":" \u003cunordered_set\u003eunordered_set是一个无序集合容器。需要#include \u003cunordered_set\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_set"},{"categories":["C++","教程"],"content":" unordered_set 元素唯一 无序 底层哈希表实现，速度比set快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_set-1"},{"categories":["C++","教程"],"content":" unordered_multiset 允许重复元素 无序 速度比multiset快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#unordered_multiset"},{"categories":["C++","教程"],"content":" \u003cbitset\u003ebitset模拟一个 bool 数组，每个元素只能是 0 或 1. ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#bitset"},{"categories":["C++","教程"],"content":" 初始化 bitset\u003c4\u003e b1; // 0000 bitset\u003c4\u003e b2(\"100\"); // 0100, b2[0] == 0 bitset\u003c4\u003e b3(\"1100\"); // 1100 bitset\u003c4\u003e b4(\"11100\"); // 1110 bitset\u003c4\u003e b5(b2); // 0100 string s = \"1010\"; bitset\u003c4\u003e b6(s); // 1010 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#初始化-1"},{"categories":["C++","教程"],"content":" 位运算 bitset\u003c4\u003e a(\"1001\"), b(\"1010\"); a \u0026 b; // 1000 AND a | b; // 1011 OR a ^ b; // 0011 XOR ~a; // 0110 NOT a \u003c\u003c 1; // 0010 SHL a \u003e\u003e 1; // 0100 SHR a == b; // false a != b; // true ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#位运算"},{"categories":["C++","教程"],"content":" 操作 reference operator[](size_t pos) 访问指定位置，0 是最右边一位，即最低位 size_t count() const noexcept 返回 1 的 个数 size_t size() const noexcept 返回长度 bool test(size_t pos) const 判断指定位置是否为 1 bool any() const noexcept 判断是否存在某一位是 1 bool none() const noexcept 判断是否全是 0 bool all() const noexcept 判断是否全是 1 bitset\u0026 set() noexcept 全部置为 1 bitset\u0026 set(size_t pos, bool val = true) 指定位置置为 1 bitset\u0026 reset() noexcept 全部置为 0 bitset\u0026 reset(size_t pos) 指定位置置为 0 bitset\u0026 flip() noexcept 翻转 bitset\u0026 flip(size_t pos) 翻转指定位置 string to_string() const 返回该二进制数的字符串 unsigned long to_ulong() const 返回该 2 进制数对应的整数，类型 unsigned long unsigned long long to_ullong() const 返回该 2 进制数对应的整数，类型 unsigned long long ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#操作-1"},{"categories":["C++","教程"],"content":" \u003calgorithm\u003e","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#algorithm"},{"categories":["C++","教程"],"content":" sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector\u003cint\u003e v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#sort"},{"categories":["C++","教程"],"content":" sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#数组排序"},{"categories":["C++","教程"],"content":" sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#类结构体排序"},{"categories":["C++","教程"],"content":" reverse","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:2","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#reverse"},{"categories":["C++","教程"],"content":" lower_bound","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:3","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#lower_bound"},{"categories":["C++","教程"],"content":" upper_bound","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:4","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#upper_bound"},{"categories":["C++","教程"],"content":" search","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:5","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#search"},{"categories":["C++","教程"],"content":" \u003ctuple\u003etuple将不同类型的许多元素打包成一个对象，便于访问，（就像定义了一个只有属性的类，并且属性只定义了类型，未定义名字）。需要#include \u003ctuple\u003e。 元素类型任意 元素数量任意 tuple\u003cint, string\u003e t1; tuple\u003cint, string\u003e t2{t1}; tuple\u003cint, string\u003e t3(t2); tuple\u003cint, string\u003e t4{1, \"one\"}; get\u003c0\u003e(t4); // 1 get\u003c1\u003e(t4); // one get\u003cint\u003e(t4); // 1 get\u003cstring\u003e(t4); // one make_tuple(2, string(\"two\")); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:12:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#tuple"},{"categories":["C++","教程"],"content":" \u003cnumeric\u003e该头文件包括了一组对数组进行某些操作的算法。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#numeric"},{"categories":["C++","教程"],"content":" accumulate T accumulate(InputIterator first, InputIterator last, T init)：默认求和 T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)：自定义函数 int res = 0; int arr[3] = {1, 2, 3}; vector\u003cint\u003e vec(arr, arr + 3); accumulate(arr, arr + 3, res); // 求和，6 accumulate(vec.begin(), vec.end(), res); // 求和，6 accumulate(arr, arr + 3, res, minus\u003cint\u003e()); // 累减，-6 accumulate(arr, arr + 3, res, [z](int x, int y) { return x + 2 * y; }); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:1","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#accumulate"},{"categories":["C++","教程"],"content":" 参考 Standard C++ Library Reference - cplusplus.com ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:14:0","series":null,"tags":["C++","教程"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/#参考"},{"categories":["PowerShell","教程"],"content":"PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 所有指令或参数均不区分大小写！ PowerShell Bash ls、dir、Get-ChildItem、gci ls -l ls -force ls -a ls -name ls mkdir、New-Item -itemtype \"directory\" mkdir echo、Write-Output、write echo ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["PowerShell","教程"],"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/#"},{"categories":["Hugo"],"content":"使用 Hugo 搭建一个博客，并使用 Github Action 自动部署到 Github Pages。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#"},{"categories":["Hugo"],"content":" 1.安装 Windows 到 Github 下载hugo_extended_0.XX.X_Windows-64bit.zip，解压并将hugo.exe所在目录添加到系统环境变量。 到 Git 官网 下载安装 Git。 Chocolatey (Windows) choco install hugo-extended git Scoop (Windows) scoop install hugo-extended git Homebrew (macOS) brew install hugo git ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#1安装"},{"categories":["Hugo"],"content":" 2.创建网站 打开命令行，输入以下内容，其中MyBlog可修改。 在 Hugo Themes 寻找更多主题。若更换别的主题，将 git 地址和 DoIt 替换。 hugo new site MyBlog cd MyBlog git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#2创建网站"},{"categories":["Hugo"],"content":" 3.添加内容","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#3添加内容"},{"categories":["Hugo"],"content":" 3.1 新建博客输入hugo new posts/My-First-Blog.md，然后打开My-First-Blog.md，显示如下： --- title: \"My First Blog\" date: 2021-02-04T16:18:47+08:00 draft: true --- Markdown 语法见 Markdown 基本语法。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#31-新建博客"},{"categories":["Hugo"],"content":" 3.2 在文章中添加图片将图片存放于static文件夹。 若图片路径为static/xxx/yyy.jpg，在博客中使用/xxx/yyy.jpg来显示图片。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#32-在文章中添加图片"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#32-shortcodes"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#321-图片"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#322-横幅"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#323-公式"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#324-代码"},{"categories":["Hugo"],"content":" 3.2 ShortcodesHugo 专属，非 markdown 语法，参考 扩展 Shortcodes。 3.2.1 图片 {{\u003c image src=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} {{\u003c figure src=\"\" link=\"\" target=\"_blank\" title=\"\" caption=\"\" height=\"\" width=\"\" \u003e}} 3.2.2 横幅 横幅类型：note、abstract、info、tip、success、question、warning、failure、danger、bug、example、quote 横幅标题 横幅是否默认展开 {{\u003c admonition note \"\" false \u003e}} 横幅内容 {{\u003c /admonition \u003e}} note abstract info tip success question warning failure danger bug example quote 3.2.3 公式 {{\u003c math \u003e}}$ 行内公式 ${{\u003c /math \u003e}} {{\u003c math \u003e}} $$ 公式块 $$ {{\u003c /math \u003e}} 3.2.4 代码 文件类型 linenostart：起始行号 hl_lines：高亮行号（从 1 开始） {{\u003c highlight java \"linenostart=5, hl_lines=5 7-9\" \u003e}} 代码块 {{\u003c /highlight \u003e}} ```java {linenostart=5, hl_lines=[5,\"7-9\"]} 代码块 ``` 3.2.5 gist 用户名 gist ID {{\u003c gist backtraxe 9457ba6238b0a98237a17dae16c006b4 \u003e}} ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#325-gist"},{"categories":["Hugo"],"content":" 4.本地部署 hugo server/serve hugo server -D # 渲染草稿，即也渲染 draft: true 的内容 浏览器打开 localhost:1313 即可看到渲染后的网站。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#4本地部署"},{"categories":["Hugo"],"content":" 5.主题自定义主题配置文件为根目录下的config.toml文件。（也可以是config.yaml、config.json） ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#5主题自定义"},{"categories":["Hugo"],"content":" 5.1 简单配置 # 域名 baseURL = \"https://backtraxe.github.io/\" # 默认语言 [en, zh-cn, ...] defaultContentLanguage = \"zh-cn\" # 语言 [zh-CN, en-us, ...] languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 标题 title = \"traXe\" # 主题 theme = \"DoIt\" [params] # 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是Backsided的博客\" # 作者配置 [author] name = \"Backsided\" email = \"\" link = \"\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#51-简单配置"},{"categories":["Hugo"],"content":" 5.2 高级配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#52-高级配置"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#53-params"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsapp"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssearch"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsheader"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsfooter"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssection"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramslist"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramshome"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramssocial"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspage"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagetoc"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagecode"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagemath"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagemapbox"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspageshare"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagecomment"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspagelibrary"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramspageseo"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramstypeit"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsverification"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsseo"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramsanalytics"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscookieconsent"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscdn"},{"categories":["Hugo"],"content":" 5.3 [params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = 'CC BY-NC 4.0' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#paramscompatibility"},{"categories":["Hugo"],"content":" [markup] # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:4","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#markup"},{"categories":["Hugo"],"content":" [author] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:5","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#author"},{"categories":["Hugo"],"content":" [sitemap] # 网站地图配置 [sitemap] changefreq = \"weekly\" filename = \"sitemap.xml\" priority = 0.5 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:6","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#sitemap"},{"categories":["Hugo"],"content":" [Permalinks] # Permalinks 配置 [Permalinks] # posts = \":year/:month/:filename\" posts = \":filename\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:7","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#permalinks"},{"categories":["Hugo"],"content":" [privacy] # 隐私信息配置 [privacy] [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:8","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#privacy"},{"categories":["Hugo"],"content":" [mediaTypes] # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\"text/plain\"] suffixes = [\"md\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:9","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#mediatypes"},{"categories":["Hugo"],"content":" [outputFormats.MarkDown] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \"text/plain\" isPlainText = true isHTML = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:10","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#outputformatsmarkdown"},{"categories":["Hugo"],"content":" [outputs] # 用于 Hugo 输出文档的设置 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] page = [\"HTML\", \"MarkDown\"] section = [\"HTML\", \"RSS\"] taxonomy = [\"HTML\", \"RSS\"] taxonomyTerm = [\"HTML\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:11","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#outputs"},{"categories":["Hugo"],"content":" 6.发布","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#6发布"},{"categories":["Hugo"],"content":" 6.1 静态页面发布输入hugo，渲染后的静态页面在public文件夹中，可将该文件夹中的内容复制到 Web 服务器进行发布。 可用hugo -d/--destination或在config.toml中修改publishdir来指定输出的文件夹。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:1","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#61-静态页面发布"},{"categories":["Hugo"],"content":" 6.2 Github Pages 发布 在 Github 新建两个仓库： \u003cUSERNAME\u003e.github.io.data 用于存放内容，仓库名称随意，可设置为私有仓库。 \u003cUSERNAME\u003e.github.io 用于部署页面。 在MyBlog根目录下运行命令行，输入以下内容： git remote add origin https://github.com/backtraxe/backtraxe.github.io.data.git git add --all git commit -m \"init blog\" git push --set-upstream origin master -f 在 Github 中创建一个 Personal access token，命名随意，勾选repo，复制其中内容。 进入\u003cUSERNAME\u003e.github.io.data仓库，点击Settings-\u003eSecrets，名称为ACCESS_TOKEN，内容填入刚才复制的token。 然后点击Actions-\u003eNew workflow-\u003eset up a workflow yourself，输入以下内容： name: Hugo Deploy on: push: branches: [ main ] # 指定分支 workflow_dispatch: # 允许手动启动 jobs: build: runs-on: ubuntu-latest steps: - name: 1. Checkout # 克隆仓库 uses: actions/checkout@v2 with: submodules: true # 启用子模块 fetch-depth: 0 - name: 2. Disable quotePath # 解决中文显示问题 run: git config --global core.quotePath false - name: 3. Setup Hugo # 安装 hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: 4. Build Hugo # 渲染页面 run: hugo --gc --minify --cleanDestinationDir - name: 5. Deploy Hugo # 将渲染后的页面复制到指定仓库，然后发布 uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.ACCESS_TOKEN }} # 与 Secrets 的名称相同 external_repository: backtraxe/backtraxe.github.io # 指定发布的仓库 publish_branch: main # 指定发布仓库的分支 publish_dir: ./public # 指定要发布的目录 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:2","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#62-github-pages-发布"},{"categories":["Hugo"],"content":" 6.3 环境迁移在新设备克隆仓库，同步所有内容。 git clone --recursive https://github.com/backtraxe/backtraxe.github.io.data.git ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:3","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#63-环境迁移"},{"categories":["Hugo"],"content":" 7.全局详细配置 # 域名 baseURL = \"\" # 构建时包含草稿 buildDrafts = false # 内容文件夹 contentDir = \"content\" # 数据文件夹 dataDir = \"data\" # 内容默认语言（中文：zh-cn） defaultContentLanguage = \"en\" # 根目录跳转到默认语言目录 defaultContentLanguageInSubdir = false # 禁用指定类型页面：page, home, section, taxonomy, term, RSS, sitemap, robotsTXT, 404 disableKinds = [] # 禁用实时重载 disableLiveReload = false # 禁用将 url/path 转小写字母 disablePathToLower = false # 启用 Emoji enableEmoji = false # 使用文件的最后 git 提交日期更新 Lastmod 参数 enableGitInfo = false # 启用 inline shortcode enableInlineShortcodes = false # 是否生成 robots.txt 文件 enableRobotsTXT = false # 日期设置 [frontmatter] # 脚注锚的前缀 footnoteAnchorPrefix = \"\" # 脚注返回链接显示的文本 footnoteReturnLinkContents = \"\" # Google Analytics 跟踪 ID googleAnalytics = \"\" # 自动检测内容中的中文/日文/韩文 hasCJKLanguage = false # 图片设置 [imaging] # 语言设置 [languages] # 启用日志 log = false # 日志保存目录 logFile = \"\" # 主题设置 [markup] # 目录设置 [menu] # 最小化构建设置 [minify] # 模块设置 [module] # 每页的默认文章数量 paginate = 10 # 固定链接 [permalinks] # 生成静态网页的目录 publishDir = \"public\" # 相关设置 [related] # 网站地图设置 [sitemap] # 静态文件目录设置 staticDir = \"static\" # 分类设置 [taxonomies] # 主题 theme = \"\" # 主题目录 themesDir = \"themes\" # 标题 title = \"\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:7:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#7全局详细配置"},{"categories":["Hugo"],"content":" 参考 Quick Start | Hugo GitHub Pages 文档 - GitHub Docs Host on GitHub - Hugo 开始使用 DoIt - 系列 - DoIt How to Create Your First Hugo Blog: a Practical Guide 创建 GitHub Pages 站点 - Github 使用Hugo和GitHub搭建博客 - Félix | Medium Configure Hugo | Hugo Github Action 自动修改文章的更新日期 - 点半九 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:8:0","series":null,"tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/#参考"},{"categories":["Markdown"],"content":" 1.标题 # 一级标题 h1 ## 二级标题 h2 ### 三级标题 h3 #### 四级标题 h4 ##### 五级标题 h5 ###### 六级标题 h6 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#1标题"},{"categories":["Markdown"],"content":" 2.强调 **粗体** *斜体* ~~删除线~~ ***斜体加粗*** ~~**删除线加粗**~~ ~~*斜体删除线*~~ ~~***斜体删除线加粗***~~ 粗体、斜体、删除线、斜体加粗、删除线加粗、斜体删除线、斜体删除线加粗 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#2强调"},{"categories":["Markdown"],"content":" 3.引用 \u003e 引用 \u003e\u003e 嵌套引用 引用 嵌套引用 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#3引用"},{"categories":["Markdown"],"content":" 4.分割线 --- *** ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#4分割线"},{"categories":["Markdown"],"content":" 5.图片 ![Backtraxe's Blog](https://backtraxe.github.io/apple-touch-icon.png \"Backtraxe's Blog\") \u003cdiv style=\"text-align: center\"\u003e \u003cimg src=\"https://backtraxe.github.io/apple-touch-icon.png\" alt=\"Backtraxe's Blog\" width=\"10%\" align=\"center\"\u003e \u003c/div\u003e Backtraxe's Blog ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#5图片"},{"categories":["Markdown"],"content":" 6.超链接 [Backtraxe's Blog](https://backtraxe.github.io/) \u003chttps://backtraxe.github.io/\u003e 这个链接用 1 作为网址变量 [traXe][1] 这个链接用 traxe 作为网址变量 [traXe][traxe] 然后在文档的结尾为变量赋值（网址） [1]: https://backtraxe.github.io/ [traxe]: https://backtraxe.github.io/ Backtraxe’s Blog https://backtraxe.github.io/ 这个链接用 1 作为网址变量 traXe 这个链接用 traxe 作为网址变量 traXe 然后在文档的结尾为变量赋值（网址） ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#6超链接"},{"categories":["Markdown"],"content":" 7.列表","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#7列表"},{"categories":["Markdown"],"content":" 7.1 无序列表 - 北京 - 上海 - 广州 - 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#71-无序列表"},{"categories":["Markdown"],"content":" 7.2 有序列表 1. 北京 1. 上海 1. 广州 1. 深圳 或者 1. 北京 2. 上海 3. 广州 4. 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#72-有序列表"},{"categories":["Markdown"],"content":" 7.3 列表嵌套 - 北京 - 上海 - 广东 1. 广州 2. 深圳 北京 上海 广东 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:3","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#73-列表嵌套"},{"categories":["Markdown"],"content":" 8.表格","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#8表格"},{"categories":["Markdown"],"content":" 8.1 markdown 风格 姓名|分数|排名 --|:--:|--: 张三|100|1 李四|85|2 王五|60|3 姓名 分数 排名 张三 100 1 李四 85 2 王五 60 3 --，:-- : 左对齐 :--: : 居中 --: : 右对齐 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#81-markdown-风格"},{"categories":["Markdown"],"content":" 8.2 html 风格 \u003ctable\u003e \u003cth\u003e \u003ctd style=\"text-align: center\"\u003e\u003cb\u003e姓名\u003c/b\u003e\u003c/td\u003e \u003ctd style=\"text-align: center\"\u003e\u003cb\u003e分数\u003c/b\u003e\u003c/td\u003e \u003ctd style=\"text-align: center\"\u003e\u003cb\u003e排名\u003c/b\u003e\u003c/td\u003e \u003c/th\u003e \u003ctr\u003e \u003ctd\u003e张三\u003c/td\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e1\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e李四\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e王五\u003c/td\u003e \u003ctd\u003e60\u003c/td\u003e \u003ctd\u003e3\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 姓名 分数 排名 张三 100 1 李四 85 2 王五 60 3 Tables Generator ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#82-html-风格"},{"categories":["Markdown"],"content":" 9.代码","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#9代码"},{"categories":["Markdown"],"content":" 9.1 单行代码 `print(\"Hello World!\")` print(\"Hello World!\") ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#91-单行代码"},{"categories":["Markdown"],"content":" 9.2 多行代码 ```cpp #include\u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ``去掉` #include\u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#92-多行代码"},{"categories":["Markdown"],"content":" 10.公式","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:0","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#10公式"},{"categories":["Markdown"],"content":" 10.1 行内公式 $E=mc^2$ $E=mc^2$ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:1","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#101-行内公式"},{"categories":["Markdown"],"content":" 10.2 多行公式 $$ \\sum_{i=1}^n a_i=0 $$ $$ \\sum_{i=1}^n a_i=0 $$ $$ \\begin{align} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{align} $$ $$ \\begin{align} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{align} $$ $$ \\begin{aligned} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{aligned} $$ $$ \\begin{aligned} x \u0026= v_0\\cos\\theta t \\newline y \u0026= v_0\\sin\\theta t - \\frac{1}{2}gt^2 \\end{aligned} $$ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:2","series":null,"tags":["Markdown"],"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/#102-多行公式"},{"categories":null,"content":"test ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"about","uri":"/about/#"},{"categories":null,"content":" 你没有连接至互联网。 ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"离线模式","uri":"/offline/#"}]